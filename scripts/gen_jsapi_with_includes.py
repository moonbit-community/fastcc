#!/usr/bin/env python3
from __future__ import annotations

import argparse
from pathlib import Path


def _read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def _emit_multiline_string(lines: list[str], content: str) -> None:
    if content == "":
        lines.append("    \"\"")
        return
    if not content.endswith("\n"):
        raise SystemExit("Include file content must end with a newline.")

    for line in content.split("\n")[:-1]:
        lines.append("    #|" + line)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate jsapi_with_includes.mbt from compat/include."
    )
    parser.add_argument("--input", required=True, help="compat/include directory")
    parser.add_argument("--output", required=True, help="output .mbt file")
    args = parser.parse_args()

    input_dir = Path(args.input)
    output_path = Path(args.output)

    if not input_dir.is_dir():
        raise SystemExit(f"Input path is not a directory: {input_dir}")

    files = sorted(
        (path for path in input_dir.rglob("*") if path.is_file()),
        key=lambda p: p.relative_to(input_dir).as_posix(),
    )

    lines: list[str] = []
    lines.append("// @generated by scripts/gen_jsapi_with_includes.py. DO NOT EDIT.")
    lines.append("///|")
    lines.append("pub fn new_in_memory_host_with_includes() -> &@host.Host {")
    lines.append("  let host = @mem_host.new()")

    for path in files:
        rel = path.relative_to(input_dir).as_posix()
        file_path = f"compat/include/{rel}"
        content = _read_text(path)
        lines.append(
            "  try! host.write_bytes_to_file(\""
            + file_path
            + "\", @encoding/utf8.encode("
        )
        _emit_multiline_string(lines, content)
        lines.append("  ))")

    lines.append("  host as &@host.Host")
    lines.append("}")
    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


if __name__ == "__main__":
    main()
