// Generated using `moon info`, DON'T EDIT IT
package "hackwaly/tinycc/frontend/lexer"

import {
  "hackwaly/tinycc/frontend/lexer/lexer_core",
  "hackwaly/tinycc/frontend/tokens",
  "hackwaly/tinycc/support/diag",
  "hackwaly/tinycc/support/intern",
  "hackwaly/tinycc/support/source",
}

// Values
pub fn add_lex_error(@lexer_core.Lexer, @source.SrcLoc, String) -> Unit

pub fn advance(@lexer_core.Lexer) -> UInt16?

pub fn advance_punct(@lexer_core.Lexer) -> Unit

pub fn is_bin_digit(UInt16) -> Bool

pub fn is_digit(UInt16) -> Bool

pub fn is_hex_digit(UInt16) -> Bool

pub fn is_ident_continue(UInt16) -> Bool

pub fn is_ident_start(UInt16) -> Bool

pub fn is_ws_no_newline(UInt16) -> Bool

pub fn lex_ident(@lexer_core.Lexer, @source.SrcLoc, Bool) -> @tokens.Token

pub fn lex_number(@lexer_core.Lexer, @source.SrcLoc, Bool, Bool) -> @tokens.Token

pub fn lex_punct(@lexer_core.Lexer, @source.SrcLoc, Bool) -> @tokens.Token

pub fn lex_string_literal(@lexer_core.Lexer, @source.SrcLoc, Bool, UInt16) -> @tokens.Token

pub fn lexer_loc(@lexer_core.Lexer) -> @source.SrcLoc

pub fn make_token(@tokens.TokenKind, @source.SrcLoc, Bool, id? : Int, lexeme_id? : Int) -> @tokens.Token

pub fn new_lexer(@source.SourceFile, @diag.DiagBag, @intern.StringInterner, @tokens.KeywordIds, @tokens.LexemePool) -> @lexer_core.Lexer

pub fn next_token(@lexer_core.Lexer) -> @tokens.Token

pub fn peek_char(@lexer_core.Lexer) -> UInt16?

pub fn peek_char_offset(@lexer_core.Lexer, Int) -> UInt16?

pub fn skip_block_comment(@lexer_core.Lexer, @source.SrcLoc) -> Unit

pub fn skip_line_comment(@lexer_core.Lexer) -> Unit

pub fn skip_string_literal(@lexer_core.Lexer, @source.SrcLoc, UInt16) -> Unit

pub fn skip_ws(@lexer_core.Lexer) -> Unit

pub fn slice_to_view(String, Int, Int) -> StringView

// Errors

// Types and methods

// Type aliases
pub using @lexer_core {type Lexer}

// Traits

