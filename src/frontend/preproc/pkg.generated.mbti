// Generated using `moon info`, DON'T EDIT IT
package "hackwaly/tinycc/frontend/preproc"

import {
  "hackwaly/tinycc/frontend/preproc/preproc_core",
  "hackwaly/tinycc/frontend/tokens/tokens_core",
  "hackwaly/tinycc/host",
  "hackwaly/tinycc/support/diag/diag_core",
  "hackwaly/tinycc/support/source/source_core",
  "moonbitlang/x/time",
}

// Values
pub fn add_hidden(@preproc_core.Preprocessor, @tokens_core.Token, Int) -> @tokens_core.Token

pub fn add_hidden_tokens(@preproc_core.Preprocessor, Array[@tokens_core.Token], Int) -> Array[@tokens_core.Token]

pub fn add_include_path(@preproc_core.Preprocessor, String) -> Unit

pub fn add_pp_error(@preproc_core.Preprocessor, @source_core.SrcLoc, String) -> Unit

pub fn advance_if(@preproc_core.IfParser) -> @tokens_core.Token?

pub fn builtin_macro_tokens(@preproc_core.Preprocessor, @tokens_core.Token) -> Array[@tokens_core.Token]?

pub fn clear_hidden_pool(@preproc_core.HiddenPool) -> Unit

pub fn current_active(@preproc_core.Preprocessor) -> Bool

pub fn decode_pp_escape_value(@preproc_core.Preprocessor, String, Int, @source_core.SrcLoc) -> (Int, Int)

pub fn define_func_macro_empty(@preproc_core.Preprocessor, String) -> Unit

pub fn define_func_macro_zero(@preproc_core.Preprocessor, String) -> Unit

pub fn define_int_macro(@preproc_core.Preprocessor, String, Int) -> Unit

pub fn define_macro(@preproc_core.Preprocessor, String, Array[@tokens_core.Token]) -> Unit

pub fn define_words_macro(@preproc_core.Preprocessor, String, Array[String]) -> Unit

pub fn dir_name(String) -> String

pub fn dump_tokens(@preproc_core.Preprocessor, Int) -> Array[@tokens_core.Token]

pub fn ensure_expanded_arg(@preproc_core.Preprocessor, Array[Array[@tokens_core.Token]], Array[Array[@tokens_core.Token]?], Int) -> Array[@tokens_core.Token]

pub fn ensure_hidden_singleton_slot(@preproc_core.HiddenPool, Int) -> Unit

pub fn ensure_macro_capacity(@preproc_core.Preprocessor, Int) -> Unit

pub fn escape_string(String) -> String

pub fn eval_has_include(@preproc_core.Preprocessor, Array[@tokens_core.Token], include_next~ : Bool) -> Int

pub fn eval_if_expr(@preproc_core.Preprocessor, Array[@tokens_core.Token], @source_core.SrcLoc) -> Bool

pub fn expand_if_tokens(@preproc_core.Preprocessor, Array[@tokens_core.Token]) -> Array[@tokens_core.Token]

pub fn expand_tokens(@preproc_core.Preprocessor, Array[@tokens_core.Token]) -> Array[@tokens_core.Token]

pub fn finalize_preprocessor(@preproc_core.Preprocessor) -> Unit

pub fn format_date(@time.ZonedDateTime) -> String

pub fn format_time(@time.ZonedDateTime) -> String

pub fn get_macro(@preproc_core.Preprocessor, Int) -> @preproc_core.Macro?

pub fn handle_directive(@preproc_core.Preprocessor, @tokens_core.Token) -> Unit

pub fn handle_line_directive(@preproc_core.Preprocessor, Array[@tokens_core.Token], @source_core.SrcLoc) -> Unit

pub fn has_macro(@preproc_core.Preprocessor, Int) -> Bool

pub fn hidden_add(@preproc_core.HiddenPool, Int, Int) -> Int

pub fn hidden_contains(@preproc_core.HiddenPool, Int, Int) -> Bool

pub fn hidden_is_empty(Int) -> Bool

pub fn include_file(@preproc_core.Preprocessor, @preproc_core.IncludeSpec, @source_core.SrcLoc, include_next~ : Bool) -> Unit

pub fn init_builtin_macros(@preproc_core.Preprocessor) -> Unit

pub fn init_datetime_literals() -> (String, String)

pub fn is_adjacent(@preproc_core.Preprocessor, @tokens_core.Token, @tokens_core.Token) -> Bool

pub fn is_builtin_macro_id(@preproc_core.Preprocessor, Int) -> Bool

pub fn is_expanding(@preproc_core.Preprocessor, Int) -> Bool

pub fn is_macro_name_token(@tokens_core.Token) -> Bool

pub fn join_path(String, String) -> String

pub fn lex_paste_tokens(@preproc_core.Preprocessor, String, String, String, @source_core.SrcLoc, Int) -> Array[@tokens_core.Token]

pub fn logical_line(@preproc_core.Preprocessor, @source_core.SrcLoc) -> Int

pub fn lookup_param_index(Array[Int], Int) -> Int?

pub fn macro_id_from_name(@preproc_core.Preprocessor, String) -> Int

pub fn macro_id_from_token(@preproc_core.Preprocessor, @tokens_core.Token) -> Int

pub fn macro_int_value(@preproc_core.Preprocessor, @tokens_core.Token, @source_core.SrcLoc) -> @preproc_core.PpValue?

pub fn macro_replacement_needs_expand(@preproc_core.Preprocessor, Int, @preproc_core.Macro) -> Bool

pub fn make_builtin_token(@tokens_core.TokenKind, id? : Int, lexeme_id? : Int) -> @tokens_core.Token

pub fn make_builtin_word_token(@preproc_core.Preprocessor, String) -> @tokens_core.Token

pub fn make_int_literal_token(@preproc_core.Preprocessor, Int, @source_core.SrcLoc) -> @tokens_core.Token

pub fn make_string_literal(@preproc_core.Preprocessor, String, @source_core.SrcLoc) -> @tokens_core.Token

pub fn match_kind(@preproc_core.IfParser, @tokens_core.TokenKind) -> Bool

pub fn merge_hidden(@preproc_core.HiddenPool, Int, Int) -> Int

pub fn month_name(Int) -> String

pub fn new_hidden_pool() -> @preproc_core.HiddenPool

pub fn new_preprocessor(@source_core.SourceMap, @source_core.SourceFile, @diag_core.DiagBag, host~ : &@host.Host) -> @preproc_core.Preprocessor

pub fn next_input_token(@preproc_core.Preprocessor) -> @tokens_core.Token

pub fn next_pp_token(@preproc_core.Preprocessor) -> @tokens_core.Token

pub fn next_raw_token(@preproc_core.Preprocessor) -> @tokens_core.Token

pub fn normalize_macro_args(@preproc_core.Macro, Array[Array[@tokens_core.Token]], @source_core.SrcLoc) -> Array[Array[@tokens_core.Token]]?

pub fn normalize_macro_tokens(Array[@tokens_core.Token]) -> Array[@tokens_core.Token]

pub fn pad2(Int) -> String

pub fn pad2_space(Int) -> String

pub fn parse_add(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_bit_and(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_bit_or(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_bit_xor(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_define_macro(@preproc_core.Preprocessor, @tokens_core.Token, Array[@tokens_core.Token], @source_core.SrcLoc) -> @preproc_core.Macro?

pub fn parse_defined(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_eq(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_has_include_path(@preproc_core.Preprocessor, Array[@tokens_core.Token]) -> @preproc_core.IncludeSpec?

pub fn parse_include_path(@preproc_core.Preprocessor, Array[@tokens_core.Token], @source_core.SrcLoc) -> @preproc_core.IncludeSpec?

pub fn parse_line_int_literal(@preproc_core.Preprocessor, String, @source_core.SrcLoc) -> Int

pub fn parse_logical_and(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_logical_or(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_macro_params(@preproc_core.Preprocessor, Array[@tokens_core.Token], @source_core.SrcLoc) -> (Array[Int], Bool, Array[@tokens_core.Token])?

pub fn parse_mul(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_pp_char_literal(@preproc_core.Preprocessor, @tokens_core.Token) -> @preproc_core.PpValue

pub fn parse_pp_hex_escape(@preproc_core.Preprocessor, String, Int, @source_core.SrcLoc) -> (Int, Int)

pub fn parse_pp_int_literal(@preproc_core.Preprocessor, String, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_pp_octal_escape(String, Int) -> (Int, Int)

pub fn parse_primary(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_rel(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_shift(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn parse_unary(@preproc_core.IfParser, @source_core.SrcLoc) -> @preproc_core.PpValue

pub fn peek_if(@preproc_core.IfParser) -> @tokens_core.Token?

pub fn peek_is_rparen(@preproc_core.IfParser) -> Bool

pub fn pop_cond(@preproc_core.Preprocessor, @source_core.SrcLoc) -> Unit

pub fn pop_expanding(@preproc_core.Preprocessor) -> Unit

pub fn pp_bool_value(Bool) -> @preproc_core.PpValue

pub fn pp_hex_digit_value(UInt16) -> Int?

pub fn pp_is_oct_digit(UInt16) -> Bool

pub fn pp_is_zero(@preproc_core.PpValue) -> Bool

pub fn pp_shift_count(@preproc_core.PpValue) -> Int

pub fn pp_token_lexeme(@preproc_core.Preprocessor, @tokens_core.Token) -> String

pub fn pp_token_lexeme_len(@preproc_core.Preprocessor, @tokens_core.Token) -> Int

pub fn pp_unsigned_result(@preproc_core.PpValue, @preproc_core.PpValue) -> Bool

pub fn prefix_tokens(Array[@tokens_core.Token], Int) -> Array[@tokens_core.Token]

pub fn push_back(@preproc_core.Preprocessor, @tokens_core.Token) -> Unit

pub fn push_cond(@preproc_core.Preprocessor, Bool) -> Unit

pub fn push_expanding(@preproc_core.Preprocessor, Int) -> Unit

pub fn push_tokens(@preproc_core.Preprocessor, Array[@tokens_core.Token]) -> Unit

pub fn read_directive_head_token(@preproc_core.Preprocessor) -> @tokens_core.Token?

pub fn read_directive_text(@preproc_core.Preprocessor) -> String

pub fn read_directive_tokens(@preproc_core.Preprocessor) -> Array[@tokens_core.Token]

pub fn read_macro_args(@preproc_core.Preprocessor, @source_core.SrcLoc) -> Array[Array[@tokens_core.Token]]?

pub fn read_macro_args_from_tokens(@preproc_core.Preprocessor, Array[@tokens_core.Token], Int, @source_core.SrcLoc) -> (Array[Array[@tokens_core.Token]], Int)?

pub fn release_expanding_guards(@preproc_core.Preprocessor) -> Unit

pub fn remove_macro(@preproc_core.Preprocessor, Int) -> Unit

pub fn resolve_include_path(@preproc_core.Preprocessor, String, Bool, include_next~ : Bool) -> String?

pub fn set_macro(@preproc_core.Preprocessor, Int, @preproc_core.Macro) -> Unit

pub fn skip_directive_line(@preproc_core.Preprocessor) -> Unit

pub fn skip_inactive(@preproc_core.Preprocessor) -> Unit

pub fn skip_paren_expr(@preproc_core.IfParser, @source_core.SrcLoc) -> Unit

pub fn slice_tokens(Array[@tokens_core.Token], Int) -> Array[@tokens_core.Token]

pub fn stringize_tokens(@preproc_core.Preprocessor, Array[@tokens_core.Token]) -> String

pub fn strip_quotes(String) -> String

pub fn substitute_macro(@preproc_core.Preprocessor, @preproc_core.Macro, Array[Array[@tokens_core.Token]], @source_core.SrcLoc) -> (Array[@tokens_core.Token], Bool)

pub fn token_needs_expansion(@preproc_core.Preprocessor, @tokens_core.Token) -> Bool

pub fn tokens_have_id(Array[@tokens_core.Token]) -> Bool

pub fn tokens_need_expansion(@preproc_core.Preprocessor, Array[@tokens_core.Token]) -> Bool

pub fn update_elif(@preproc_core.Preprocessor, Bool, @source_core.SrcLoc) -> Unit

pub fn update_else(@preproc_core.Preprocessor, @source_core.SrcLoc) -> Unit

// Errors

// Types and methods

// Type aliases
pub using @preproc_core {type CondState}

pub using @preproc_core {type ExpandingGuard}

pub using @preproc_core {type HiddenNode}

pub using @preproc_core {type HiddenPool}

pub using @preproc_core {type IfParser}

pub using @preproc_core {type IncludeSpec}

pub using @preproc_core {type Macro}

pub using @preproc_core {type PpValue}

pub using @preproc_core {type PreprocBuiltinIds}

pub using @preproc_core {type Preprocessor}

// Traits

