// Generated using `moon info`, DON'T EDIT IT
package "hackwaly/tinycc/sem"

import {
  "hackwaly/tinycc/frontend/ast",
  "hackwaly/tinycc/support/diag",
  "hackwaly/tinycc/support/source",
  "moonbitlang/core/hashmap",
}

// Values
pub fn add_sem_error(SemContext, @source.SrcLoc, String) -> Unit

pub fn adjust_param_type_for_local(@ast.CType) -> @ast.CType

pub fn align_to(Int, Int) -> Int

pub fn apply_inferred_array_size(@ast.CType, Int) -> @ast.CType

pub fn atomic_builtin_return_type(SemContext, String, Int, Array[@ast.Expr], @source.SrcLoc) -> @ast.CType?

pub fn atomic_builtin_template_from_ident(SemContext, String, Int) -> String?

pub fn attr_align_value(SemContext, @ast.Attributes, @source.SrcLoc) -> Int?

pub fn attrs_layout_empty(@ast.Attributes) -> Bool

pub fn builtin_call_kind(SemContext, String, Int) -> BuiltinCallKind?

pub fn check_translation_unit(@ast.TranslationUnit, @diag.DiagBag) -> SemContext

pub fn common_int_type(SemContext, @ast.CType, @ast.CType) -> @ast.CType

pub fn compound_literal_key(Int) -> Int

pub fn compound_literal_type(SemContext, @ast.CType, @ast.Initializer, @source.SrcLoc, Int) -> @ast.CType

pub fn const_int64_from_expr(SemContext, @ast.Expr, @source.SrcLoc) -> Int64?

pub fn const_int_from_expr(SemContext, @ast.Expr, @source.SrcLoc) -> Int?

pub fn current_local_scope_id(SemContext) -> Int

pub fn decay_type(@ast.CType) -> @ast.CType

pub fn default_int_type() -> @ast.CType

pub fn ensure_struct_fields(SemContext, String, Int, Array[@ast.RecordItem]?, is_union~ : Bool, @source.SrcLoc) -> RecordDef?

pub fn enum_const_value(SemContext, String, Int) -> Int?

pub fn eval_builtin_offsetof(SemContext, @ast.CType, Array[String], @source.SrcLoc) -> Int?

pub fn find_field_index_cached(SemContext, @ast.CType, String, Int, @source.SrcLoc) -> Int?

pub fn float_size(@ast.CFloatKind) -> Int

pub fn get_function_by_id(SemContext, Int) -> FuncSig?

pub fn get_global_by_id(SemContext, Int) -> @ast.CType?

pub fn[T] get_opt_by_id(Array[T?], Int) -> T?

pub fn has_function_by_id(SemContext, Int) -> Bool

pub fn[T] has_opt_by_id(Array[T?], Int) -> Bool

pub fn int_size(@ast.CIntKind) -> Int

pub fn is_char_type(@ast.CType) -> Bool

pub fn is_int_like(@ast.CType) -> Bool

pub fn next_init_field(Array[@ast.Field], Int) -> (@ast.Field, Int)?

pub fn pop_scope(SemContext) -> Unit

pub fn push_scope(SemContext) -> Unit

pub fn record_local_binding(SemContext, Int, @ast.CType) -> Unit

pub fn resolve_struct_fields(SemContext, String, Int, Array[@ast.RecordItem]?, is_union~ : Bool) -> Array[@ast.Field]?

pub fn resolve_type(SemContext, @ast.CType, @source.SrcLoc) -> @ast.CType

pub fn[T] set_opt_by_id(Array[T?], Int, T) -> Unit

pub fn strip_qual_attrs(@ast.CType) -> @ast.CType

pub fn strip_qualifiers(@ast.CType) -> @ast.CType

pub fn strip_top_qualifiers(@ast.CType) -> @ast.CType

pub fn strip_top_qualifiers_keep_attrs(@ast.CType) -> @ast.CType

pub fn struct_size_align(SemContext, Array[@ast.Field], @ast.Attributes, @source.SrcLoc) -> (Int, Int)

pub fn try_eval_int_const(SemContext, @ast.Expr) -> Int?

pub fn type_contains_vla(@ast.CType) -> Bool

pub fn type_for_sizeof(SemContext, @ast.Expr) -> @ast.CType

pub fn type_of_expr(SemContext, @ast.Expr) -> @ast.CType

pub fn type_of_lvalue(SemContext, @ast.Expr) -> @ast.CType?

pub fn type_size_align(SemContext, @ast.CType, @source.SrcLoc) -> (Int, Int)?

pub fn union_size_align(SemContext, Array[@ast.Field], @ast.Attributes, @source.SrcLoc) -> (Int, Int)

// Errors

// Types and methods
pub(all) enum BuiltinCallKind {
  ChooseExpr
  Expect
  ConstantP
  Unreachable
  SyncSynchronize
  VaStart
  VaCopy
  VaEnd
  FrameAddress
  ReturnAddress
}
pub impl Eq for BuiltinCallKind
pub impl Show for BuiltinCallKind
pub impl ToJson for BuiltinCallKind

pub(all) struct FieldAccessInfo {
  offset : Int
  ty : @ast.CType
  bit_offset : Int?
  bit_width : Int?
  bit_unit_size : Int?
}

pub struct FuncSig {
  return_type : @ast.CType
  params : Array[@ast.CType]
  varargs : Bool
  is_old_style : Bool
  call_conv : @ast.CallConv
}
pub impl Eq for FuncSig
pub impl Show for FuncSig
pub impl ToJson for FuncSig

type LocalOverride

pub struct RecordDef {
  fields : Array[@ast.Field]
  attrs : @ast.Attributes
}

pub struct SemContext {
  diags : @diag.DiagBag
  globals : @hashmap.HashMap[String, @ast.CType]
  globals_by_id : Array[@ast.CType?]
  functions : @hashmap.HashMap[String, FuncSig]
  functions_by_id : Array[FuncSig?]
  builtin_call_ids : Array[BuiltinCallKind?]
  builtin_sig_ids : Array[FuncSig?]
  atomic_template_ids : Array[String?]
  function_defs : @hashmap.HashMap[String, Bool]
  local_scope_ids_by_id : Array[Int]
  local_scope_stack : Array[Int]
  mut next_local_scope_id : Int
  local_values_by_id : Array[@ast.CType?]
  local_overrides : Array[Array[LocalOverride]]
  type_aliases : @hashmap.HashMap[String, @ast.CType]
  struct_defs : @hashmap.HashMap[String, RecordDef]
  struct_defs_by_id : Array[RecordDef?]
  union_defs : @hashmap.HashMap[String, RecordDef]
  union_defs_by_id : Array[RecordDef?]
  struct_member_cache : @hashmap.HashMap[String, @hashmap.HashMap[String, @ast.CType]]
  struct_member_cache_by_id : Array[@hashmap.HashMap[Int, @ast.CType]?]
  union_member_cache : @hashmap.HashMap[String, @hashmap.HashMap[String, @ast.CType]]
  union_member_cache_by_id : Array[@hashmap.HashMap[Int, @ast.CType]?]
  struct_field_access_cache : @hashmap.HashMap[String, @hashmap.HashMap[String, FieldAccessInfo]]
  struct_field_access_cache_by_id : Array[@hashmap.HashMap[Int, FieldAccessInfo]?]
  union_field_access_cache : @hashmap.HashMap[String, @hashmap.HashMap[String, FieldAccessInfo]]
  union_field_access_cache_by_id : Array[@hashmap.HashMap[Int, FieldAccessInfo]?]
  struct_field_index_cache : @hashmap.HashMap[String, @hashmap.HashMap[String, Int]]
  struct_field_index_cache_by_id : Array[@hashmap.HashMap[Int, Int]?]
  union_field_index_cache : @hashmap.HashMap[String, @hashmap.HashMap[String, Int]]
  union_field_index_cache_by_id : Array[@hashmap.HashMap[Int, Int]?]
  struct_size_cache : @hashmap.HashMap[String, (Int, Int)]
  struct_size_cache_by_id : Array[(Int, Int)?]
  union_size_cache : @hashmap.HashMap[String, (Int, Int)]
  union_size_cache_by_id : Array[(Int, Int)?]
  func_compound_literals : @hashmap.HashMap[String, Array[Int]]
  func_compound_literals_by_id : Array[Array[Int]?]
  compound_literal_sizes : @hashmap.HashMap[Int, (Int, Int)]
  func_has_compound_literal : @hashmap.HashMap[String, Bool]
  func_has_stmt_expr : @hashmap.HashMap[String, Bool]
  func_has_stmt_expr_by_id : Array[Bool?]
  func_has_static_local : @hashmap.HashMap[String, Bool]
  func_has_static_local_by_id : Array[Bool?]
  func_has_local_decl : @hashmap.HashMap[String, Bool]
  func_has_local_decl_by_id : Array[Bool?]
  enum_defs : @hashmap.HashMap[String, Array[@ast.EnumItem]]
  enum_defs_by_id : Array[Array[@ast.EnumItem]?]
  enum_consts : @hashmap.HashMap[String, Int]
  enum_consts_by_id : Array[Int?]
  enum_types : @hashmap.HashMap[String, @ast.CType]
  enum_types_by_id : Array[@ast.CType?]
  compound_literal_types : @hashmap.HashMap[Int, @ast.CType]
  expr_type_cache : Array[@ast.CType?]
  func_agg_temps : @hashmap.HashMap[String, (Int, Int)]
  func_agg_temps_by_id : Array[(Int, Int)?]
  switch_stack : Array[SwitchInfo]
  mut labels_defined : @hashmap.HashMap[String, Bool]
  mut labels_used : Array[(String, @source.SrcLoc)]
  mut loop_depth : Int
  mut switch_depth : Int
  mut current_func_name : String?
  mut current_func_id : Int
  mut current_agg_temp_size : Int
  mut current_agg_temp_align : Int
  mut record_agg_temps : Bool
}

type SwitchInfo

// Type aliases

// Traits

