const $_1L = { hi: -1, lo: -1 };
const $1000000000000000000L = { hi: 232830643, lo: -1486618624 };
const $0L = { hi: 0, lo: 0 };
const $1L = { hi: 0, lo: 1 };
const $10L = { hi: 0, lo: 10 };
const $100L = { hi: 0, lo: 100 };
const $1000L = { hi: 0, lo: 1000 };
const $10000L = { hi: 0, lo: 10000 };
const $100000L = { hi: 0, lo: 100000 };
const $1000000L = { hi: 0, lo: 1000000 };
const $10000000L = { hi: 0, lo: 10000000 };
const $100000000L = { hi: 0, lo: 100000000 };
const $1000000000L = { hi: 0, lo: 1000000000 };
const $10000000000L = { hi: 2, lo: 1410065408 };
const $100000000000L = { hi: 23, lo: 1215752192 };
const $1000000000000L = { hi: 232, lo: -727379968 };
const $10000000000000L = { hi: 2328, lo: 1316134912 };
const $100000000000000L = { hi: 23283, lo: 276447232 };
const $1000000000000000L = { hi: 232830, lo: -1530494976 };
const $22L = { hi: 0, lo: 22 };
const $37L = { hi: 0, lo: 37 };
const $_22L = { hi: -1, lo: -22 };
const $65535L = { hi: 0, lo: 65535 };
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void = { $tag: 0 };
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Bool = { $tag: 1 };
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int.prototype.$tag = 2;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float.prototype.$tag = 3;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer.prototype.$tag = 4;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array.prototype.$tag = 5;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Struct(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Struct.prototype.$tag = 6;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Union(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Union.prototype.$tag = 7;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Enum(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Enum.prototype.$tag = 8;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$TypeofExpr(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$TypeofExpr.prototype.$tag = 9;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function.prototype.$tag = 10;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed.prototype.$tag = 11;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified.prototype.$tag = 12;
const $60L = { hi: 0, lo: 60 };
const $9223372036854775807L = { hi: 2147483647, lo: -1 };
const $_4503599627370496L = { hi: -1048576, lo: 0 };
const $9221120237041090561L = { hi: 2146959360, lo: 1 };
const $9218868437227405312L = { hi: 2146435072, lo: 0 };
const $2L = { hi: 0, lo: 2 };
const $400L = { hi: 0, lo: 400 };
const $365L = { hi: 0, lo: 365 };
const $97L = { hi: 0, lo: 97 };
const $5L = { hi: 0, lo: 5 };
const $30L = { hi: 0, lo: 30 };
const $7L = { hi: 0, lo: 7 };
const $_4503599627370497L = { hi: -1048577, lo: -1 };
const $9218868437227405311L = { hi: 2146435071, lo: -1 };
const $24L = { hi: 0, lo: 24 };
class $PanicError extends Error {}
function $panic() {
  throw new $PanicError();
}
function $bound_check(arr, index) {
  if (index < 0 || index >= arr.length) throw new Error("Index out of bounds");
}
function $compare_int(a, b) {
  return (a >= b) - (a <= b);
}
const moonbitlang$core$builtin$$random_seed = () => {
  if (globalThis.crypto?.getRandomValues) {
    const array = new Uint32Array(1);
    globalThis.crypto.getRandomValues(array);
    return array[0] | 0; // Convert to signed 32
  } else {
    return Math.floor(Math.random() * 0x100000000) | 0; // Fallback to Math.random
  }
};
function Result$Err$0$(param0) {
  this._0 = param0;
}
Result$Err$0$.prototype.$tag = 0;
function Result$Ok$0$(param0) {
  this._0 = param0;
}
Result$Ok$0$.prototype.$tag = 1;
function Error$moonbitlang$47$core$47$encoding$47$utf8$46$Malformed$46$Malformed(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$encoding$47$utf8$46$Malformed$46$Malformed.prototype.$tag = 4;
function Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError.prototype.$tag = 3;
function Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure.prototype.$tag = 2;
const Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$IndexOutOfBounds = { $tag: 1 };
const Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$InvalidIndex = { $tag: 0 };
const moonbitlang$core$builtin$$int_to_string_js = (x, radix) => {
  return x.toString(radix);
};
const moonbitlang$core$builtin$$uint64_to_string_js = (num, radix) => {
  return (BigInt(num.hi >>> 0) << 32n | BigInt(num.lo >>> 0)).toString(radix);
};
function Result$Err$1$(param0) {
  this._0 = param0;
}
Result$Err$1$.prototype.$tag = 0;
function Result$Ok$1$(param0) {
  this._0 = param0;
}
Result$Ok$1$.prototype.$tag = 1;
function Result$Err$2$(param0) {
  this._0 = param0;
}
Result$Err$2$.prototype.$tag = 0;
function Result$Ok$2$(param0) {
  this._0 = param0;
}
Result$Ok$2$.prototype.$tag = 1;
function Result$Err$3$(param0) {
  this._0 = param0;
}
Result$Err$3$.prototype.$tag = 0;
function Result$Ok$3$(param0) {
  this._0 = param0;
}
Result$Ok$3$.prototype.$tag = 1;
function Result$Err$4$(param0) {
  this._0 = param0;
}
Result$Err$4$.prototype.$tag = 0;
function Result$Ok$4$(param0) {
  this._0 = param0;
}
Result$Ok$4$.prototype.$tag = 1;
function Result$Err$5$(param0) {
  this._0 = param0;
}
Result$Err$5$.prototype.$tag = 0;
function Result$Ok$5$(param0) {
  this._0 = param0;
}
Result$Ok$5$.prototype.$tag = 1;
function Result$Err$6$(param0) {
  this._0 = param0;
}
Result$Err$6$.prototype.$tag = 0;
function Result$Ok$6$(param0) {
  this._0 = param0;
}
Result$Ok$6$.prototype.$tag = 1;
function $unsafe_bytes_sub_string(bytes, byte_offset, byte_length) {
  const end_offset = byte_offset + byte_length;
  let buf = '';
  while (byte_offset < end_offset) {
    buf += String.fromCharCode(bytes[byte_offset] | (bytes[byte_offset + 1] << 8));
    byte_offset += 2;
  }
  return buf;
}
function $makebytes(a, b) {
  const arr = new Uint8Array(a);
  if (b !== 0) {
    arr.fill(b);
  }
  return arr;
}
function $make_array_len_and_init(a, b) {
  const arr = new Array(a);
  arr.fill(b);
  return arr;
}
const moonbitlang$core$builtin$$JSArray$push = (arr, val) => { arr.push(val); };
const moonbitlang$core$builtin$$MyInt64$convert_to_double_u = (a) => (a.hi >>> 0) * 4294967296.0 + (a.lo >>> 0);
const moonbitlang$core$builtin$$MyInt64$reinterpret_as_double = function f(a) {
  let view = f._view;
  if (view === undefined) {
    view = f._view = new DataView(new ArrayBuffer(8));
  }
  view.setUint32(0, a.hi);
  view.setUint32(4, a.lo);
  return view.getFloat64(0);
};
const moonbitlang$core$builtin$$try_init_wasm_helper = function() {
  try {
    return new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (e) {
    return undefined;
  }
};
const moonbitlang$core$builtin$$MyInt64$div_bigint = (a, b) => {
  const aVal = (BigInt(a.hi) << 32n) | BigInt(a.lo >>> 0);
  const bVal = (BigInt(b.hi) << 32n) | BigInt(b.lo >>> 0);
  const result = aVal / bVal;
  const lo = Number(result & 0xFFFFFFFFn);
  const hi = Number((result >> 32n) & 0xFFFFFFFFn);
  return { hi: hi | 0, lo: lo | 0 };
};
const moonbitlang$core$builtin$$MyInt64$div_u_bigint = (a, b) => {
  const aVal = (BigInt(a.hi >>> 0) << 32n) | BigInt(a.lo >>> 0);
  const bVal = (BigInt(b.hi >>> 0) << 32n) | BigInt(b.lo >>> 0);
  const result = aVal / bVal;
  const lo = Number(result & 0xFFFFFFFFn);
  const hi = Number((result >> 32n) & 0xFFFFFFFFn);
  return { hi: hi | 0, lo: lo | 0 };
};
const moonbitlang$core$builtin$$MyInt64$mod_bigint = (a, b) => {
  const aVal = (BigInt(a.hi) << 32n) | BigInt(a.lo >>> 0);
  const bVal = (BigInt(b.hi) << 32n) | BigInt(b.lo >>> 0);
  const result = aVal % bVal;
  const lo = Number(result & 0xFFFFFFFFn);
  const hi = Number((result >> 32n) & 0xFFFFFFFFn);
  return { hi: hi | 0, lo: lo | 0 };
};
const moonbitlang$core$builtin$$MyInt64$mod_u_bigint = (a, b) => {
  const aVal = (BigInt(a.hi >>> 0) << 32n) | BigInt(a.lo >>> 0);
  const bVal = (BigInt(b.hi >>> 0) << 32n) | BigInt(b.lo >>> 0);
  const result = aVal % bVal;
  const lo = Number(result & 0xFFFFFFFFn);
  const hi = Number((result >> 32n) & 0xFFFFFFFFn);
  return { hi: hi | 0, lo: lo | 0 };
};
const moonbitlang$core$builtin$$MyInt64$compare = (a, b) => {
  const ahi = a.hi;
  const bhi = b.hi;
  if (ahi < bhi) {
    return -1;
  }
  if (ahi > bhi) {
    return 1;
  }
  const alo = a.lo >>> 0;
  const blo = b.lo >>> 0;
  if (alo < blo) {
    return -1;
  }
  if (alo > blo) {
    return 1;
  }
  return 0;
};
const moonbitlang$core$builtin$$MyInt64$compare_u = (a, b) => {
  const ahi = a.hi >>> 0;
  const bhi = b.hi >>> 0;
  if (ahi < bhi) {
    return -1;
  }
  if (ahi > bhi) {
    return 1;
  }
  const alo = a.lo >>> 0;
  const blo = b.lo >>> 0;
  if (alo < blo) {
    return -1;
  }
  if (alo > blo) {
    return 1;
  }
  return 0;
};
const moonbitlang$core$builtin$$MyInt64$reinterpret_double = function f(a) {
  let view = f._view;
  if (view === undefined) {
    view = f._view = new DataView(new ArrayBuffer(8));
  }
  view.setFloat64(0, a);
  const hi = view.getInt32(0);
  const lo = view.getInt32(4);
  return { hi, lo };
};
const moonbitlang$core$builtin$$MyInt64$convert_to_double = (a) => a.hi * 4294967296.0 + (a.lo >>> 0);
const moonbitlang$core$builtin$$JSArray$copy = (arr) => arr.slice(0);
const moonbitlang$core$builtin$$MyInt64$from_double = (a) => {
  if (isNaN(a)) {
    return { hi: 0, lo: 0 };
  }
  if (a >= 9223372036854775807) {
    return { hi: 0x7fffffff, lo: 0xffffffff };
  }
  if (a <= -9223372036854775808) {
    return { hi: -2147483648, lo: 0 };
  }
  let neg = false;
  if (a < 0) {
    neg = true;
    a = -a;
  }
  let hi = (a * (1 / 0x100000000)) | 0;
  let lo = a >>> 0;
  if (neg) {
    if (lo === 0) {
      hi = ~hi + 1;
    } else {
      hi = ~hi;
      lo = ~lo + 1;
    }
  }
  return { hi, lo };
};
const $bytes_literal$0 = new Uint8Array();
const moonbitlang$core$builtin$$JSArray$set_length = (arr, len) => { arr.length = len; };
const moonbitlang$core$builtin$$JSArray$pop = (arr) => arr.pop();
const Option$None$7$ = { $tag: 0 };
function Option$Some$7$(param0) {
  this._0 = param0;
}
Option$Some$7$.prototype.$tag = 1;
const Option$None$8$ = { $tag: 0 };
function Option$Some$8$(param0) {
  this._0 = param0;
}
Option$Some$8$.prototype.$tag = 1;
const Option$None$9$ = { $tag: 0 };
function Option$Some$9$(param0) {
  this._0 = param0;
}
Option$Some$9$.prototype.$tag = 1;
const Option$None$10$ = { $tag: 0 };
function Option$Some$10$(param0) {
  this._0 = param0;
}
Option$Some$10$.prototype.$tag = 1;
const Option$None$11$ = { $tag: 0 };
function Option$Some$11$(param0) {
  this._0 = param0;
}
Option$Some$11$.prototype.$tag = 1;
function Result$Err$12$(param0) {
  this._0 = param0;
}
Result$Err$12$.prototype.$tag = 0;
function Result$Ok$12$(param0) {
  this._0 = param0;
}
Result$Ok$12$.prototype.$tag = 1;
function Result$Err$13$(param0) {
  this._0 = param0;
}
Result$Err$13$.prototype.$tag = 0;
function Result$Ok$13$(param0) {
  this._0 = param0;
}
Result$Ok$13$.prototype.$tag = 1;
function Result$Err$14$(param0) {
  this._0 = param0;
}
Result$Err$14$.prototype.$tag = 0;
function Result$Ok$14$(param0) {
  this._0 = param0;
}
Result$Ok$14$.prototype.$tag = 1;
function Result$Err$15$(param0) {
  this._0 = param0;
}
Result$Err$15$.prototype.$tag = 0;
function Result$Ok$15$(param0) {
  this._0 = param0;
}
Result$Ok$15$.prototype.$tag = 1;
function Result$Err$16$(param0) {
  this._0 = param0;
}
Result$Err$16$.prototype.$tag = 0;
function Result$Ok$16$(param0) {
  this._0 = param0;
}
Result$Ok$16$.prototype.$tag = 1;
function Result$Err$17$(param0) {
  this._0 = param0;
}
Result$Err$17$.prototype.$tag = 0;
function Result$Ok$17$(param0) {
  this._0 = param0;
}
Result$Ok$17$.prototype.$tag = 1;
function Result$Err$18$(param0) {
  this._0 = param0;
}
Result$Err$18$.prototype.$tag = 0;
function Result$Ok$18$(param0) {
  this._0 = param0;
}
Result$Ok$18$.prototype.$tag = 1;
function Result$Err$19$(param0) {
  this._0 = param0;
}
Result$Err$19$.prototype.$tag = 0;
function Result$Ok$19$(param0) {
  this._0 = param0;
}
Result$Ok$19$.prototype.$tag = 1;
const $16L = { hi: 0, lo: 16 };
const $_9223372036854775808L = { hi: -2147483648, lo: 0 };
const $65536L = { hi: 0, lo: 65536 };
const Option$None$20$ = { $tag: 0 };
function Option$Some$20$(param0) {
  this._0 = param0;
}
Option$Some$20$.prototype.$tag = 1;
const Option$None$21$ = { $tag: 0 };
function Option$Some$21$(param0) {
  this._0 = param0;
}
Option$Some$21$.prototype.$tag = 1;
const Option$None$22$ = { $tag: 0 };
function Option$Some$22$(param0) {
  this._0 = param0;
}
Option$Some$22$.prototype.$tag = 1;
function Result$Err$23$(param0) {
  this._0 = param0;
}
Result$Err$23$.prototype.$tag = 0;
function Result$Ok$23$(param0) {
  this._0 = param0;
}
Result$Ok$23$.prototype.$tag = 1;
const moonbitlang$core$env$$now_internal = function() {
   const nowMs = Date.now();
   return ({ hi : Number(BigInt(nowMs) >> 32n), lo : nowMs & 0xFFFFFFFF });
 };
function Result$Err$24$(param0) {
  this._0 = param0;
}
Result$Err$24$.prototype.$tag = 0;
function Result$Ok$24$(param0) {
  this._0 = param0;
}
Result$Ok$24$.prototype.$tag = 1;
function Result$Err$25$(param0) {
  this._0 = param0;
}
Result$Err$25$.prototype.$tag = 0;
function Result$Ok$25$(param0) {
  this._0 = param0;
}
Result$Ok$25$.prototype.$tag = 1;
const $256L = { hi: 0, lo: 256 };
const $1384120320L = { hi: 0, lo: 1384120320 };
const $1386217472L = { hi: 0, lo: 1386217472 };
const $3535798272L = { hi: 0, lo: -759169024 };
const $3537895424L = { hi: 0, lo: -757071872 };
const $310378496L = { hi: 0, lo: 310378496 };
const $2097120L = { hi: 0, lo: 2097120 };
const $312475648L = { hi: 0, lo: 312475648 };
const $2457862144L = { hi: 0, lo: -1837105152 };
const $2459959296L = { hi: 0, lo: -1835008000 };
const $2462056448L = { hi: 0, lo: -1832910848 };
const $2464153600L = { hi: 0, lo: -1830813696 };
const $838861792L = { hi: 0, lo: 838861792 };
const $2986345440L = { hi: 0, lo: -1308621856 };
const $3531603968L = { hi: 0, lo: -763363328 };
const $4068474880L = { hi: 0, lo: -226492416 };
const $1027604480L = { hi: 0, lo: 1027604480 };
const $1010827264L = { hi: 0, lo: 1010827264 };
const $511L = { hi: 0, lo: 511 };
const $1012951040L = { hi: 0, lo: 1012951040 };
const $3112173568L = { hi: 0, lo: -1182793728 };
const $3095396352L = { hi: 0, lo: -1199570944 };
const $3097520128L = { hi: 0, lo: -1197447168 };
const $960495616L = { hi: 0, lo: 960495616 };
const $943718400L = { hi: 0, lo: 943718400 };
const $941647872L = { hi: 0, lo: 941647872 };
const $4294967295L = { hi: 0, lo: -1 };
const $4095L = { hi: 0, lo: 4095 };
const $16773120L = { hi: 0, lo: 16773120 };
const $2415919104L = { hi: 0, lo: -1879048192 };
const $4181721088L = { hi: 0, lo: -113246208 };
const $2432696320L = { hi: 0, lo: -1862270976 };
const $2436890624L = { hi: 0, lo: -1858076672 };
const $16777215L = { hi: 0, lo: 16777215 };
const $4162785248L = { hi: 0, lo: -132182048 };
const $2332033024L = { hi: 0, lo: -1962934272 };
const $4165011424L = { hi: 0, lo: -129955872 };
function Result$Err$26$(param0) {
  this._0 = param0;
}
Result$Err$26$.prototype.$tag = 0;
function Result$Ok$26$(param0) {
  this._0 = param0;
}
Result$Ok$26$.prototype.$tag = 1;
const $4096L = { hi: 0, lo: 4096 };
const $2432697312L = { hi: 0, lo: -1862269984 };
const $2336121824L = { hi: 0, lo: -1958845472 };
const $704660416L = { hi: 0, lo: 704660416 };
const $4L = { hi: 0, lo: 4 };
const $2852160448L = { hi: 0, lo: -1442806848 };
const $3L = { hi: 0, lo: 3 };
const $1393064960L = { hi: 0, lo: 1393064960 };
const $8L = { hi: 0, lo: 8 };
const $3545824256L = { hi: 0, lo: -749143040 };
const $6L = { hi: 0, lo: 6 };
const $3545299968L = { hi: 0, lo: -749667328 };
const $3544775680L = { hi: 0, lo: -750191616 };
const $2839543808L = { hi: 0, lo: -1455423488 };
const $956301312L = { hi: 0, lo: 956301312 };
const $939524096L = { hi: 0, lo: 939524096 };
const $1023410176L = { hi: 0, lo: 1023410176 };
const $1006632960L = { hi: 0, lo: 1006632960 };
const $1008756736L = { hi: 0, lo: 1008756736 };
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default = { $tag: 0 };
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Cdecl = { $tag: 1 };
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Stdcall = { $tag: 2 };
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Fastcall = { $tag: 3 };
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Thiscall = { $tag: 4 };
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Regparm(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Regparm.prototype.$tag = 5;
const Option$None$27$ = { $tag: 0 };
function Option$Some$27$(param0) {
  this._0 = param0;
}
Option$Some$27$.prototype.$tag = 1;
const $2147483648L = { hi: 0, lo: -2147483648 };
const $4294967296L = { hi: 1, lo: 0 };
const Option$None$28$ = { $tag: 0 };
function Option$Some$28$(param0) {
  this._0 = param0;
}
Option$Some$28$.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$Expr(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$Expr.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List.prototype.$tag = 1;
const $reinterpret_view = new DataView(new ArrayBuffer(8));
function $i32_reinterpret_f32(a) {
  $reinterpret_view.setFloat32(0, a, true);
  return $reinterpret_view.getInt32(0, true);
}
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$FloatLit(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$FloatLit.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$CharLit(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$CharLit.prototype.$tag = 2;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StringLit(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StringLit.prototype.$tag = 3;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Ident(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Ident.prototype.$tag = 4;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$LabelAddr(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$LabelAddr.prototype.$tag = 5;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinTypesCompatibleP(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinTypesCompatibleP.prototype.$tag = 6;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinOffsetof(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinOffsetof.prototype.$tag = 7;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinVaArg(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinVaArg.prototype.$tag = 8;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary.prototype.$tag = 9;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Cast(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Cast.prototype.$tag = 10;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$CompoundLiteral(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$CompoundLiteral.prototype.$tag = 11;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StmtExpr(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StmtExpr.prototype.$tag = 12;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$SizeofExpr(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$SizeofExpr.prototype.$tag = 13;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$SizeofType(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$SizeofType.prototype.$tag = 14;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$AlignofExpr(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$AlignofExpr.prototype.$tag = 15;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$AlignofType(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$AlignofType.prototype.$tag = 16;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Binary(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Binary.prototype.$tag = 17;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Conditional(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Conditional.prototype.$tag = 18;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Call(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Call.prototype.$tag = 19;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Index(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Index.prototype.$tag = 20;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Member(param0, param1, param2, param3, param4, param5) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
  this._5 = param5;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Member.prototype.$tag = 21;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Index(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Index.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$IndexRange(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$IndexRange.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Field(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Field.prototype.$tag = 2;
const $255L = { hi: 0, lo: 255 };
const Option$None$29$ = { $tag: 0 };
function Option$Some$29$(param0) {
  this._0 = param0;
}
Option$Some$29$.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Run(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Run.prototype.$tag = 0;
const $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Help = { $tag: 1 };
const $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error = { $tag: 2 };
function $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Define(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Define.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Undef(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Undef.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$tokens$47$tokens_core$46$LexemeEntry$Owned(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$tokens$47$tokens_core$46$LexemeEntry$Owned.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$tokens$47$tokens_core$46$LexemeEntry$Slice(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$tokens$47$tokens_core$46$LexemeEntry$Slice.prototype.$tag = 1;
function Result$Err$30$(param0) {
  this._0 = param0;
}
Result$Err$30$.prototype.$tag = 0;
function Result$Ok$30$(param0) {
  this._0 = param0;
}
Result$Ok$30$.prototype.$tag = 1;
function Result$Err$31$(param0) {
  this._0 = param0;
}
Result$Err$31$.prototype.$tag = 0;
function Result$Ok$31$(param0) {
  this._0 = param0;
}
Result$Ok$31$.prototype.$tag = 1;
function Result$Err$32$(param0) {
  this._0 = param0;
}
Result$Err$32$.prototype.$tag = 0;
function Result$Ok$32$(param0) {
  this._0 = param0;
}
Result$Ok$32$.prototype.$tag = 1;
function Result$Err$33$(param0) {
  this._0 = param0;
}
Result$Err$33$.prototype.$tag = 0;
function Result$Ok$33$(param0) {
  this._0 = param0;
}
Result$Ok$33$.prototype.$tag = 1;
function Result$Err$34$(param0) {
  this._0 = param0;
}
Result$Err$34$.prototype.$tag = 0;
function Result$Ok$34$(param0) {
  this._0 = param0;
}
Result$Ok$34$.prototype.$tag = 1;
const Option$None$35$ = { $tag: 0 };
function Option$Some$35$(param0) {
  this._0 = param0;
}
Option$Some$35$.prototype.$tag = 1;
const Option$None$36$ = { $tag: 0 };
function Option$Some$36$(param0) {
  this._0 = param0;
}
Option$Some$36$.prototype.$tag = 1;
const $63L = { hi: 0, lo: 63 };
const Option$None$37$ = { $tag: 0 };
function Option$Some$37$(param0) {
  this._0 = param0;
}
Option$Some$37$.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Compound(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Compound.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$If(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$If.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$While(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$While.prototype.$tag = 2;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$DoWhile(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$DoWhile.prototype.$tag = 3;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$For(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$For.prototype.$tag = 4;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Switch(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Switch.prototype.$tag = 5;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Case(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Case.prototype.$tag = 6;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Default(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Default.prototype.$tag = 7;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Label(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Label.prototype.$tag = 8;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Goto(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Goto.prototype.$tag = 9;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$GotoExpr(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$GotoExpr.prototype.$tag = 10;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Break(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Break.prototype.$tag = 11;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Continue(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Continue.prototype.$tag = 12;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Return(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Return.prototype.$tag = 13;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Asm(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Asm.prototype.$tag = 14;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$ExprStmt(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$ExprStmt.prototype.$tag = 15;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$DeclStmt(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$DeclStmt.prototype.$tag = 16;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$TagDef(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$TagDef.prototype.$tag = 17;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$StaticAssert(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$StaticAssert.prototype.$tag = 18;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty.prototype.$tag = 19;
const $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$AlignSpec$Default = { $tag: 0 };
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$AlignSpec$Expr(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$AlignSpec$Expr.prototype.$tag = 1;
const Option$None$38$ = { $tag: 0 };
function Option$Some$38$(param0) {
  this._0 = param0;
}
Option$Some$38$.prototype.$tag = 1;
const Option$None$39$ = { $tag: 0 };
function Option$Some$39$(param0) {
  this._0 = param0;
}
Option$Some$39$.prototype.$tag = 1;
const Option$None$40$ = { $tag: 0 };
function Option$Some$40$(param0) {
  this._0 = param0;
}
Option$Some$40$.prototype.$tag = 1;
const Option$None$41$ = { $tag: 0 };
function Option$Some$41$(param0) {
  this._0 = param0;
}
Option$Some$41$.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$RecordItem$Field(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$RecordItem$Field.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$RecordItem$StaticAssert(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$RecordItem$StaticAssert.prototype.$tag = 1;
const Option$None$42$ = { $tag: 0 };
function Option$Some$42$(param0) {
  this._0 = param0;
}
Option$Some$42$.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Pointer(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Pointer.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Array(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Array.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Function(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Function.prototype.$tag = 2;
const Option$None$43$ = { $tag: 0 };
function Option$Some$43$(param0) {
  this._0 = param0;
}
Option$Some$43$.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$FuncDef(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$FuncDef.prototype.$tag = 0;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$FuncDecl(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$FuncDecl.prototype.$tag = 1;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Var(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Var.prototype.$tag = 2;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Typedef(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Typedef.prototype.$tag = 3;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$TagDef(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$TagDef.prototype.$tag = 4;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$StaticAssert(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$StaticAssert.prototype.$tag = 5;
function $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Asm(param0) {
  this._0 = param0;
}
$64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Asm.prototype.$tag = 6;
const moonbitlang$x$sys$internal$ffi$$get_env_var_internal = function(key) {
   const env = process.env;
   return env[key] || "";
 };
const moonbitlang$x$sys$internal$ffi$$is_env_var_exists_internal = function(key) {
   return key in process.env;
 };
const $999L = { hi: 0, lo: 999 };
function Result$Err$44$(param0) {
  this._0 = param0;
}
Result$Err$44$.prototype.$tag = 0;
function Result$Ok$44$(param0) {
  this._0 = param0;
}
Result$Ok$44$.prototype.$tag = 1;
const $$$64$hackwaly$47$tinycc$47$host$47$mem_host$46$InMemoryHost$36$as$36$64$hackwaly$47$tinycc$47$host$46$Host = { method_0: hackwaly$tinycc$host$$Host$path_exists$0$, method_1: hackwaly$tinycc$host$$Host$read_file_to_string$0$, method_2: hackwaly$tinycc$host$$Host$read_file_to_bytes$0$, method_3: hackwaly$tinycc$host$$Host$write_bytes_to_file$0$, method_4: hackwaly$tinycc$host$$Host$remove_file$0$ };
const $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger = { method_0: moonbitlang$core$builtin$$Logger$write_string$1$, method_1: moonbitlang$core$builtin$$Logger$write_substring$2$, method_2: moonbitlang$core$builtin$$Logger$write_view$1$, method_3: moonbitlang$core$builtin$$Logger$write_char$1$ };
function Error$$to_string(_e) {
  switch (_e.$tag) {
    case 0: {
      return moonbitlang$core$builtin$$Show$to_string$3$(_e);
    }
    case 1: {
      return moonbitlang$core$builtin$$Show$to_string$3$(_e);
    }
    case 4: {
      return "moonbitlang/core/encoding/utf8.Malformed.Malformed";
    }
    case 2: {
      return moonbitlang$core$builtin$$Show$to_string$4$(_e);
    }
    default: {
      return moonbitlang$core$builtin$$Show$to_string$5$(_e);
    }
  }
}
const moonbitlang$core$builtin$$wasm_helper_cache = { tried: false, exports: undefined };
const moonbitlang$core$uint64$$max_value = $_1L;
const moonbitlang$core$strconv$$base_err_str = "invalid base";
const moonbitlang$core$strconv$$range_err_str = "value out of range";
const moonbitlang$core$strconv$$syntax_err_str = "invalid syntax";
const moonbitlang$core$strconv$$parse_int64$46$inner$46$42$bind$124$603 = "";
const moonbitlang$core$strconv$$min_19digit_int = $1000000000000000000L;
const moonbitlang$core$strconv$$parse_scientific$46$exp_num$124$279 = $0L;
const moonbitlang$core$strconv$$parse_number$46$exp_number$124$260 = $0L;
const moonbitlang$core$strconv$$double_info = { mantissa_bits: 52, exponent_bits: 11, bias: -1023 };
const moonbitlang$core$strconv$$powtab = [1, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43, 46, 49, 53, 56, 59];
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2126 = { _0: 0, _1: "" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2127 = { _0: 1, _1: "5" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2128 = { _0: 1, _1: "25" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2129 = { _0: 1, _1: "125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2130 = { _0: 2, _1: "625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2131 = { _0: 2, _1: "3125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2132 = { _0: 2, _1: "15625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2133 = { _0: 3, _1: "78125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2134 = { _0: 3, _1: "390625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2135 = { _0: 3, _1: "1953125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2136 = { _0: 4, _1: "9765625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2137 = { _0: 4, _1: "48828125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2138 = { _0: 4, _1: "244140625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2139 = { _0: 4, _1: "1220703125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2140 = { _0: 5, _1: "6103515625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2141 = { _0: 5, _1: "30517578125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2142 = { _0: 5, _1: "152587890625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2143 = { _0: 6, _1: "762939453125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2144 = { _0: 6, _1: "3814697265625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2145 = { _0: 6, _1: "19073486328125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2146 = { _0: 7, _1: "95367431640625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2147 = { _0: 7, _1: "476837158203125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2148 = { _0: 7, _1: "2384185791015625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2149 = { _0: 7, _1: "11920928955078125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2150 = { _0: 8, _1: "59604644775390625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2151 = { _0: 8, _1: "298023223876953125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2152 = { _0: 8, _1: "1490116119384765625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2153 = { _0: 9, _1: "7450580596923828125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2154 = { _0: 9, _1: "37252902984619140625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2155 = { _0: 9, _1: "186264514923095703125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2156 = { _0: 10, _1: "931322574615478515625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2157 = { _0: 10, _1: "4656612873077392578125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2158 = { _0: 10, _1: "23283064365386962890625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2159 = { _0: 10, _1: "116415321826934814453125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2160 = { _0: 11, _1: "582076609134674072265625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2161 = { _0: 11, _1: "2910383045673370361328125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2162 = { _0: 11, _1: "14551915228366851806640625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2163 = { _0: 12, _1: "72759576141834259033203125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2164 = { _0: 12, _1: "363797880709171295166015625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2165 = { _0: 12, _1: "1818989403545856475830078125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2166 = { _0: 13, _1: "9094947017729282379150390625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2167 = { _0: 13, _1: "45474735088646411895751953125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2168 = { _0: 13, _1: "227373675443232059478759765625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2169 = { _0: 13, _1: "1136868377216160297393798828125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2170 = { _0: 14, _1: "5684341886080801486968994140625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2171 = { _0: 14, _1: "28421709430404007434844970703125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2172 = { _0: 14, _1: "142108547152020037174224853515625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2173 = { _0: 15, _1: "710542735760100185871124267578125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2174 = { _0: 15, _1: "3552713678800500929355621337890625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2175 = { _0: 15, _1: "17763568394002504646778106689453125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2176 = { _0: 16, _1: "88817841970012523233890533447265625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2177 = { _0: 16, _1: "444089209850062616169452667236328125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2178 = { _0: 16, _1: "2220446049250313080847263336181640625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2179 = { _0: 16, _1: "11102230246251565404236316680908203125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2180 = { _0: 17, _1: "55511151231257827021181583404541015625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2181 = { _0: 17, _1: "277555756156289135105907917022705078125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2182 = { _0: 17, _1: "1387778780781445675529539585113525390625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2183 = { _0: 18, _1: "6938893903907228377647697925567626953125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2184 = { _0: 18, _1: "34694469519536141888238489627838134765625" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2185 = { _0: 18, _1: "173472347597680709441192448139190673828125" };
const moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2186 = { _0: 19, _1: "867361737988403547205962240695953369140625" };
const moonbitlang$core$strconv$$left_shift_cheats = [moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2126, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2127, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2128, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2129, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2130, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2131, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2132, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2133, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2134, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2135, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2136, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2137, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2138, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2139, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2140, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2141, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2142, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2143, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2144, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2145, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2146, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2147, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2148, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2149, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2150, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2151, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2152, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2153, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2154, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2155, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2156, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2157, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2158, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2159, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2160, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2161, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2162, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2163, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2164, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2165, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2166, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2167, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2168, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2169, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2170, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2171, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2172, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2173, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2174, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2175, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2176, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2177, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2178, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2179, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2180, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2181, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2182, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2183, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2184, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2185, moonbitlang$core$strconv$$left_shift_cheats$46$tuple$47$2186];
const moonbitlang$core$strconv$$int_pow10 = [$1L, $10L, $100L, $1000L, $10000L, $100000L, $1000000L, $10000000L, $100000000L, $1000000000L, $10000000000L, $100000000000L, $1000000000000L, $10000000000000L, $100000000000000L, $1000000000000000L];
const moonbitlang$core$strconv$$max_exponent_fast_path = $22L;
const moonbitlang$core$strconv$$table = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1e+12, 1e+13, 1e+14, 1e+15, 1e+16, 1e+17, 1e+18, 1e+19, 1e+20, 1e+21, 1e+22, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const moonbitlang$core$strconv$$max_exponent_disguised_fast_path = $37L;
const moonbitlang$core$strconv$$min_exponent_fast_path = $_22L;
const hackwaly$tinycc$backend$arm64$$vstack = [];
const hackwaly$tinycc$backend$arm64$$u64_mask$46$one$124$203 = $1L;
const hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191 = $65535L;
const hackwaly$tinycc$backend$arm64$$arm64_movimm$46$mask16$124$183 = $65535L;
const hackwaly$tinycc$support$util$target_config$$char_is_unsigned = true;
const hackwaly$tinycc$backend$macho$$build_strtab$46$42$bind$124$199 = " ";
const hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4747 = { sectname: "__text", segname: "__TEXT", flags: -2147482624, align: 4, is_zerofill: false };
const hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4748 = { sectname: "__const", segname: "__TEXT", flags: 0, align: 4, is_zerofill: false };
const hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4749 = { sectname: "__cstring", segname: "__TEXT", flags: 2, align: 1, is_zerofill: false };
const hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4750 = { sectname: "__data", segname: "__DATA", flags: 0, align: 4, is_zerofill: false };
const hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4751 = { sectname: "__bss", segname: "__DATA", flags: 1, align: 4, is_zerofill: true };
const hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4752 = { sectname: "__data", segname: "__DATA", flags: 0, align: 4, is_zerofill: false };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4786 = { _0: 5, _1: true };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4787 = { _0: 6, _1: false };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4788 = { _0: 2, _1: true };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4789 = { _0: 2, _1: true };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4790 = { _0: 3, _1: true };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4791 = { _0: 3, _1: true };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4792 = { _0: 4, _1: false };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4793 = { _0: 4, _1: false };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4794 = { _0: 0, _1: false };
const hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4795 = { _0: 0, _1: false };
const hackwaly$tinycc$backend$macho$$segment_prot$46$tuple$47$4822 = { _0: 5, _1: 5 };
const hackwaly$tinycc$backend$macho$$segment_prot$46$tuple$47$4823 = { _0: 3, _1: 3 };
const hackwaly$tinycc$frontend$ast$ast_core$$default_int_type_value = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(2, false);
const hackwaly$tinycc$frontend$ast$ast_core$$empty_qual$46$record$47$5496 = { is_const: false, is_volatile: false, is_restrict: false, is_atomic: false };
const hackwaly$tinycc$sem$sem_core$$size_t_type_value = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(3, true);
const hackwaly$tinycc$sem$sem_core$$void_pointer_type_value = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void);
const hackwaly$tinycc$sem$sem_core$$has_builtin_prefix$46$42$bind$124$2102 = "__builtin_";
const hackwaly$tinycc$sem$sem_core$$has_atomic_prefix$46$42$bind$124$2377 = "__atomic_";
const hackwaly$tinycc$sem$sem_core$$qual_to_string$46$42$bind$124$2747 = " ";
const hackwaly$tinycc$sem$sem_core$$type_to_string$46$42$bind$124$2752 = ", ";
const hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range$46$constr$47$6000 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(2, true);
const hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range$46$constr$47$6001 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(4, false);
const hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range$46$constr$47$6002 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(2, false);
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6238 = "alm.?";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6239 = "Asm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6240 = "alsm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6241 = "aplbmm.b";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6242 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6243 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6244 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6245 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6246 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6247 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6248 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6249 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6250 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6251 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6252 = "avm.v";
const hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6253 = "avm.v";
const hackwaly$tinycc$backend$codegen$$callee_saved_regs_list = [19, 20, 21, 22, 23, 24, 25, 26, 27, 28];
const hackwaly$tinycc$backend$codegen$$caller_saved_regs_list = [9, 10, 11, 12, 13, 14, 15];
const hackwaly$tinycc$backend$codegen$$static_local_func_name$46$prefix$124$3500 = "__local_static.";
const hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11130 = 0;
const hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11131 = 1;
const hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11132 = 2;
const hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11133 = 3;
const hackwaly$tinycc$driver$cli$$expand_cli_args$46$42$bind$124$125 = "@";
const hackwaly$tinycc$driver$cli$$is_c_source_path$46$42$bind$124$131 = ".c";
const hackwaly$tinycc$driver$cli$$is_c_source_path$46$42$bind$124$132 = ".i";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$135 = "-";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$136 = "-o";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$137 = "-I";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$145 = "-D";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$153 = "-U";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$154 = "-W";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$155 = "-w";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$156 = "-O";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$157 = "-g";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$158 = "-Z";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$159 = "-Q";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$160 = "-isystem";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$161 = "-L";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$162 = "-l";
const hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$163 = "-";
const hackwaly$tinycc$support$intern$intern_core$$tok_hash_init = 1;
const hackwaly$tinycc$frontend$tokens$tokens_core$$empty_hidden = 0;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$749 = "if";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$744 = "do";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$739 = "for";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$734 = "int";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$729 = "asm";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$724 = "else";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$719 = "goto";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$714 = "case";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$709 = "auto";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$704 = "void";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$699 = "char";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$694 = "long";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$689 = "enum";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$684 = "while";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$679 = "break";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$674 = "const";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$669 = "float";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$664 = "_Bool";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$659 = "short";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$654 = "union";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$649 = "__asm";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$644 = "return";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$639 = "switch";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$634 = "extern";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$629 = "static";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$624 = "signed";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$619 = "inline";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$614 = "double";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$609 = "struct";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$604 = "sizeof";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$599 = "typeof";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$594 = "default";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$589 = "typedef";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$584 = "__asm__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$579 = "__const";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$574 = "continue";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$569 = "unsigned";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$564 = "volatile";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$559 = "register";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$554 = "restrict";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$549 = "_Alignof";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$544 = "__typeof";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$539 = "__inline";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$534 = "__signed";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$529 = "_Float16";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$524 = "_Noreturn";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$519 = "_Atomic";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$514 = "__alignof";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$509 = "__const__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$504 = "__typeof__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$499 = "__volatile";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$494 = "__restrict";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$489 = "__inline__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$484 = "__signed__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$479 = "__unsigned";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$474 = "__alignof__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$469 = "__attribute";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$464 = "__volatile__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$459 = "__restrict__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$454 = "__unsigned__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$449 = "__attribute__";
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$444 = "_Static_assert";
const moonbitlang$x$time$$utc_offset = { id: "Z", abbrev: "UTC", seconds: 0, dst: false };
const moonbitlang$x$time$$seconds_per_minute = $60L;
const moonbitlang$x$time$$invalid_date_err = "Invalid date";
const moonbitlang$x$time$$invalid_time_err = "Invalid time";
const moonbitlang$x$time$$invalid_date_time_err = "Invalid date time";
const moonbitlang$x$time$$nanoseconds_per_second = $1000000000L;
const moonbitlang$x$time$$year_deltas = [0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63, 64, 64, 64, 64, 65, 65, 65, 65, 66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68, 68, 69, 69, 69, 69, 70, 70, 70, 70, 71, 71, 71, 71, 72, 72, 72, 72, 73, 73, 73, 73, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75, 76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79, 80, 80, 80, 80, 81, 81, 81, 81, 82, 82, 82, 82, 83, 83, 83, 83, 84, 84, 84, 84, 85, 85, 85, 85, 86, 86, 86, 86, 87, 87, 87, 87, 88, 88, 88, 88, 89, 89, 89, 89, 90, 90, 90, 90, 91, 91, 91, 91, 92, 92, 92, 92, 93, 93, 93, 93, 94, 94, 94, 94, 95, 95, 95, 95, 96, 96, 96, 96, 97, 97, 97, 97];
const moonbitlang$x$time$$minutes_per_hour = $60L;
const hackwaly$tinycc$frontend$preproc$preproc_core$$dir_name$46$42$bind$124$782 = "/";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$906 = "__LINE__";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$901 = "__FILE__";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$896 = "__DATE__";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$891 = "__TIME__";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$886 = "defined";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$881 = "__has_include";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$876 = "__has_include_next";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$871 = "define";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$866 = "undef";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$861 = "if";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$856 = "ifdef";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$851 = "ifndef";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$846 = "elif";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$841 = "else";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$836 = "endif";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$831 = "include";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$826 = "include_next";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$821 = "line";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$816 = "error";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$811 = "warning";
const hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$806 = "pragma";
const hackwaly$tinycc$frontend$preproc$preproc_core$$join_path$46$42$bind$124$993 = "/";
const hackwaly$tinycc$frontend$preproc$preproc_core$$resolve_include_path$46$42$bind$124$996 = "/";
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal$46$max_signed$124$199 = $9223372036854775807L;
const hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$892 = "__builtin_types_compatible_p";
const hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$887 = "__builtin_offsetof";
const hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$882 = "__builtin_va_arg";
const hackwaly$tinycc$frontend$parser$parser_core$$normalize_attr_name$46$42$bind$124$1061 = "_";
const hackwaly$tinycc$driver$$default_output_path$46$42$bind$124$238 = "/";
const hackwaly$tinycc$driver$$default_output_path$46$42$bind$124$232 = ".";
const hackwaly$tinycc$driver$$join_temp_path$46$42$bind$124$247 = "/";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$11 = "#ifndef TARGETCONDITIONALS_H\n#define TARGETCONDITIONALS_H\n\n#define TARGET_OS_EMBEDDED 0\n#define TARGET_IPHONE_SIMULATOR 0\n#define TARGET_OS_MACCATALYST 0\n\n#endif";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$14 = "#ifndef _TCC_COMPAT_ASSERT_H\n#define _TCC_COMPAT_ASSERT_H\n\n#ifdef NDEBUG\n#define assert(x) ((void)0)\n#else\n#define assert(x) ((void)0)\n#endif\n\n#endif /* _TCC_COMPAT_ASSERT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$17 = "#ifndef _TCC_COMPAT_CRT_EXTERNS_H\n#define _TCC_COMPAT_CRT_EXTERNS_H\n\n#ifdef __APPLE__\nchar ***_NSGetEnviron(void);\n#endif\n\n#endif /* _TCC_COMPAT_CRT_EXTERNS_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$20 = "#ifndef _TCC_COMPAT_CTYPE_H\n#define _TCC_COMPAT_CTYPE_H\n\nint isalnum(int c);\nint isalpha(int c);\nint isblank(int c);\nint iscntrl(int c);\nint isdigit(int c);\nint isgraph(int c);\nint islower(int c);\nint isprint(int c);\nint ispunct(int c);\nint isspace(int c);\nint isupper(int c);\nint isxdigit(int c);\nint tolower(int c);\nint toupper(int c);\n\n#endif /* _TCC_COMPAT_CTYPE_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$23 = "#ifndef _TCC_COMPAT_DIRENT_H\n#define _TCC_COMPAT_DIRENT_H\n\n#include <sys/types.h>\n#include <stdint.h>\n\ntypedef struct DIR DIR;\n\n#if defined(__APPLE__)\n#define TCC_DIRENT_NAME_MAX 1024\n#pragma pack(4)\nstruct dirent {\n  uint64_t d_ino;\n  uint64_t d_seekoff;\n  uint16_t d_reclen;\n  uint16_t d_namlen;\n  uint8_t d_type;\n  char d_name[TCC_DIRENT_NAME_MAX];\n};\n#pragma pack()\n#else\nstruct dirent {\n  char d_name[256];\n};\n#endif\n\nDIR *opendir(const char *name);\nstruct dirent *readdir(DIR *dirp);\nint closedir(DIR *dirp);\n\n#endif /* _TCC_COMPAT_DIRENT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$26 = "#ifndef _TCC_COMPAT_DISPATCH_DISPATCH_H\n#define _TCC_COMPAT_DISPATCH_DISPATCH_H\n\n#include <stdint.h>\n\ntypedef void *dispatch_object_t;\ntypedef void *dispatch_queue_t;\ntypedef void *dispatch_group_t;\ntypedef void *dispatch_queue_attr_t;\ntypedef void *dispatch_source_t;\ntypedef struct dispatch_semaphore_s *dispatch_semaphore_t;\n\ntypedef uint64_t dispatch_time_t;\ntypedef int64_t dispatch_once_t;\n\n#define DISPATCH_TIME_FOREVER (~(dispatch_time_t)0)\n#define DISPATCH_TIME_NOW ((dispatch_time_t)0)\n\ndispatch_semaphore_t dispatch_semaphore_create(long value);\nlong dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);\nlong dispatch_semaphore_signal(dispatch_semaphore_t dsema);\nvoid dispatch_release(dispatch_object_t object);\n\n#endif /* _TCC_COMPAT_DISPATCH_DISPATCH_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$29 = "#ifndef _TCC_COMPAT_DLFCN_H\n#define _TCC_COMPAT_DLFCN_H\n\n#include <stddef.h>\n\n#define RTLD_LAZY   0x1\n#define RTLD_NOW    0x2\n#define RTLD_GLOBAL 0x100\n#define RTLD_LOCAL  0\n#define RTLD_DEFAULT ((void *)-2)\n#define RTLD_NEXT ((void *)-1)\n\nvoid *dlopen(const char *filename, int flag);\nvoid *dlsym(void *handle, const char *symbol);\nint dlclose(void *handle);\nchar *dlerror(void);\n\n#endif /* _TCC_COMPAT_DLFCN_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$32 = "#ifndef _TCC_COMPAT_ERRNO_H\n#define _TCC_COMPAT_ERRNO_H\n\nextern int errno;\n\n#if defined(__APPLE__)\n#define EPERM 1\n#define ENOENT 2\n#define ESRCH 3\n#define EINTR 4\n#define EIO 5\n#define ENXIO 6\n#define E2BIG 7\n#define ENOEXEC 8\n#define EBADF 9\n#define ECHILD 10\n#define EDEADLK 11\n#define ENOMEM 12\n#define EACCES 13\n#define EFAULT 14\n#define EBUSY 16\n#define EEXIST 17\n#define EXDEV 18\n#define ENODEV 19\n#define ENOTDIR 20\n#define EISDIR 21\n#define EINVAL 22\n#define ENFILE 23\n#define EMFILE 24\n#define ENOTTY 25\n#define EFBIG 27\n#define ENOSPC 28\n#define ESPIPE 29\n#define EROFS 30\n#define EPIPE 32\n#define EDOM 33\n#define ERANGE 34\n#define EAGAIN 35\n#define ENAMETOOLONG 63\n#define ENOTEMPTY 66\n#define ENOLCK 77\n#define ENOSYS 78\n#define ETIMEDOUT 60\n#else\n#define EPERM 1\n#define ENOENT 2\n#define ESRCH 3\n#define EINTR 4\n#define EIO 5\n#define ENXIO 6\n#define E2BIG 7\n#define ENOEXEC 8\n#define EBADF 9\n#define ECHILD 10\n#define EAGAIN 11\n#define ENOMEM 12\n#define EACCES 13\n#define EFAULT 14\n#define EBUSY 16\n#define EEXIST 17\n#define EXDEV 18\n#define ENODEV 19\n#define ENOTDIR 20\n#define EISDIR 21\n#define EINVAL 22\n#define ENFILE 23\n#define EMFILE 24\n#define ENOTTY 25\n#define EFBIG 27\n#define ENOSPC 28\n#define ESPIPE 29\n#define EROFS 30\n#define EPIPE 32\n#define EDOM 33\n#define ERANGE 34\n#define EDEADLK 35\n#define ENAMETOOLONG 36\n#define ENOSYS 38\n#define ENOTEMPTY 39\n#define ETIMEDOUT 110\n#define ENOLCK 77\n#endif\n\n#endif /* _TCC_COMPAT_ERRNO_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$35 = "#ifndef _TCC_COMPAT_FCNTL_H\n#define _TCC_COMPAT_FCNTL_H\n\n#include <sys/types.h>\n\n#define O_RDONLY 0x0000\n#define O_WRONLY 0x0001\n#define O_RDWR   0x0002\n#define O_ACCMODE 0x0003\n#define O_CREAT  0x0200\n#define O_EXCL   0x0800\n#define O_TRUNC  0x0400\n#define O_APPEND 0x0008\n#define O_NONBLOCK 0x0004\n#define O_CLOEXEC 0x1000000\n\n#define F_RDLCK 1\n#define F_WRLCK 3\n#define F_UNLCK 2\n#define F_GETLK 7\n#define F_SETLK 8\n#define F_SETLKW 9\n\n#if defined(__APPLE__)\nstruct flock {\n  off_t l_start;\n  off_t l_len;\n  pid_t l_pid;\n  short l_type;\n  short l_whence;\n};\n#else\nstruct flock {\n  short l_type;\n  short l_whence;\n  off_t l_start;\n  off_t l_len;\n  pid_t l_pid;\n};\n#endif\n\nint open(const char *path, int flags, ...);\nint creat(const char *path, mode_t mode);\nint fcntl(int fd, int cmd, ...);\n\n#endif /* _TCC_COMPAT_FCNTL_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$38 = "#ifndef _TCC_COMPAT_FENV_H\n#define _TCC_COMPAT_FENV_H\n\ntypedef int fexcept_t;\ntypedef struct {\n  unsigned int __control;\n} fenv_t;\n\n#define FE_TONEAREST 0\n#define FE_DOWNWARD 0\n#define FE_UPWARD 0\n#define FE_TOWARDZERO 0\n#define FE_ALL_EXCEPT 0\n\n#endif /* _TCC_COMPAT_FENV_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$41 = "#ifndef _TCC_COMPAT_FLOAT_H\n#define _TCC_COMPAT_FLOAT_H\n\n#define FLT_RADIX 2\n\n/* IEEE float */\n#define FLT_MANT_DIG 24\n#define FLT_DIG 6\n#define FLT_ROUNDS 1\n#define FLT_EPSILON 1.19209290e-07F\n#define FLT_MIN_EXP (-125)\n#define FLT_MIN 1.17549435e-38F\n#define FLT_MIN_10_EXP (-37)\n#define FLT_MAX_EXP 128\n#define FLT_MAX 3.40282347e+38F\n#define FLT_MAX_10_EXP 38\n\n/* IEEE double */\n#define DBL_MANT_DIG 53\n#define DBL_DIG 15\n#define DBL_EPSILON 2.2204460492503131e-16\n#define DBL_MIN_EXP (-1021)\n#define DBL_MIN 2.2250738585072014e-308\n#define DBL_MIN_10_EXP (-307)\n#define DBL_MAX_EXP 1024\n#define DBL_MAX 1.7976931348623157e+308\n#define DBL_MAX_10_EXP 308\n\n/* horrible intel long double */\n#if defined __i386__ || defined __x86_64__\n\n#define LDBL_MANT_DIG 64\n#define LDBL_DIG 18\n#define LDBL_EPSILON 1.08420217248550443401e-19L\n#define LDBL_MIN_EXP (-16381)\n#define LDBL_MIN 3.36210314311209350626e-4932L\n#define LDBL_MIN_10_EXP (-4931)\n#define LDBL_MAX_EXP 16384\n#define LDBL_MAX 1.18973149535723176502e+4932L\n#define LDBL_MAX_10_EXP 4932\n#define DECIMAL_DIG 21\n\n#elif defined __aarch64__ || defined __riscv\n/*\n * Use values from:\n * gcc -dM -E -xc /dev/null | grep LDBL | sed -e \"s/__//g\"\n */\n#define LDBL_MANT_DIG 113\n#define LDBL_DIG 33\n#define LDBL_EPSILON 1.92592994438723585305597794258492732e-34L\n#define LDBL_MIN_EXP (-16381)\n#define LDBL_MIN 3.36210314311209350626267781732175260e-4932L\n#define LDBL_MIN_10_EXP (-4931)\n#define LDBL_MAX_EXP 16384\n#define LDBL_MAX 1.18973149535723176508575932662800702e+4932L\n#define LDBL_MAX_10_EXP 4932\n#define DECIMAL_DIG 36\n\n#else\n\n/* same as IEEE double */\n#define LDBL_MANT_DIG 53\n#define LDBL_DIG 15\n#define LDBL_EPSILON 2.2204460492503131e-16L\n#define LDBL_MIN_EXP (-1021)\n#define LDBL_MIN 2.2250738585072014e-308L\n#define LDBL_MIN_10_EXP (-307)\n#define LDBL_MAX_EXP 1024\n#define LDBL_MAX 1.7976931348623157e+308L\n#define LDBL_MAX_10_EXP 308\n#define DECIMAL_DIG 17\n\n#endif\n\n#endif /* _TCC_COMPAT_FLOAT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$44 = "#ifndef _TCC_COMPAT_GLOB_H\n#define _TCC_COMPAT_GLOB_H\n\n#include <stddef.h>\n\ntypedef struct {\n  size_t gl_pathc;\n  char **gl_pathv;\n  size_t gl_offs;\n} glob_t;\n\n#define GLOB_ERR 1\n#define GLOB_NOSPACE 2\n#define GLOB_ABORTED 3\n#define GLOB_NOMATCH 4\n\nint glob(const char *pattern, int flags, int (*errfunc)(const char *, int), glob_t *pglob);\nvoid globfree(glob_t *pglob);\n\n#endif /* _TCC_COMPAT_GLOB_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$47 = "#ifndef _TCC_COMPAT_INTTYPES_H\n#define _TCC_COMPAT_INTTYPES_H\n\n#include <stdint.h>\n\ntypedef struct {\n  intmax_t quot;\n  intmax_t rem;\n} imaxdiv_t;\n\n#define PRId8  \"d\"\n#define PRId16 \"d\"\n#define PRId32 \"d\"\n#define PRId64 \"lld\"\n\n#define PRIu8  \"u\"\n#define PRIu16 \"u\"\n#define PRIu32 \"u\"\n#define PRIu64 \"llu\"\n\n#define PRIx8  \"x\"\n#define PRIx16 \"x\"\n#define PRIx32 \"x\"\n#define PRIx64 \"llx\"\n\nstatic inline intmax_t imaxabs(intmax_t n) { return n < 0 ? -n : n; }\n\nstatic inline imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom) {\n  imaxdiv_t r;\n  r.quot = numer / denom;\n  r.rem = numer % denom;\n  return r;\n}\n\n#ifndef _TCC_COMPAT_BUILTIN_BITS\n#define _TCC_COMPAT_BUILTIN_BITS\nstatic inline int tcc_builtin_clz32(unsigned int x) {\n  int n = 0;\n  unsigned int mask = 1u << ((sizeof(unsigned int) * 8) - 1);\n  while (mask && (x & mask) == 0) {\n    n++;\n    mask >>= 1;\n  }\n  return n;\n}\n\nstatic inline int tcc_builtin_clz64(uint64_t x) {\n  int n = 0;\n  uint64_t mask = (uint64_t)1 << 63;\n  while (mask && (x & mask) == 0) {\n    n++;\n    mask >>= 1;\n  }\n  return n;\n}\n\nstatic inline int tcc_builtin_ctz32(unsigned int x) {\n  int n = 0;\n  unsigned int mask = 1u;\n  while (mask && (x & mask) == 0) {\n    n++;\n    mask <<= 1;\n  }\n  return n;\n}\n\nstatic inline int tcc_builtin_ctz64(uint64_t x) {\n  int n = 0;\n  uint64_t mask = (uint64_t)1;\n  while (mask && (x & mask) == 0) {\n    n++;\n    mask <<= 1;\n  }\n  return n;\n}\n\n#define __builtin_clz(x) tcc_builtin_clz32((unsigned int)(x))\n#define __builtin_clzll(x) tcc_builtin_clz64((uint64_t)(x))\n#define __builtin_ctz(x) tcc_builtin_ctz32((unsigned int)(x))\n#define __builtin_ctzll(x) tcc_builtin_ctz64((uint64_t)(x))\n#endif\n\n#define strtoimax strtoll\n#define strtoumax strtoull\n#define wcstoimax wcstoll\n#define wcstoumax wcstoull\n\n#endif /* _TCC_COMPAT_INTTYPES_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$50 = "#ifndef _TCC_COMPAT_LIBKERN_OSCACHECONTROL_H\n#define _TCC_COMPAT_LIBKERN_OSCACHECONTROL_H\n\n#include <stddef.h>\n\nstatic inline void sys_icache_invalidate(void *start, size_t len) {\n  (void)start;\n  (void)len;\n}\n\n#endif /* _TCC_COMPAT_LIBKERN_OSCACHECONTROL_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$53 = "#ifndef _TCC_COMPAT_LIBPROC_H\n#define _TCC_COMPAT_LIBPROC_H\n\n#include <stdint.h>\n\nint proc_pidpath(int pid, void *buffer, uint32_t buffersize);\n\n#endif /* _TCC_COMPAT_LIBPROC_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$56 = "#ifndef _TCC_COMPAT_LIMITS_H\n#define _TCC_COMPAT_LIMITS_H\n\n#include <stdint.h>\n\n#define CHAR_BIT 8\n\n#define SCHAR_MIN (-128)\n#define SCHAR_MAX 127\n#define UCHAR_MAX 255\n\n#define SHRT_MIN (-32768)\n#define SHRT_MAX 32767\n#define USHRT_MAX 65535\n\n#define INT_MIN (-2147483647 - 1)\n#define INT_MAX 2147483647\n#define UINT_MAX 4294967295U\n\n#define LONG_MIN (-9223372036854775807L - 1L)\n#define LONG_MAX 9223372036854775807L\n#define ULONG_MAX 18446744073709551615UL\n\n#define LLONG_MIN (-9223372036854775807LL - 1LL)\n#define LLONG_MAX 9223372036854775807LL\n#define ULLONG_MAX 18446744073709551615ULL\n\n#define FILENAME_MAX 1024\n\n#endif /* _TCC_COMPAT_LIMITS_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$59 = "#ifndef _TCC_COMPAT_LOCALE_H\n#define _TCC_COMPAT_LOCALE_H\n\n#define LC_ALL 0\n#define LC_COLLATE 1\n#define LC_CTYPE 2\n#define LC_MONETARY 3\n#define LC_NUMERIC 4\n#define LC_TIME 5\n\nstruct lconv {\n  char *decimal_point;\n  char *thousands_sep;\n  char *grouping;\n  char *int_curr_symbol;\n  char *currency_symbol;\n  char *mon_decimal_point;\n  char *mon_thousands_sep;\n  char *mon_grouping;\n  char *positive_sign;\n  char *negative_sign;\n  char int_frac_digits;\n  char frac_digits;\n  char p_cs_precedes;\n  char p_sep_by_space;\n  char n_cs_precedes;\n  char n_sep_by_space;\n  char p_sign_posn;\n  char n_sign_posn;\n};\n\nchar *setlocale(int category, const char *locale);\nstruct lconv *localeconv(void);\n\n#endif /* _TCC_COMPAT_LOCALE_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$62 = "#ifndef _TCC_COMPAT_MALLOC_MALLOC_H\n#define _TCC_COMPAT_MALLOC_MALLOC_H\n\n#include <stddef.h>\n\nsize_t malloc_size(const void *ptr);\nsize_t malloc_usable_size(void *ptr);\n\n#endif /* _TCC_COMPAT_MALLOC_MALLOC_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$65 = "#ifndef _TCC_COMPAT_MATH_H\n#define _TCC_COMPAT_MATH_H\n\n#include <stddef.h>\n#include <stdint.h>\n\n#ifndef __builtin_huge_val\n#define __builtin_huge_val() 1e500\n#endif\n#ifndef __builtin_huge_valf\n#define __builtin_huge_valf() 1e50f\n#endif\n#ifndef __builtin_huge_vall\n#define __builtin_huge_vall() 1e5000L\n#endif\n#ifndef __builtin_nanf\n#define __builtin_nanf(ignored_string) (0.0F/0.0F)\n#endif\n\n#define HUGE_VAL (__builtin_huge_val())\n#define HUGE_VALF (__builtin_huge_valf())\n#define HUGE_VALL (__builtin_huge_vall())\n#define NAN (__builtin_nanf(\"\"))\n#define INFINITY (1.0F/0.0F)\n\ndouble sin(double x);\ndouble cos(double x);\ndouble tan(double x);\ndouble asin(double x);\ndouble acos(double x);\ndouble atan(double x);\ndouble atan2(double y, double x);\ndouble sinh(double x);\ndouble cosh(double x);\ndouble tanh(double x);\ndouble asinh(double x);\ndouble acosh(double x);\ndouble atanh(double x);\ndouble exp(double x);\ndouble expm1(double x);\ndouble log(double x);\ndouble log1p(double x);\ndouble log2(double x);\ndouble log10(double x);\ndouble pow(double x, double y);\ndouble cbrt(double x);\ndouble sqrt(double x);\ndouble ceil(double x);\ndouble floor(double x);\ndouble fabs(double x);\ndouble fmod(double x, double y);\ndouble modf(double x, double *iptr);\ndouble trunc(double x);\ndouble round(double x);\ndouble frexp(double x, int *exp);\ndouble ldexp(double x, int exp);\ndouble fmin(double x, double y);\ndouble fmax(double x, double y);\ndouble hypot(double x, double y);\nlong lrint(double x);\n\nfloat sinf(float x);\nfloat cosf(float x);\nfloat tanf(float x);\nfloat asinf(float x);\nfloat acosf(float x);\nfloat atanf(float x);\nfloat atan2f(float y, float x);\nfloat sinhf(float x);\nfloat coshf(float x);\nfloat tanhf(float x);\nfloat asinhf(float x);\nfloat acoshf(float x);\nfloat atanhf(float x);\nfloat expf(float x);\nfloat expm1f(float x);\nfloat logf(float x);\nfloat log1pf(float x);\nfloat log2f(float x);\nfloat log10f(float x);\nfloat powf(float x, float y);\nfloat cbrtf(float x);\nfloat sqrtf(float x);\nfloat ceilf(float x);\nfloat floorf(float x);\nfloat fabsf(float x);\nfloat fmodf(float x, float y);\nfloat modff(float x, float *iptr);\nfloat truncf(float x);\nfloat roundf(float x);\nfloat frexpf(float x, int *exp);\nfloat ldexpf(float x, int exp);\nfloat fminf(float x, float y);\nfloat fmaxf(float x, float y);\nfloat hypotf(float x, float y);\nlong lrintf(float x);\n\nint isnan(double x);\nint isinf(double x);\nstatic inline int finite(double x) { return !isnan(x) && !isinf(x); }\n#define isfinite(x) finite(x)\nstatic inline int tcc_signbit_double(double x) {\n  union { double d; uint64_t u; } v;\n  v.d = x;\n  return (int)(v.u >> 63);\n}\n#define signbit(x) tcc_signbit_double((double)(x))\n\n#endif /* _TCC_COMPAT_MATH_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$68 = "#ifndef _TCC_COMPAT_PTHREAD_H\n#define _TCC_COMPAT_PTHREAD_H\n\n#include <sys/types.h>\n#include <time.h>\n\ntypedef void *pthread_t;\n\n#if defined(__APPLE__)\ntypedef struct { long __sig; char __opaque[56]; } pthread_attr_t;\ntypedef struct { long __sig; char __opaque[56]; } pthread_mutex_t;\ntypedef struct { long __sig; char __opaque[8]; } pthread_mutexattr_t;\ntypedef struct { long __sig; char __opaque[40]; } pthread_cond_t;\ntypedef struct { long __sig; char __opaque[8]; } pthread_condattr_t;\ntypedef struct { long __sig; char __opaque[192]; } pthread_rwlock_t;\ntypedef struct { long __sig; char __opaque[16]; } pthread_rwlockattr_t;\ntypedef struct { long __sig; char __opaque[8]; } pthread_once_t;\n\n#define _PTHREAD_MUTEX_SIG_init 0x32aaaba7\n#define _PTHREAD_COND_SIG_init 0x3cb0b1bb\n#define _PTHREAD_RWLOCK_SIG_init 0x2da8b3b4\n#define _PTHREAD_ONCE_SIG_init 0x30b1bcba\n\n#define PTHREAD_MUTEX_INITIALIZER {_PTHREAD_MUTEX_SIG_init, {0}}\n#define PTHREAD_COND_INITIALIZER {_PTHREAD_COND_SIG_init, {0}}\n#define PTHREAD_RWLOCK_INITIALIZER {_PTHREAD_RWLOCK_SIG_init, {0}}\n#define PTHREAD_ONCE_INIT {_PTHREAD_ONCE_SIG_init, {0}}\n#else\ntypedef struct { int __opaque; } pthread_attr_t;\ntypedef struct { int __opaque; } pthread_mutex_t;\ntypedef struct { int __opaque; } pthread_mutexattr_t;\ntypedef struct { int __opaque; } pthread_cond_t;\ntypedef struct { int __opaque; } pthread_condattr_t;\ntypedef struct { int __opaque; } pthread_rwlock_t;\ntypedef struct { int __opaque; } pthread_rwlockattr_t;\ntypedef struct { int __opaque; } pthread_once_t;\n\n#define PTHREAD_MUTEX_INITIALIZER {0}\n#define PTHREAD_COND_INITIALIZER {0}\n#define PTHREAD_RWLOCK_INITIALIZER {0}\n#define PTHREAD_ONCE_INIT {0}\n#endif\n#define PTHREAD_CREATE_DETACHED 2\n#define PTHREAD_MUTEX_NORMAL 0\n#define PTHREAD_MUTEX_ERRORCHECK 1\n#define PTHREAD_MUTEX_RECURSIVE 2\n#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL\n\nint pthread_create(\n  pthread_t *thread,\n  const pthread_attr_t *attr,\n  void *(*start_routine)(void *),\n  void *arg\n);\nint pthread_join(pthread_t thread, void **retval);\nint pthread_detach(pthread_t thread);\n\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutexattr_init(pthread_mutexattr_t *attr);\nint pthread_mutexattr_destroy(pthread_mutexattr_t *attr);\nint pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);\n\nint pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);\nint pthread_cond_destroy(pthread_cond_t *cond);\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\nint pthread_cond_timedwait(\n  pthread_cond_t *cond,\n  pthread_mutex_t *mutex,\n  const struct timespec *abstime\n);\nint pthread_cond_signal(pthread_cond_t *cond);\nint pthread_cond_broadcast(pthread_cond_t *cond);\n\nint pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr);\nint pthread_rwlock_destroy(pthread_rwlock_t *lock);\nint pthread_rwlock_rdlock(pthread_rwlock_t *lock);\nint pthread_rwlock_wrlock(pthread_rwlock_t *lock);\nint pthread_rwlock_unlock(pthread_rwlock_t *lock);\nint pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *attr, int pref);\n\npthread_t pthread_self(void);\nint pthread_equal(pthread_t t1, pthread_t t2);\n\n#endif /* _TCC_COMPAT_PTHREAD_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$71 = "#ifndef _TCC_COMPAT_SEMAPHORE_H\n#define _TCC_COMPAT_SEMAPHORE_H\n\ntypedef struct { long __opaque[4]; } sem_t;\n\nint sem_init(sem_t *sem, int pshared, unsigned int value);\nint sem_destroy(sem_t *sem);\nint sem_wait(sem_t *sem);\nint sem_trywait(sem_t *sem);\nint sem_post(sem_t *sem);\nint sem_getvalue(sem_t *sem, int *sval);\n\n#endif /* _TCC_COMPAT_SEMAPHORE_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$74 = "#ifndef _TCC_COMPAT_SETJMP_H\n#define _TCC_COMPAT_SETJMP_H\n\ntypedef long jmp_buf[32];\n\nint setjmp(jmp_buf env);\nvoid longjmp(jmp_buf env, int val);\n\n#endif /* _TCC_COMPAT_SETJMP_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$77 = "#ifndef _TCC_COMPAT_SIGNAL_H\n#define _TCC_COMPAT_SIGNAL_H\n\n#include <sys/types.h>\n\ntypedef unsigned long sigset_t;\ntypedef void (*sig_t)(int);\ntypedef void (*sighandler_t)(int);\n\ntypedef struct siginfo {\n  int si_signo;\n  int si_code;\n  void *si_addr;\n} siginfo_t;\n\ntypedef struct stack {\n  void *ss_sp;\n  size_t ss_size;\n  int ss_flags;\n} stack_t;\n\nstruct sigaction {\n  int sa_flags;\n  sigset_t sa_mask;\n  union {\n    sighandler_t sa_handler;\n    void (*sa_sigaction)(int, siginfo_t *, void *);\n  };\n};\n\n#define SIG_DFL ((sighandler_t)0)\n#define SIG_IGN ((sighandler_t)1)\n#define SIG_ERR ((sighandler_t)-1)\n\n#define SIGABRT 6\n#define SIGFPE  8\n#define SIGKILL 9\n#define SIGBUS  10\n#define SIGSEGV 11\n#define SIGPIPE 13\n#define SIGALRM 14\n#define SIGTERM 15\n#define SIGINT  2\n#define SIGQUIT 3\n#define SIGHUP  1\n#define SIGTRAP 5\n#define SIGILL  4\n#define SIGSTOP 17\n#define SIGTSTP 18\n#define SIGCONT 19\n#define SIGCHLD 20\n#define SIGTTIN 21\n#define SIGTTOU 22\n#define SIGUSR1 30\n#define SIGUSR2 31\n\n#define SIG_BLOCK   0\n#define SIG_UNBLOCK 1\n#define SIG_SETMASK 2\n\n#define SA_ONSTACK   0x0001\n#define SA_RESTART   0x0002\n#define SA_NOCLDSTOP 0x0004\n#define SA_SIGINFO   0x0008\n#define SA_RESETHAND 0x0010\n\n#define FPE_INTDIV 1\n#define FPE_FLTDIV 2\n\nint sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);\nint sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\nint sigemptyset(sigset_t *set);\nint sigfillset(sigset_t *set);\nint sigaddset(sigset_t *set, int signo);\nsighandler_t signal(int signum, sighandler_t handler);\nint raise(int signum);\nint sigaltstack(const stack_t *ss, stack_t *oss);\n\n#endif /* _TCC_COMPAT_SIGNAL_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$80 = "#ifndef _TCC_COMPAT_STDARG_H\n#define _TCC_COMPAT_STDARG_H\n\ntypedef __builtin_va_list va_list;\n#define va_start __builtin_va_start\n#define va_arg __builtin_va_arg\n#define va_copy __builtin_va_copy\n#define va_end __builtin_va_end\n\ntypedef va_list __gnuc_va_list;\n#define _VA_LIST_DEFINED\n\n#endif /* _TCC_COMPAT_STDARG_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$83 = "#ifndef _TCC_COMPAT_STDATOMIC_H\n#define _TCC_COMPAT_STDATOMIC_H\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n#define __ATOMIC_RELAXED 0\n#define __ATOMIC_CONSUME 1\n#define __ATOMIC_ACQUIRE 2\n#define __ATOMIC_RELEASE 3\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_SEQ_CST 5\n\ntypedef enum {\n  memory_order_relaxed = __ATOMIC_RELAXED,\n  memory_order_consume = __ATOMIC_CONSUME,\n  memory_order_acquire = __ATOMIC_ACQUIRE,\n  memory_order_release = __ATOMIC_RELEASE,\n  memory_order_acq_rel = __ATOMIC_ACQ_REL,\n  memory_order_seq_cst = __ATOMIC_SEQ_CST,\n} memory_order;\n\ntypedef _Atomic(_Bool) atomic_bool;\ntypedef _Atomic(char) atomic_char;\ntypedef _Atomic(signed char) atomic_schar;\ntypedef _Atomic(unsigned char) atomic_uchar;\ntypedef _Atomic(short) atomic_short;\ntypedef _Atomic(unsigned short) atomic_ushort;\ntypedef _Atomic(int) atomic_int;\ntypedef _Atomic(unsigned int) atomic_uint;\ntypedef _Atomic(long) atomic_long;\ntypedef _Atomic(unsigned long) atomic_ulong;\ntypedef _Atomic(long long) atomic_llong;\ntypedef _Atomic(unsigned long long) atomic_ullong;\ntypedef _Atomic(uint_least16_t) atomic_char16_t;\ntypedef _Atomic(uint_least32_t) atomic_char32_t;\ntypedef _Atomic(wchar_t) atomic_wchar_t;\ntypedef _Atomic(int_least8_t) atomic_int_least8_t;\ntypedef _Atomic(uint_least8_t) atomic_uint_least8_t;\ntypedef _Atomic(int_least16_t) atomic_int_least16_t;\ntypedef _Atomic(uint_least16_t) atomic_uint_least16_t;\ntypedef _Atomic(int_least32_t) atomic_int_least32_t;\ntypedef _Atomic(uint_least32_t) atomic_uint_least32_t;\ntypedef _Atomic(int_least64_t) atomic_int_least64_t;\ntypedef _Atomic(uint_least64_t) atomic_uint_least64_t;\ntypedef _Atomic(int_fast8_t) atomic_int_fast8_t;\ntypedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;\ntypedef _Atomic(int_fast16_t) atomic_int_fast16_t;\ntypedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;\ntypedef _Atomic(int_fast32_t) atomic_int_fast32_t;\ntypedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;\ntypedef _Atomic(int_fast64_t) atomic_int_fast64_t;\ntypedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;\ntypedef _Atomic(intptr_t) atomic_intptr_t;\ntypedef _Atomic(uintptr_t) atomic_uintptr_t;\ntypedef _Atomic(size_t) atomic_size_t;\ntypedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;\ntypedef _Atomic(intmax_t) atomic_intmax_t;\ntypedef _Atomic(uintmax_t) atomic_uintmax_t;\n\ntypedef struct {\n  atomic_bool value;\n} atomic_flag;\n\n#define ATOMIC_FLAG_INIT {0}\n#define ATOMIC_VAR_INIT(value) (value)\n\n#define atomic_init(object, desired) \\\n  atomic_store_explicit(object, desired, __ATOMIC_RELAXED)\n\n#define __atomic_store_n(ptr, val, order) \\\n  (*(ptr) = (val), __atomic_store((ptr), &(typeof(*(ptr))){val}, (order)))\n#define atomic_store_explicit(object, desired, order) \\\n  ({ __typeof__ (object) ptr = (object); \\\n     __typeof__ (*ptr) tmp = (desired); \\\n     __atomic_store (ptr, &tmp, (order)); \\\n  })\n#define atomic_store(object, desired) \\\n  atomic_store_explicit (object, desired, __ATOMIC_SEQ_CST)\n\n#define __atomic_load_n(ptr, order) \\\n  ({ typeof(*(ptr)) __val; \\\n     __atomic_load((ptr), &__val, (order)); \\\n     __val; })\n#define atomic_load_explicit(object, order) \\\n  ({ __typeof__ (object) ptr = (object); \\\n     __typeof__ (*ptr) tmp; \\\n     __atomic_load (ptr, &tmp, (order)); \\\n     tmp; \\\n  })\n#define atomic_load(object) atomic_load_explicit (object, __ATOMIC_SEQ_CST)\n\n#define atomic_exchange_explicit(object, desired, order) \\\n  ({ __typeof__ (object) ptr = (object); \\\n     __typeof__ (*ptr) val = (desired); \\\n     __typeof__ (*ptr) tmp; \\\n     __atomic_exchange (ptr, &val, &tmp, (order)); \\\n     tmp; \\\n  })\n#define atomic_exchange(object, desired) \\\n  atomic_exchange_explicit (object, desired, __ATOMIC_SEQ_CST)\n#define __atomic_compare_exchange_n(ptr, expected, desired, weak, success, failure) \\\n  ({ typeof(*(ptr)) __desired = (desired); \\\n     __atomic_compare_exchange((ptr), (expected), &__desired, \\\n       (weak), (success), (failure)); })\n#define atomic_compare_exchange_strong_explicit(object, expected, desired, success, failure) \\\n  ({ __typeof__ (object) ptr = (object); \\\n     __typeof__ (*ptr) tmp = desired; \\\n     __atomic_compare_exchange(ptr, expected, &tmp, 0, success, failure); \\\n  })\n#define atomic_compare_exchange_strong(object, expected, desired) \\\n  atomic_compare_exchange_strong_explicit (object, expected, desired, \\\n                                           __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\n#define atomic_compare_exchange_weak_explicit(object, expected, desired, success, failure) \\\n  ({ __typeof__ (object) ptr = (object); \\\n     __typeof__ (*ptr) tmp = desired; \\\n     __atomic_compare_exchange(ptr, expected, &tmp, 1, success, failure); \\\n  })\n#define atomic_compare_exchange_weak(object, expected, desired) \\\n  atomic_compare_exchange_weak_explicit (object, expected, desired, \\\n                                         __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)\n\n#define atomic_fetch_add(object, operand) \\\n  __atomic_fetch_add(object, operand, __ATOMIC_SEQ_CST)\n#define atomic_fetch_add_explicit __atomic_fetch_add\n\n#define atomic_fetch_sub(object, operand) \\\n  __atomic_fetch_sub(object, operand, __ATOMIC_SEQ_CST)\n#define atomic_fetch_sub_explicit __atomic_fetch_sub\n\n#define atomic_fetch_or(object, operand) \\\n  __atomic_fetch_or(object, operand, __ATOMIC_SEQ_CST)\n#define atomic_fetch_or_explicit __atomic_fetch_or\n\n#define atomic_fetch_xor(object, operand) \\\n  __atomic_fetch_xor(object, operand, __ATOMIC_SEQ_CST)\n#define atomic_fetch_xor_explicit __atomic_fetch_xor\n\n#define atomic_fetch_and(object, operand) \\\n  __atomic_fetch_and(object, operand, __ATOMIC_SEQ_CST)\n#define atomic_fetch_and_explicit __atomic_fetch_and\n\nextern void atomic_thread_fence(memory_order order);\n#define __atomic_thread_fence(order) atomic_thread_fence(order)\nextern void atomic_signal_fence(memory_order order);\n#define __atomic_signal_fence(order) atomic_signal_fence(order)\n#define atomic_signal_fence(order) __atomic_signal_fence(order)\nextern bool __atomic_is_lock_free(size_t size, void *ptr);\n#define atomic_is_lock_free(OBJ) __atomic_is_lock_free(sizeof(*(OBJ)), (OBJ))\n\nextern bool atomic_flag_test_and_set(void *object);\nextern bool atomic_flag_test_and_set_explicit(void *object, memory_order order);\nextern void atomic_flag_clear(void *object);\nextern void atomic_flag_clear_explicit(void *object, memory_order order);\n\n#endif /* _TCC_COMPAT_STDATOMIC_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$86 = "#ifndef _TCC_COMPAT_STDBOOL_H\n#define _TCC_COMPAT_STDBOOL_H\n\n#define bool _Bool\n#define true 1\n#define false 0\n#define __bool_true_false_are_defined 1\n\n#endif /* _TCC_COMPAT_STDBOOL_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$89 = "#ifndef _TCC_COMPAT_STDDEF_H\n#define _TCC_COMPAT_STDDEF_H\n\ntypedef unsigned long size_t;\ntypedef long ssize_t;\ntypedef long ptrdiff_t;\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\ntypedef int wchar_t;\ntypedef int wint_t;\n\n#ifndef NULL\n#define NULL ((void *)0)\n#endif\n\n#ifndef offsetof\n#define offsetof(type, field) __builtin_offsetof(type, field)\n#endif\n\n#endif /* _TCC_COMPAT_STDDEF_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$92 = "#include <stddef.h>\n#ifndef _TCC_COMPAT_STDINT_H\n#define _TCC_COMPAT_STDINT_H\n\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\n\ntypedef short int16_t;\ntypedef unsigned short uint16_t;\n\ntypedef int int32_t;\ntypedef unsigned int uint32_t;\n\ntypedef long long int64_t;\ntypedef unsigned long long uint64_t;\n\ntypedef int8_t int_least8_t;\ntypedef uint8_t uint_least8_t;\ntypedef int16_t int_least16_t;\ntypedef uint16_t uint_least16_t;\ntypedef int32_t int_least32_t;\ntypedef uint32_t uint_least32_t;\ntypedef int64_t int_least64_t;\ntypedef uint64_t uint_least64_t;\n\ntypedef int8_t int_fast8_t;\ntypedef uint8_t uint_fast8_t;\ntypedef int16_t int_fast16_t;\ntypedef uint16_t uint_fast16_t;\ntypedef int32_t int_fast32_t;\ntypedef uint32_t uint_fast32_t;\ntypedef int64_t int_fast64_t;\ntypedef uint64_t uint_fast64_t;\n\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n\ntypedef long long intmax_t;\ntypedef unsigned long long uintmax_t;\n\n#define INT8_C(c)   c\n#define INT16_C(c)  c\n#define INT32_C(c)  c\n#define INT64_C(c)  c##LL\n#define UINT8_C(c)  c##U\n#define UINT16_C(c) c##U\n#define UINT32_C(c) c##U\n#define UINT64_C(c) c##ULL\n\n#define INTMAX_C(c)  INT64_C(c)\n#define UINTMAX_C(c) UINT64_C(c)\n\n#define INT8_MIN (-128)\n#define INT16_MIN (-32768)\n#define INT32_MIN (-2147483647 - 1)\n#define INT64_MIN (-9223372036854775807LL - 1)\n\n#define INT8_MAX 127\n#define INT16_MAX 32767\n#define INT32_MAX 2147483647\n#define INT64_MAX 9223372036854775807LL\n\n#define UINT8_MAX 255U\n#define UINT16_MAX 65535U\n#define UINT32_MAX 4294967295U\n#define UINT64_MAX 18446744073709551615ULL\n\n#define INT_LEAST8_MIN INT8_MIN\n#define INT_LEAST16_MIN INT16_MIN\n#define INT_LEAST32_MIN INT32_MIN\n#define INT_LEAST64_MIN INT64_MIN\n\n#define INT_LEAST8_MAX INT8_MAX\n#define INT_LEAST16_MAX INT16_MAX\n#define INT_LEAST32_MAX INT32_MAX\n#define INT_LEAST64_MAX INT64_MAX\n\n#define UINT_LEAST8_MAX UINT8_MAX\n#define UINT_LEAST16_MAX UINT16_MAX\n#define UINT_LEAST32_MAX UINT32_MAX\n#define UINT_LEAST64_MAX UINT64_MAX\n\n#define INT_FAST8_MIN INT8_MIN\n#define INT_FAST16_MIN INT16_MIN\n#define INT_FAST32_MIN INT32_MIN\n#define INT_FAST64_MIN INT64_MIN\n\n#define INT_FAST8_MAX INT8_MAX\n#define INT_FAST16_MAX INT16_MAX\n#define INT_FAST32_MAX INT32_MAX\n#define INT_FAST64_MAX INT64_MAX\n\n#define UINT_FAST8_MAX UINT8_MAX\n#define UINT_FAST16_MAX UINT16_MAX\n#define UINT_FAST32_MAX UINT32_MAX\n#define UINT_FAST64_MAX UINT64_MAX\n\n#if defined(__LP64__)\n#define INTPTR_MIN INT64_MIN\n#define INTPTR_MAX INT64_MAX\n#define UINTPTR_MAX UINT64_MAX\n#define PTRDIFF_MIN INT64_MIN\n#define PTRDIFF_MAX INT64_MAX\n#define SIZE_MAX UINT64_MAX\n#else\n#define INTPTR_MIN INT32_MIN\n#define INTPTR_MAX INT32_MAX\n#define UINTPTR_MAX UINT32_MAX\n#define PTRDIFF_MIN INT32_MIN\n#define PTRDIFF_MAX INT32_MAX\n#define SIZE_MAX UINT32_MAX\n#endif\n\n#define INTMAX_MIN INT64_MIN\n#define INTMAX_MAX INT64_MAX\n#define UINTMAX_MAX UINT64_MAX\n\n#endif /* _TCC_COMPAT_STDINT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$95 = "#ifndef _TCC_COMPAT_STDIO_H\n#define _TCC_COMPAT_STDIO_H\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <limits.h>\n\n#define EOF (-1)\n#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n#define BUFSIZ 1024\n\ntypedef struct __tcc_file FILE;\ntypedef long fpos_t;\n\nextern FILE *__stdinp;\nextern FILE *__stdoutp;\nextern FILE *__stderrp;\n\n#define stdin __stdinp\n#define stdout __stdoutp\n#define stderr __stderrp\n\nint remove(const char *path);\nint rename(const char *oldpath, const char *newpath);\n\nFILE *fopen(const char *path, const char *mode);\nFILE *freopen(const char *path, const char *mode, FILE *stream);\nFILE *fdopen(int fd, const char *mode);\nFILE *popen(const char *command, const char *mode);\nint fclose(FILE *stream);\nint fflush(FILE *stream);\n\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\nint fgetc(FILE *stream);\nint getc(FILE *stream);\nint getchar(void);\nint ungetc(int c, FILE *stream);\nint fputc(int c, FILE *stream);\nint putc(int c, FILE *stream);\nint putchar(int c);\nint fputs(const char *s, FILE *stream);\nint puts(const char *s);\n\nint fprintf(FILE *stream, const char *fmt, ...);\nint printf(const char *fmt, ...);\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nint sprintf(char *buf, const char *fmt, ...);\nint vfprintf(FILE *stream, const char *fmt, va_list ap);\nint vprintf(const char *fmt, va_list ap);\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list ap);\nint vsprintf(char *buf, const char *fmt, va_list ap);\n\nvoid clearerr(FILE *stream);\nint ferror(FILE *stream);\nint feof(FILE *stream);\n\nint fseek(FILE *stream, long offset, int whence);\nlong ftell(FILE *stream);\nvoid rewind(FILE *stream);\nint fgetpos(FILE *stream, fpos_t *pos);\nint fsetpos(FILE *stream, const fpos_t *pos);\n\nvoid setbuf(FILE *stream, char *buf);\nint setvbuf(FILE *stream, char *buf, int mode, size_t size);\n\nFILE *tmpfile(void);\nchar *tmpnam(char *s);\n\nint fileno(FILE *stream);\nint pclose(FILE *stream);\n\nvoid perror(const char *s);\n\n#endif /* _TCC_COMPAT_STDIO_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$98 = "#ifndef _TCC_COMPAT_STDLIB_H\n#define _TCC_COMPAT_STDLIB_H\n\n#include <stddef.h>\n\ntypedef struct { int quot, rem; } div_t;\ntypedef struct { long quot, rem; } ldiv_t;\ntypedef struct { long long quot, rem; } lldiv_t;\n\n#define EXIT_SUCCESS 0\n#define EXIT_FAILURE 1\n\nvoid abort(void);\nvoid exit(int status);\nint atexit(void (*fn)(void));\n\nint atoi(const char *s);\nlong atol(const char *s);\nlong long atoll(const char *s);\n\nlong strtol(const char *s, char **endp, int base);\nlong long strtoll(const char *s, char **endp, int base);\nunsigned long strtoul(const char *s, char **endp, int base);\nunsigned long long strtoull(const char *s, char **endp, int base);\ndouble strtod(const char *s, char **endp);\nfloat strtof(const char *s, char **endp);\nlong double strtold(const char *s, char **endp);\n\nvoid *malloc(size_t size);\nvoid *calloc(size_t nmemb, size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid *aligned_alloc(size_t alignment, size_t size);\nvoid free(void *ptr);\nvoid *alloca(size_t size);\n#ifndef alloca\n#define alloca(size) __builtin_alloca(size)\n#endif\n\nvoid *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*cmp)(const void *, const void *));\nvoid qsort(void *base, size_t nmemb, size_t size, int (*cmp)(const void *, const void *));\n\nint rand(void);\nvoid srand(unsigned int seed);\n\nchar *getenv(const char *name);\nint system(const char *cmd);\n\nint mkstemp(char *template);\nchar *mktemp(char *template);\nchar *realpath(const char *path, char *resolved);\n\nlong labs(long n);\nlong long llabs(long long n);\ndiv_t div(int x, int y);\nldiv_t ldiv(long x, long y);\nlldiv_t lldiv(long long x, long long y);\n\n#endif /* _TCC_COMPAT_STDLIB_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$101 = "#ifndef _STDNORETURN_H\n#define _STDNORETURN_H\n\n/* ISOC11 noreturn */\n#define noreturn _Noreturn\n\n#endif /* _STDNORETURN_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$104 = "#ifndef _TCC_COMPAT_STRING_H\n#define _TCC_COMPAT_STRING_H\n\n#include <stddef.h>\n\nvoid *memcpy(void *dst, const void *src, size_t n);\nvoid *memmove(void *dst, const void *src, size_t n);\nvoid *memset(void *s, int c, size_t n);\nint memcmp(const void *a, const void *b, size_t n);\nvoid *memchr(const void *s, int c, size_t n);\n\nsize_t strlen(const char *s);\nint strcmp(const char *a, const char *b);\nint strncmp(const char *a, const char *b, size_t n);\nchar *strcpy(char *dst, const char *src);\nchar *strncpy(char *dst, const char *src, size_t n);\nchar *strcat(char *dst, const char *src);\nchar *strncat(char *dst, const char *src, size_t n);\nchar *strchr(const char *s, int c);\nchar *strrchr(const char *s, int c);\nchar *strstr(const char *haystack, const char *needle);\nchar *strpbrk(const char *s, const char *accept);\nsize_t strspn(const char *s, const char *accept);\nsize_t strcspn(const char *s, const char *reject);\nchar *strtok(char *s, const char *delim);\nchar *strdup(const char *s);\n\nint strcasecmp(const char *s1, const char *s2);\nint strncasecmp(const char *s1, const char *s2, size_t n);\n\nchar *strerror(int errnum);\n\n#endif /* _TCC_COMPAT_STRING_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$107 = "#ifndef _TCC_COMPAT_SYS_FILE_H\n#define _TCC_COMPAT_SYS_FILE_H\n\n#define LOCK_SH 1\n#define LOCK_EX 2\n#define LOCK_NB 4\n#define LOCK_UN 8\n\nint flock(int fd, int operation);\n\n#endif /* _TCC_COMPAT_SYS_FILE_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$110 = "#ifndef _TCC_COMPAT_SYS_IOCTL_H\n#define _TCC_COMPAT_SYS_IOCTL_H\n\n#include <sys/types.h>\n\nstruct winsize {\n  unsigned short ws_row;\n  unsigned short ws_col;\n  unsigned short ws_xpixel;\n  unsigned short ws_ypixel;\n};\n\n#define TIOCGWINSZ 0x5413\n\nint ioctl(int fd, unsigned long request, ...);\n\n#endif /* _TCC_COMPAT_SYS_IOCTL_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$113 = "#ifndef _TCC_COMPAT_SYS_MMAN_H\n#define _TCC_COMPAT_SYS_MMAN_H\n\n#include <sys/types.h>\n\n#define PROT_NONE  0x00\n#define PROT_READ  0x01\n#define PROT_WRITE 0x02\n#define PROT_EXEC  0x04\n\n#define MAP_SHARED    0x0001\n#define MAP_PRIVATE   0x0002\n#define MAP_FIXED     0x0010\n#define MAP_ANON      0x1000\n#define MAP_ANONYMOUS MAP_ANON\n\n#define MAP_FAILED ((void *)-1)\n\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\nint munmap(void *addr, size_t length);\nint mprotect(void *addr, size_t len, int prot);\nint msync(void *addr, size_t len, int flags);\n\n#endif /* _TCC_COMPAT_SYS_MMAN_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$116 = "#ifndef _SYS_MOUNT_H\n#define _SYS_MOUNT_H\n\n#include <sys/types.h>\n\n#define MNT_RDONLY 0x00000001\n\n#if defined(__APPLE__)\n#ifndef MFSNAMELEN\n#define MFSNAMELEN 15\n#endif\n#ifndef MFSTYPENAMELEN\n#define MFSTYPENAMELEN 16\n#endif\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n#ifndef MNAMELEN\n#define MNAMELEN MAXPATHLEN\n#endif\n\nstruct statfs {\n  uint32_t f_bsize;\n  int32_t f_iosize;\n  uint64_t f_blocks;\n  uint64_t f_bfree;\n  uint64_t f_bavail;\n  uint64_t f_files;\n  uint64_t f_ffree;\n  fsid_t f_fsid;\n  uid_t f_owner;\n  uint32_t f_type;\n  uint32_t f_flags;\n  uint32_t f_fssubtype;\n  char f_fstypename[MFSTYPENAMELEN];\n  char f_mntonname[MAXPATHLEN];\n  char f_mntfromname[MAXPATHLEN];\n  uint32_t f_flags_ext;\n  uint32_t f_reserved[7];\n};\n#else\nstruct statfs {\n  unsigned long f_flags;\n  char f_fstypename[16];\n};\n#endif\n\nint statfs(const char *path, struct statfs *buf);\nint fstatfs(int fd, struct statfs *buf);\n\n#endif";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$119 = "#ifndef _TCC_COMPAT_SYS_PTRACE_H\n#define _TCC_COMPAT_SYS_PTRACE_H\n\nint ptrace(int request, ...);\n\n#endif /* _TCC_COMPAT_SYS_PTRACE_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$122 = "#ifndef _TCC_COMPAT_SYS_SELECT_H\n#define _TCC_COMPAT_SYS_SELECT_H\n\n#include <sys/time.h>\n#include <string.h>\n\n#ifndef _TCC_COMPAT_FD_SET_DEFINED\n#define _TCC_COMPAT_FD_SET_DEFINED\ntypedef struct { unsigned long bits[16]; } fd_set;\n#endif\n\n#ifndef _TCC_COMPAT_FD_SET_MACROS\n#define _TCC_COMPAT_FD_SET_MACROS\n#define _TCC_COMPAT_NFDBITS (8U * (unsigned int)sizeof(unsigned long))\n#define _TCC_COMPAT_FD_INDEX(fd) ((unsigned int)(fd) / _TCC_COMPAT_NFDBITS)\n#define _TCC_COMPAT_FD_MASK(fd) (1UL << ((unsigned int)(fd) % _TCC_COMPAT_NFDBITS))\n\n#define FD_ZERO(set) do { \\\n  size_t _i; \\\n  for (_i = 0; _i < (sizeof((set)->bits) / sizeof((set)->bits[0])); _i++) { \\\n    (set)->bits[_i] = 0; \\\n  } \\\n} while (0)\n\n#define FD_SET(fd, set) ((set)->bits[_TCC_COMPAT_FD_INDEX(fd)] |= _TCC_COMPAT_FD_MASK(fd))\n#define FD_CLR(fd, set) ((set)->bits[_TCC_COMPAT_FD_INDEX(fd)] &= ~_TCC_COMPAT_FD_MASK(fd))\n#define FD_ISSET(fd, set) (((set)->bits[_TCC_COMPAT_FD_INDEX(fd)] & _TCC_COMPAT_FD_MASK(fd)) != 0)\n#endif\n\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n\n#endif /* _TCC_COMPAT_SYS_SELECT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$125 = "#ifndef _TCC_COMPAT_SYS_STAT_H\n#define _TCC_COMPAT_SYS_STAT_H\n\n#include <sys/types.h>\n#include <time.h>\n\n#define S_IFMT  0170000\n#define S_IFIFO 0010000\n#define S_IFCHR 0020000\n#define S_IFDIR 0040000\n#define S_IFBLK 0060000\n#define S_IFREG 0100000\n#define S_IFLNK 0120000\n#define S_IFSOCK 0140000\n\n#define S_ISDIR(m)  (((m) & S_IFMT) == S_IFDIR)\n#define S_ISREG(m)  (((m) & S_IFMT) == S_IFREG)\n#define S_ISCHR(m)  (((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)  (((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)\n#define S_ISLNK(m)  (((m) & S_IFMT) == S_IFLNK)\n#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)\n\n#define S_IRWXU 0700\n#define S_IRUSR 0400\n#define S_IWUSR 0200\n#define S_IXUSR 0100\n#define S_IRWXG 0070\n#define S_IRGRP 0040\n#define S_IWGRP 0020\n#define S_IXGRP 0010\n#define S_IRWXO 0007\n#define S_IROTH 0004\n#define S_IWOTH 0002\n#define S_IXOTH 0001\n#define S_ISUID 0004000\n#define S_ISGID 0002000\n\n#if defined(__APPLE__)\nstruct stat {\n  dev_t st_dev;\n  mode_t st_mode;\n  nlink_t st_nlink;\n  ino_t st_ino;\n  uid_t st_uid;\n  gid_t st_gid;\n  dev_t st_rdev;\n  struct timespec st_atimespec;\n  struct timespec st_mtimespec;\n  struct timespec st_ctimespec;\n  struct timespec st_birthtimespec;\n  off_t st_size;\n  blkcnt_t st_blocks;\n  blksize_t st_blksize;\n  uint32_t st_flags;\n  uint32_t st_gen;\n  int32_t st_lspare;\n  int64_t st_qspare[2];\n};\n#define st_atime st_atimespec.tv_sec\n#define st_mtime st_mtimespec.tv_sec\n#define st_ctime st_ctimespec.tv_sec\n#define st_birthtime st_birthtimespec.tv_sec\n#else\nstruct stat {\n  dev_t st_dev;\n  ino_t st_ino;\n  mode_t st_mode;\n  nlink_t st_nlink;\n  uid_t st_uid;\n  gid_t st_gid;\n  dev_t st_rdev;\n  off_t st_size;\n  blkcnt_t st_blocks;\n  time_t st_atime;\n  time_t st_mtime;\n  time_t st_ctime;\n  struct timespec st_atimespec;\n  struct timespec st_mtimespec;\n  struct timespec st_ctimespec;\n};\n#endif\n\nint stat(const char *path, struct stat *buf);\nint lstat(const char *path, struct stat *buf);\nint fstat(int fd, struct stat *buf);\nint chmod(const char *path, mode_t mode);\nint fchmod(int fd, mode_t mode);\nint mkdir(const char *path, mode_t mode);\n\n#endif /* _TCC_COMPAT_SYS_STAT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$128 = "#ifndef _TCC_COMPAT_SYS_STATVFS_H\n#define _TCC_COMPAT_SYS_STATVFS_H\n\n#include <sys/types.h>\n\nstruct statvfs {\n  unsigned long f_bsize;\n  unsigned long f_frsize;\n  unsigned long f_blocks;\n  unsigned long f_bfree;\n  unsigned long f_bavail;\n  unsigned long f_files;\n  unsigned long f_ffree;\n  unsigned long f_favail;\n  unsigned long f_fsid;\n  unsigned long f_flag;\n  unsigned long f_namemax;\n};\n\nint statvfs(const char *path, struct statvfs *buf);\n\n#endif /* _TCC_COMPAT_SYS_STATVFS_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$131 = "#ifndef _TCC_COMPAT_SYS_SYSCALL_H\n#define _TCC_COMPAT_SYS_SYSCALL_H\n\n#if defined(__x86_64__)\n#define SYS_write 1\n#define SYS_exit 60\n#elif defined(__aarch64__)\n#define SYS_write 64\n#define SYS_exit 93\n#elif defined(__riscv)\n#define SYS_write 64\n#define SYS_exit 93\n#elif defined(__i386__)\n#define SYS_write 4\n#define SYS_exit 1\n#elif defined(__arm__)\n#define SYS_write 4\n#define SYS_exit 1\n#else\n#define SYS_write 1\n#define SYS_exit 60\n#endif\n\n#endif /* _TCC_COMPAT_SYS_SYSCALL_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$134 = "#ifndef _TCC_COMPAT_SYS_TIME_H\n#define _TCC_COMPAT_SYS_TIME_H\n\n#include <sys/types.h>\n#include <time.h>\n\nstruct timeval {\n  time_t tv_sec;\n  suseconds_t tv_usec;\n};\n\nstruct timezone {\n  int tz_minuteswest;\n  int tz_dsttime;\n};\n\nint gettimeofday(struct timeval *tv, struct timezone *tz);\n\n#endif /* _TCC_COMPAT_SYS_TIME_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$137 = "#ifndef _TCC_COMPAT_SYS_TYPES_H\n#define _TCC_COMPAT_SYS_TYPES_H\n\n#include <stddef.h>\n#include <stdint.h>\n\ntypedef unsigned long size_t;\ntypedef long ssize_t;\ntypedef long time_t;\n#if defined(__APPLE__)\ntypedef int64_t off_t;\ntypedef int32_t suseconds_t;\ntypedef uint32_t useconds_t;\ntypedef uint16_t mode_t;\ntypedef int32_t pid_t;\ntypedef uint32_t uid_t;\ntypedef uint32_t gid_t;\ntypedef struct { int32_t val[2]; } fsid_t;\n#else\ntypedef long off_t;\ntypedef long suseconds_t;\ntypedef long useconds_t;\ntypedef unsigned int mode_t;\ntypedef int pid_t;\ntypedef unsigned int uid_t;\ntypedef unsigned int gid_t;\n#endif\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned short ushort;\ntypedef unsigned char uchar;\n\n#if defined(__APPLE__)\ntypedef int32_t blksize_t;\ntypedef int64_t blkcnt_t;\ntypedef int32_t dev_t;\ntypedef uint64_t ino_t;\ntypedef uint16_t nlink_t;\n#else\ntypedef long blksize_t;\ntypedef long blkcnt_t;\ntypedef long dev_t;\ntypedef unsigned long ino_t;\ntypedef unsigned long nlink_t;\n#endif\n\n#ifndef _TCC_COMPAT_FD_SET_DEFINED\n#define _TCC_COMPAT_FD_SET_DEFINED\ntypedef struct { unsigned long bits[16]; } fd_set;\n#endif\n\n#ifndef _TCC_COMPAT_FD_SET_MACROS\n#define _TCC_COMPAT_FD_SET_MACROS\n#define _TCC_COMPAT_NFDBITS (8U * (unsigned int)sizeof(unsigned long))\n#define _TCC_COMPAT_FD_INDEX(fd) ((unsigned int)(fd) / _TCC_COMPAT_NFDBITS)\n#define _TCC_COMPAT_FD_MASK(fd) (1UL << ((unsigned int)(fd) % _TCC_COMPAT_NFDBITS))\n\n#define FD_ZERO(set) do { \\\n  size_t _i; \\\n  for (_i = 0; _i < (sizeof((set)->bits) / sizeof((set)->bits[0])); _i++) { \\\n    (set)->bits[_i] = 0; \\\n  } \\\n} while (0)\n\n#define FD_SET(fd, set) ((set)->bits[_TCC_COMPAT_FD_INDEX(fd)] |= _TCC_COMPAT_FD_MASK(fd))\n#define FD_CLR(fd, set) ((set)->bits[_TCC_COMPAT_FD_INDEX(fd)] &= ~_TCC_COMPAT_FD_MASK(fd))\n#define FD_ISSET(fd, set) (((set)->bits[_TCC_COMPAT_FD_INDEX(fd)] & _TCC_COMPAT_FD_MASK(fd)) != 0)\n#endif\n\n#endif /* _TCC_COMPAT_SYS_TYPES_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$140 = "#ifndef _TCC_COMPAT_SYS_UCONTEXT_H\n#define _TCC_COMPAT_SYS_UCONTEXT_H\n\n#include <signal.h>\n#include <stdint.h>\n\ntypedef struct __tcc_arm_thread_state64 {\n  uint64_t __x[29];\n  uint64_t __fp;\n  uint64_t __lr;\n  uint64_t __sp;\n  uint64_t __pc;\n  uint32_t __cpsr;\n  uint32_t __pad;\n} __tcc_arm_thread_state64;\n\ntypedef struct __tcc_mcontext64 {\n  __tcc_arm_thread_state64 __ss;\n} mcontext_t;\n\ntypedef struct ucontext {\n  unsigned long uc_onstack;\n  sigset_t uc_sigmask;\n  stack_t uc_stack;\n  mcontext_t *uc_mcontext;\n  struct ucontext *uc_link;\n} ucontext_t;\n\n#endif /* _TCC_COMPAT_SYS_UCONTEXT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$143 = "#ifndef _SYS_UIO_H\n#define _SYS_UIO_H\n\n#include <stddef.h>\n\nstruct iovec {\n  void *iov_base;\n  size_t iov_len;\n};\n\n#endif";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$146 = "#ifndef _TCC_COMPAT_SYS_UTSNAME_H\n#define _TCC_COMPAT_SYS_UTSNAME_H\n\nstruct utsname {\n  char sysname[256];\n  char nodename[256];\n  char release[256];\n  char version[256];\n  char machine[256];\n};\n\nint uname(struct utsname *name);\n\n#endif /* _TCC_COMPAT_SYS_UTSNAME_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$149 = "#ifndef _TCC_COMPAT_SYS_WAIT_H\n#define _TCC_COMPAT_SYS_WAIT_H\n\n#include <sys/types.h>\n\n#define WEXITSTATUS(status) (((status) >> 8) & 0xff)\n#define WIFEXITED(status) (((status) & 0x7f) == 0)\n#define WIFSIGNALED(status) (((status) & 0x7f) != 0 && ((status) & 0x7f) != 0x7f)\n#define WTERMSIG(status) ((status) & 0x7f)\n#define WNOHANG 0x00000001\n\npid_t wait(int *status);\npid_t waitpid(pid_t pid, int *status, int options);\n\n#endif /* _TCC_COMPAT_SYS_WAIT_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$152 = "#ifndef _TCC_COMPAT_TERMIOS_H\n#define _TCC_COMPAT_TERMIOS_H\n\n#include <sys/types.h>\n\ntypedef unsigned int tcflag_t;\ntypedef unsigned char cc_t;\ntypedef unsigned int speed_t;\n\n#ifndef NCCS\n#define NCCS 32\n#endif\n\nstruct termios {\n  tcflag_t c_iflag;\n  tcflag_t c_oflag;\n  tcflag_t c_cflag;\n  tcflag_t c_lflag;\n  cc_t c_cc[NCCS];\n  speed_t c_ispeed;\n  speed_t c_ospeed;\n};\n\n#define TCSANOW 0\n#define TCSADRAIN 1\n#define TCSAFLUSH 2\n\n#define IGNBRK  0x00000001\n#define BRKINT  0x00000002\n#define PARMRK  0x00000008\n#define ISTRIP  0x00000020\n#define INLCR   0x00000040\n#define IGNCR   0x00000080\n#define ICRNL   0x00000100\n#define IXON    0x00000200\n\n#define OPOST   0x00000001\n\n#define ICANON 0x0002\n#define ECHO 0x0008\n#define ISIG 0x0001\n#define ECHONL 0x00000010\n#define IEXTEN 0x00000400\n\n#define CSIZE  0x00000300\n#define PARENB 0x00001000\n#define CS8    0x00000300\n\n#define VMIN  16\n#define VTIME 17\n\nint tcgetattr(int fd, struct termios *termios_p);\nint tcsetattr(int fd, int optional_actions, const struct termios *termios_p);\nint tcflush(int fd, int queue_selector);\nspeed_t cfgetispeed(const struct termios *termios_p);\nspeed_t cfgetospeed(const struct termios *termios_p);\nint cfsetispeed(struct termios *termios_p, speed_t speed);\nint cfsetospeed(struct termios *termios_p, speed_t speed);\nint cfmakeraw(struct termios *termios_p);\n\n#endif /* _TCC_COMPAT_TERMIOS_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$155 = "#ifndef _TCC_COMPAT_TIME_H\n#define _TCC_COMPAT_TIME_H\n\n#include <stddef.h>\n#include <sys/types.h>\n\ntypedef long clock_t;\n\nstruct tm {\n  int tm_sec;\n  int tm_min;\n  int tm_hour;\n  int tm_mday;\n  int tm_mon;\n  int tm_year;\n  int tm_wday;\n  int tm_yday;\n  int tm_isdst;\n  long tm_gmtoff;\n#if defined(__APPLE__)\n  char *tm_zone;\n#endif\n};\n\nstruct timespec {\n  time_t tv_sec;\n  long tv_nsec;\n};\n\n#define CLOCKS_PER_SEC 1000000\n#define CLOCK_REALTIME 0\n#define CLOCK_MONOTONIC 6\n\ntime_t time(time_t *tloc);\ndouble difftime(time_t end, time_t beginning);\nclock_t clock(void);\nchar *ctime(const time_t *timep);\nstruct tm *localtime(const time_t *timep);\nstruct tm *localtime_r(const time_t *timep, struct tm *result);\nstruct tm *gmtime(const time_t *timep);\nstruct tm *gmtime_r(const time_t *timep, struct tm *result);\nsize_t strftime(char *s, size_t max, const char *fmt, const struct tm *tm);\n\nint nanosleep(const struct timespec *req, struct timespec *rem);\nint clock_gettime(int clock_id, struct timespec *tp);\n\n#endif /* _TCC_COMPAT_TIME_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$158 = "#ifndef _TCC_COMPAT_UNISTD_H\n#define _TCC_COMPAT_UNISTD_H\n\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#define F_OK 0\n#define X_OK 1\n#define W_OK 2\n#define R_OK 4\n\n#define STDIN_FILENO 0\n#define STDOUT_FILENO 1\n#define STDERR_FILENO 2\n\n#define _SC_PAGESIZE 29\n#define _SC_NPROCESSORS_ONLN 83\n#define _SC_OPEN_MAX 5\n\nint access(const char *path, int mode);\nint unlink(const char *path);\nint rmdir(const char *path);\nint close(int fd);\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\nssize_t pread(int fd, void *buf, size_t count, off_t offset);\nssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);\noff_t lseek(int fd, off_t offset, int whence);\nint ftruncate(int fd, off_t length);\nint pipe(int fds[2]);\nunsigned sleep(unsigned seconds);\nint usleep(useconds_t usec);\nint getpagesize(void);\nlong sysconf(int name);\nchar *getcwd(char *buf, size_t size);\nint chdir(const char *path);\nint isatty(int fd);\nint dup(int oldfd);\nint dup2(int oldfd, int newfd);\npid_t fork(void);\nint execv(const char *path, char *const argv[]);\nint execlp(const char *file, const char *arg, ...);\npid_t getpid(void);\nint fchown(int fd, uid_t owner, gid_t group);\nuid_t geteuid(void);\nssize_t readlink(const char *path, char *buf, size_t bufsiz);\n\nextern int optind;\n\n#endif /* _TCC_COMPAT_UNISTD_H */";
const hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$161 = "#ifndef _TCC_COMPAT_UTIME_H\n#define _TCC_COMPAT_UTIME_H\n\n#include <time.h>\n\nstruct utimbuf {\n  time_t actime;\n  time_t modtime;\n};\n\nint utime(const char *filename, const struct utimbuf *times);\n\n#endif /* _TCC_COMPAT_UTIME_H */";
const moonbitlang$core$builtin$$seed = moonbitlang$core$builtin$$random_seed();
const hackwaly$tinycc$frontend$ast$ast_core$$parse_int64_literal$46$constr$47$5546 = $0L;
const moonbitlang$core$builtin$$brute_force_find$46$constr$47$611 = 0;
const moonbitlang$core$builtin$$boyer_moore_horspool_find$46$constr$47$597 = 0;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6009 = 4;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6010 = 0;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6011 = 1;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6012 = 2;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6013 = 3;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6014 = 5;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6015 = 6;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6016 = 7;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6017 = 8;
const hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6018 = 9;
const hackwaly$tinycc$support$util$$char_is_unsigned = hackwaly$tinycc$support$util$target_config$$char_is_unsigned;
const hackwaly$tinycc$sem$sem_core$$char_type_value = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(0, hackwaly$tinycc$support$util$$char_is_unsigned);
const hackwaly$tinycc$sem$sem_core$$char_pointer_type_value = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$sem$sem_core$$char_type_value);
const hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6652 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(1);
const hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6653 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(0);
const hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6654 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(2);
const hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6655 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(1);
const hackwaly$tinycc$sem$sem_core$$int_literal_type$46$constr$47$6687 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(2, false);
const hackwaly$tinycc$sem$sem_core$$type_size_align$46$tuple$47$7582 = { _0: 1, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$type_size_align$46$constr$47$7583 = hackwaly$tinycc$sem$sem_core$$type_size_align$46$tuple$47$7582;
const hackwaly$tinycc$sem$sem_core$$type_size_align$46$tuple$47$7584 = { _0: 8, _1: 8 };
const hackwaly$tinycc$sem$sem_core$$type_size_align$46$constr$47$7585 = hackwaly$tinycc$sem$sem_core$$type_size_align$46$tuple$47$7584;
const hackwaly$tinycc$sem$sem_core$$type_size_align$46$tuple$47$7586 = { _0: 8, _1: 8 };
const hackwaly$tinycc$sem$sem_core$$type_size_align$46$constr$47$7587 = hackwaly$tinycc$sem$sem_core$$type_size_align$46$tuple$47$7586;
const hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7706 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7707 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7708 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7709 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$resolve_align_spec$46$constr$47$7691 = 16;
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7048 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7049 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7050 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7051 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7052 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7053 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7054 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7055 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7056 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7057 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7058 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7059 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7060 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7061 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7062 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7063 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7064 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7065 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7066 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7067 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7068 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7069 = { _0: 0, _1: false };
const hackwaly$tinycc$sem$sem_core$$check_initializer_list$46$constr$47$7852 = 0;
const hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7767 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7768 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7769 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7770 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8263 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8264 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8265 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8266 = { _0: 0, _1: 1 };
const hackwaly$tinycc$sem$sem_core$$cast_const_int64_value$46$tuple$47$7186 = { _0: $0L, _1: false };
const moonbitlang$core$double$$neg_infinity = moonbitlang$core$int64$$Int64$reinterpret_as_double($_4503599627370496L);
const moonbitlang$core$double$$not_a_number = moonbitlang$core$int64$$Int64$reinterpret_as_double($9221120237041090561L);
const moonbitlang$core$double$$infinity = moonbitlang$core$int64$$Int64$reinterpret_as_double($9218868437227405312L);
const moonbitlang$core$strconv$$max_mantissa_fast_path = moonbitlang$core$builtin$$Shl$shl$6$($2L, 52);
const moonbitlang$core$strconv$$checked_mul$46$constr$47$2613 = $0L;
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8931 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8932 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8933 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8934 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8935 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8936 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8937 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8938 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8939 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8940 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8941 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8942 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8943 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8944 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8945 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8946 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8947 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8948 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8949 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8950 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8951 = { _0: $0L, _1: false };
const hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8952 = { _0: $0L, _1: false };
const hackwaly$tinycc$backend$codegen$$collect_union_field_access_cache$46$constr$47$9582 = 0;
const hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9449 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9450 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9451 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9452 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9681 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9682 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9683 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9684 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$union_field_access_info$46$constr$47$9750 = 0;
const hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$tuple$47$11135 = { _0: 8, _1: false };
const hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$constr$47$11136 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$tuple$47$11135;
const hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$tuple$47$11137 = { _0: 1, _1: false };
const hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$constr$47$11138 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$tuple$47$11137;
const hackwaly$tinycc$backend$codegen$$cg_push_scope$46$record$47$10771 = { num: 0, loc: 0, locorig: 0 };
const hackwaly$tinycc$backend$codegen$$arm64_pcs_size_align$46$tuple$47$10777 = { _0: 8, _1: 8 };
const hackwaly$tinycc$backend$codegen$$arm64_pcs_size_align$46$constr$47$10778 = hackwaly$tinycc$backend$codegen$$arm64_pcs_size_align$46$tuple$47$10777;
const hackwaly$tinycc$backend$codegen$$arm64_pcs_aux$46$tuple$47$10785 = { _0: 0, _1: 0 };
const hackwaly$tinycc$backend$codegen$$arm64_pcs_aux$46$tuple$47$10786 = { _0: 0, _1: 1 };
const hackwaly$tinycc$backend$codegen$$promote_vararg_type$46$constr$47$11757 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(1);
const hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11846 = { break_chain: 0, cont_chain: 0, break_depth: 0, cont_depth: 0 };
const hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11847 = { break_chain: 0, cont_chain: 0, break_depth: 0, cont_depth: 0 };
const hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11848 = { break_chain: 0, cont_chain: 0, break_depth: 0, cont_depth: 0 };
const hackwaly$tinycc$backend$codegen$$gen_stmt$46$tuple$47$11849 = { _0: false, _1: false };
const hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11850 = { break_chain: 0, break_depth: 0 };
const hackwaly$tinycc$backend$codegen$$gen_builtin_va_arg_load$46$tuple$47$13056 = { _0: 8, _1: false };
const hackwaly$tinycc$backend$codegen$$gen_expr_int32$46$constr$47$12504 = 1;
const hackwaly$tinycc$backend$codegen$$gen_expr_int32$46$constr$47$12505 = 0;
const hackwaly$tinycc$backend$macho$$build_symtab$46$tuple$47$4766 = { _0: 0, _1: 0 };
const hackwaly$tinycc$backend$macho$$build_symtab$46$tuple$47$4767 = { _0: 0, _1: 0 };
const hackwaly$tinycc$backend$macho$$segment_file_range$46$tuple$47$4810 = { _0: 0, _1: 0 };
const hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14381 = ".bss";
const hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14382 = ".data";
const hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14383 = ".cstring";
const hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14384 = ".rodata";
const hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14385 = ".text";
const hackwaly$tinycc$frontend$tokens$$empty_hidden = hackwaly$tinycc$frontend$tokens$tokens_core$$empty_hidden;
const hackwaly$tinycc$support$intern$$tok_hash_init = hackwaly$tinycc$support$intern$intern_core$$tok_hash_init;
const moonbitlang$x$time$$utc_zone = { id: "UTC", offsets: [moonbitlang$x$time$$utc_offset], transitions: [] };
const moonbitlang$x$time$$days_per_400_years = moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Mul$mul$7$($400L, $365L), $97L);
const moonbitlang$x$time$$days_zero_year_to_unix_epoch = moonbitlang$core$builtin$$Sub$sub$7$(moonbitlang$core$builtin$$Mul$mul$7$($5L, moonbitlang$x$time$$days_per_400_years), moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Mul$mul$7$($30L, $365L), $7L));
const moonbitlang$core$double$$min_value = moonbitlang$core$int64$$Int64$reinterpret_as_double($_4503599627370497L);
const moonbitlang$core$double$$max_value = moonbitlang$core$int64$$Int64$reinterpret_as_double($9218868437227405311L);
const moonbitlang$x$time$$seconds_per_hour = moonbitlang$core$builtin$$Mul$mul$7$(moonbitlang$x$time$$seconds_per_minute, $60L);
const moonbitlang$x$time$$seconds_per_day = moonbitlang$core$builtin$$Mul$mul$7$(moonbitlang$x$time$$seconds_per_hour, $24L);
const moonbitlang$x$time$$nanoseconds_per_minute = moonbitlang$core$builtin$$Mul$mul$7$(moonbitlang$x$time$$nanoseconds_per_second, moonbitlang$x$time$$seconds_per_minute);
const moonbitlang$x$time$$nanoseconds_per_hour = moonbitlang$core$builtin$$Mul$mul$7$(moonbitlang$x$time$$nanoseconds_per_minute, moonbitlang$x$time$$minutes_per_hour);
const moonbitlang$x$time$$nanoseconds_per_day = moonbitlang$core$builtin$$Mul$mul$7$(moonbitlang$x$time$$nanoseconds_per_second, moonbitlang$x$time$$seconds_per_day);
const hackwaly$tinycc$frontend$preproc$preproc_core$$init_datetime_literals$46$tuple$47$15302 = { _0: "Jan 01 1970", _1: "00:00:00" };
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14732 = 7;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14733 = 11;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14734 = 10;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14735 = 33;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14736 = 48;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14737 = 8;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14738 = 15;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14739 = 17;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14740 = 26;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14741 = 31;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14742 = 32;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14743 = 38;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14744 = 42;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14745 = 9;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14746 = 13;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14747 = 23;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14748 = 34;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14749 = 36;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14750 = 37;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14751 = 40;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14752 = 48;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14753 = 14;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14754 = 16;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14755 = 19;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14756 = 20;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14757 = 22;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14758 = 27;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14759 = 35;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14760 = 39;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14761 = 43;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14762 = 45;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14763 = 18;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14764 = 41;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14765 = 48;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14766 = 23;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14767 = 12;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14768 = 21;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14769 = 24;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14770 = 25;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14771 = 29;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14772 = 44;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14773 = 45;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14774 = 27;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14775 = 22;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14776 = 34;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14777 = 28;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14778 = 30;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14779 = 44;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14780 = 23;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14781 = 45;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14782 = 24;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14783 = 29;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14784 = 27;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14785 = 22;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14786 = 21;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14787 = 44;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14788 = 46;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14789 = 24;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14790 = 29;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14791 = 21;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14792 = 46;
const hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14793 = 47;
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal$46$record$47$15929 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal$46$record$47$15930 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_char_literal$46$record$47$15994 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_char_literal$46$record$47$15995 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_defined$46$record$47$15955 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_defined$46$record$47$15956 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul$46$record$47$16085 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul$46$record$47$16086 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16109 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16110 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16111 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16112 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16113 = { value: $0L, is_unsigned: false };
const hackwaly$tinycc$frontend$parser$parser_core$$parse_postfix_tail$46$tuple$47$17405 = { _0: "", _1: 0 };
const hackwaly$tinycc$frontend$parser$parser_core$$parse_postfix_tail$46$tuple$47$17406 = { _0: "", _1: 0 };
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16615 = 0;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16616 = 1;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16617 = 2;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16618 = 3;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16619 = 4;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16620 = 5;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16621 = 6;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16622 = 7;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16623 = 8;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16624 = 10;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16625 = 9;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16804 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16805 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16806 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16807 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16808 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16809 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16810 = 0;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16811 = 1;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16812 = 2;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16813 = 3;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16814 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16815 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16816 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16817 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_param_list$46$constr$47$17058 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(2, false);
const hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16851 = true;
const hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16852 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(2);
const hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16853 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(1);
const hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16854 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(0);
const hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16855 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(0);
const hackwaly$tinycc$frontend$parser$parser_core$$parse_designator_list$46$tuple$47$17367 = { _0: "", _1: 0 };
const hackwaly$tinycc$frontend$parser$parser_core$$parse_decl$46$constr$47$17461 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(2, false);
const hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$constr$47$16248 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(1, true);
const hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$tuple$47$16249 = { _0: "_Float16", _1: hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$constr$47$16248 };
const hackwaly$tinycc$sem$sem_core$$default_type_aliases$46$constr$47$5812 = 1;
const hackwaly$tinycc$sem$sem_core$$promote_old_style_param_type$46$constr$47$8858 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(1);
const _p = 0;
const _tmp = 1 | 1 << (2 + _p | 0);
const _p$2 = 1;
const _tmp$2 = 1 | 1 << (2 + _p$2 | 0);
const _p$3 = 2;
const _tmp$3 = 1 | 1 << (2 + _p$3 | 0);
const _p$4 = 3;
const _tmp$4 = 1 | 1 << (2 + _p$4 | 0);
const _p$5 = 4;
const _tmp$5 = 1 | 1 << (2 + _p$5 | 0);
const _p$6 = 5;
const _tmp$6 = 1 | 1 << (2 + _p$6 | 0);
const _p$7 = 6;
const _tmp$7 = 1 | 1 << (2 + _p$7 | 0);
const _p$8 = 7;
const _tmp$8 = 1 | 1 << (2 + _p$8 | 0);
const _p$9 = 8;
const _tmp$9 = 1 | 1 << (2 + _p$9 | 0);
const _p$10 = 9;
const _tmp$10 = 1 | 1 << (2 + _p$10 | 0);
const _p$11 = 10;
const _tmp$11 = 1 | 1 << (2 + _p$11 | 0);
const _p$12 = 11;
const _tmp$12 = 1 | 1 << (2 + _p$12 | 0);
const _p$13 = 12;
const _tmp$13 = 1 | 1 << (2 + _p$13 | 0);
const _p$14 = 13;
const _tmp$14 = 1 | 1 << (2 + _p$14 | 0);
const _p$15 = 14;
const _tmp$15 = 1 | 1 << (2 + _p$15 | 0);
const _p$16 = 15;
const _tmp$16 = 1 | 1 << (2 + _p$16 | 0);
const _p$17 = 16;
const _tmp$17 = 1 | 1 << (2 + _p$17 | 0);
const _p$18 = 17;
const _tmp$18 = 1 | 1 << (2 + _p$18 | 0);
const _p$19 = 18;
const _tmp$19 = 1 | 1 << (2 + _p$19 | 0);
const _p$20 = 0;
const _tmp$20 = 2 | 1 << (22 + _p$20 | 0);
const _p$21 = 1;
const _tmp$21 = 2 | 1 << (22 + _p$21 | 0);
const _p$22 = 2;
const _tmp$22 = 2 | 1 << (22 + _p$22 | 0);
const _p$23 = 3;
const _tmp$23 = 2 | 1 << (22 + _p$23 | 0);
const _p$24 = 4;
const _tmp$24 = 2 | 1 << (22 + _p$24 | 0);
const _p$25 = 5;
const _tmp$25 = 2 | 1 << (22 + _p$25 | 0);
const _p$26 = 6;
const _tmp$26 = 2 | 1 << (22 + _p$26 | 0);
const _p$27 = 7;
const hackwaly$tinycc$backend$arm64$$reg_classes = [_tmp, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, 2097152, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, 2 | 1 << (22 + _p$27 | 0)];
function moonbitlang$core$abort$$abort$8$(msg) {
  $panic();
}
function moonbitlang$core$abort$$abort$9$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$10$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$11$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$12$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$13$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$14$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$15$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$16$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$17$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$18$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$Logger$write_object$19$(self, obj) {
  moonbitlang$core$builtin$$Show$output$19$(obj, self);
}
function moonbitlang$core$builtin$$Show$output$20$(_x_5029, _x_5030) {
  if (_x_5029.$tag === 1) {
    _x_5030.method_table.method_0(_x_5030.self, "IndexOutOfBounds");
    return;
  } else {
    _x_5030.method_table.method_0(_x_5030.self, "InvalidIndex");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$21$(_x_5015, _x_5016) {
  const _Failure = _x_5015;
  const _$42$arg_5017 = _Failure._0;
  _x_5016.method_table.method_0(_x_5016.self, "Failure(");
  moonbitlang$core$builtin$$Logger$write_object$19$(_x_5016, _$42$arg_5017);
  _x_5016.method_table.method_0(_x_5016.self, ")");
}
function moonbitlang$core$builtin$$Hasher$consume4(self, input) {
  const _p$28 = (self.acc >>> 0) + ((Math.imul(input, -1028477379) | 0) >>> 0) | 0;
  const _p$29 = 17;
  self.acc = Math.imul(_p$28 << _p$29 | (_p$28 >>> (32 - _p$29 | 0) | 0), 668265263) | 0;
}
function moonbitlang$core$builtin$$Hasher$combine_uint(self, value) {
  self.acc = (self.acc >>> 0) + (4 >>> 0) | 0;
  moonbitlang$core$builtin$$Hasher$consume4(self, value);
}
function moonbitlang$core$builtin$$abort$8$(string, loc) {
  moonbitlang$core$abort$$abort$8$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$9$(string, loc) {
  return moonbitlang$core$abort$$abort$9$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$10$(string, loc) {
  return moonbitlang$core$abort$$abort$10$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$11$(string, loc) {
  return moonbitlang$core$abort$$abort$11$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$12$(string, loc) {
  return moonbitlang$core$abort$$abort$12$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$13$(string, loc) {
  return moonbitlang$core$abort$$abort$13$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$14$(string, loc) {
  return moonbitlang$core$abort$$abort$14$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$15$(string, loc) {
  return moonbitlang$core$abort$$abort$15$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$16$(string, loc) {
  return moonbitlang$core$abort$$abort$16$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$17$(string, loc) {
  return moonbitlang$core$abort$$abort$17$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$18$(string, loc) {
  return moonbitlang$core$abort$$abort$18$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$22$(loc)}\n`);
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$11$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < len) {
        const _tmp$28 = dst_offset + i | 0;
        const _tmp$29 = src_offset + i | 0;
        $bound_check(src, _tmp$29);
        $bound_check(dst, _tmp$28);
        dst[_tmp$28] = src[_tmp$29];
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp$27 = len - 1 | 0;
    while (true) {
      const i = _tmp$27;
      if (i >= 0) {
        const _tmp$28 = dst_offset + i | 0;
        const _tmp$29 = src_offset + i | 0;
        $bound_check(src, _tmp$29);
        $bound_check(dst, _tmp$28);
        dst[_tmp$28] = src[_tmp$29];
        _tmp$27 = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$builtin$$StringBuilder$new$46$inner(size_hint) {
  return { val: "" };
}
function moonbitlang$core$builtin$$Logger$write_char$1$(self, ch) {
  const _bind = self;
  _bind.val = `${_bind.val}${String.fromCodePoint(ch)}`;
}
function moonbitlang$core$uint16$$UInt16$is_leading_surrogate(self) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(self, 55296) && moonbitlang$core$builtin$$Compare$op_le$23$(self, 56319);
}
function moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(self) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(self, 56320) && moonbitlang$core$builtin$$Compare$op_le$23$(self, 57343);
}
function moonbitlang$core$builtin$$code_point_of_surrogate_pair(leading, trailing) {
  return (((Math.imul(leading - 55296 | 0, 1024) | 0) + trailing | 0) - 56320 | 0) + 65536 | 0;
}
function moonbitlang$core$string$$String$unsafe_char_at(self, index) {
  const c1 = self.charCodeAt(index);
  if (moonbitlang$core$uint16$$UInt16$is_leading_surrogate(c1)) {
    const _tmp$27 = index + 1 | 0;
    const c2 = self.charCodeAt(_tmp$27);
    return moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2);
  } else {
    return c1;
  }
}
function moonbitlang$core$array$$Array$at$19$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$24$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$25$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$26$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$27$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$28$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$29$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$30$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$31$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$32$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$33$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$34$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$35$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$36$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$37$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$38$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$39$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$12$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$40$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$15$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$41$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$42$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$43$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$44$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$45$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$46$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$47$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$48$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$49$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$50$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$51$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$52$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$53$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$54$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$55$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$56$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$57$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$58$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$59$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$60$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$61$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$62$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$63$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$64$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$65$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$66$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$67$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$17$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$68$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$69$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$70$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$71$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$18$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$72$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$73$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$74$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$75$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$76$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$77$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$SourceLocRepr$parse(repr) {
  const _bind = { str: repr, start: 0, end: repr.length };
  const _data = _bind.str;
  const _start = _bind.start;
  const _end = _start + (_bind.end - _bind.start | 0) | 0;
  let _cursor = _start;
  let accept_state = -1;
  let match_end = -1;
  let match_tag_saver_0 = -1;
  let match_tag_saver_1 = -1;
  let match_tag_saver_2 = -1;
  let match_tag_saver_3 = -1;
  let match_tag_saver_4 = -1;
  let tag_0 = -1;
  let tag_1 = -1;
  let tag_1_1 = -1;
  let tag_1_2 = -1;
  let tag_3 = -1;
  let tag_2 = -1;
  let tag_2_1 = -1;
  let tag_4 = -1;
  _L: {
    let join_dispatch_19;
    _L$2: {
      if (_cursor < _end) {
        const _p$28 = _cursor;
        const next_char = _data.charCodeAt(_p$28);
        _cursor = _cursor + 1 | 0;
        if (next_char < 65) {
          if (next_char < 64) {
            break _L;
          } else {
            while (true) {
              tag_0 = _cursor;
              if (_cursor < _end) {
                _L$3: {
                  const _p$29 = _cursor;
                  const next_char$2 = _data.charCodeAt(_p$29);
                  _cursor = _cursor + 1 | 0;
                  if (next_char$2 < 55296) {
                    if (next_char$2 < 58) {
                      break _L$3;
                    } else {
                      if (next_char$2 > 58) {
                        break _L$3;
                      } else {
                        if (_cursor < _end) {
                          _L$4: {
                            const _p$30 = _cursor;
                            const next_char$3 = _data.charCodeAt(_p$30);
                            _cursor = _cursor + 1 | 0;
                            if (next_char$3 < 56319) {
                              if (next_char$3 < 55296) {
                                break _L$4;
                              } else {
                                join_dispatch_19 = 7;
                                break _L$2;
                              }
                            } else {
                              if (next_char$3 > 56319) {
                                if (next_char$3 < 65536) {
                                  break _L$4;
                                } else {
                                  break _L;
                                }
                              } else {
                                join_dispatch_19 = 8;
                                break _L$2;
                              }
                            }
                          }
                          join_dispatch_19 = 0;
                          break _L$2;
                        } else {
                          break _L;
                        }
                      }
                    }
                  } else {
                    if (next_char$2 > 56318) {
                      if (next_char$2 < 57344) {
                        if (_cursor < _end) {
                          const _p$30 = _cursor;
                          const next_char$3 = _data.charCodeAt(_p$30);
                          _cursor = _cursor + 1 | 0;
                          if (next_char$3 < 56320) {
                            break _L;
                          } else {
                            if (next_char$3 > 57343) {
                              break _L;
                            } else {
                              continue;
                            }
                          }
                        } else {
                          break _L;
                        }
                      } else {
                        if (next_char$2 > 65535) {
                          break _L;
                        } else {
                          break _L$3;
                        }
                      }
                    } else {
                      if (_cursor < _end) {
                        const _p$30 = _cursor;
                        const next_char$3 = _data.charCodeAt(_p$30);
                        _cursor = _cursor + 1 | 0;
                        if (next_char$3 < 56320) {
                          break _L;
                        } else {
                          if (next_char$3 > 65535) {
                            break _L;
                          } else {
                            continue;
                          }
                        }
                      } else {
                        break _L;
                      }
                    }
                  }
                }
                continue;
              } else {
                break _L;
              }
            }
          }
        } else {
          break _L;
        }
      } else {
        break _L;
      }
    }
    let _tmp$27 = join_dispatch_19;
    _L$3: while (true) {
      const dispatch_19 = _tmp$27;
      _L$4: {
        _L$5: {
          switch (dispatch_19) {
            case 3: {
              tag_1_2 = tag_1_1;
              tag_1_1 = tag_1;
              tag_1 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p$28 = _cursor;
                  const next_char = _data.charCodeAt(_p$28);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        tag_1 = _cursor;
                        tag_2_1 = tag_2;
                        tag_2 = _cursor;
                        tag_3 = _cursor;
                        if (_cursor < _end) {
                          _L$7: {
                            const _p$29 = _cursor;
                            const next_char$2 = _data.charCodeAt(_p$29);
                            _cursor = _cursor + 1 | 0;
                            if (next_char$2 < 59) {
                              if (next_char$2 < 46) {
                                if (next_char$2 < 45) {
                                  break _L$7;
                                } else {
                                  break _L$4;
                                }
                              } else {
                                if (next_char$2 > 47) {
                                  if (next_char$2 < 58) {
                                    _tmp$27 = 6;
                                    continue _L$3;
                                  } else {
                                    _tmp$27 = 3;
                                    continue _L$3;
                                  }
                                } else {
                                  break _L$7;
                                }
                              }
                            } else {
                              if (next_char$2 > 55295) {
                                if (next_char$2 < 57344) {
                                  if (next_char$2 < 56319) {
                                    _tmp$27 = 7;
                                    continue _L$3;
                                  } else {
                                    _tmp$27 = 8;
                                    continue _L$3;
                                  }
                                } else {
                                  if (next_char$2 > 65535) {
                                    break _L;
                                  } else {
                                    break _L$7;
                                  }
                                }
                              } else {
                                break _L$7;
                              }
                            }
                          }
                          _tmp$27 = 0;
                          continue _L$3;
                        } else {
                          break _L;
                        }
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp$27 = 1;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp$27 = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp$27 = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp$27 = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 2: {
              tag_1 = _cursor;
              tag_2 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p$28 = _cursor;
                  const next_char = _data.charCodeAt(_p$28);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp$27 = 2;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp$27 = 3;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp$27 = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp$27 = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp$27 = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 0: {
              tag_1 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p$28 = _cursor;
                  const next_char = _data.charCodeAt(_p$28);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      break _L$6;
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp$27 = 1;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp$27 = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp$27 = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp$27 = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 8: {
              if (_cursor < _end) {
                const _p$28 = _cursor;
                const next_char = _data.charCodeAt(_p$28);
                _cursor = _cursor + 1 | 0;
                if (next_char < 56320) {
                  break _L;
                } else {
                  if (next_char > 57343) {
                    break _L;
                  } else {
                    _tmp$27 = 0;
                    continue _L$3;
                  }
                }
              } else {
                break _L;
              }
            }
            case 4: {
              tag_1 = _cursor;
              tag_4 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p$28 = _cursor;
                  const next_char = _data.charCodeAt(_p$28);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp$27 = 4;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        tag_1_2 = tag_1_1;
                        tag_1_1 = tag_1;
                        tag_1 = _cursor;
                        if (_cursor < _end) {
                          _L$7: {
                            const _p$29 = _cursor;
                            const next_char$2 = _data.charCodeAt(_p$29);
                            _cursor = _cursor + 1 | 0;
                            if (next_char$2 < 55296) {
                              if (next_char$2 < 58) {
                                if (next_char$2 < 48) {
                                  break _L$7;
                                } else {
                                  tag_1 = _cursor;
                                  tag_2_1 = tag_2;
                                  tag_2 = _cursor;
                                  if (_cursor < _end) {
                                    _L$8: {
                                      const _p$30 = _cursor;
                                      const next_char$3 = _data.charCodeAt(_p$30);
                                      _cursor = _cursor + 1 | 0;
                                      if (next_char$3 < 55296) {
                                        if (next_char$3 < 58) {
                                          if (next_char$3 < 48) {
                                            break _L$8;
                                          } else {
                                            _tmp$27 = 5;
                                            continue _L$3;
                                          }
                                        } else {
                                          if (next_char$3 > 58) {
                                            break _L$8;
                                          } else {
                                            _tmp$27 = 3;
                                            continue _L$3;
                                          }
                                        }
                                      } else {
                                        if (next_char$3 > 56318) {
                                          if (next_char$3 < 57344) {
                                            _tmp$27 = 8;
                                            continue _L$3;
                                          } else {
                                            if (next_char$3 > 65535) {
                                              break _L;
                                            } else {
                                              break _L$8;
                                            }
                                          }
                                        } else {
                                          _tmp$27 = 7;
                                          continue _L$3;
                                        }
                                      }
                                    }
                                    _tmp$27 = 0;
                                    continue _L$3;
                                  } else {
                                    break _L$5;
                                  }
                                }
                              } else {
                                if (next_char$2 > 58) {
                                  break _L$7;
                                } else {
                                  _tmp$27 = 1;
                                  continue _L$3;
                                }
                              }
                            } else {
                              if (next_char$2 > 56318) {
                                if (next_char$2 < 57344) {
                                  _tmp$27 = 8;
                                  continue _L$3;
                                } else {
                                  if (next_char$2 > 65535) {
                                    break _L;
                                  } else {
                                    break _L$7;
                                  }
                                }
                              } else {
                                _tmp$27 = 7;
                                continue _L$3;
                              }
                            }
                          }
                          _tmp$27 = 0;
                          continue _L$3;
                        } else {
                          break _L;
                        }
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp$27 = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp$27 = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp$27 = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 5: {
              tag_1 = _cursor;
              tag_2 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p$28 = _cursor;
                  const next_char = _data.charCodeAt(_p$28);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp$27 = 5;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp$27 = 3;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp$27 = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp$27 = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp$27 = 0;
                continue _L$3;
              } else {
                break _L$5;
              }
            }
            case 6: {
              tag_1 = _cursor;
              tag_2 = _cursor;
              tag_3 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p$28 = _cursor;
                  const next_char = _data.charCodeAt(_p$28);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 59) {
                    if (next_char < 46) {
                      if (next_char < 45) {
                        break _L$6;
                      } else {
                        break _L$4;
                      }
                    } else {
                      if (next_char > 47) {
                        if (next_char < 58) {
                          _tmp$27 = 6;
                          continue _L$3;
                        } else {
                          _tmp$27 = 3;
                          continue _L$3;
                        }
                      } else {
                        break _L$6;
                      }
                    }
                  } else {
                    if (next_char > 55295) {
                      if (next_char < 57344) {
                        if (next_char < 56319) {
                          _tmp$27 = 7;
                          continue _L$3;
                        } else {
                          _tmp$27 = 8;
                          continue _L$3;
                        }
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      break _L$6;
                    }
                  }
                }
                _tmp$27 = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 7: {
              if (_cursor < _end) {
                const _p$28 = _cursor;
                const next_char = _data.charCodeAt(_p$28);
                _cursor = _cursor + 1 | 0;
                if (next_char < 56320) {
                  break _L;
                } else {
                  if (next_char > 65535) {
                    break _L;
                  } else {
                    _tmp$27 = 0;
                    continue _L$3;
                  }
                }
              } else {
                break _L;
              }
            }
            case 1: {
              tag_1_1 = tag_1;
              tag_1 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p$28 = _cursor;
                  const next_char = _data.charCodeAt(_p$28);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp$27 = 2;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp$27 = 1;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp$27 = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp$27 = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp$27 = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            default: {
              break _L;
            }
          }
        }
        tag_1 = tag_1_2;
        tag_2 = tag_2_1;
        match_tag_saver_0 = tag_0;
        match_tag_saver_1 = tag_1;
        match_tag_saver_2 = tag_2;
        match_tag_saver_3 = tag_3;
        match_tag_saver_4 = tag_4;
        accept_state = 0;
        match_end = _cursor;
        break _L;
      }
      tag_1_1 = tag_1_2;
      tag_1 = _cursor;
      tag_2 = tag_2_1;
      if (_cursor < _end) {
        _L$5: {
          const _p$28 = _cursor;
          const next_char = _data.charCodeAt(_p$28);
          _cursor = _cursor + 1 | 0;
          if (next_char < 55296) {
            if (next_char < 58) {
              if (next_char < 48) {
                break _L$5;
              } else {
                _tmp$27 = 4;
                continue;
              }
            } else {
              if (next_char > 58) {
                break _L$5;
              } else {
                _tmp$27 = 1;
                continue;
              }
            }
          } else {
            if (next_char > 56318) {
              if (next_char < 57344) {
                _tmp$27 = 8;
                continue;
              } else {
                if (next_char > 65535) {
                  break _L;
                } else {
                  break _L$5;
                }
              }
            } else {
              _tmp$27 = 7;
              continue;
            }
          }
        }
        _tmp$27 = 0;
        continue;
      } else {
        break _L;
      }
    }
  }
  if (accept_state === 0) {
    let start_line;
    let _try_err;
    _L$2: {
      _L$3: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_1 + 1 | 0, match_tag_saver_2);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          start_line = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$3;
        }
        break _L$2;
      }
      start_line = $panic();
    }
    let start_column;
    let _try_err$2;
    _L$3: {
      _L$4: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_2 + 1 | 0, match_tag_saver_3);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          start_column = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp$27 = _err._0;
          _try_err$2 = _tmp$27;
          break _L$4;
        }
        break _L$3;
      }
      start_column = $panic();
    }
    let pkg;
    let _try_err$3;
    _L$4: {
      _L$5: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, _start + 1 | 0, match_tag_saver_0);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          pkg = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp$27 = _err._0;
          _try_err$3 = _tmp$27;
          break _L$5;
        }
        break _L$4;
      }
      pkg = $panic();
    }
    let filename;
    let _try_err$4;
    _L$5: {
      _L$6: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_0 + 1 | 0, match_tag_saver_1);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          filename = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp$27 = _err._0;
          _try_err$4 = _tmp$27;
          break _L$6;
        }
        break _L$5;
      }
      filename = $panic();
    }
    let end_line;
    let _try_err$5;
    _L$6: {
      _L$7: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_3 + 1 | 0, match_tag_saver_4);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          end_line = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp$27 = _err._0;
          _try_err$5 = _tmp$27;
          break _L$7;
        }
        break _L$6;
      }
      end_line = $panic();
    }
    let end_column;
    let _try_err$6;
    _L$7: {
      _L$8: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_4 + 1 | 0, match_end);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          end_column = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp$27 = _err._0;
          _try_err$6 = _tmp$27;
          break _L$8;
        }
        break _L$7;
      }
      end_column = $panic();
    }
    return { pkg: pkg, filename: filename, start_line: start_line, start_column: start_column, end_line: end_line, end_column: end_column };
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$Logger$write_string$1$(self, str) {
  const _bind = self;
  _bind.val = `${_bind.val}${str}`;
}
function moonbitlang$core$builtin$$Hasher$combine_int(self, value) {
  moonbitlang$core$builtin$$Hasher$combine_uint(self, value);
}
function moonbitlang$core$builtin$$MyInt64$from_int(value) {
  return { hi: value >> 31 & -1, lo: value | 0 };
}
function moonbitlang$core$int$$Int$to_int64(self) {
  return moonbitlang$core$builtin$$MyInt64$from_int(self);
}
function moonbitlang$core$int$$Int$to_uint64(self) {
  return moonbitlang$core$int$$Int$to_int64(self);
}
function moonbitlang$core$builtin$$Hasher$combine$19$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$19$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$26$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$26$(value, self);
}
function moonbitlang$core$builtin$$Eq$not_equal$78$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$79$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$80$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$6$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$81$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$7$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$82$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$83$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$84$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$85$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$86$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$87$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$88$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$12$(x, y);
}
function moonbitlang$core$builtin$$Compare$op_lt$80$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$6$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_lt$81$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$7$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_lt$23$(x, y) {
  return $compare_int(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_gt$23$(x, y) {
  return $compare_int(x, y) > 0;
}
function moonbitlang$core$builtin$$Compare$op_gt$80$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$6$(x, y) > 0;
}
function moonbitlang$core$builtin$$Compare$op_gt$81$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$7$(x, y) > 0;
}
function moonbitlang$core$builtin$$Compare$op_le$23$(x, y) {
  return $compare_int(x, y) <= 0;
}
function moonbitlang$core$builtin$$Compare$op_le$80$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$6$(x, y) <= 0;
}
function moonbitlang$core$builtin$$Compare$op_le$81$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$7$(x, y) <= 0;
}
function moonbitlang$core$builtin$$Compare$op_ge$23$(x, y) {
  return $compare_int(x, y) >= 0;
}
function moonbitlang$core$builtin$$Compare$op_ge$80$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$6$(x, y) >= 0;
}
function moonbitlang$core$builtin$$Compare$op_ge$81$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$7$(x, y) >= 0;
}
function moonbitlang$core$builtin$$Hasher$avalanche(self) {
  let acc = self.acc;
  acc = acc ^ (acc >>> 15 | 0);
  acc = Math.imul(acc, -2048144777) | 0;
  acc = acc ^ (acc >>> 13 | 0);
  acc = Math.imul(acc, -1028477379) | 0;
  acc = acc ^ (acc >>> 16 | 0);
  return acc;
}
function moonbitlang$core$builtin$$Hasher$finalize(self) {
  return moonbitlang$core$builtin$$Hasher$avalanche(self);
}
function moonbitlang$core$builtin$$Hasher$new$46$inner(seed) {
  return { acc: (seed >>> 0) + (374761393 >>> 0) | 0 };
}
function moonbitlang$core$builtin$$Hasher$new(seed$46$opt) {
  let seed;
  if (seed$46$opt === undefined) {
    seed = moonbitlang$core$builtin$$seed;
  } else {
    const _Some = seed$46$opt;
    seed = _Some;
  }
  return moonbitlang$core$builtin$$Hasher$new$46$inner(seed);
}
function moonbitlang$core$builtin$$Hash$hash$89$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$19$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Hash$hash$90$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$26$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$string$$String$sub$46$inner(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  if (start$2 >= 0 && (start$2 <= end$2 && end$2 <= len)) {
    if (start$2 < len && moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(self.charCodeAt(start$2))) {
      return new Result$Err$0$(Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$InvalidIndex);
    }
    if (end$2 < len && moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(self.charCodeAt(end$2))) {
      return new Result$Err$0$(Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$InvalidIndex);
    }
    return new Result$Ok$0$({ str: self, start: start$2, end: end$2 });
  } else {
    return new Result$Err$0$(Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$IndexOutOfBounds);
  }
}
function moonbitlang$core$string$$String$sub(self, start$46$opt, end) {
  let start;
  if (start$46$opt === undefined) {
    start = 0;
  } else {
    const _Some = start$46$opt;
    start = _Some;
  }
  return moonbitlang$core$string$$String$sub$46$inner(self, start, end);
}
function moonbitlang$core$builtin$$Logger$write_substring$2$(self, value, start, len) {
  let _tmp$27;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$core$string$$String$sub$46$inner(value, start, start + len | 0);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$27 = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$28 = _err._0;
        _try_err = _tmp$28;
        break _L$2;
      }
      break _L;
    }
    _tmp$27 = $panic();
  }
  moonbitlang$core$builtin$$Logger$write_view$1$(self, _tmp$27);
}
function moonbitlang$core$builtin$$Show$to_string$22$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$91$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$80$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$6$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$92$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$93$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$90$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$26$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$4$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$21$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$3$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$20$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$5$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$94$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$int$$Int$to_string$46$inner(self, radix) {
  return moonbitlang$core$builtin$$int_to_string_js(self, radix);
}
function moonbitlang$core$uint64$$UInt64$to_string$46$inner(self, radix) {
  return moonbitlang$core$builtin$$uint64_to_string_js(self, radix);
}
function moonbitlang$core$builtin$$fail$19$(msg, loc) {
  return new Result$Err$1$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`${moonbitlang$core$builtin$$Show$to_string$22$(loc)} FAILED: ${msg}`));
}
function moonbitlang$core$builtin$$fail$95$(msg, loc) {
  return new Result$Err$2$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`${moonbitlang$core$builtin$$Show$to_string$22$(loc)} FAILED: ${msg}`));
}
function moonbitlang$core$builtin$$fail$8$(msg, loc) {
  return new Result$Err$3$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`${moonbitlang$core$builtin$$Show$to_string$22$(loc)} FAILED: ${msg}`));
}
function moonbitlang$core$builtin$$fail$26$(msg, loc) {
  return new Result$Err$4$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`${moonbitlang$core$builtin$$Show$to_string$22$(loc)} FAILED: ${msg}`));
}
function moonbitlang$core$builtin$$fail$25$(msg, loc) {
  return new Result$Err$5$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`${moonbitlang$core$builtin$$Show$to_string$22$(loc)} FAILED: ${msg}`));
}
function moonbitlang$core$builtin$$fail$96$(msg, loc) {
  return new Result$Err$6$(new Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure(`${moonbitlang$core$builtin$$Show$to_string$22$(loc)} FAILED: ${msg}`));
}
function moonbitlang$core$string$$StringView$at(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp$27 = self.str;
    const _tmp$28 = self.start + index | 0;
    return _tmp$27.charCodeAt(_tmp$28);
  } else {
    return moonbitlang$core$builtin$$abort$13$("Index out of bounds", "@moonbitlang/core/builtin:stringview.mbt:40:5-40:33");
  }
}
function moonbitlang$core$string$$StringView$view$46$inner(self, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.end - self.start | 0;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  return start_offset >= 0 && (start_offset <= end_offset$2 && end_offset$2 <= (self.end - self.start | 0)) ? { str: self.str, start: self.start + start_offset | 0, end: self.start + end_offset$2 | 0 } : moonbitlang$core$builtin$$abort$12$("Invalid index for View", "@moonbitlang/core/builtin:stringview.mbt:113:5-113:36");
}
function moonbitlang$core$builtin$$unsafe_sub_string(_tmp$27, _tmp$28, _tmp$29) {
  return $unsafe_bytes_sub_string(_tmp$27, _tmp$28, _tmp$29);
}
function moonbitlang$core$bytes$$Bytes$to_unchecked_string$46$inner(self, offset, length) {
  const len = self.length;
  let length$2;
  if (length === undefined) {
    length$2 = len - offset | 0;
  } else {
    const _Some = length;
    length$2 = _Some;
  }
  return offset >= 0 && (length$2 >= 0 && (offset + length$2 | 0) <= len) ? moonbitlang$core$builtin$$unsafe_sub_string(self, offset, length$2) : $panic();
}
function moonbitlang$core$builtin$$to_hex$46$to_hex_digit$124$3743(i) {
  if (i < 10) {
    const _p$28 = 48;
    const _p$29 = (i + _p$28 | 0) & 255;
    return _p$29;
  } else {
    const _p$28 = 97;
    const _p$29 = (i + _p$28 | 0) & 255;
    const _p$30 = 10;
    const _p$31 = (_p$29 - _p$30 | 0) & 255;
    return _p$31;
  }
}
function moonbitlang$core$byte$$Byte$to_hex(b) {
  const _self = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  const _p$28 = 16;
  moonbitlang$core$builtin$$Logger$write_char$1$(_self, moonbitlang$core$builtin$$to_hex$46$to_hex_digit$124$3743((b / _p$28 | 0) & 255));
  const _p$29 = 16;
  moonbitlang$core$builtin$$Logger$write_char$1$(_self, moonbitlang$core$builtin$$to_hex$46$to_hex_digit$124$3743((b % _p$29 | 0) & 255));
  const _p$30 = _self;
  return _p$30.val;
}
function moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i) {
  const logger = _env._1;
  const self = _env._0;
  if (i > seg) {
    logger.method_table.method_1(logger.self, self, seg, i - seg | 0);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$19$(self, logger) {
  logger.method_table.method_3(logger.self, 34);
  const _env = { _0: self, _1: logger };
  const len = self.length;
  let _tmp$27 = 0;
  let _tmp$28 = 0;
  _L: while (true) {
    const i = _tmp$27;
    const seg = _tmp$28;
    if (i >= len) {
      moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i);
      break;
    }
    const code = self.charCodeAt(i);
    let c;
    _L$2: {
      switch (code) {
        case 34: {
          c = code;
          break _L$2;
        }
        case 92: {
          c = code;
          break _L$2;
        }
        case 10: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\n");
          _tmp$27 = i + 1 | 0;
          _tmp$28 = i + 1 | 0;
          continue _L;
        }
        case 13: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\r");
          _tmp$27 = i + 1 | 0;
          _tmp$28 = i + 1 | 0;
          continue _L;
        }
        case 8: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\b");
          _tmp$27 = i + 1 | 0;
          _tmp$28 = i + 1 | 0;
          continue _L;
        }
        case 9: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\t");
          _tmp$27 = i + 1 | 0;
          _tmp$28 = i + 1 | 0;
          continue _L;
        }
        default: {
          if (moonbitlang$core$builtin$$Compare$op_lt$23$(code, 32)) {
            moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i);
            logger.method_table.method_0(logger.self, "\\u{");
            logger.method_table.method_0(logger.self, moonbitlang$core$byte$$Byte$to_hex(code & 255));
            logger.method_table.method_3(logger.self, 125);
            _tmp$27 = i + 1 | 0;
            _tmp$28 = i + 1 | 0;
            continue _L;
          } else {
            _tmp$27 = i + 1 | 0;
            continue _L;
          }
        }
      }
    }
    moonbitlang$core$builtin$$output$46$flush_segment$124$3733(_env, seg, i);
    logger.method_table.method_3(logger.self, 92);
    logger.method_table.method_3(logger.self, c);
    _tmp$27 = i + 1 | 0;
    _tmp$28 = i + 1 | 0;
    continue;
  }
  logger.method_table.method_3(logger.self, 34);
}
function moonbitlang$core$builtin$$Show$to_string$12$(self) {
  return self.str.substring(self.start, self.end);
}
function moonbitlang$core$string$$StringView$iter(self) {
  const start = self.start;
  const end = self.end;
  const index = { val: start };
  const _p$28 = () => {
    if (index.val < end) {
      const _tmp$27 = self.str;
      const _tmp$28 = index.val;
      const c1 = _tmp$27.charCodeAt(_tmp$28);
      if (moonbitlang$core$uint16$$UInt16$is_leading_surrogate(c1) && (index.val + 1 | 0) < self.end) {
        const _tmp$29 = self.str;
        const _tmp$30 = index.val + 1 | 0;
        const c2 = _tmp$29.charCodeAt(_tmp$30);
        if (moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(c2)) {
          index.val = index.val + 2 | 0;
          return moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2);
        }
      }
      index.val = index.val + 1 | 0;
      return c1;
    } else {
      return -1;
    }
  };
  return _p$28;
}
function moonbitlang$core$builtin$$Iter2$new$97$(f) {
  return f;
}
function moonbitlang$core$string$$StringView$iter2(self) {
  const start = self.start;
  const end = self.end;
  const index = { val: start };
  const char_index = { val: 0 };
  return moonbitlang$core$builtin$$Iter2$new$97$(() => {
    if (index.val < end) {
      const _tmp$27 = self.str;
      const _tmp$28 = index.val;
      const c1 = _tmp$27.charCodeAt(_tmp$28);
      if (moonbitlang$core$uint16$$UInt16$is_leading_surrogate(c1) && (index.val + 1 | 0) < self.end) {
        const _tmp$29 = self.str;
        const _tmp$30 = index.val + 1 | 0;
        const c2 = _tmp$29.charCodeAt(_tmp$30);
        if (moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(c2)) {
          const result = { _0: char_index.val, _1: moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2) };
          index.val = index.val + 2 | 0;
          char_index.val = char_index.val + 1 | 0;
          return result;
        }
      }
      const result = { _0: char_index.val, _1: c1 };
      index.val = index.val + 1 | 0;
      char_index.val = char_index.val + 1 | 0;
      return result;
    } else {
      return undefined;
    }
  });
}
function moonbitlang$core$builtin$$Eq$equal$12$(self, other) {
  const len = self.end - self.start | 0;
  if (len === (other.end - other.start | 0)) {
    if (self.str === other.str && self.start === other.start) {
      return true;
    }
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < len) {
        const _tmp$28 = self.str;
        const _tmp$29 = self.start + i | 0;
        const _p$28 = _tmp$28.charCodeAt(_tmp$29);
        const _tmp$30 = other.str;
        const _tmp$31 = other.start + i | 0;
        const _p$29 = _tmp$30.charCodeAt(_tmp$31);
        if (_p$28 === _p$29) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return true;
  } else {
    return false;
  }
}
function moonbitlang$core$string$$String$view$46$inner(self, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  return start_offset >= 0 && (start_offset <= end_offset$2 && end_offset$2 <= self.length) ? { str: self, start: start_offset, end: end_offset$2 } : moonbitlang$core$builtin$$abort$12$("Invalid index for View", "@moonbitlang/core/builtin:stringview.mbt:399:5-399:36");
}
function moonbitlang$core$string$$String$char_length_eq$46$inner(self, len, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  let _tmp$27 = start_offset;
  let _tmp$28 = 0;
  while (true) {
    const index = _tmp$27;
    const count = _tmp$28;
    if (index < end_offset$2 && count < len) {
      const c1 = self.charCodeAt(index);
      if (moonbitlang$core$uint16$$UInt16$is_leading_surrogate(c1) && (index + 1 | 0) < end_offset$2) {
        const _tmp$29 = index + 1 | 0;
        const c2 = self.charCodeAt(_tmp$29);
        if (moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(c2)) {
          _tmp$27 = index + 2 | 0;
          _tmp$28 = count + 1 | 0;
          continue;
        } else {
          moonbitlang$core$builtin$$abort$8$("invalid surrogate pair", "@moonbitlang/core/builtin:string.mbt:424:9-424:40");
        }
      }
      _tmp$27 = index + 1 | 0;
      _tmp$28 = count + 1 | 0;
      continue;
    } else {
      return count === len && index === end_offset$2;
    }
  }
}
function moonbitlang$core$string$$String$char_length_ge$46$inner(self, len, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  let _tmp$27 = start_offset;
  let _tmp$28 = 0;
  while (true) {
    const index = _tmp$27;
    const count = _tmp$28;
    if (index < end_offset$2 && count < len) {
      const c1 = self.charCodeAt(index);
      if (moonbitlang$core$uint16$$UInt16$is_leading_surrogate(c1) && (index + 1 | 0) < end_offset$2) {
        const _tmp$29 = index + 1 | 0;
        const c2 = self.charCodeAt(_tmp$29);
        if (moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(c2)) {
          _tmp$27 = index + 2 | 0;
          _tmp$28 = count + 1 | 0;
          continue;
        } else {
          moonbitlang$core$builtin$$abort$8$("invalid surrogate pair", "@moonbitlang/core/builtin:string.mbt:452:9-452:40");
        }
      }
      _tmp$27 = index + 1 | 0;
      _tmp$28 = count + 1 | 0;
      continue;
    } else {
      return count >= len;
    }
  }
}
function moonbitlang$core$string$$String$offset_of_nth_char_backward(self, n, start_offset, end_offset) {
  let char_count = 0;
  let utf16_offset = end_offset;
  while (true) {
    if ((utf16_offset - 1 | 0) >= start_offset && char_count < n) {
      const _tmp$27 = utf16_offset - 1 | 0;
      const c = self.charCodeAt(_tmp$27);
      if (moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(c)) {
        utf16_offset = utf16_offset - 2 | 0;
      } else {
        utf16_offset = utf16_offset - 1 | 0;
      }
      char_count = char_count + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return char_count < n || utf16_offset < start_offset ? undefined : utf16_offset;
}
function moonbitlang$core$string$$String$offset_of_nth_char_forward(self, n, start_offset, end_offset) {
  if (start_offset >= 0 && start_offset <= end_offset) {
    let utf16_offset = start_offset;
    let char_count = 0;
    while (true) {
      if (utf16_offset < end_offset && char_count < n) {
        const _tmp$27 = utf16_offset;
        const c = self.charCodeAt(_tmp$27);
        if (moonbitlang$core$uint16$$UInt16$is_leading_surrogate(c)) {
          utf16_offset = utf16_offset + 2 | 0;
        } else {
          utf16_offset = utf16_offset + 1 | 0;
        }
        char_count = char_count + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return char_count < n || utf16_offset >= end_offset ? undefined : utf16_offset;
  } else {
    return moonbitlang$core$builtin$$abort$17$("Invalid start index", "@moonbitlang/core/builtin:string.mbt:327:5-327:33");
  }
}
function moonbitlang$core$string$$String$offset_of_nth_char$46$inner(self, i, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  return i >= 0 ? moonbitlang$core$string$$String$offset_of_nth_char_forward(self, i, start_offset, end_offset$2) : moonbitlang$core$string$$String$offset_of_nth_char_backward(self, -i | 0, start_offset, end_offset$2);
}
function moonbitlang$core$builtin$$Logger$write_view$1$(self, str) {
  const _bind = self;
  _bind.val = `${_bind.val}${moonbitlang$core$builtin$$Show$to_string$12$(str)}`;
}
function moonbitlang$core$builtin$$boyer_moore_horspool_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const skip_table = $make_array_len_and_init(256, needle_len);
      const _end4200 = needle_len - 1 | 0;
      let _tmp$27 = 0;
      while (true) {
        const i = _tmp$27;
        if (i < _end4200) {
          const _tmp$28 = needle.str;
          const _tmp$29 = needle.start + i | 0;
          const _tmp$30 = _tmp$28.charCodeAt(_tmp$29) & 255;
          $bound_check(skip_table, _tmp$30);
          skip_table[_tmp$30] = (needle_len - 1 | 0) - i | 0;
          _tmp$27 = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      let _tmp$28 = 0;
      while (true) {
        const i = _tmp$28;
        if (i <= (haystack_len - needle_len | 0)) {
          const _end4206 = needle_len - 1 | 0;
          let _tmp$29 = 0;
          while (true) {
            const j = _tmp$29;
            if (j <= _end4206) {
              const _p$28 = i + j | 0;
              const _tmp$30 = haystack.str;
              const _tmp$31 = haystack.start + _p$28 | 0;
              const _p$29 = _tmp$30.charCodeAt(_tmp$31);
              const _tmp$32 = needle.str;
              const _tmp$33 = needle.start + j | 0;
              const _p$30 = _tmp$32.charCodeAt(_tmp$33);
              if (_p$29 !== _p$30) {
                break;
              }
              _tmp$29 = j + 1 | 0;
              continue;
            } else {
              return i;
            }
          }
          const _p$28 = (i + needle_len | 0) - 1 | 0;
          const _tmp$30 = haystack.str;
          const _tmp$31 = haystack.start + _p$28 | 0;
          const _tmp$32 = _tmp$30.charCodeAt(_tmp$31) & 255;
          $bound_check(skip_table, _tmp$32);
          _tmp$28 = i + skip_table[_tmp$32] | 0;
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return moonbitlang$core$builtin$$boyer_moore_horspool_find$46$constr$47$597;
  }
}
function moonbitlang$core$builtin$$brute_force_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const _p$28 = 0;
      const _tmp$27 = needle.str;
      const _tmp$28 = needle.start + _p$28 | 0;
      const needle_first = _tmp$27.charCodeAt(_tmp$28);
      const forward_len = haystack_len - needle_len | 0;
      let i = 0;
      while (true) {
        if (i <= forward_len) {
          while (true) {
            let _tmp$29;
            if (i <= forward_len) {
              const _p$29 = i;
              const _tmp$30 = haystack.str;
              const _tmp$31 = haystack.start + _p$29 | 0;
              const _p$30 = _tmp$30.charCodeAt(_tmp$31);
              _tmp$29 = _p$30 !== needle_first;
            } else {
              _tmp$29 = false;
            }
            if (_tmp$29) {
              i = i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          if (i <= forward_len) {
            let _tmp$29 = 1;
            while (true) {
              const j = _tmp$29;
              if (j < needle_len) {
                const _p$29 = i + j | 0;
                const _tmp$30 = haystack.str;
                const _tmp$31 = haystack.start + _p$29 | 0;
                const _p$30 = _tmp$30.charCodeAt(_tmp$31);
                const _tmp$32 = needle.str;
                const _tmp$33 = needle.start + j | 0;
                const _p$31 = _tmp$32.charCodeAt(_tmp$33);
                if (_p$30 !== _p$31) {
                  break;
                }
                _tmp$29 = j + 1 | 0;
                continue;
              } else {
                return i;
              }
            }
            i = i + 1 | 0;
          }
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return moonbitlang$core$builtin$$brute_force_find$46$constr$47$611;
  }
}
function moonbitlang$core$string$$StringView$find(self, str) {
  return (str.end - str.start | 0) <= 4 ? moonbitlang$core$builtin$$brute_force_find(self, str) : moonbitlang$core$builtin$$boyer_moore_horspool_find(self, str);
}
function moonbitlang$core$builtin$$boyer_moore_horspool_rev_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const skip_table = $make_array_len_and_init(256, needle_len);
      let _tmp$27 = needle_len - 1 | 0;
      while (true) {
        const i = _tmp$27;
        if (i > 0) {
          const _tmp$28 = needle.str;
          const _tmp$29 = needle.start + i | 0;
          const _tmp$30 = _tmp$28.charCodeAt(_tmp$29) & 255;
          $bound_check(skip_table, _tmp$30);
          skip_table[_tmp$30] = i;
          _tmp$27 = i - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      let _tmp$28 = haystack_len - needle_len | 0;
      while (true) {
        const i = _tmp$28;
        if (i >= 0) {
          let _tmp$29 = 0;
          while (true) {
            const j = _tmp$29;
            if (j < needle_len) {
              const _p$28 = i + j | 0;
              const _tmp$30 = haystack.str;
              const _tmp$31 = haystack.start + _p$28 | 0;
              const _p$29 = _tmp$30.charCodeAt(_tmp$31);
              const _tmp$32 = needle.str;
              const _tmp$33 = needle.start + j | 0;
              const _p$30 = _tmp$32.charCodeAt(_tmp$33);
              if (_p$29 !== _p$30) {
                break;
              }
              _tmp$29 = j + 1 | 0;
              continue;
            } else {
              return i;
            }
          }
          const _tmp$30 = haystack.str;
          const _tmp$31 = haystack.start + i | 0;
          const _tmp$32 = _tmp$30.charCodeAt(_tmp$31) & 255;
          $bound_check(skip_table, _tmp$32);
          _tmp$28 = i - skip_table[_tmp$32] | 0;
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return haystack_len;
  }
}
function moonbitlang$core$string$$StringView$find_by(self, pred) {
  const _it = moonbitlang$core$string$$StringView$iter2(self);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter2$next$97$(_it);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _i = _x._0;
      const _c = _x._1;
      if (pred(_c)) {
        return _i;
      }
      continue;
    }
  }
  return undefined;
}
function moonbitlang$core$string$$String$find_by(self, pred) {
  return moonbitlang$core$string$$StringView$find_by({ str: self, start: 0, end: self.length }, pred);
}
function moonbitlang$core$builtin$$brute_force_rev_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const _p$28 = 0;
      const _tmp$27 = needle.str;
      const _tmp$28 = needle.start + _p$28 | 0;
      const needle_first = _tmp$27.charCodeAt(_tmp$28);
      let i = haystack_len - needle_len | 0;
      while (true) {
        if (i >= 0) {
          while (true) {
            let _tmp$29;
            if (i >= 0) {
              const _p$29 = i;
              const _tmp$30 = haystack.str;
              const _tmp$31 = haystack.start + _p$29 | 0;
              const _p$30 = _tmp$30.charCodeAt(_tmp$31);
              _tmp$29 = _p$30 !== needle_first;
            } else {
              _tmp$29 = false;
            }
            if (_tmp$29) {
              i = i - 1 | 0;
              continue;
            } else {
              break;
            }
          }
          if (i >= 0) {
            let _tmp$29 = 1;
            while (true) {
              const j = _tmp$29;
              if (j < needle_len) {
                const _p$29 = i + j | 0;
                const _tmp$30 = haystack.str;
                const _tmp$31 = haystack.start + _p$29 | 0;
                const _p$30 = _tmp$30.charCodeAt(_tmp$31);
                const _tmp$32 = needle.str;
                const _tmp$33 = needle.start + j | 0;
                const _p$31 = _tmp$32.charCodeAt(_tmp$33);
                if (_p$30 !== _p$31) {
                  break;
                }
                _tmp$29 = j + 1 | 0;
                continue;
              } else {
                return i;
              }
            }
            i = i - 1 | 0;
          }
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return haystack_len;
  }
}
function moonbitlang$core$string$$StringView$rev_find(self, str) {
  return (str.end - str.start | 0) <= 4 ? moonbitlang$core$builtin$$brute_force_rev_find(self, str) : moonbitlang$core$builtin$$boyer_moore_horspool_rev_find(self, str);
}
function moonbitlang$core$string$$String$rev_find(self, str) {
  return moonbitlang$core$string$$StringView$rev_find({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$string$$StringView$has_suffix(self, str) {
  const _bind = moonbitlang$core$string$$StringView$rev_find(self, str);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _i = _Some;
    return _i === ((self.end - self.start | 0) - (str.end - str.start | 0) | 0);
  }
}
function moonbitlang$core$string$$String$has_suffix(self, str) {
  return moonbitlang$core$string$$StringView$has_suffix({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$string$$StringView$has_prefix(self, str) {
  const _bind = moonbitlang$core$string$$StringView$find(self, str);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _i = _Some;
    return _i === 0;
  }
}
function moonbitlang$core$string$$String$has_prefix(self, str) {
  return moonbitlang$core$string$$StringView$has_prefix({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$array$$Array$new$46$inner$98$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$99$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$100$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$101$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$19$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$31$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$102$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$103$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$26$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$15$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$41$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$40$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$57$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$66$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$104$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$24$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$50$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$52$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$67$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$105$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$29$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$12$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$32$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$37$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$38$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$49$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$55$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$17$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$new$46$inner$68$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$push$19$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$25$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$106$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$98$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$99$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$100$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$24$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$104$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$101$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$31$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$107$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$27$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$15$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$30$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$26$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$108$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$40$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$52$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$105$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$50$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$29$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$33$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$48$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$46$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$47$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$109$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$68$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$110$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$12$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$44$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$111$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$35$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$36$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$37$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$38$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$32$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$43$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$41$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$102$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$103$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$62$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$67$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$49$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$56$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$54$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$34$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$42$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$112$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$39$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$53$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$18$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$58$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$57$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$55$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$17$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$76$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$70$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$63$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$64$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$45$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$71$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$66$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$69$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$113$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$114$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$75$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$28$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$72$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$73$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$65$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$74$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$77$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$builtin$$Iter$next$115$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$116$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$117$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$118$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$string$$StringView$contains_char(self, c) {
  const len = self.end - self.start | 0;
  if (len > 0) {
    const c$2 = c;
    if (c$2 <= 65535) {
      let _tmp$27 = 0;
      while (true) {
        const i = _tmp$27;
        if (i < len) {
          const _tmp$28 = self.str;
          const _tmp$29 = self.start + i | 0;
          if (_tmp$28.charCodeAt(_tmp$29) === c$2) {
            return true;
          }
          _tmp$27 = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    } else {
      if (len >= 2) {
        const adj = c$2 - 65536 | 0;
        const high = 55296 + (adj >> 10) | 0;
        const low = 56320 + (adj & 1023) | 0;
        let i = 0;
        while (true) {
          if (i < (len - 1 | 0)) {
            const _p$28 = i;
            const _tmp$27 = self.str;
            const _tmp$28 = self.start + _p$28 | 0;
            if (_tmp$27.charCodeAt(_tmp$28) === high) {
              i = i + 1 | 0;
              const _p$29 = i;
              const _tmp$29 = self.str;
              const _tmp$30 = self.start + _p$29 | 0;
              if (_tmp$29.charCodeAt(_tmp$30) === low) {
                return true;
              }
            }
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      } else {
        return false;
      }
    }
    return false;
  } else {
    return false;
  }
}
function moonbitlang$core$string$$StringView$trim_start$46$inner(self, chars) {
  let _tmp$27 = self;
  while (true) {
    const _param = _tmp$27;
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param.str, 0, _param.start, _param.end)) {
      return _param;
    } else {
      const _c = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 0, _param.start, _param.end));
      const _tmp$28 = _param.str;
      const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
      let _tmp$29;
      if (_bind === undefined) {
        _tmp$29 = _param.end;
      } else {
        const _Some = _bind;
        _tmp$29 = _Some;
      }
      const _tmp$30 = _tmp$29;
      const _x = { str: _tmp$28, start: _tmp$30, end: _param.end };
      if (moonbitlang$core$string$$StringView$contains_char(chars, _c)) {
        _tmp$27 = _x;
        continue;
      } else {
        return _param;
      }
    }
  }
}
function moonbitlang$core$string$$StringView$trim_end$46$inner(self, chars) {
  let _tmp$27 = self;
  while (true) {
    const _param = _tmp$27;
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param.str, 0, _param.start, _param.end)) {
      return _param;
    } else {
      const _c = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, -1, _param.start, _param.end));
      const _x = { str: _param.str, start: _param.start, end: moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, -1, _param.start, _param.end) };
      if (moonbitlang$core$string$$StringView$contains_char(chars, _c)) {
        _tmp$27 = _x;
        continue;
      } else {
        return _param;
      }
    }
  }
}
function moonbitlang$core$string$$StringView$trim$46$inner(self, chars) {
  return moonbitlang$core$string$$StringView$trim_end$46$inner(moonbitlang$core$string$$StringView$trim_start$46$inner(self, chars), chars);
}
function moonbitlang$core$string$$String$trim$46$inner(self, chars) {
  return moonbitlang$core$string$$StringView$trim$46$inner({ str: self, start: 0, end: self.length }, chars);
}
function moonbitlang$core$string$$StringView$is_empty(self) {
  return (self.end - self.start | 0) === 0;
}
function moonbitlang$core$string$$String$iter(self) {
  const len = self.length;
  const index = { val: 0 };
  const _p$28 = () => {
    if (index.val < len) {
      const _tmp$27 = index.val;
      const c1 = self.charCodeAt(_tmp$27);
      if (moonbitlang$core$uint16$$UInt16$is_leading_surrogate(c1) && (index.val + 1 | 0) < len) {
        const _tmp$28 = index.val + 1 | 0;
        const c2 = self.charCodeAt(_tmp$28);
        if (moonbitlang$core$uint16$$UInt16$is_trailing_surrogate(c2)) {
          const c = moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2);
          index.val = index.val + 2 | 0;
          return c;
        }
      }
      index.val = index.val + 1 | 0;
      return c1;
    } else {
      return -1;
    }
  };
  return _p$28;
}
function moonbitlang$core$char$$Char$is_ascii_uppercase(self) {
  return self >= 65 && self <= 90;
}
function moonbitlang$core$string$$String$to_lower(self) {
  const _bind = moonbitlang$core$string$$String$find_by(self, (x) => moonbitlang$core$char$$Char$is_ascii_uppercase(x));
  if (_bind === undefined) {
    return self;
  } else {
    const _Some = _bind;
    const _idx = _Some;
    const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(self.length);
    const head = moonbitlang$core$string$$String$view$46$inner(self, 0, _idx);
    moonbitlang$core$builtin$$Logger$write_substring$2$(buf, head.str, head.start, head.end - head.start | 0);
    const _it = moonbitlang$core$string$$StringView$iter(moonbitlang$core$string$$String$view$46$inner(self, _idx, undefined));
    while (true) {
      const _bind$2 = moonbitlang$core$builtin$$Iter$next$115$(_it);
      if (_bind$2 === -1) {
        break;
      } else {
        const _Some$2 = _bind$2;
        const _c = _Some$2;
        if (moonbitlang$core$char$$Char$is_ascii_uppercase(_c)) {
          moonbitlang$core$builtin$$Logger$write_char$1$(buf, _c + 32 | 0);
        } else {
          moonbitlang$core$builtin$$Logger$write_char$1$(buf, _c);
        }
        continue;
      }
    }
    return buf.val;
  }
}
function moonbitlang$core$builtin$$ToStringView$to_string_view$19$(self) {
  return { str: self, start: 0, end: self.length };
}
function moonbitlang$core$builtin$$Show$output$26$(self, logger) {
  logger.method_table.method_0(logger.self, moonbitlang$core$int$$Int$to_string$46$inner(self, 10));
}
function moonbitlang$core$builtin$$Show$output$6$(self, logger) {
  logger.method_table.method_0(logger.self, moonbitlang$core$uint64$$UInt64$to_string$46$inner(self, 10));
}
function moonbitlang$core$array$$ArrayView$at$11$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp$27 = self.buf;
    const _tmp$28 = self.start + index | 0;
    $bound_check(_tmp$27, _tmp$28);
    return _tmp$27[_tmp$28];
  } else {
    return moonbitlang$core$builtin$$abort$11$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$90$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$90$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$15$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp$27 = self.buf;
    const _tmp$28 = self.start + index | 0;
    $bound_check(_tmp$27, _tmp$28);
    return _tmp$27[_tmp$28];
  } else {
    return moonbitlang$core$builtin$$abort$15$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$90$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$90$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$any$119$(self, f) {
  const _len = self.end - self.start | 0;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const v = self.buf[self.start + _i | 0];
      if (f(v)) {
        return true;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return false;
}
function moonbitlang$core$array$$FixedArray$sub$46$inner$11$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  if (start$2 >= 0 && (start$2 <= end$2 && end$2 <= len)) {
    const _bind = self;
    const _bind$2 = end$2 - start$2 | 0;
    return { buf: _bind, start: start$2, end: start$2 + _bind$2 | 0 };
  } else {
    return moonbitlang$core$builtin$$abort$10$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:351:5-351:38");
  }
}
function moonbitlang$core$builtin$$Eq$equal$120$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$121$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$122$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$123$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$124$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return _x === _y;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$125$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$87$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$126$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$55$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$127$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return _x === _y;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$128$(self, other) {
  if (self.$tag === 0) {
    if (other.$tag === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    const _Some = self;
    const _x = _Some._0;
    if (other.$tag === 1) {
      const _Some$2 = other;
      const _y = _Some$2._0;
      return moonbitlang$core$builtin$$Eq$equal$129$(_x, _y);
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$130$(self, other) {
  if (self.$tag === 0) {
    if (other.$tag === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    const _Some = self;
    const _x = _Some._0;
    if (other.$tag === 1) {
      const _Some$2 = other;
      const _y = _Some$2._0;
      return moonbitlang$core$builtin$$Eq$equal$131$(_x, _y);
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$132$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$49$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$133$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$134$(_x, _y);
    }
  }
}
function moonbitlang$core$array$$MutArrayView$at$18$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp$27 = self.buf;
    const _tmp$28 = self.start + index | 0;
    $bound_check(_tmp$27, _tmp$28);
    return _tmp$27[_tmp$28];
  } else {
    return moonbitlang$core$builtin$$abort$18$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$90$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$90$(index)}`, "@moonbitlang/core/builtin:mutarrayview.mbt:97:5-99:6");
  }
}
function moonbitlang$core$array$$MutArrayView$set$18$(self, index, value) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp$27 = self.buf;
    const _tmp$28 = self.start + index | 0;
    $bound_check(_tmp$27, _tmp$28);
    _tmp$27[_tmp$28] = value;
    return;
  } else {
    moonbitlang$core$builtin$$abort$8$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$90$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$90$(index)}`, "@moonbitlang/core/builtin:mutarrayview.mbt:161:5-163:6");
    return;
  }
}
function moonbitlang$core$array$$Array$mut_view$46$inner$18$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  if (start$2 >= 0 && (start$2 <= end$2 && end$2 <= len)) {
    const _bind = self;
    const _bind$2 = end$2 - start$2 | 0;
    return { buf: _bind, start: start$2, end: start$2 + _bind$2 | 0 };
  } else {
    return moonbitlang$core$builtin$$abort$16$("View index out of bounds", "@moonbitlang/core/builtin:mutarrayview.mbt:237:5-237:38");
  }
}
function moonbitlang$core$array$$MutArrayView$mut_view$46$inner$18$(self, start, end) {
  const len = self.end - self.start | 0;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  if (start$2 >= 0 && (start$2 <= end$2 && end$2 <= len)) {
    const _bind = self.buf;
    const _bind$2 = self.start + start$2 | 0;
    const _bind$3 = end$2 - start$2 | 0;
    return { buf: _bind, start: _bind$2, end: _bind$2 + _bind$3 | 0 };
  } else {
    return moonbitlang$core$builtin$$abort$16$("View index out of bounds", "@moonbitlang/core/builtin:mutarrayview.mbt:286:5-286:38");
  }
}
function moonbitlang$core$int$$Int$next_power_of_two(self) {
  if (self >= 0) {
    if (self <= 1) {
      return 1;
    }
    if (self > 1073741824) {
      return 1073741824;
    }
    return (2147483647 >> (Math.clz32(self - 1 | 0) - 1 | 0)) + 1 | 0;
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$Map$new$46$inner$135$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$135$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp$27 = self.entries;
    $bound_check(_tmp$27, _bind);
    const _p$28 = _tmp$27[_bind];
    let _tmp$28;
    if (_p$28 === undefined) {
      _tmp$28 = $panic();
    } else {
      const _p$29 = _p$28;
      _tmp$28 = _p$29;
    }
    _tmp$28.next = entry;
  }
  self.tail = idx;
  const _tmp$27 = self.entries;
  $bound_check(_tmp$27, idx);
  _tmp$27[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$set_entry$135$(self, entry, new_idx) {
  const _tmp$27 = self.entries;
  $bound_check(_tmp$27, new_idx);
  _tmp$27[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$push_away$135$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$135$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$135$(self, entry$2, idx$2);
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set_with_hash$135$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$135$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$135$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$135$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$grow$135$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p$28 = self.capacity;
  self.grow_at = (Math.imul(_p$28, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp$27 = old_head;
  while (true) {
    const _param = _tmp$27;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$135$(self, _key, _value, _hash);
      _tmp$27 = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$set$135$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$135$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$builtin$$Map$from_array$135$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p$28 = capacity;
  if (length > ((Math.imul(_p$28, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$135$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$135$(m, e._0, e._1);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$get$135$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$contains$135$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$remove_entry$135$(self, entry) {
  const _bind = entry.prev;
  if (_bind === -1) {
    self.head = entry.next;
  } else {
    const _tmp$27 = self.entries;
    $bound_check(_tmp$27, _bind);
    const _p$28 = _tmp$27[_bind];
    let _tmp$28;
    if (_p$28 === undefined) {
      _tmp$28 = $panic();
    } else {
      const _p$29 = _p$28;
      _tmp$28 = _p$29;
    }
    const _tmp$29 = _tmp$28;
    _tmp$29.next = entry.next;
  }
  const _bind$2 = entry.next;
  if (_bind$2 === undefined) {
    self.tail = entry.prev;
    return;
  } else {
    const _Some = _bind$2;
    const _next = _Some;
    _next.prev = entry.prev;
    return;
  }
}
function moonbitlang$core$builtin$$Map$shift_back$135$(self, idx) {
  let _tmp$27 = idx;
  while (true) {
    const idx$2 = _tmp$27;
    const next = idx$2 + 1 & self.capacity_mask;
    _L: {
      const _tmp$28 = self.entries;
      $bound_check(_tmp$28, next);
      const _bind = _tmp$28[next];
      if (_bind === undefined) {
        break _L;
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _x$2 = _x.psl;
        if (_x$2 === 0) {
          break _L;
        } else {
          _x.psl = _x.psl - 1 | 0;
          moonbitlang$core$builtin$$Map$set_entry$135$(self, _x, idx$2);
          _tmp$27 = next;
          continue;
        }
      }
    }
    const _tmp$28 = self.entries;
    $bound_check(_tmp$28, idx$2);
    _tmp$28[idx$2] = undefined;
    return;
  }
}
function moonbitlang$core$builtin$$Map$remove_with_hash$135$(self, key, hash) {
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        moonbitlang$core$builtin$$Map$remove_entry$135$(self, _entry);
        moonbitlang$core$builtin$$Map$shift_back$135$(self, idx);
        self.size = self.size - 1 | 0;
        break;
      }
      if (i > _entry.psl) {
        break;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$remove$135$(self, key) {
  moonbitlang$core$builtin$$Map$remove_with_hash$135$(self, key, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$builtin$$MyInt64$extend_i32_u(value) {
  return { hi: 0, lo: value };
}
function moonbitlang$core$uint64$$UInt64$extend_uint(value) {
  return moonbitlang$core$builtin$$MyInt64$extend_i32_u(value);
}
function moonbitlang$core$uint$$UInt$to_uint64(self) {
  return moonbitlang$core$uint64$$UInt64$extend_uint(self);
}
function moonbitlang$core$double$$Double$convert_uint64(value) {
  return moonbitlang$core$builtin$$MyInt64$convert_to_double_u(value);
}
function moonbitlang$core$int64$$Int64$reinterpret_as_double(self) {
  return moonbitlang$core$builtin$$MyInt64$reinterpret_as_double(self);
}
function moonbitlang$core$builtin$$Iter2$next$136$(self) {
  return moonbitlang$core$builtin$$Iter$next$116$(self);
}
function moonbitlang$core$builtin$$Iter2$next$137$(self) {
  return moonbitlang$core$builtin$$Iter$next$117$(self);
}
function moonbitlang$core$builtin$$Iter2$next$97$(self) {
  return moonbitlang$core$builtin$$Iter$next$118$(self);
}
function moonbitlang$core$uint64$$UInt64$to_int(self) {
  const _p$28 = self;
  return _p$28.lo;
}
function moonbitlang$core$uint64$$UInt64$to_byte(self) {
  return moonbitlang$core$uint64$$UInt64$to_int(self) & 255;
}
function moonbitlang$core$byte$$Byte$to_int64(self) {
  return moonbitlang$core$int$$Int$to_int64(self);
}
function moonbitlang$core$builtin$$Neg$neg$138$(self) {
  return self.lo === 0 ? { hi: ~self.hi + 1 | 0, lo: 0 } : { hi: ~self.hi, lo: ~self.lo + 1 | 0 };
}
function moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, bhi, blo) {
  const _ahi = self.hi;
  const _alo = self.lo;
  const lo = _alo + blo | 0;
  const s = lo >> 31;
  const as_ = _alo >> 31;
  const bs = blo >> 31;
  const c = (as_ & bs | ~s & (as_ ^ bs)) & 1;
  const hi = (_ahi + bhi | 0) + c | 0;
  return { hi: hi, lo: lo };
}
function moonbitlang$core$builtin$$Add$add$138$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, other.hi, other.lo);
}
function moonbitlang$core$builtin$$Sub$sub$138$(self, other) {
  return other.lo === 0 ? { hi: self.hi - other.hi | 0, lo: self.lo } : moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, ~other.hi, ~other.lo + 1 | 0);
}
function moonbitlang$core$builtin$$Mul$mul$138$(self, other) {
  const _ahi = self.hi;
  const _alo = self.lo;
  const _bhi = other.hi;
  const _blo = other.lo;
  const ahi = _ahi;
  const alo = _alo;
  const bhi = _bhi;
  const blo = _blo;
  const a48 = ahi >>> 16 | 0;
  const a32 = ahi & 65535;
  const a16 = alo >>> 16 | 0;
  const a00 = alo & 65535;
  const b48 = bhi >>> 16 | 0;
  const b32 = bhi & 65535;
  const b16 = blo >>> 16 | 0;
  const b00 = blo & 65535;
  const c00 = Math.imul(a00, b00) | 0;
  const c16 = c00 >>> 16 | 0;
  const c00$2 = c00 & 65535;
  const c16$2 = (c16 >>> 0) + ((Math.imul(a16, b00) | 0) >>> 0) | 0;
  const c32 = c16$2 >>> 16 | 0;
  const c16$3 = c16$2 & 65535;
  const c16$4 = (c16$3 >>> 0) + ((Math.imul(a00, b16) | 0) >>> 0) | 0;
  const c32$2 = (c32 >>> 0) + ((c16$4 >>> 16 | 0) >>> 0) | 0;
  const c16$5 = c16$4 & 65535;
  const c32$3 = (c32$2 >>> 0) + ((Math.imul(a32, b00) | 0) >>> 0) | 0;
  const c48 = c32$3 >>> 16 | 0;
  const c32$4 = c32$3 & 65535;
  const c32$5 = (c32$4 >>> 0) + ((Math.imul(a16, b16) | 0) >>> 0) | 0;
  const c48$2 = (c48 >>> 0) + ((c32$5 >>> 16 | 0) >>> 0) | 0;
  const c32$6 = c32$5 & 65535;
  const c32$7 = (c32$6 >>> 0) + ((Math.imul(a00, b32) | 0) >>> 0) | 0;
  const c48$3 = (c48$2 >>> 0) + ((c32$7 >>> 16 | 0) >>> 0) | 0;
  const c32$8 = c32$7 & 65535;
  const c48$4 = (((((((c48$3 >>> 0) + ((Math.imul(a48, b00) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a32, b16) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a16, b32) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a00, b48) | 0) >>> 0) | 0;
  const c48$5 = c48$4 & 65535;
  return { hi: c48$5 << 16 | c32$8, lo: c16$5 << 16 | c00$2 };
}
function moonbitlang$core$builtin$$try_get_int64_wasm_helper() {
  if (moonbitlang$core$builtin$$wasm_helper_cache.tried) {
    const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
    return !(_bind === undefined);
  }
  moonbitlang$core$builtin$$wasm_helper_cache.tried = true;
  moonbitlang$core$builtin$$wasm_helper_cache.exports = moonbitlang$core$builtin$$try_init_wasm_helper();
  const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
  return !(_bind === undefined);
}
function moonbitlang$core$builtin$$Div$div$138$(self, other) {
  if (!(other.hi === 0 && other.lo === 0)) {
    if (!moonbitlang$core$builtin$$try_get_int64_wasm_helper()) {
      return moonbitlang$core$builtin$$MyInt64$div_bigint(self, other);
    }
    const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
    if (_bind === undefined) {
      return $panic();
    } else {
      const _Some = _bind;
      const _exports = _Some;
      const _ahi = self.hi;
      const _alo = self.lo;
      const _bhi = other.hi;
      const _blo = other.lo;
      const _func = _exports.div_s;
      const lo = _func(_alo, _ahi, _blo, _bhi);
      const _func$2 = _exports.get_high;
      const hi = _func$2();
      return { hi: hi, lo: lo };
    }
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$MyInt64$div_u(self, other) {
  if (!(other.hi === 0 && other.lo === 0)) {
    if (!moonbitlang$core$builtin$$try_get_int64_wasm_helper()) {
      return moonbitlang$core$builtin$$MyInt64$div_u_bigint(self, other);
    }
    const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
    if (_bind === undefined) {
      return $panic();
    } else {
      const _Some = _bind;
      const _exports = _Some;
      const _ahi = self.hi;
      const _alo = self.lo;
      const _bhi = other.hi;
      const _blo = other.lo;
      const _func = _exports.div_u;
      const lo = _func(_alo, _ahi, _blo, _bhi);
      const _func$2 = _exports.get_high;
      const hi = _func$2();
      return { hi: hi, lo: lo };
    }
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$Mod$mod$138$(self, other) {
  if (!(other.hi === 0 && other.lo === 0)) {
    if (!moonbitlang$core$builtin$$try_get_int64_wasm_helper()) {
      return moonbitlang$core$builtin$$MyInt64$mod_bigint(self, other);
    }
    const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
    if (_bind === undefined) {
      return $panic();
    } else {
      const _Some = _bind;
      const _exports = _Some;
      const _ahi = self.hi;
      const _alo = self.lo;
      const _bhi = other.hi;
      const _blo = other.lo;
      const _func = _exports.rem_s;
      const lo = _func(_alo, _ahi, _blo, _bhi);
      const _func$2 = _exports.get_high;
      const hi = _func$2();
      return { hi: hi, lo: lo };
    }
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$MyInt64$mod_u(self, other) {
  if (!(other.hi === 0 && other.lo === 0)) {
    if (!moonbitlang$core$builtin$$try_get_int64_wasm_helper()) {
      return moonbitlang$core$builtin$$MyInt64$mod_u_bigint(self, other);
    }
    const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
    if (_bind === undefined) {
      return $panic();
    } else {
      const _Some = _bind;
      const _exports = _Some;
      const _ahi = self.hi;
      const _alo = self.lo;
      const _bhi = other.hi;
      const _blo = other.lo;
      const _func = _exports.rem_u;
      const lo = _func(_alo, _ahi, _blo, _bhi);
      const _func$2 = _exports.get_high;
      const hi = _func$2();
      return { hi: hi, lo: lo };
    }
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$MyInt64$lnot(self) {
  return { hi: ~self.hi, lo: ~self.lo };
}
function moonbitlang$core$builtin$$MyInt64$land(self, other) {
  return { hi: self.hi & other.hi, lo: self.lo & other.lo };
}
function moonbitlang$core$builtin$$MyInt64$lor(self, other) {
  return { hi: self.hi | other.hi, lo: self.lo | other.lo };
}
function moonbitlang$core$builtin$$MyInt64$lxor(self, other) {
  return { hi: self.hi ^ other.hi, lo: self.lo ^ other.lo };
}
function moonbitlang$core$builtin$$MyInt64$lsl(self, shift) {
  const shift$2 = shift & 63;
  if (shift$2 === 0) {
    return self;
  } else {
    if (shift$2 < 32) {
      const _hi = self.hi;
      const _lo = self.lo;
      const hi = _hi;
      const lo = _lo;
      const hi$2 = hi << shift$2 | (lo >>> (32 - shift$2 | 0) | 0);
      const lo$2 = lo << shift$2;
      return { hi: hi$2, lo: lo$2 };
    } else {
      return { hi: self.lo << (shift$2 - 32 | 0), lo: 0 };
    }
  }
}
function moonbitlang$core$builtin$$MyInt64$lsr(self, shift) {
  const shift$2 = shift & 63;
  return shift$2 === 0 ? self : shift$2 < 32 ? { hi: self.hi >>> shift$2 | 0, lo: self.lo >>> shift$2 | self.hi << (32 - shift$2 | 0) } : { hi: 0, lo: self.hi >>> (shift$2 - 32 | 0) | 0 };
}
function moonbitlang$core$builtin$$MyInt64$asr(self, shift) {
  const shift$2 = shift & 63;
  return shift$2 === 0 ? self : shift$2 < 32 ? { hi: self.hi >> shift$2, lo: self.lo >>> shift$2 | self.hi << (32 - shift$2 | 0) } : { hi: self.hi >> 31, lo: self.hi >> (shift$2 - 32 | 0) };
}
function moonbitlang$core$builtin$$Neg$neg$7$(self) {
  return moonbitlang$core$builtin$$Neg$neg$138$(self);
}
function moonbitlang$core$builtin$$Add$add$7$(self, other) {
  return moonbitlang$core$builtin$$Add$add$138$(self, other);
}
function moonbitlang$core$builtin$$Sub$sub$7$(self, other) {
  return moonbitlang$core$builtin$$Sub$sub$138$(self, other);
}
function moonbitlang$core$builtin$$Mul$mul$7$(self, other) {
  return moonbitlang$core$builtin$$Mul$mul$138$(self, other);
}
function moonbitlang$core$builtin$$Div$div$7$(self, other) {
  return moonbitlang$core$builtin$$Div$div$138$(self, other);
}
function moonbitlang$core$builtin$$Mod$mod$7$(self, other) {
  return moonbitlang$core$builtin$$Mod$mod$138$(self, other);
}
function moonbitlang$core$builtin$$BitAnd$land$7$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$land(self, other);
}
function moonbitlang$core$builtin$$BitOr$lor$7$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$lor(self, other);
}
function moonbitlang$core$builtin$$BitXOr$lxor$7$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$lxor(self, other);
}
function moonbitlang$core$builtin$$Shr$shr$7$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$asr(self, other);
}
function moonbitlang$core$builtin$$Shl$shl$7$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$lsl(self, other);
}
function moonbitlang$core$builtin$$Eq$equal$7$(self, other) {
  const _p$28 = self;
  const _p$29 = other;
  return _p$28.hi === _p$29.hi && _p$28.lo === _p$29.lo;
}
function moonbitlang$core$builtin$$Compare$compare$7$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$compare(self, other);
}
function moonbitlang$core$int64$$Int64$to_int(self) {
  const _p$28 = self;
  return _p$28.lo;
}
function moonbitlang$core$double$$Double$convert_int64(value) {
  return moonbitlang$core$builtin$$MyInt64$convert_to_double(value);
}
function moonbitlang$core$int64$$Int64$to_double(self) {
  return moonbitlang$core$double$$Double$convert_int64(self);
}
function moonbitlang$core$uint64$$UInt64$reinterpret_as_double(self) {
  return moonbitlang$core$builtin$$MyInt64$reinterpret_as_double(self);
}
function moonbitlang$core$double$$Double$reinterpret_as_uint64(self) {
  return moonbitlang$core$builtin$$MyInt64$reinterpret_double(self);
}
function moonbitlang$core$builtin$$Add$add$6$(self, other) {
  return moonbitlang$core$builtin$$Add$add$138$(self, other);
}
function moonbitlang$core$builtin$$Sub$sub$6$(self, other) {
  return moonbitlang$core$builtin$$Sub$sub$138$(self, other);
}
function moonbitlang$core$builtin$$Mul$mul$6$(self, other) {
  return moonbitlang$core$builtin$$Mul$mul$138$(self, other);
}
function moonbitlang$core$builtin$$Div$div$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$div_u(self, other);
}
function moonbitlang$core$builtin$$Mod$mod$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$mod_u(self, other);
}
function moonbitlang$core$uint64$$UInt64$to_uint(self) {
  const _p$28 = self;
  return _p$28.lo;
}
function moonbitlang$core$builtin$$Compare$compare$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$compare_u(self, other);
}
function moonbitlang$core$builtin$$Eq$equal$6$(self, other) {
  const _p$28 = self;
  const _p$29 = other;
  return _p$28.hi === _p$29.hi && _p$28.lo === _p$29.lo;
}
function moonbitlang$core$builtin$$BitAnd$land$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$land(self, other);
}
function moonbitlang$core$builtin$$BitOr$lor$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$lor(self, other);
}
function moonbitlang$core$builtin$$BitXOr$lxor$6$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$lxor(self, other);
}
function moonbitlang$core$uint64$$UInt64$lnot(self) {
  return moonbitlang$core$builtin$$MyInt64$lnot(self);
}
function moonbitlang$core$builtin$$Shl$shl$6$(self, shift) {
  return moonbitlang$core$builtin$$MyInt64$lsl(self, shift);
}
function moonbitlang$core$builtin$$Shr$shr$6$(self, shift) {
  return moonbitlang$core$builtin$$MyInt64$lsr(self, shift);
}
function moonbitlang$core$uint64$$UInt64$clz(self) {
  const _p$28 = self;
  return _p$28.hi !== 0 ? Math.clz32(_p$28.hi) : 32 + Math.clz32(_p$28.lo) | 0;
}
function moonbitlang$core$builtin$$Hasher$combine_string(self, value) {
  const _end2395 = value.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end2395) {
      moonbitlang$core$builtin$$Hasher$combine_uint(self, value.charCodeAt(i));
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$19$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_string(hasher, self);
}
function moonbitlang$core$builtin$$Hash$hash_combine$26$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self);
}
function moonbitlang$core$double$$Double$to_int64(self) {
  return moonbitlang$core$builtin$$MyInt64$from_double(self);
}
function moonbitlang$core$double$$Double$to_int(self) {
  return self !== self ? 0 : self >= 2147483647 ? 2147483647 : self <= -2147483648 ? -2147483648 : self | 0;
}
function moonbitlang$core$bytes$$Bytes$makei$139$(length, value) {
  if (length <= 0) {
    return $bytes_literal$0;
  }
  const arr = $makebytes(length, value(0));
  let _tmp$27 = 1;
  while (true) {
    const i = _tmp$27;
    if (i < length) {
      $bound_check(arr, i);
      arr[i] = value(i);
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$builtin$$println$19$(input) {
  console.log(input);
}
function moonbitlang$core$bytes$$Bytes$sub$46$inner(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  if (start$2 >= 0 && (start$2 <= end$2 && end$2 <= len)) {
    const _bind = end$2 - start$2 | 0;
    return { bytes: self, start: start$2, end: start$2 + _bind | 0 };
  } else {
    return moonbitlang$core$builtin$$abort$9$("Invalid index for View", "@moonbitlang/core/builtin:bytesview.mbt:162:5-162:36");
  }
}
function moonbitlang$core$array$$FixedArray$blit_from_bytes(self, bytes_offset, src, src_offset, length) {
  const e1 = (bytes_offset + length | 0) - 1 | 0;
  const e2 = (src_offset + length | 0) - 1 | 0;
  const len1 = self.length;
  const len2 = src.length;
  if (length >= 0 && (bytes_offset >= 0 && (e1 < len1 && (src_offset >= 0 && e2 < len2)))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$11$(self, bytes_offset, src, src_offset, length);
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$bytes$$Bytes$from_array(arr) {
  return moonbitlang$core$bytes$$Bytes$makei$139$(arr.end - arr.start | 0, (i) => moonbitlang$core$array$$ArrayView$at$11$(arr, i));
}
function moonbitlang$core$array$$Array$make$24$(len, elem) {
  const arr = new Array(len);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      arr[i] = elem;
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$26$(len, elem) {
  const arr = new Array(len);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      arr[i] = elem;
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$61$(len, elem) {
  const arr = new Array(len);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      arr[i] = elem;
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$51$(len, elem) {
  const arr = new Array(len);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      arr[i] = elem;
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$15$(len, elem) {
  const arr = new Array(len);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      arr[i] = elem;
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$set$24$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$27$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$30$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$43$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$32$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$26$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$50$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$61$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$46$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$47$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$48$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$109$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$110$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$41$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$51$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$52$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$28$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$53$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$58$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$56$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$57$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$15$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$25$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$63$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$64$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$45$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$71$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$66$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$69$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$67$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$17$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$72$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$73$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$65$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$74$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$77$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$140$(self, logger) {
  const pkg = self.pkg;
  const _data = pkg.str;
  const _start = pkg.start;
  const _end = _start + (pkg.end - pkg.start | 0) | 0;
  let _cursor = _start;
  let accept_state = -1;
  let match_end = -1;
  let match_tag_saver_0 = -1;
  let tag_0 = -1;
  let _bind;
  _L: {
    _L$2: {
      _L$3: while (true) {
        if (_cursor < _end) {
          _L$4: {
            _L$5: {
              const _p$28 = _cursor;
              const next_char = _data.charCodeAt(_p$28);
              _cursor = _cursor + 1 | 0;
              if (next_char < 55296) {
                if (next_char < 47) {
                  break _L$5;
                } else {
                  if (next_char > 47) {
                    break _L$5;
                  } else {
                    _L$6: while (true) {
                      tag_0 = _cursor;
                      if (_cursor < _end) {
                        _L$7: {
                          const _p$29 = _cursor;
                          const next_char$2 = _data.charCodeAt(_p$29);
                          _cursor = _cursor + 1 | 0;
                          if (next_char$2 < 55296) {
                            if (next_char$2 < 47) {
                              break _L$7;
                            } else {
                              if (next_char$2 > 47) {
                                break _L$7;
                              } else {
                                while (true) {
                                  if (_cursor < _end) {
                                    _L$8: {
                                      const _p$30 = _cursor;
                                      const next_char$3 = _data.charCodeAt(_p$30);
                                      _cursor = _cursor + 1 | 0;
                                      if (next_char$3 < 56319) {
                                        if (next_char$3 < 55296) {
                                          break _L$8;
                                        } else {
                                          if (_cursor < _end) {
                                            const _p$31 = _cursor;
                                            const next_char$4 = _data.charCodeAt(_p$31);
                                            _cursor = _cursor + 1 | 0;
                                            if (next_char$4 < 56320) {
                                              break _L$2;
                                            } else {
                                              if (next_char$4 > 65535) {
                                                break _L$2;
                                              } else {
                                                continue;
                                              }
                                            }
                                          } else {
                                            break _L$2;
                                          }
                                        }
                                      } else {
                                        if (next_char$3 > 56319) {
                                          if (next_char$3 < 65536) {
                                            break _L$8;
                                          } else {
                                            break _L$2;
                                          }
                                        } else {
                                          if (_cursor < _end) {
                                            const _p$31 = _cursor;
                                            const next_char$4 = _data.charCodeAt(_p$31);
                                            _cursor = _cursor + 1 | 0;
                                            if (next_char$4 < 56320) {
                                              break _L$2;
                                            } else {
                                              if (next_char$4 > 57343) {
                                                break _L$2;
                                              } else {
                                                continue;
                                              }
                                            }
                                          } else {
                                            break _L$2;
                                          }
                                        }
                                      }
                                    }
                                    continue;
                                  } else {
                                    match_tag_saver_0 = tag_0;
                                    accept_state = 0;
                                    match_end = _cursor;
                                    break _L$2;
                                  }
                                }
                              }
                            }
                          } else {
                            if (next_char$2 > 56318) {
                              if (next_char$2 < 57344) {
                                if (_cursor < _end) {
                                  const _p$30 = _cursor;
                                  const next_char$3 = _data.charCodeAt(_p$30);
                                  _cursor = _cursor + 1 | 0;
                                  if (next_char$3 < 56320) {
                                    break _L$2;
                                  } else {
                                    if (next_char$3 > 57343) {
                                      break _L$2;
                                    } else {
                                      continue;
                                    }
                                  }
                                } else {
                                  break _L$2;
                                }
                              } else {
                                if (next_char$2 > 65535) {
                                  break _L$2;
                                } else {
                                  break _L$7;
                                }
                              }
                            } else {
                              if (_cursor < _end) {
                                const _p$30 = _cursor;
                                const next_char$3 = _data.charCodeAt(_p$30);
                                _cursor = _cursor + 1 | 0;
                                if (next_char$3 < 56320) {
                                  break _L$2;
                                } else {
                                  if (next_char$3 > 65535) {
                                    break _L$2;
                                  } else {
                                    continue;
                                  }
                                }
                              } else {
                                break _L$2;
                              }
                            }
                          }
                        }
                        continue;
                      } else {
                        break _L$2;
                      }
                    }
                  }
                }
              } else {
                if (next_char > 56318) {
                  if (next_char < 57344) {
                    if (_cursor < _end) {
                      const _p$29 = _cursor;
                      const next_char$2 = _data.charCodeAt(_p$29);
                      _cursor = _cursor + 1 | 0;
                      if (next_char$2 < 56320) {
                        break _L$2;
                      } else {
                        if (next_char$2 > 57343) {
                          break _L$2;
                        } else {
                          continue;
                        }
                      }
                    } else {
                      break _L$2;
                    }
                  } else {
                    if (next_char > 65535) {
                      break _L$2;
                    } else {
                      break _L$5;
                    }
                  }
                } else {
                  if (_cursor < _end) {
                    const _p$29 = _cursor;
                    const next_char$2 = _data.charCodeAt(_p$29);
                    _cursor = _cursor + 1 | 0;
                    if (next_char$2 < 56320) {
                      break _L$2;
                    } else {
                      if (next_char$2 > 65535) {
                        break _L$2;
                      } else {
                        continue;
                      }
                    }
                  } else {
                    break _L$2;
                  }
                }
              }
              break _L$4;
            }
            continue;
          }
        } else {
          break _L$2;
        }
      }
      break _L;
    }
    if (accept_state === 0) {
      let package_name;
      let _try_err;
      _L$3: {
        _L$4: {
          const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_0 + 1 | 0, match_end);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            package_name = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp$27 = _err._0;
            _try_err = _tmp$27;
            break _L$4;
          }
          break _L$3;
        }
        package_name = $panic();
      }
      let module_name;
      let _try_err$2;
      _L$4: {
        _L$5: {
          const _bind$2 = moonbitlang$core$string$$String$sub(_data, _start, match_tag_saver_0);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            module_name = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp$27 = _err._0;
            _try_err$2 = _tmp$27;
            break _L$5;
          }
          break _L$4;
        }
        module_name = $panic();
      }
      _bind = { _0: module_name, _1: package_name };
    } else {
      _bind = { _0: pkg, _1: undefined };
    }
  }
  const _module_name = _bind._0;
  const _package_name = _bind._1;
  if (_package_name === undefined) {
  } else {
    const _Some = _package_name;
    const _pkg_name = _Some;
    logger.method_table.method_2(logger.self, _pkg_name);
    logger.method_table.method_3(logger.self, 47);
  }
  logger.method_table.method_2(logger.self, self.filename);
  logger.method_table.method_3(logger.self, 58);
  logger.method_table.method_2(logger.self, self.start_line);
  logger.method_table.method_3(logger.self, 58);
  logger.method_table.method_2(logger.self, self.start_column);
  logger.method_table.method_3(logger.self, 45);
  logger.method_table.method_2(logger.self, self.end_line);
  logger.method_table.method_3(logger.self, 58);
  logger.method_table.method_2(logger.self, self.end_column);
  logger.method_table.method_3(logger.self, 64);
  logger.method_table.method_2(logger.self, _module_name);
}
function moonbitlang$core$builtin$$Show$output$91$(self, logger) {
  moonbitlang$core$builtin$$Show$output$140$(moonbitlang$core$builtin$$SourceLocRepr$parse(self), logger);
}
function moonbitlang$core$array$$Array$sub$46$inner$15$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  if (start$2 >= 0 && (start$2 <= end$2 && end$2 <= len)) {
    const _bind = self;
    const _bind$2 = end$2 - start$2 | 0;
    return { buf: _bind, start: start$2, end: start$2 + _bind$2 | 0 };
  } else {
    return moonbitlang$core$builtin$$abort$14$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:251:5-251:38");
  }
}
function moonbitlang$core$array$$ArrayView$to_array$15$(self) {
  const len = self.end - self.start | 0;
  if (len === 0) {
    return [];
  } else {
    const arr = moonbitlang$core$array$$Array$make$15$(len, moonbitlang$core$array$$ArrayView$at$15$(self, 0));
    const _len = self.end - self.start | 0;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const v = self.buf[self.start + _i | 0];
        moonbitlang$core$array$$Array$set$15$(arr, _i, v);
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return arr;
  }
}
function moonbitlang$core$array$$ArrayView$join$19$(self, separator) {
  if ((self.end - self.start | 0) === 0) {
    return "";
  } else {
    const _hd = self.buf[self.start];
    const _bind = self.buf;
    const _bind$2 = 1 + self.start | 0;
    const _bind$3 = self.end;
    const _x = { buf: _bind, start: _bind$2, end: _bind$3 };
    const hd = moonbitlang$core$builtin$$ToStringView$to_string_view$19$(_hd);
    let size_hint = hd.end - hd.start | 0;
    const _len = _x.end - _x.start | 0;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const s = _bind[_bind$2 + _i | 0];
        const _tmp$28 = size_hint;
        const _p$28 = moonbitlang$core$builtin$$ToStringView$to_string_view$19$(s);
        size_hint = _tmp$28 + ((_p$28.end - _p$28.start | 0) + (separator.end - separator.start | 0) | 0) | 0;
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    size_hint = size_hint << 1;
    const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(size_hint);
    moonbitlang$core$builtin$$Logger$write_view$1$(buf, hd);
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(separator.str, 0, separator.start, separator.end)) {
      const _len$2 = _x.end - _x.start | 0;
      let _tmp$28 = 0;
      while (true) {
        const _i = _tmp$28;
        if (_i < _len$2) {
          const s = _bind[_bind$2 + _i | 0];
          const s$2 = moonbitlang$core$builtin$$ToStringView$to_string_view$19$(s);
          moonbitlang$core$builtin$$Logger$write_view$1$(buf, s$2);
          _tmp$28 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    } else {
      const _len$2 = _x.end - _x.start | 0;
      let _tmp$28 = 0;
      while (true) {
        const _i = _tmp$28;
        if (_i < _len$2) {
          const s = _bind[_bind$2 + _i | 0];
          const s$2 = moonbitlang$core$builtin$$ToStringView$to_string_view$19$(s);
          moonbitlang$core$builtin$$Logger$write_view$1$(buf, separator);
          moonbitlang$core$builtin$$Logger$write_view$1$(buf, s$2);
          _tmp$28 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
    return buf.val;
  }
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$102$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$103$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$19$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$26$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$43$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$15$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$41$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$40$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$32$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$12$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$24$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_truncate_to_length$42$(self, new_len) {
  moonbitlang$core$builtin$$JSArray$set_length(self, new_len);
}
function moonbitlang$core$array$$Array$unsafe_pop$25$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$15$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$26$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$109$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$110$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$33$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$48$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$46$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$47$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$40$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$102$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$103$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$19$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$41$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$67$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$56$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$52$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$53$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$pop$25$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$25$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$15$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$15$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$26$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$26$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$109$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$109$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$110$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$110$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$33$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$33$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$48$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$48$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$46$(self) {
  if (self.length === 0) {
    return Option$None$7$;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$46$(self);
    return new Option$Some$7$(v);
  }
}
function moonbitlang$core$array$$Array$pop$47$(self) {
  if (self.length === 0) {
    return Option$None$8$;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$47$(self);
    return new Option$Some$8$(v);
  }
}
function moonbitlang$core$array$$Array$pop$40$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$40$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$102$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$102$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$103$(self) {
  if (self.length === 0) {
    return Option$None$9$;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$103$(self);
    return new Option$Some$9$(v);
  }
}
function moonbitlang$core$array$$Array$pop$19$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$19$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$41$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$41$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$67$(self) {
  if (self.length === 0) {
    return -1;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$67$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$56$(self) {
  if (self.length === 0) {
    return Option$None$10$;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$56$(self);
    return new Option$Some$10$(v);
  }
}
function moonbitlang$core$array$$Array$pop$52$(self) {
  if (self.length === 0) {
    return Option$None$11$;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$52$(self);
    return new Option$Some$11$(v);
  }
}
function moonbitlang$core$array$$Array$pop$53$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$53$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$copy$104$(self) {
  return moonbitlang$core$builtin$$JSArray$copy(self);
}
function moonbitlang$core$array$$MutArrayView$swap$18$(arr, i, j) {
  const temp = moonbitlang$core$array$$MutArrayView$at$18$(arr, i);
  moonbitlang$core$array$$MutArrayView$set$18$(arr, i, moonbitlang$core$array$$MutArrayView$at$18$(arr, j));
  moonbitlang$core$array$$MutArrayView$set$18$(arr, j, temp);
}
function moonbitlang$core$array$$MutArrayView$slice$18$(arr, start, end) {
  return moonbitlang$core$array$$MutArrayView$mut_view$46$inner$18$(arr, start, end);
}
function moonbitlang$core$array$$MutArrayView$rev_in_place$18$(arr) {
  const len = arr.end - arr.start | 0;
  const mid_len = len / 2 | 0;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < mid_len) {
      const j = (len - i | 0) - 1 | 0;
      const temp = moonbitlang$core$array$$MutArrayView$at$18$(arr, i);
      moonbitlang$core$array$$MutArrayView$set$18$(arr, i, moonbitlang$core$array$$MutArrayView$at$18$(arr, j));
      moonbitlang$core$array$$MutArrayView$set$18$(arr, j, temp);
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_get_limit(len) {
  let len$2 = len;
  let limit = 0;
  while (true) {
    if (len$2 > 0) {
      len$2 = len$2 / 2 | 0;
      limit = limit + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return limit;
}
function moonbitlang$core$builtin$$fixed_bubble_sort_by$18$(arr, cmp) {
  const _end538 = arr.end - arr.start | 0;
  let _tmp$27 = 1;
  while (true) {
    const i = _tmp$27;
    if (i < _end538) {
      let _tmp$28 = i;
      while (true) {
        const j = _tmp$28;
        if (j > 0 && cmp(moonbitlang$core$array$$MutArrayView$at$18$(arr, j - 1 | 0), moonbitlang$core$array$$MutArrayView$at$18$(arr, j)) > 0) {
          moonbitlang$core$array$$MutArrayView$swap$18$(arr, j, j - 1 | 0);
          _tmp$28 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$1891(_env, a, b) {
  const arr = _env._2;
  const swaps = _env._1;
  const cmp = _env._0;
  if (cmp(moonbitlang$core$array$$MutArrayView$at$18$(arr, a), moonbitlang$core$array$$MutArrayView$at$18$(arr, b)) > 0) {
    moonbitlang$core$array$$MutArrayView$swap$18$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$1892(_env, a, b, c) {
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$1891(_env, a, b);
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$1891(_env, b, c);
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$1891(_env, a, b);
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$18$(arr, cmp) {
  const len = arr.end - arr.start | 0;
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: cmp, _1: swaps, _2: arr };
    if (len > 50) {
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$1892(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$1892(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$1892(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$1892(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$MutArrayView$rev_in_place$18$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$builtin$$fixed_sift_down_by$18$(arr, index, cmp) {
  let index$2 = index;
  const len = arr.end - arr.start | 0;
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$MutArrayView$at$18$(arr, child), moonbitlang$core$array$$MutArrayView$at$18$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$MutArrayView$at$18$(arr, index$2), moonbitlang$core$array$$MutArrayView$at$18$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$MutArrayView$swap$18$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_heap_sort_by$18$(arr, cmp) {
  const len = arr.end - arr.start | 0;
  let _tmp$27 = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp$27;
    if (i >= 0) {
      moonbitlang$core$builtin$$fixed_sift_down_by$18$(arr, i, cmp);
      _tmp$27 = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$28 = len - 1 | 0;
  while (true) {
    const i = _tmp$28;
    if (i > 0) {
      moonbitlang$core$array$$MutArrayView$swap$18$(arr, 0, i);
      moonbitlang$core$builtin$$fixed_sift_down_by$18$(moonbitlang$core$array$$MutArrayView$slice$18$(arr, 0, i), 0, cmp);
      _tmp$28 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_partition_by$18$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$MutArrayView$swap$18$(arr, pivot_index, (arr.end - arr.start | 0) - 1 | 0);
  const pivot = moonbitlang$core$array$$MutArrayView$at$18$(arr, (arr.end - arr.start | 0) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end527 = (arr.end - arr.start | 0) - 1 | 0;
  let _tmp$27 = 0;
  while (true) {
    const j = _tmp$27;
    if (j < _end527) {
      if (cmp(moonbitlang$core$array$$MutArrayView$at$18$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$MutArrayView$swap$18$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp$27 = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$MutArrayView$swap$18$(arr, i, (arr.end - arr.start | 0) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$builtin$$fixed_try_bubble_sort_by$18$(arr, cmp) {
  let tries = 0;
  const _end548 = arr.end - arr.start | 0;
  let _tmp$27 = 1;
  while (true) {
    const i = _tmp$27;
    if (i < _end548) {
      let sorted = true;
      let _tmp$28 = i;
      while (true) {
        const j = _tmp$28;
        if (j > 0 && cmp(moonbitlang$core$array$$MutArrayView$at$18$(arr, j - 1 | 0), moonbitlang$core$array$$MutArrayView$at$18$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$MutArrayView$swap$18$(arr, j, j - 1 | 0);
          _tmp$28 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$builtin$$fixed_quick_sort_by$18$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const _p$28 = arr$2;
    const len = _p$28.end - _p$28.start | 0;
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$builtin$$fixed_bubble_sort_by$18$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$builtin$$fixed_heap_sort_by$18$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$builtin$$fixed_choose_pivot_by$18$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$builtin$$fixed_try_bubble_sort_by$18$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$builtin$$fixed_partition_by$18$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    const _p$29 = len - _pivot | 0;
    balanced = (_pivot > _p$29 ? _p$29 : _pivot) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$MutArrayView$at$18$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$MutArrayView$at$18$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$MutArrayView$slice$18$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$MutArrayView$slice$18$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$MutArrayView$slice$18$(arr$2, _pivot + 1 | 0, len);
    if ((left.end - left.start | 0) < (right.end - right.start | 0)) {
      moonbitlang$core$builtin$$fixed_quick_sort_by$18$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$MutArrayView$at$18$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$builtin$$fixed_quick_sort_by$18$(right, cmp, moonbitlang$core$array$$MutArrayView$at$18$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$MutArrayView$sort_by$18$(self, cmp) {
  moonbitlang$core$builtin$$fixed_quick_sort_by$18$(self, cmp, undefined, moonbitlang$core$builtin$$fixed_get_limit(self.end - self.start | 0));
}
function moonbitlang$core$array$$Array$sort_by$18$(self, cmp) {
  moonbitlang$core$array$$MutArrayView$sort_by$18$(moonbitlang$core$array$$Array$mut_view$46$inner$18$(self, 0, undefined), cmp);
}
function moonbitlang$core$array$$Array$get$27$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : undefined;
}
function moonbitlang$core$array$$Array$get$26$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : undefined;
}
function moonbitlang$core$array$$Array$get$109$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : undefined;
}
function moonbitlang$core$array$$Array$get$110$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : undefined;
}
function moonbitlang$core$builtin$$Eq$equal$141$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$39$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$142$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$29$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$129$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$113$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$131$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$114$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$143$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (self[i] === other[i]) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$144$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$49$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$145$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$55$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$146$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$38$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$147$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$99$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$148$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$37$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$149$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$112$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$array$$Array$any$119$(self, f) {
  return moonbitlang$core$array$$ArrayView$any$119$({ buf: self, start: 0, end: self.length }, f);
}
function moonbitlang$core$array$$Array$clear$102$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$102$(self, 0);
}
function moonbitlang$core$array$$Array$clear$103$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$103$(self, 0);
}
function moonbitlang$core$array$$Array$clear$19$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$19$(self, 0);
}
function moonbitlang$core$array$$Array$clear$26$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$26$(self, 0);
}
function moonbitlang$core$array$$Array$clear$43$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$43$(self, 0);
}
function moonbitlang$core$array$$Array$clear$15$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$15$(self, 0);
}
function moonbitlang$core$array$$Array$clear$41$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$41$(self, 0);
}
function moonbitlang$core$array$$Array$clear$40$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$40$(self, 0);
}
function moonbitlang$core$array$$Array$clear$32$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$32$(self, 0);
}
function moonbitlang$core$array$$Array$clear$12$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$12$(self, 0);
}
function moonbitlang$core$array$$Array$clear$24$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$24$(self, 0);
}
function moonbitlang$core$array$$Array$clear$42$(self) {
  moonbitlang$core$array$$Array$unsafe_truncate_to_length$42$(self, 0);
}
function moonbitlang$core$array$$Array$contains$19$(self, value) {
  const _len = self.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const v = self[_i];
      if (v === value) {
        return true;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$array$$Array$contains$26$(self, value) {
  const _len = self.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const v = self[_i];
      if (v === value) {
        return true;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$array$$Array$resize$26$(self, new_len, f) {
  if (new_len < 0) {
    moonbitlang$core$builtin$$abort$8$("negative new length", "@moonbitlang/core/builtin:array.mbt:1192:5-1192:33");
  }
  if (new_len < self.length) {
    moonbitlang$core$array$$Array$unsafe_truncate_to_length$26$(self, new_len);
    return;
  } else {
    const len = self.length;
    let _tmp$27 = len;
    while (true) {
      const _ = _tmp$27;
      if (_ < new_len) {
        moonbitlang$core$array$$Array$push$26$(self, f);
        _tmp$27 = _ + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$Array$join$19$(self, separator) {
  return moonbitlang$core$array$$ArrayView$join$19$({ buf: self, start: 0, end: self.length }, separator);
}
function moonbitlang$core$buffer$$Buffer$grow_if_necessary(self, required) {
  const start = self.data.length <= 0 ? 1 : self.data.length;
  let enough_space;
  let _tmp$27 = start;
  while (true) {
    const space = _tmp$27;
    if (space >= required) {
      enough_space = space;
      break;
    }
    _tmp$27 = Math.imul(space, 2) | 0;
    continue;
  }
  if (enough_space !== self.data.length) {
    const new_data = $makebytes(enough_space, 0);
    moonbitlang$core$array$$FixedArray$unsafe_blit$11$(new_data, 0, self.data, 0, self.len);
    self.data = new_data;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$buffer$$Buffer$write_byte(self, value) {
  moonbitlang$core$buffer$$Buffer$grow_if_necessary(self, self.len + 1 | 0);
  const _tmp$27 = self.data;
  const _tmp$28 = self.len;
  $bound_check(_tmp$27, _tmp$28);
  _tmp$27[_tmp$28] = value;
  self.len = self.len + 1 | 0;
}
function moonbitlang$core$buffer$$new$46$inner(size_hint) {
  const initial = size_hint < 1 ? 1 : size_hint;
  const data = $makebytes(initial, 0);
  return { data: data, len: 0 };
}
function moonbitlang$core$buffer$$Buffer$write_uint64_le(self, value) {
  moonbitlang$core$buffer$$Buffer$grow_if_necessary(self, self.len + 8 | 0);
  const offset = self.len;
  const _tmp$27 = self.data;
  $bound_check(_tmp$27, offset);
  _tmp$27[offset] = moonbitlang$core$uint64$$UInt64$to_byte(value);
  const _tmp$28 = self.data;
  const _tmp$29 = offset + 1 | 0;
  $bound_check(_tmp$28, _tmp$29);
  _tmp$28[_tmp$29] = moonbitlang$core$uint64$$UInt64$to_byte(moonbitlang$core$builtin$$Shr$shr$6$(value, 8));
  const _tmp$30 = self.data;
  const _tmp$31 = offset + 2 | 0;
  $bound_check(_tmp$30, _tmp$31);
  _tmp$30[_tmp$31] = moonbitlang$core$uint64$$UInt64$to_byte(moonbitlang$core$builtin$$Shr$shr$6$(value, 16));
  const _tmp$32 = self.data;
  const _tmp$33 = offset + 3 | 0;
  $bound_check(_tmp$32, _tmp$33);
  _tmp$32[_tmp$33] = moonbitlang$core$uint64$$UInt64$to_byte(moonbitlang$core$builtin$$Shr$shr$6$(value, 24));
  const _tmp$34 = self.data;
  const _tmp$35 = offset + 4 | 0;
  $bound_check(_tmp$34, _tmp$35);
  _tmp$34[_tmp$35] = moonbitlang$core$uint64$$UInt64$to_byte(moonbitlang$core$builtin$$Shr$shr$6$(value, 32));
  const _tmp$36 = self.data;
  const _tmp$37 = offset + 5 | 0;
  $bound_check(_tmp$36, _tmp$37);
  _tmp$36[_tmp$37] = moonbitlang$core$uint64$$UInt64$to_byte(moonbitlang$core$builtin$$Shr$shr$6$(value, 40));
  const _tmp$38 = self.data;
  const _tmp$39 = offset + 6 | 0;
  $bound_check(_tmp$38, _tmp$39);
  _tmp$38[_tmp$39] = moonbitlang$core$uint64$$UInt64$to_byte(moonbitlang$core$builtin$$Shr$shr$6$(value, 48));
  const _tmp$40 = self.data;
  const _tmp$41 = offset + 7 | 0;
  $bound_check(_tmp$40, _tmp$41);
  _tmp$40[_tmp$41] = moonbitlang$core$uint64$$UInt64$to_byte(moonbitlang$core$builtin$$Shr$shr$6$(value, 56));
  self.len = self.len + 8 | 0;
}
function moonbitlang$core$buffer$$Buffer$write_uint_le(self, value) {
  moonbitlang$core$buffer$$Buffer$grow_if_necessary(self, self.len + 4 | 0);
  const offset = self.len;
  const _tmp$27 = self.data;
  $bound_check(_tmp$27, offset);
  _tmp$27[offset] = value & 255;
  const _tmp$28 = self.data;
  const _tmp$29 = offset + 1 | 0;
  const _p$28 = value >>> 8 | 0;
  $bound_check(_tmp$28, _tmp$29);
  _tmp$28[_tmp$29] = _p$28 & 255;
  const _tmp$30 = self.data;
  const _tmp$31 = offset + 2 | 0;
  const _p$29 = value >>> 16 | 0;
  $bound_check(_tmp$30, _tmp$31);
  _tmp$30[_tmp$31] = _p$29 & 255;
  const _tmp$32 = self.data;
  const _tmp$33 = offset + 3 | 0;
  const _p$30 = value >>> 24 | 0;
  $bound_check(_tmp$32, _tmp$33);
  _tmp$32[_tmp$33] = _p$30 & 255;
  self.len = self.len + 4 | 0;
}
function moonbitlang$core$buffer$$Buffer$write_int_le(self, value) {
  moonbitlang$core$buffer$$Buffer$write_uint_le(self, value);
}
function moonbitlang$core$buffer$$Buffer$write_uint16_le(self, value) {
  moonbitlang$core$buffer$$Buffer$grow_if_necessary(self, self.len + 2 | 0);
  const offset = self.len;
  const _tmp$27 = self.data;
  $bound_check(_tmp$27, offset);
  _tmp$27[offset] = value & 255;
  const _tmp$28 = self.data;
  const _tmp$29 = offset + 1 | 0;
  $bound_check(_tmp$28, _tmp$29);
  _tmp$28[_tmp$29] = value >> 8 & 255;
  self.len = self.len + 2 | 0;
}
function moonbitlang$core$buffer$$Buffer$write_bytes(self, value) {
  const val_len = value.length;
  moonbitlang$core$buffer$$Buffer$grow_if_necessary(self, self.len + val_len | 0);
  moonbitlang$core$array$$FixedArray$blit_from_bytes(self.data, self.len, value, 0, val_len);
  self.len = self.len + val_len | 0;
}
function moonbitlang$core$buffer$$Buffer$write_char_utf8(buf, value) {
  const code = value;
  if (code >>> 0 < 128 >>> 0) {
    moonbitlang$core$buffer$$Buffer$grow_if_necessary(buf, buf.len + 1 | 0);
    const _tmp$27 = buf.data;
    const _tmp$28 = buf.len;
    const _p$28 = code & 127 | 0;
    $bound_check(_tmp$27, _tmp$28);
    _tmp$27[_tmp$28] = _p$28 & 255;
    buf.len = buf.len + 1 | 0;
    return;
  } else {
    if (code >>> 0 < 2048 >>> 0) {
      moonbitlang$core$buffer$$Buffer$grow_if_necessary(buf, buf.len + 2 | 0);
      const _tmp$27 = buf.data;
      const _tmp$28 = buf.len;
      const _p$28 = code >>> 6 & 31 | 192;
      $bound_check(_tmp$27, _tmp$28);
      _tmp$27[_tmp$28] = _p$28 & 255;
      const _tmp$29 = buf.data;
      const _tmp$30 = buf.len + 1 | 0;
      const _p$29 = code & 63 | 128;
      $bound_check(_tmp$29, _tmp$30);
      _tmp$29[_tmp$30] = _p$29 & 255;
      buf.len = buf.len + 2 | 0;
      return;
    } else {
      if (code >>> 0 < 65536 >>> 0) {
        moonbitlang$core$buffer$$Buffer$grow_if_necessary(buf, buf.len + 3 | 0);
        const _tmp$27 = buf.data;
        const _tmp$28 = buf.len;
        const _p$28 = code >>> 12 & 15 | 224;
        $bound_check(_tmp$27, _tmp$28);
        _tmp$27[_tmp$28] = _p$28 & 255;
        const _tmp$29 = buf.data;
        const _tmp$30 = buf.len + 1 | 0;
        const _p$29 = code >>> 6 & 63 | 128;
        $bound_check(_tmp$29, _tmp$30);
        _tmp$29[_tmp$30] = _p$29 & 255;
        const _tmp$31 = buf.data;
        const _tmp$32 = buf.len + 2 | 0;
        const _p$30 = code & 63 | 128;
        $bound_check(_tmp$31, _tmp$32);
        _tmp$31[_tmp$32] = _p$30 & 255;
        buf.len = buf.len + 3 | 0;
        return;
      } else {
        if (code >>> 0 < 1114112 >>> 0) {
          moonbitlang$core$buffer$$Buffer$grow_if_necessary(buf, buf.len + 4 | 0);
          const _tmp$27 = buf.data;
          const _tmp$28 = buf.len;
          const _p$28 = code >>> 18 & 7 | 240;
          $bound_check(_tmp$27, _tmp$28);
          _tmp$27[_tmp$28] = _p$28 & 255;
          const _tmp$29 = buf.data;
          const _tmp$30 = buf.len + 1 | 0;
          const _p$29 = code >>> 12 & 63 | 128;
          $bound_check(_tmp$29, _tmp$30);
          _tmp$29[_tmp$30] = _p$29 & 255;
          const _tmp$31 = buf.data;
          const _tmp$32 = buf.len + 2 | 0;
          const _p$30 = code >>> 6 & 63 | 128;
          $bound_check(_tmp$31, _tmp$32);
          _tmp$31[_tmp$32] = _p$30 & 255;
          const _tmp$33 = buf.data;
          const _tmp$34 = buf.len + 3 | 0;
          const _p$31 = code & 63 | 128;
          $bound_check(_tmp$33, _tmp$34);
          _tmp$33[_tmp$34] = _p$31 & 255;
          buf.len = buf.len + 4 | 0;
          return;
        } else {
          moonbitlang$core$builtin$$abort$8$("Char out of range", "@moonbitlang/core/buffer:buffer.mbt:811:10-811:36");
          return;
        }
      }
    }
  }
}
function moonbitlang$core$buffer$$Buffer$write_string_utf8(buf, string) {
  const _it = moonbitlang$core$string$$StringView$iter(string);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$115$(_it);
    if (_bind === -1) {
      return;
    } else {
      const _Some = _bind;
      const _ch = _Some;
      moonbitlang$core$buffer$$Buffer$write_char_utf8(buf, _ch);
      continue;
    }
  }
}
function moonbitlang$core$buffer$$Buffer$to_bytes(self) {
  return moonbitlang$core$bytes$$Bytes$from_array(moonbitlang$core$array$$FixedArray$sub$46$inner$11$(self.data, 0, self.len));
}
function moonbitlang$core$buffer$$Buffer$view(self) {
  return moonbitlang$core$array$$FixedArray$sub$46$inner$11$(self.data, 0, self.len);
}
function moonbitlang$core$strconv$$base_err$150$() {
  return new Result$Err$12$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$base_err_str));
}
function moonbitlang$core$strconv$$check_and_consume_base(view, base) {
  if (base === 0) {
    _L: {
      let rest;
      _L$2: {
        let rest$2;
        _L$3: {
          let rest$3;
          _L$4: {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(view.str, 2, view.start, view.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 0, view.start, view.end));
              if (_x === 48) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 1, view.start, view.end));
                switch (_x$2) {
                  case 120: {
                    const _tmp$27 = view.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$28;
                    if (_bind === undefined) {
                      _tmp$28 = view.end;
                    } else {
                      const _Some = _bind;
                      _tmp$28 = _Some;
                    }
                    const _tmp$29 = _tmp$28;
                    const _x$3 = { str: _tmp$27, start: _tmp$29, end: view.end };
                    rest$3 = _x$3;
                    break _L$4;
                  }
                  case 88: {
                    const _tmp$30 = view.str;
                    const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$31;
                    if (_bind$2 === undefined) {
                      _tmp$31 = view.end;
                    } else {
                      const _Some = _bind$2;
                      _tmp$31 = _Some;
                    }
                    const _tmp$32 = _tmp$31;
                    const _x$4 = { str: _tmp$30, start: _tmp$32, end: view.end };
                    rest$3 = _x$4;
                    break _L$4;
                  }
                  case 111: {
                    const _tmp$33 = view.str;
                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$34;
                    if (_bind$3 === undefined) {
                      _tmp$34 = view.end;
                    } else {
                      const _Some = _bind$3;
                      _tmp$34 = _Some;
                    }
                    const _tmp$35 = _tmp$34;
                    const _x$5 = { str: _tmp$33, start: _tmp$35, end: view.end };
                    rest$2 = _x$5;
                    break _L$3;
                  }
                  case 79: {
                    const _tmp$36 = view.str;
                    const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$37;
                    if (_bind$4 === undefined) {
                      _tmp$37 = view.end;
                    } else {
                      const _Some = _bind$4;
                      _tmp$37 = _Some;
                    }
                    const _tmp$38 = _tmp$37;
                    const _x$6 = { str: _tmp$36, start: _tmp$38, end: view.end };
                    rest$2 = _x$6;
                    break _L$3;
                  }
                  case 98: {
                    const _tmp$39 = view.str;
                    const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$40;
                    if (_bind$5 === undefined) {
                      _tmp$40 = view.end;
                    } else {
                      const _Some = _bind$5;
                      _tmp$40 = _Some;
                    }
                    const _tmp$41 = _tmp$40;
                    const _x$7 = { str: _tmp$39, start: _tmp$41, end: view.end };
                    rest = _x$7;
                    break _L$2;
                  }
                  case 66: {
                    const _tmp$42 = view.str;
                    const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$43;
                    if (_bind$6 === undefined) {
                      _tmp$43 = view.end;
                    } else {
                      const _Some = _bind$6;
                      _tmp$43 = _Some;
                    }
                    const _tmp$44 = _tmp$43;
                    const _x$8 = { str: _tmp$42, start: _tmp$44, end: view.end };
                    rest = _x$8;
                    break _L$2;
                  }
                  default: {
                    break _L;
                  }
                }
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return new Result$Ok$12$({ _0: 16, _1: rest$3, _2: true });
        }
        return new Result$Ok$12$({ _0: 8, _1: rest$2, _2: true });
      }
      return new Result$Ok$12$({ _0: 2, _1: rest, _2: true });
    }
    return new Result$Ok$12$({ _0: 10, _1: view, _2: false });
  } else {
    _L: {
      let rest;
      _L$2: {
        let rest$2;
        _L$3: {
          let rest$3;
          _L$4: {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(view.str, 2, view.start, view.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 0, view.start, view.end));
              if (_x === 48) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 1, view.start, view.end));
                switch (_x$2) {
                  case 120: {
                    const _tmp$27 = view.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$28;
                    if (_bind === undefined) {
                      _tmp$28 = view.end;
                    } else {
                      const _Some = _bind;
                      _tmp$28 = _Some;
                    }
                    const _tmp$29 = _tmp$28;
                    const _x$3 = { str: _tmp$27, start: _tmp$29, end: view.end };
                    if (base === 16) {
                      rest$3 = _x$3;
                      break _L$4;
                    } else {
                      break _L;
                    }
                  }
                  case 88: {
                    const _tmp$30 = view.str;
                    const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$31;
                    if (_bind$2 === undefined) {
                      _tmp$31 = view.end;
                    } else {
                      const _Some = _bind$2;
                      _tmp$31 = _Some;
                    }
                    const _tmp$32 = _tmp$31;
                    const _x$4 = { str: _tmp$30, start: _tmp$32, end: view.end };
                    if (base === 16) {
                      rest$3 = _x$4;
                      break _L$4;
                    } else {
                      break _L;
                    }
                  }
                  case 111: {
                    const _tmp$33 = view.str;
                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$34;
                    if (_bind$3 === undefined) {
                      _tmp$34 = view.end;
                    } else {
                      const _Some = _bind$3;
                      _tmp$34 = _Some;
                    }
                    const _tmp$35 = _tmp$34;
                    const _x$5 = { str: _tmp$33, start: _tmp$35, end: view.end };
                    if (base === 8) {
                      rest$2 = _x$5;
                      break _L$3;
                    } else {
                      break _L;
                    }
                  }
                  case 79: {
                    const _tmp$36 = view.str;
                    const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$37;
                    if (_bind$4 === undefined) {
                      _tmp$37 = view.end;
                    } else {
                      const _Some = _bind$4;
                      _tmp$37 = _Some;
                    }
                    const _tmp$38 = _tmp$37;
                    const _x$6 = { str: _tmp$36, start: _tmp$38, end: view.end };
                    if (base === 8) {
                      rest$2 = _x$6;
                      break _L$3;
                    } else {
                      break _L;
                    }
                  }
                  case 98: {
                    const _tmp$39 = view.str;
                    const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$40;
                    if (_bind$5 === undefined) {
                      _tmp$40 = view.end;
                    } else {
                      const _Some = _bind$5;
                      _tmp$40 = _Some;
                    }
                    const _tmp$41 = _tmp$40;
                    const _x$7 = { str: _tmp$39, start: _tmp$41, end: view.end };
                    if (base === 2) {
                      rest = _x$7;
                      break _L$2;
                    } else {
                      break _L;
                    }
                  }
                  case 66: {
                    const _tmp$42 = view.str;
                    const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$43;
                    if (_bind$6 === undefined) {
                      _tmp$43 = view.end;
                    } else {
                      const _Some = _bind$6;
                      _tmp$43 = _Some;
                    }
                    const _tmp$44 = _tmp$43;
                    const _x$8 = { str: _tmp$42, start: _tmp$44, end: view.end };
                    if (base === 2) {
                      rest = _x$8;
                      break _L$2;
                    } else {
                      break _L;
                    }
                  }
                  default: {
                    break _L;
                  }
                }
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return new Result$Ok$12$({ _0: 16, _1: rest$3, _2: true });
        }
        return new Result$Ok$12$({ _0: 8, _1: rest$2, _2: true });
      }
      return new Result$Ok$12$({ _0: 2, _1: rest, _2: true });
    }
    return base >= 2 && base <= 36 ? new Result$Ok$12$({ _0: base, _1: view, _2: false }) : moonbitlang$core$strconv$$base_err$150$();
  }
}
function moonbitlang$core$strconv$$range_err$8$() {
  return new Result$Err$13$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$range_err$7$() {
  return new Result$Err$14$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$syntax_err$151$() {
  return new Result$Err$15$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$152$() {
  return new Result$Err$16$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$26$() {
  return new Result$Err$17$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$7$() {
  return new Result$Err$14$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$12$() {
  return new Result$Err$18$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$153$() {
  return new Result$Err$19$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$overflow_threshold(base, neg) {
  return !neg ? (base === 10 ? moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Div$div$7$($9223372036854775807L, $10L), $1L) : base === 16 ? moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Div$div$7$($9223372036854775807L, $16L), $1L) : moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Div$div$7$($9223372036854775807L, moonbitlang$core$int$$Int$to_int64(base)), $1L)) : base === 10 ? moonbitlang$core$builtin$$Div$div$7$($_9223372036854775808L, $10L) : base === 16 ? moonbitlang$core$builtin$$Div$div$7$($_9223372036854775808L, $16L) : moonbitlang$core$builtin$$Div$div$7$($_9223372036854775808L, moonbitlang$core$int$$Int$to_int64(base));
}
function moonbitlang$core$strconv$$parse_int64$46$inner(str, base) {
  if (moonbitlang$core$builtin$$Eq$not_equal$88$(str, { str: moonbitlang$core$strconv$$parse_int64$46$inner$46$42$bind$124$603, start: 0, end: moonbitlang$core$strconv$$parse_int64$46$inner$46$42$bind$124$603.length })) {
    let _bind;
    let rest;
    _L: {
      _L$2: {
        const _bind$2 = moonbitlang$core$string$$StringView$view$46$inner(str, 0, undefined);
        if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind$2.str, 1, _bind$2.start, _bind$2.end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_bind$2.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$2.str, 0, _bind$2.start, _bind$2.end));
          switch (_x) {
            case 43: {
              const _tmp$27 = _bind$2.str;
              const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$2.str, 1, _bind$2.start, _bind$2.end);
              let _tmp$28;
              if (_bind$3 === undefined) {
                _tmp$28 = _bind$2.end;
              } else {
                const _Some = _bind$3;
                _tmp$28 = _Some;
              }
              const _tmp$29 = _tmp$28;
              const _x$2 = { str: _tmp$27, start: _tmp$29, end: _bind$2.end };
              _bind = { _0: false, _1: _x$2 };
              break;
            }
            case 45: {
              const _tmp$30 = _bind$2.str;
              const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$2.str, 1, _bind$2.start, _bind$2.end);
              let _tmp$31;
              if (_bind$4 === undefined) {
                _tmp$31 = _bind$2.end;
              } else {
                const _Some = _bind$4;
                _tmp$31 = _Some;
              }
              const _tmp$32 = _tmp$31;
              const _x$3 = { str: _tmp$30, start: _tmp$32, end: _bind$2.end };
              _bind = { _0: true, _1: _x$3 };
              break;
            }
            default: {
              rest = _bind$2;
              break _L$2;
            }
          }
        } else {
          rest = _bind$2;
          break _L$2;
        }
        break _L;
      }
      _bind = { _0: false, _1: rest };
    }
    const _neg = _bind._0;
    const _rest = _bind._1;
    const _bind$2 = moonbitlang$core$strconv$$check_and_consume_base(_rest, base);
    let _bind$3;
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _bind$3 = _ok._0;
    } else {
      return _bind$2;
    }
    const _num_base = _bind$3._0;
    const _rest$2 = _bind$3._1;
    const _allow_underscore = _bind$3._2;
    const overflow_threshold = moonbitlang$core$strconv$$overflow_threshold(_num_base, _neg);
    let has_digit;
    if (moonbitlang$core$string$$String$char_length_ge$46$inner(_rest$2.str, 1, _rest$2.start, _rest$2.end)) {
      const _x = moonbitlang$core$string$$String$unsafe_char_at(_rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_rest$2.str, 0, _rest$2.start, _rest$2.end));
      if (_x >= 48 && _x <= 57) {
        has_digit = true;
      } else {
        if (_x >= 97 && _x <= 122) {
          has_digit = true;
        } else {
          if (_x >= 65 && _x <= 90) {
            has_digit = true;
          } else {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(_rest$2.str, 2, _rest$2.start, _rest$2.end)) {
              if (_x === 95) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_rest$2.str, 1, _rest$2.start, _rest$2.end));
                has_digit = _x$2 >= 48 && _x$2 <= 57 ? true : _x$2 >= 97 && _x$2 <= 122 ? true : _x$2 >= 65 && _x$2 <= 90;
              } else {
                has_digit = false;
              }
            } else {
              has_digit = false;
            }
          }
        }
      }
    } else {
      has_digit = false;
    }
    if (has_digit) {
      let _tmp$27;
      let _tmp$28 = _rest$2;
      let _tmp$29 = $0L;
      let _tmp$30 = _allow_underscore;
      while (true) {
        const _param_0 = _tmp$28;
        const _param_1 = _tmp$29;
        const _param_2 = _tmp$30;
        let acc;
        let rest$2;
        let c;
        _L$2: {
          if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param_0.str, 1, _param_0.start, _param_0.end)) {
            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_0.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 0, _param_0.start, _param_0.end));
            if (_x === 95) {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$7$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp$27 = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            } else {
              const _tmp$31 = _param_0.str;
              const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
              let _tmp$32;
              if (_bind$4 === undefined) {
                _tmp$32 = _param_0.end;
              } else {
                const _Some = _bind$4;
                _tmp$32 = _Some;
              }
              const _tmp$33 = _tmp$32;
              const _x$2 = { str: _tmp$31, start: _tmp$33, end: _param_0.end };
              acc = _param_1;
              rest$2 = _x$2;
              c = _x;
              break _L$2;
            }
          } else {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(_param_0.str, 1, _param_0.start, _param_0.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_0.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 0, _param_0.start, _param_0.end));
              if (_x === 95) {
                if (_param_2 === false) {
                  const _bind$4 = moonbitlang$core$strconv$$syntax_err$7$();
                  if (_bind$4.$tag === 1) {
                    const _ok = _bind$4;
                    _tmp$27 = _ok._0;
                    break;
                  } else {
                    return _bind$4;
                  }
                } else {
                  const _tmp$31 = _param_0.str;
                  const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
                  let _tmp$32;
                  if (_bind$4 === undefined) {
                    _tmp$32 = _param_0.end;
                  } else {
                    const _Some = _bind$4;
                    _tmp$32 = _Some;
                  }
                  const _tmp$33 = _tmp$32;
                  const _x$2 = { str: _tmp$31, start: _tmp$33, end: _param_0.end };
                  _tmp$28 = _x$2;
                  _tmp$30 = false;
                  continue;
                }
              } else {
                const _tmp$31 = _param_0.str;
                const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
                let _tmp$32;
                if (_bind$4 === undefined) {
                  _tmp$32 = _param_0.end;
                } else {
                  const _Some = _bind$4;
                  _tmp$32 = _Some;
                }
                const _tmp$33 = _tmp$32;
                const _x$2 = { str: _tmp$31, start: _tmp$33, end: _param_0.end };
                acc = _param_1;
                rest$2 = _x$2;
                c = _x;
                break _L$2;
              }
            } else {
              _tmp$27 = _param_1;
              break;
            }
          }
        }
        const c$2 = c;
        let d;
        if (c$2 >= 48 && c$2 <= 57) {
          d = c$2 - 48 | 0;
        } else {
          if (c$2 >= 97 && c$2 <= 122) {
            d = c$2 + -87 | 0;
          } else {
            if (c$2 >= 65 && c$2 <= 90) {
              d = c$2 + -55 | 0;
            } else {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$26$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                d = _ok._0;
              } else {
                return _bind$4;
              }
            }
          }
        }
        if (d < _num_base) {
          if (_neg) {
            if (moonbitlang$core$builtin$$Compare$op_ge$81$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$builtin$$Sub$sub$7$(moonbitlang$core$builtin$$Mul$mul$7$(acc, moonbitlang$core$int$$Int$to_int64(_num_base)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$Compare$op_le$81$(next_acc, acc)) {
                _tmp$28 = rest$2;
                _tmp$29 = next_acc;
                _tmp$30 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$7$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp$27 = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$7$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp$27 = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          } else {
            if (moonbitlang$core$builtin$$Compare$op_lt$81$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Mul$mul$7$(acc, moonbitlang$core$int$$Int$to_int64(_num_base)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$Compare$op_ge$81$(next_acc, acc)) {
                _tmp$28 = rest$2;
                _tmp$29 = next_acc;
                _tmp$30 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$7$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp$27 = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$7$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp$27 = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          }
        } else {
          const _bind$4 = moonbitlang$core$strconv$$syntax_err$7$();
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _tmp$27 = _ok._0;
            break;
          } else {
            return _bind$4;
          }
        }
      }
      return new Result$Ok$14$(_tmp$27);
    } else {
      return moonbitlang$core$strconv$$syntax_err$7$();
    }
  } else {
    return moonbitlang$core$strconv$$syntax_err$7$();
  }
}
function moonbitlang$core$strconv$$parse_int$46$inner(str, base) {
  const _bind = moonbitlang$core$strconv$$parse_int64$46$inner(str, base);
  let n;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    n = _ok._0;
  } else {
    return _bind;
  }
  if (moonbitlang$core$builtin$$Compare$op_lt$81$(n, moonbitlang$core$int$$Int$to_int64(-2147483648)) || moonbitlang$core$builtin$$Compare$op_gt$81$(n, moonbitlang$core$int$$Int$to_int64(2147483647))) {
    const _bind$2 = moonbitlang$core$strconv$$range_err$8$();
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
  }
  return new Result$Ok$17$(moonbitlang$core$int64$$Int64$to_int(n));
}
function moonbitlang$core$strconv$$check_underscore(str) {
  let rest;
  if (moonbitlang$core$string$$String$char_length_ge$46$inner(str.str, 1, str.start, str.end)) {
    const _x = moonbitlang$core$string$$String$unsafe_char_at(str.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(str.str, 0, str.start, str.end));
    switch (_x) {
      case 43: {
        const _tmp$27 = str.str;
        const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(str.str, 1, str.start, str.end);
        let _tmp$28;
        if (_bind === undefined) {
          _tmp$28 = str.end;
        } else {
          const _Some = _bind;
          _tmp$28 = _Some;
        }
        const _tmp$29 = _tmp$28;
        const _x$2 = { str: _tmp$27, start: _tmp$29, end: str.end };
        rest = _x$2;
        break;
      }
      case 45: {
        const _tmp$30 = str.str;
        const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(str.str, 1, str.start, str.end);
        let _tmp$31;
        if (_bind$2 === undefined) {
          _tmp$31 = str.end;
        } else {
          const _Some = _bind$2;
          _tmp$31 = _Some;
        }
        const _tmp$32 = _tmp$31;
        const _x$3 = { str: _tmp$30, start: _tmp$32, end: str.end };
        rest = _x$3;
        break;
      }
      default: {
        rest = str;
      }
    }
  } else {
    rest = str;
  }
  const _data = rest.str;
  const _start = rest.start;
  const _end = _start + (rest.end - rest.start | 0) | 0;
  let _cursor = _start;
  let accept_state = -1;
  let match_end = -1;
  let _bind;
  _L: {
    if ((_cursor + 1 | 0) < _end) {
      const _p$28 = _cursor;
      const next_char = _data.charCodeAt(_p$28);
      _cursor = _cursor + 1 | 0;
      if (next_char < 49) {
        if (next_char < 48) {
          break _L;
        } else {
          _L$2: {
            _L$3: {
              _L$4: {
                const _p$29 = _cursor;
                const next_char$2 = _data.charCodeAt(_p$29);
                _cursor = _cursor + 1 | 0;
                if (next_char$2 < 98) {
                  if (next_char$2 < 79) {
                    if (next_char$2 < 66) {
                      break _L;
                    } else {
                      if (next_char$2 > 66) {
                        break _L;
                      } else {
                        break _L$2;
                      }
                    }
                  } else {
                    if (next_char$2 > 79) {
                      if (next_char$2 < 88) {
                        break _L;
                      } else {
                        if (next_char$2 > 88) {
                          break _L;
                        } else {
                          break _L$4;
                        }
                      }
                    } else {
                      break _L$3;
                    }
                  }
                } else {
                  if (next_char$2 > 98) {
                    if (next_char$2 < 120) {
                      if (next_char$2 < 111) {
                        break _L;
                      } else {
                        if (next_char$2 > 111) {
                          break _L;
                        } else {
                          break _L$3;
                        }
                      }
                    } else {
                      if (next_char$2 > 120) {
                        break _L;
                      } else {
                        break _L$4;
                      }
                    }
                  } else {
                    break _L$2;
                  }
                }
              }
              accept_state = 2;
              match_end = _cursor;
              break _L;
            }
            accept_state = 1;
            match_end = _cursor;
            break _L;
          }
          accept_state = 0;
          match_end = _cursor;
          break _L;
        }
      } else {
        break _L;
      }
    } else {
      break _L;
    }
  }
  switch (accept_state) {
    case 2: {
      let rest$2;
      let _try_err;
      _L$2: {
        _L$3: {
          const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_end, _end);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            rest$2 = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp$27 = _err._0;
            _try_err = _tmp$27;
            break _L$3;
          }
          break _L$2;
        }
        rest$2 = $panic();
      }
      _bind = { _0: rest$2, _1: true, _2: true };
      break;
    }
    case 1: {
      let rest$3;
      let _try_err$2;
      _L$3: {
        _L$4: {
          const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_end, _end);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            rest$3 = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp$27 = _err._0;
            _try_err$2 = _tmp$27;
            break _L$4;
          }
          break _L$3;
        }
        rest$3 = $panic();
      }
      _bind = { _0: rest$3, _1: true, _2: false };
      break;
    }
    case 0: {
      let rest$4;
      let _try_err$3;
      _L$4: {
        _L$5: {
          const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_end, _end);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            rest$4 = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp$27 = _err._0;
            _try_err$3 = _tmp$27;
            break _L$5;
          }
          break _L$4;
        }
        rest$4 = $panic();
      }
      _bind = { _0: rest$4, _1: true, _2: false };
      break;
    }
    default: {
      _bind = { _0: rest, _1: false, _2: false };
    }
  }
  const _rest = _bind._0;
  const _allow_underscore = _bind._1;
  const _hex = _bind._2;
  let _tmp$27 = _rest;
  let _tmp$28 = _allow_underscore;
  let _tmp$29 = false;
  while (true) {
    const _param_0 = _tmp$27;
    const _param_1 = _tmp$28;
    const _param_2 = _tmp$29;
    let rest$5;
    let c;
    let follow_underscore;
    _L$5: {
      if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param_0.str, 0, _param_0.start, _param_0.end)) {
        return true;
      } else {
        if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param_0.str, 1, _param_0.start, _param_0.end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_0.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 0, _param_0.start, _param_0.end));
          if (_x === 95) {
            return false;
          } else {
            const _tmp$30 = _param_0.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
            let _tmp$31;
            if (_bind$2 === undefined) {
              _tmp$31 = _param_0.end;
            } else {
              const _Some = _bind$2;
              _tmp$31 = _Some;
            }
            const _tmp$32 = _tmp$31;
            const _x$2 = { str: _tmp$30, start: _tmp$32, end: _param_0.end };
            rest$5 = _x$2;
            c = _x;
            follow_underscore = _param_2;
            break _L$5;
          }
        } else {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_0.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 0, _param_0.start, _param_0.end));
          if (_x === 95) {
            if (_param_1 === false) {
              return false;
            } else {
              const _tmp$30 = _param_0.str;
              const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
              let _tmp$31;
              if (_bind$2 === undefined) {
                _tmp$31 = _param_0.end;
              } else {
                const _Some = _bind$2;
                _tmp$31 = _Some;
              }
              const _tmp$32 = _tmp$31;
              const _x$2 = { str: _tmp$30, start: _tmp$32, end: _param_0.end };
              _tmp$27 = _x$2;
              _tmp$28 = false;
              _tmp$29 = true;
              continue;
            }
          } else {
            const _tmp$30 = _param_0.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
            let _tmp$31;
            if (_bind$2 === undefined) {
              _tmp$31 = _param_0.end;
            } else {
              const _Some = _bind$2;
              _tmp$31 = _Some;
            }
            const _tmp$32 = _tmp$31;
            const _x$2 = { str: _tmp$30, start: _tmp$32, end: _param_0.end };
            rest$5 = _x$2;
            c = _x;
            follow_underscore = _param_2;
            break _L$5;
          }
        }
      }
    }
    if (c >= 48 && c <= 57 ? true : _hex && (c >= 97 && c <= 102 ? true : c >= 65 && c <= 70)) {
      _tmp$27 = rest$5;
      _tmp$28 = true;
      _tmp$29 = false;
      continue;
    } else {
      if (follow_underscore) {
        return false;
      } else {
        _tmp$27 = rest$5;
        _tmp$28 = false;
        _tmp$29 = false;
        continue;
      }
    }
  }
}
function moonbitlang$core$strconv$$Decimal$new_priv() {
  return { digits: $makebytes(800, 0), digits_num: 0, decimal_point: 0, negative: false, truncated: false };
}
function moonbitlang$core$strconv$$Decimal$trim(self) {
  while (true) {
    let _tmp$27;
    if (self.digits_num > 0) {
      const _tmp$28 = self.digits;
      const _tmp$29 = self.digits_num - 1 | 0;
      $bound_check(_tmp$28, _tmp$29);
      const _p$28 = _tmp$28[_tmp$29];
      const _p$29 = 0;
      _tmp$27 = _p$28 === _p$29;
    } else {
      _tmp$27 = false;
    }
    if (_tmp$27) {
      self.digits_num = self.digits_num - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (self.digits_num === 0) {
    self.decimal_point = 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$strconv$$parse_decimal_from_view(str) {
  const d = moonbitlang$core$strconv$$Decimal$new_priv();
  let has_dp = false;
  let has_digits = false;
  let rest;
  _L: {
    _L$2: {
      if (moonbitlang$core$string$$String$char_length_ge$46$inner(str.str, 1, str.start, str.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(str.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(str.str, 0, str.start, str.end));
        switch (_x) {
          case 45: {
            const _tmp$27 = str.str;
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(str.str, 1, str.start, str.end);
            let _tmp$28;
            if (_bind === undefined) {
              _tmp$28 = str.end;
            } else {
              const _Some = _bind;
              _tmp$28 = _Some;
            }
            const _tmp$29 = _tmp$28;
            const _x$2 = { str: _tmp$27, start: _tmp$29, end: str.end };
            d.negative = true;
            rest = _x$2;
            break;
          }
          case 43: {
            const _tmp$30 = str.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(str.str, 1, str.start, str.end);
            let _tmp$31;
            if (_bind$2 === undefined) {
              _tmp$31 = str.end;
            } else {
              const _Some = _bind$2;
              _tmp$31 = _Some;
            }
            const _tmp$32 = _tmp$31;
            rest = { str: _tmp$30, start: _tmp$32, end: str.end };
            break;
          }
          default: {
            break _L$2;
          }
        }
      } else {
        break _L$2;
      }
      break _L;
    }
    rest = str;
  }
  let rest$2;
  let _tmp$27 = rest;
  while (true) {
    const _param = _tmp$27;
    if (moonbitlang$core$string$$String$char_length_ge$46$inner(_param.str, 1, _param.start, _param.end)) {
      const _x = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 0, _param.start, _param.end));
      if (_x === 95) {
        const _tmp$28 = _param.str;
        const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
        let _tmp$29;
        if (_bind === undefined) {
          _tmp$29 = _param.end;
        } else {
          const _Some = _bind;
          _tmp$29 = _Some;
        }
        const _tmp$30 = _tmp$29;
        const _x$2 = { str: _tmp$28, start: _tmp$30, end: _param.end };
        _tmp$27 = _x$2;
        continue;
      } else {
        if (_x === 46) {
          const _tmp$28 = _param.str;
          const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
          let _tmp$29;
          if (_bind === undefined) {
            _tmp$29 = _param.end;
          } else {
            const _Some = _bind;
            _tmp$29 = _Some;
          }
          const _tmp$30 = _tmp$29;
          const _x$2 = { str: _tmp$28, start: _tmp$30, end: _param.end };
          if (!has_dp) {
            has_dp = true;
            d.decimal_point = d.digits_num;
            _tmp$27 = _x$2;
            continue;
          } else {
            const _bind$2 = moonbitlang$core$strconv$$syntax_err$12$();
            if (_bind$2.$tag === 1) {
              const _ok = _bind$2;
              rest$2 = _ok._0;
              break;
            } else {
              return _bind$2;
            }
          }
        } else {
          if (_x >= 48 && _x <= 57) {
            const _tmp$28 = _param.str;
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
            let _tmp$29;
            if (_bind === undefined) {
              _tmp$29 = _param.end;
            } else {
              const _Some = _bind;
              _tmp$29 = _Some;
            }
            const _tmp$30 = _tmp$29;
            const _x$2 = { str: _tmp$28, start: _tmp$30, end: _param.end };
            has_digits = true;
            if (_x === 48 && d.digits_num === 0) {
              d.decimal_point = d.decimal_point - 1 | 0;
              _tmp$27 = _x$2;
              continue;
            }
            if (d.digits_num < d.digits.length) {
              const _tmp$31 = d.digits;
              const _tmp$32 = d.digits_num;
              $bound_check(_tmp$31, _tmp$32);
              _tmp$31[_tmp$32] = (_x - 48 | 0) & 255;
              d.digits_num = d.digits_num + 1 | 0;
            } else {
              if (_x !== 48) {
                d.truncated = true;
              }
            }
            _tmp$27 = _x$2;
            continue;
          } else {
            rest$2 = _param;
            break;
          }
        }
      }
    } else {
      rest$2 = _param;
      break;
    }
  }
  if (has_digits) {
    if (!has_dp) {
      d.decimal_point = d.digits_num;
    }
    let rest$3;
    let rest$4;
    _L$2: {
      _L$3: {
        if (moonbitlang$core$string$$String$char_length_ge$46$inner(rest$2.str, 1, rest$2.start, rest$2.end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest$2.str, 0, rest$2.start, rest$2.end));
          switch (_x) {
            case 101: {
              const _tmp$28 = rest$2.str;
              const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest$2.str, 1, rest$2.start, rest$2.end);
              let _tmp$29;
              if (_bind === undefined) {
                _tmp$29 = rest$2.end;
              } else {
                const _Some = _bind;
                _tmp$29 = _Some;
              }
              const _tmp$30 = _tmp$29;
              const _x$2 = { str: _tmp$28, start: _tmp$30, end: rest$2.end };
              rest$4 = _x$2;
              break _L$3;
            }
            case 69: {
              const _tmp$31 = rest$2.str;
              const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest$2.str, 1, rest$2.start, rest$2.end);
              let _tmp$32;
              if (_bind$2 === undefined) {
                _tmp$32 = rest$2.end;
              } else {
                const _Some = _bind$2;
                _tmp$32 = _Some;
              }
              const _tmp$33 = _tmp$32;
              const _x$3 = { str: _tmp$31, start: _tmp$33, end: rest$2.end };
              rest$4 = _x$3;
              break _L$3;
            }
            default: {
              rest$3 = rest$2;
            }
          }
        } else {
          rest$3 = rest$2;
        }
        break _L$2;
      }
      let exp_sign = 1;
      let rest$5;
      if (moonbitlang$core$string$$String$char_length_ge$46$inner(rest$4.str, 1, rest$4.start, rest$4.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(rest$4.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest$4.str, 0, rest$4.start, rest$4.end));
        switch (_x) {
          case 43: {
            const _tmp$28 = rest$4.str;
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest$4.str, 1, rest$4.start, rest$4.end);
            let _tmp$29;
            if (_bind === undefined) {
              _tmp$29 = rest$4.end;
            } else {
              const _Some = _bind;
              _tmp$29 = _Some;
            }
            const _tmp$30 = _tmp$29;
            rest$5 = { str: _tmp$28, start: _tmp$30, end: rest$4.end };
            break;
          }
          case 45: {
            const _tmp$31 = rest$4.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest$4.str, 1, rest$4.start, rest$4.end);
            let _tmp$32;
            if (_bind$2 === undefined) {
              _tmp$32 = rest$4.end;
            } else {
              const _Some = _bind$2;
              _tmp$32 = _Some;
            }
            const _tmp$33 = _tmp$32;
            const _x$2 = { str: _tmp$31, start: _tmp$33, end: rest$4.end };
            exp_sign = -1;
            rest$5 = _x$2;
            break;
          }
          default: {
            rest$5 = rest$4;
          }
        }
      } else {
        rest$5 = rest$4;
      }
      _L$4: {
        _L$5: {
          if (moonbitlang$core$string$$String$char_length_ge$46$inner(rest$5.str, 1, rest$5.start, rest$5.end)) {
            const _x = moonbitlang$core$string$$String$unsafe_char_at(rest$5.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest$5.str, 0, rest$5.start, rest$5.end));
            if (_x >= 48 && _x <= 57) {
              let exp = 0;
              let rest$6;
              let _tmp$28 = rest$5;
              while (true) {
                const _param = _tmp$28;
                if (moonbitlang$core$string$$String$char_length_ge$46$inner(_param.str, 1, _param.start, _param.end)) {
                  const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 0, _param.start, _param.end));
                  if (_x$2 === 95) {
                    const _tmp$29 = _param.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
                    let _tmp$30;
                    if (_bind === undefined) {
                      _tmp$30 = _param.end;
                    } else {
                      const _Some = _bind;
                      _tmp$30 = _Some;
                    }
                    const _tmp$31 = _tmp$30;
                    const _x$3 = { str: _tmp$29, start: _tmp$31, end: _param.end };
                    _tmp$28 = _x$3;
                    continue;
                  } else {
                    if (_x$2 >= 48 && _x$2 <= 57) {
                      const _tmp$29 = _param.str;
                      const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
                      let _tmp$30;
                      if (_bind === undefined) {
                        _tmp$30 = _param.end;
                      } else {
                        const _Some = _bind;
                        _tmp$30 = _Some;
                      }
                      const _tmp$31 = _tmp$30;
                      const _x$3 = { str: _tmp$29, start: _tmp$31, end: _param.end };
                      exp = (Math.imul(exp, 10) | 0) + (_x$2 - 48 | 0) | 0;
                      _tmp$28 = _x$3;
                      continue;
                    } else {
                      rest$6 = _param;
                      break;
                    }
                  }
                } else {
                  rest$6 = _param;
                  break;
                }
              }
              d.decimal_point = d.decimal_point + (Math.imul(exp_sign, exp) | 0) | 0;
              rest$3 = rest$6;
            } else {
              break _L$5;
            }
          } else {
            break _L$5;
          }
          break _L$4;
        }
        const _bind = moonbitlang$core$strconv$$syntax_err$12$();
        if (_bind.$tag === 1) {
          const _ok = _bind;
          rest$3 = _ok._0;
        } else {
          return _bind;
        }
      }
    }
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(rest$3.str, 0, rest$3.start, rest$3.end)) {
      moonbitlang$core$strconv$$Decimal$trim(d);
      return new Result$Ok$19$(d);
    } else {
      return moonbitlang$core$strconv$$syntax_err$153$();
    }
  } else {
    return moonbitlang$core$strconv$$syntax_err$153$();
  }
}
function moonbitlang$core$strconv$$parse_decimal_priv(str) {
  return moonbitlang$core$strconv$$parse_decimal_from_view(str);
}
function moonbitlang$core$strconv$$parse_inf_nan(rest) {
  let _bind;
  let rest$2;
  _L: {
    _L$2: {
      if (moonbitlang$core$string$$String$char_length_ge$46$inner(rest.str, 1, rest.start, rest.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(rest.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest.str, 0, rest.start, rest.end));
        switch (_x) {
          case 45: {
            const _tmp$27 = rest.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest.str, 1, rest.start, rest.end);
            let _tmp$28;
            if (_bind$2 === undefined) {
              _tmp$28 = rest.end;
            } else {
              const _Some = _bind$2;
              _tmp$28 = _Some;
            }
            const _tmp$29 = _tmp$28;
            const _x$2 = { str: _tmp$27, start: _tmp$29, end: rest.end };
            _bind = { _0: false, _1: _x$2 };
            break;
          }
          case 43: {
            const _tmp$30 = rest.str;
            const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(rest.str, 1, rest.start, rest.end);
            let _tmp$31;
            if (_bind$3 === undefined) {
              _tmp$31 = rest.end;
            } else {
              const _Some = _bind$3;
              _tmp$31 = _Some;
            }
            const _tmp$32 = _tmp$31;
            const _x$3 = { str: _tmp$30, start: _tmp$32, end: rest.end };
            rest$2 = _x$3;
            break _L$2;
          }
          default: {
            rest$2 = rest;
            break _L$2;
          }
        }
      } else {
        rest$2 = rest;
        break _L$2;
      }
      break _L;
    }
    _bind = { _0: true, _1: rest$2 };
  }
  const _pos = _bind._0;
  const _rest = _bind._1;
  const _data = _rest.str;
  const _start = _rest.start;
  const _end = _start + (_rest.end - _rest.start | 0) | 0;
  let _cursor = _start;
  let accept_state = -1;
  let match_end = -1;
  _L$2: {
    _L$3: {
      if ((_cursor + 2 | 0) < _end) {
        _L$4: {
          _L$5: {
            const _p$28 = _cursor;
            const next_char = _data.charCodeAt(_p$28);
            _cursor = _cursor + 1 | 0;
            if (next_char < 105) {
              if (next_char < 74) {
                if (next_char < 73) {
                  break _L$2;
                } else {
                  break _L$4;
                }
              } else {
                if (next_char > 77) {
                  if (next_char < 79) {
                    break _L$5;
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
              }
            } else {
              if (next_char > 105) {
                if (next_char < 111) {
                  if (next_char < 110) {
                    break _L$2;
                  } else {
                    break _L$5;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$4;
              }
            }
          }
          _L$6: {
            const _p$28 = _cursor;
            const next_char = _data.charCodeAt(_p$28);
            _cursor = _cursor + 1 | 0;
            if (next_char < 97) {
              if (next_char < 65) {
                break _L$2;
              } else {
                if (next_char > 65) {
                  break _L$2;
                } else {
                  break _L$6;
                }
              }
            } else {
              if (next_char > 97) {
                break _L$2;
              } else {
                break _L$6;
              }
            }
          }
          _L$7: {
            const _p$28 = _cursor;
            const next_char = _data.charCodeAt(_p$28);
            _cursor = _cursor + 1 | 0;
            if (next_char < 110) {
              if (next_char < 78) {
                break _L$2;
              } else {
                if (next_char > 78) {
                  break _L$2;
                } else {
                  break _L$7;
                }
              }
            } else {
              if (next_char > 110) {
                break _L$2;
              } else {
                break _L$7;
              }
            }
          }
          if (_cursor < _end) {
            break _L$2;
          } else {
            accept_state = 0;
            match_end = _cursor;
            break _L$2;
          }
        }
        _L$5: {
          const _p$28 = _cursor;
          const next_char = _data.charCodeAt(_p$28);
          _cursor = _cursor + 1 | 0;
          if (next_char < 110) {
            if (next_char < 78) {
              break _L$2;
            } else {
              if (next_char > 78) {
                break _L$2;
              } else {
                break _L$5;
              }
            }
          } else {
            if (next_char > 110) {
              break _L$2;
            } else {
              break _L$5;
            }
          }
        }
        _L$6: {
          const _p$28 = _cursor;
          const next_char = _data.charCodeAt(_p$28);
          _cursor = _cursor + 1 | 0;
          if (next_char < 102) {
            if (next_char < 70) {
              break _L$2;
            } else {
              if (next_char > 70) {
                break _L$2;
              } else {
                break _L$6;
              }
            }
          } else {
            if (next_char > 102) {
              break _L$2;
            } else {
              break _L$6;
            }
          }
        }
        if (_cursor < _end) {
          _L$7: {
            const _p$28 = _cursor;
            const next_char = _data.charCodeAt(_p$28);
            _cursor = _cursor + 1 | 0;
            if (next_char < 105) {
              if (next_char < 73) {
                break _L$2;
              } else {
                if (next_char > 73) {
                  break _L$2;
                } else {
                  break _L$7;
                }
              }
            } else {
              if (next_char > 105) {
                break _L$2;
              } else {
                break _L$7;
              }
            }
          }
          if ((_cursor + 3 | 0) < _end) {
            _L$8: {
              const _p$28 = _cursor;
              const next_char = _data.charCodeAt(_p$28);
              _cursor = _cursor + 1 | 0;
              if (next_char < 110) {
                if (next_char < 78) {
                  break _L$2;
                } else {
                  if (next_char > 78) {
                    break _L$2;
                  } else {
                    break _L$8;
                  }
                }
              } else {
                if (next_char > 110) {
                  break _L$2;
                } else {
                  break _L$8;
                }
              }
            }
            _L$9: {
              const _p$28 = _cursor;
              const next_char = _data.charCodeAt(_p$28);
              _cursor = _cursor + 1 | 0;
              if (next_char < 105) {
                if (next_char < 73) {
                  break _L$2;
                } else {
                  if (next_char > 73) {
                    break _L$2;
                  } else {
                    break _L$9;
                  }
                }
              } else {
                if (next_char > 105) {
                  break _L$2;
                } else {
                  break _L$9;
                }
              }
            }
            _L$10: {
              const _p$28 = _cursor;
              const next_char = _data.charCodeAt(_p$28);
              _cursor = _cursor + 1 | 0;
              if (next_char < 116) {
                if (next_char < 84) {
                  break _L$2;
                } else {
                  if (next_char > 84) {
                    break _L$2;
                  } else {
                    break _L$10;
                  }
                }
              } else {
                if (next_char > 116) {
                  break _L$2;
                } else {
                  break _L$10;
                }
              }
            }
            _L$11: {
              const _p$28 = _cursor;
              const next_char = _data.charCodeAt(_p$28);
              _cursor = _cursor + 1 | 0;
              if (next_char < 121) {
                if (next_char < 89) {
                  break _L$2;
                } else {
                  if (next_char > 89) {
                    break _L$2;
                  } else {
                    break _L$11;
                  }
                }
              } else {
                if (next_char > 121) {
                  break _L$2;
                } else {
                  break _L$11;
                }
              }
            }
            if (_cursor < _end) {
              break _L$2;
            } else {
              break _L$3;
            }
          } else {
            break _L$2;
          }
        } else {
          break _L$3;
        }
      } else {
        break _L$2;
      }
    }
    accept_state = 1;
    match_end = _cursor;
    break _L$2;
  }
  switch (accept_state) {
    case 0: {
      return new Result$Ok$15$(moonbitlang$core$double$$not_a_number);
    }
    case 1: {
      return _pos ? new Result$Ok$15$(moonbitlang$core$double$$infinity) : new Result$Ok$15$(moonbitlang$core$double$$neg_infinity);
    }
    default: {
      return moonbitlang$core$strconv$$syntax_err$151$();
    }
  }
}
function $moonbitlang$core$strconv$$moonbitlang$core$string$$StringView$fold_digits$6$(self, init, f) {
  let ret = init;
  let len = 0;
  let str = self;
  while (true) {
    const _bind = str;
    if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind.str, 1, _bind.start, _bind.end)) {
      const _ch = moonbitlang$core$string$$String$unsafe_char_at(_bind.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 0, _bind.start, _bind.end));
      const _tmp$27 = _bind.str;
      const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 1, _bind.start, _bind.end);
      let _tmp$28;
      if (_bind$2 === undefined) {
        _tmp$28 = _bind.end;
      } else {
        const _Some = _bind$2;
        _tmp$28 = _Some;
      }
      const _tmp$29 = _tmp$28;
      const _x = { str: _tmp$27, start: _tmp$29, end: _bind.end };
      if (_ch >= 48 && _ch <= 57) {
        len = len + 1 | 0;
        ret = f(_ch - 48 | 0, ret);
      } else {
        if (_ch !== 95) {
          break;
        }
      }
      str = _x;
      continue;
    } else {
      break;
    }
  }
  return { _0: str, _1: ret, _2: len };
}
function $moonbitlang$core$strconv$$moonbitlang$core$string$$StringView$fold_digits$7$(self, init, f) {
  let ret = init;
  let len = 0;
  let str = self;
  while (true) {
    const _bind = str;
    if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind.str, 1, _bind.start, _bind.end)) {
      const _ch = moonbitlang$core$string$$String$unsafe_char_at(_bind.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 0, _bind.start, _bind.end));
      const _tmp$27 = _bind.str;
      const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 1, _bind.start, _bind.end);
      let _tmp$28;
      if (_bind$2 === undefined) {
        _tmp$28 = _bind.end;
      } else {
        const _Some = _bind$2;
        _tmp$28 = _Some;
      }
      const _tmp$29 = _tmp$28;
      const _x = { str: _tmp$27, start: _tmp$29, end: _bind.end };
      if (_ch >= 48 && _ch <= 57) {
        len = len + 1 | 0;
        ret = f(_ch - 48 | 0, ret);
      } else {
        if (_ch !== 95) {
          break;
        }
      }
      str = _x;
      continue;
    } else {
      break;
    }
  }
  return { _0: str, _1: ret, _2: len };
}
function moonbitlang$core$strconv$$parse_digits(s, x) {
  return $moonbitlang$core$strconv$$moonbitlang$core$string$$StringView$fold_digits$6$(s, x, (digit, acc) => moonbitlang$core$builtin$$Add$add$6$(moonbitlang$core$builtin$$Mul$mul$6$(acc, $10L), moonbitlang$core$uint64$$UInt64$extend_uint(digit)));
}
function moonbitlang$core$strconv$$parse_scientific(s) {
  let s$2 = s;
  let neg_exp = false;
  let rest;
  let ch;
  _L: {
    _L$2: {
      const _bind = s$2;
      if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind.str, 1, _bind.start, _bind.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(_bind.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 0, _bind.start, _bind.end));
        switch (_x) {
          case 43: {
            const _tmp$27 = _bind.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 1, _bind.start, _bind.end);
            let _tmp$28;
            if (_bind$2 === undefined) {
              _tmp$28 = _bind.end;
            } else {
              const _Some = _bind$2;
              _tmp$28 = _Some;
            }
            const _tmp$29 = _tmp$28;
            const _x$2 = { str: _tmp$27, start: _tmp$29, end: _bind.end };
            rest = _x$2;
            ch = _x;
            break _L$2;
          }
          case 45: {
            const _tmp$30 = _bind.str;
            const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 1, _bind.start, _bind.end);
            let _tmp$31;
            if (_bind$3 === undefined) {
              _tmp$31 = _bind.end;
            } else {
              const _Some = _bind$3;
              _tmp$31 = _Some;
            }
            const _tmp$32 = _tmp$31;
            const _x$3 = { str: _tmp$30, start: _tmp$32, end: _bind.end };
            rest = _x$3;
            ch = _x;
            break _L$2;
          }
        }
      }
      break _L;
    }
    neg_exp = ch === 45;
    s$2 = rest;
  }
  _L$2: {
    const _bind = s$2;
    if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind.str, 1, _bind.start, _bind.end)) {
      const _x = moonbitlang$core$string$$String$unsafe_char_at(_bind.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind.str, 0, _bind.start, _bind.end));
      if (_x >= 48 && _x <= 57) {
        const _bind$2 = $moonbitlang$core$strconv$$moonbitlang$core$string$$StringView$fold_digits$7$(s$2, moonbitlang$core$strconv$$parse_scientific$46$exp_num$124$279, (digit, exp_num) => moonbitlang$core$builtin$$Compare$op_lt$81$(exp_num, $65536L) ? moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Mul$mul$7$($10L, exp_num), moonbitlang$core$int$$Int$to_int64(digit)) : exp_num);
        const _s = _bind$2._0;
        const _exp_num = _bind$2._1;
        return neg_exp ? { _0: _s, _1: moonbitlang$core$builtin$$Neg$neg$7$(_exp_num) } : { _0: _s, _1: _exp_num };
      } else {
        break _L$2;
      }
    } else {
      break _L$2;
    }
  }
  return undefined;
}
function moonbitlang$core$strconv$$try_parse_19digits(s, x) {
  let x$2 = x;
  let len = 0;
  let _tmp$27 = s;
  while (true) {
    const _param = _tmp$27;
    let s$2;
    _L: {
      if (moonbitlang$core$string$$String$char_length_ge$46$inner(_param.str, 1, _param.start, _param.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 0, _param.start, _param.end));
        if (_x >= 48 && _x <= 57) {
          const _tmp$28 = _param.str;
          const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
          let _tmp$29;
          if (_bind === undefined) {
            _tmp$29 = _param.end;
          } else {
            const _Some = _bind;
            _tmp$29 = _Some;
          }
          const _tmp$30 = _tmp$29;
          const _x$2 = { str: _tmp$28, start: _tmp$30, end: _param.end };
          if (moonbitlang$core$builtin$$Compare$op_lt$80$(x$2, moonbitlang$core$strconv$$min_19digit_int)) {
            len = len + 1 | 0;
            x$2 = moonbitlang$core$builtin$$Add$add$6$(moonbitlang$core$builtin$$Mul$mul$6$(x$2, $10L), moonbitlang$core$uint64$$UInt64$extend_uint(_x - 48 | 0));
            _tmp$27 = _x$2;
            continue;
          } else {
            s$2 = _param;
            break _L;
          }
        } else {
          if (_x === 95) {
            const _tmp$28 = _param.str;
            const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
            let _tmp$29;
            if (_bind === undefined) {
              _tmp$29 = _param.end;
            } else {
              const _Some = _bind;
              _tmp$29 = _Some;
            }
            const _tmp$30 = _tmp$29;
            const _x$2 = { str: _tmp$28, start: _tmp$30, end: _param.end };
            _tmp$27 = _x$2;
            continue;
          } else {
            s$2 = _param;
            break _L;
          }
        }
      } else {
        s$2 = _param;
        break _L;
      }
    }
    return { _0: s$2, _1: x$2, _2: len };
  }
}
function moonbitlang$core$strconv$$parse_number(s) {
  let _bind;
  let rest;
  _L: {
    _L$2: {
      if (moonbitlang$core$string$$String$char_length_ge$46$inner(s.str, 1, s.start, s.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(s.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(s.str, 0, s.start, s.end));
        switch (_x) {
          case 45: {
            const _tmp$27 = s.str;
            const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(s.str, 1, s.start, s.end);
            let _tmp$28;
            if (_bind$2 === undefined) {
              _tmp$28 = s.end;
            } else {
              const _Some = _bind$2;
              _tmp$28 = _Some;
            }
            const _tmp$29 = _tmp$28;
            const _x$2 = { str: _tmp$27, start: _tmp$29, end: s.end };
            _bind = { _0: _x$2, _1: true };
            break;
          }
          case 43: {
            const _tmp$30 = s.str;
            const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(s.str, 1, s.start, s.end);
            let _tmp$31;
            if (_bind$3 === undefined) {
              _tmp$31 = s.end;
            } else {
              const _Some = _bind$3;
              _tmp$31 = _Some;
            }
            const _tmp$32 = _tmp$31;
            const _x$3 = { str: _tmp$30, start: _tmp$32, end: s.end };
            rest = _x$3;
            break _L$2;
          }
          default: {
            rest = s;
            break _L$2;
          }
        }
      } else {
        rest = s;
        break _L$2;
      }
      break _L;
    }
    _bind = { _0: rest, _1: false };
  }
  const _s = _bind._0;
  const _negative = _bind._1;
  if (moonbitlang$core$string$$StringView$is_empty(_s)) {
    return new Result$Ok$16$(undefined);
  }
  const _bind$2 = moonbitlang$core$strconv$$parse_digits(_s, $0L);
  const _s$2 = _bind$2._0;
  const _mantissa = _bind$2._1;
  const _consumed = _bind$2._2;
  let mantissa = _mantissa;
  let s$2 = _s$2;
  let n_digits = _consumed;
  let n_after_dot = 0;
  let exponent = $0L;
  const _bind$3 = s$2;
  if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind$3.str, 1, _bind$3.start, _bind$3.end)) {
    const _x = moonbitlang$core$string$$String$unsafe_char_at(_bind$3.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$3.str, 0, _bind$3.start, _bind$3.end));
    if (_x === 46) {
      const _tmp$27 = _bind$3.str;
      const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$3.str, 1, _bind$3.start, _bind$3.end);
      let _tmp$28;
      if (_bind$4 === undefined) {
        _tmp$28 = _bind$3.end;
      } else {
        const _Some = _bind$4;
        _tmp$28 = _Some;
      }
      const _tmp$29 = _tmp$28;
      const _x$2 = { str: _tmp$27, start: _tmp$29, end: _bind$3.end };
      s$2 = _x$2;
      const _bind$5 = moonbitlang$core$strconv$$parse_digits(s$2, mantissa);
      const _new_s = _bind$5._0;
      const _new_mantissa = _bind$5._1;
      const _consumed_digit = _bind$5._2;
      s$2 = _new_s;
      mantissa = _new_mantissa;
      n_after_dot = _consumed_digit;
      exponent = moonbitlang$core$builtin$$Neg$neg$7$(moonbitlang$core$int$$Int$to_int64(n_after_dot));
    }
  }
  n_digits = n_digits + n_after_dot | 0;
  if (n_digits === 0) {
    return new Result$Ok$16$(undefined);
  }
  let rest$2;
  _L$2: {
    _L$3: {
      const _bind$4 = s$2;
      if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind$4.str, 1, _bind$4.start, _bind$4.end)) {
        const _x = moonbitlang$core$string$$String$unsafe_char_at(_bind$4.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$4.str, 0, _bind$4.start, _bind$4.end));
        switch (_x) {
          case 101: {
            const _tmp$27 = _bind$4.str;
            const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$4.str, 1, _bind$4.start, _bind$4.end);
            let _tmp$28;
            if (_bind$5 === undefined) {
              _tmp$28 = _bind$4.end;
            } else {
              const _Some = _bind$5;
              _tmp$28 = _Some;
            }
            const _tmp$29 = _tmp$28;
            const _x$2 = { str: _tmp$27, start: _tmp$29, end: _bind$4.end };
            rest$2 = _x$2;
            break _L$3;
          }
          case 69: {
            const _tmp$30 = _bind$4.str;
            const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$4.str, 1, _bind$4.start, _bind$4.end);
            let _tmp$31;
            if (_bind$6 === undefined) {
              _tmp$31 = _bind$4.end;
            } else {
              const _Some = _bind$6;
              _tmp$31 = _Some;
            }
            const _tmp$32 = _tmp$31;
            const _x$3 = { str: _tmp$30, start: _tmp$32, end: _bind$4.end };
            rest$2 = _x$3;
            break _L$3;
          }
        }
      }
      break _L$2;
    }
    const _bind$4 = moonbitlang$core$strconv$$parse_scientific(rest$2);
    let _bind$5;
    if (_bind$4 === undefined) {
      return new Result$Ok$16$(undefined);
    } else {
      const _Some = _bind$4;
      _bind$5 = _Some;
    }
    const _new_s = _bind$5._0;
    const _exp_number = _bind$5._1;
    s$2 = _new_s;
    exponent = moonbitlang$core$builtin$$Add$add$7$(exponent, _exp_number);
  }
  const _bind$4 = s$2;
  if (moonbitlang$core$string$$String$char_length_eq$46$inner(_bind$4.str, 0, _bind$4.start, _bind$4.end)) {
    if (n_digits <= 19) {
      return new Result$Ok$16$({ exponent: exponent, mantissa: mantissa, negative: _negative, many_digits: false });
    }
    n_digits = n_digits - 19 | 0;
    let many_digits = false;
    let _tmp$27 = s.str;
    let _tmp$28 = s.start;
    let _tmp$29 = s.end;
    _L$3: while (true) {
      const _param_str = _tmp$27;
      const _param_start = _tmp$28;
      const _param_end = _tmp$29;
      let rest$3;
      let ch;
      _L$4: {
        if (moonbitlang$core$string$$String$char_length_ge$46$inner(_param_str, 1, _param_start, _param_end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_str, 0, _param_start, _param_end));
          switch (_x) {
            case 48: {
              const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_str, 1, _param_start, _param_end);
              let _tmp$30;
              if (_bind$5 === undefined) {
                _tmp$30 = _param_end;
              } else {
                const _Some = _bind$5;
                _tmp$30 = _Some;
              }
              const _x$2 = { str: _param_str, start: _tmp$30, end: _param_end };
              rest$3 = _x$2;
              ch = _x;
              break _L$4;
            }
            case 46: {
              const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_str, 1, _param_start, _param_end);
              let _tmp$31;
              if (_bind$6 === undefined) {
                _tmp$31 = _param_end;
              } else {
                const _Some = _bind$6;
                _tmp$31 = _Some;
              }
              const _x$3 = { str: _param_str, start: _tmp$31, end: _param_end };
              rest$3 = _x$3;
              ch = _x;
              break _L$4;
            }
            default: {
              break _L$3;
            }
          }
        } else {
          break;
        }
      }
      n_digits = n_digits - ((ch - 46 | 0) / 2 | 0) | 0;
      _tmp$27 = rest$3.str;
      _tmp$28 = rest$3.start;
      _tmp$29 = rest$3.end;
      continue;
    }
    let mantissa$2 = mantissa;
    if (n_digits > 0) {
      many_digits = true;
      mantissa$2 = $0L;
      const _bind$5 = moonbitlang$core$strconv$$try_parse_19digits(s, mantissa$2);
      const _s$3 = _bind$5._0;
      const _new_mantissa = _bind$5._1;
      const _consumed_digit = _bind$5._2;
      mantissa$2 = _new_mantissa;
      let _tmp$30;
      if (moonbitlang$core$builtin$$Compare$op_ge$80$(mantissa$2, moonbitlang$core$strconv$$min_19digit_int)) {
        _tmp$30 = _consumed_digit;
      } else {
        if (moonbitlang$core$string$$String$char_length_ge$46$inner(_s$3.str, 1, _s$3.start, _s$3.end)) {
          const _tmp$31 = _s$3.str;
          const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_s$3.str, 1, _s$3.start, _s$3.end);
          let _tmp$32;
          if (_bind$6 === undefined) {
            _tmp$32 = _s$3.end;
          } else {
            const _Some = _bind$6;
            _tmp$32 = _Some;
          }
          const _tmp$33 = _tmp$32;
          const _x = { str: _tmp$31, start: _tmp$33, end: _s$3.end };
          const _bind$7 = moonbitlang$core$strconv$$try_parse_19digits(_x, mantissa$2);
          const _new_mantissa$2 = _bind$7._1;
          const _consumed_digit$2 = _bind$7._2;
          mantissa$2 = _new_mantissa$2;
          _tmp$30 = _consumed_digit$2;
        } else {
          return new Result$Ok$16$(undefined);
        }
      }
      exponent = moonbitlang$core$int$$Int$to_int64(_tmp$30);
      exponent = moonbitlang$core$builtin$$Add$add$7$(exponent, moonbitlang$core$strconv$$parse_number$46$exp_number$124$260);
    }
    return new Result$Ok$16$({ exponent: exponent, mantissa: mantissa$2, negative: _negative, many_digits: many_digits });
  } else {
    return moonbitlang$core$strconv$$syntax_err$152$();
  }
}
function moonbitlang$core$strconv$$assemble_bits(mantissa, exponent, negative) {
  const biased_exp = exponent - moonbitlang$core$strconv$$double_info.bias | 0;
  let bits = moonbitlang$core$builtin$$BitAnd$land$7$(mantissa, moonbitlang$core$builtin$$Sub$sub$7$(moonbitlang$core$builtin$$Shl$shl$7$($1L, moonbitlang$core$strconv$$double_info.mantissa_bits), $1L));
  const exp_bits = moonbitlang$core$int$$Int$to_int64(biased_exp & ((1 << moonbitlang$core$strconv$$double_info.exponent_bits) - 1 | 0));
  bits = moonbitlang$core$builtin$$BitOr$lor$7$(bits, moonbitlang$core$builtin$$Shl$shl$7$(exp_bits, moonbitlang$core$strconv$$double_info.mantissa_bits));
  if (negative) {
    bits = moonbitlang$core$builtin$$BitOr$lor$7$(bits, moonbitlang$core$builtin$$Shl$shl$7$(moonbitlang$core$builtin$$Shl$shl$7$($1L, moonbitlang$core$strconv$$double_info.mantissa_bits), moonbitlang$core$strconv$$double_info.exponent_bits));
  }
  return bits;
}
function moonbitlang$core$strconv$$Decimal$should_round_up(self, d) {
  if (d < 0 || d >= self.digits_num) {
    return false;
  }
  let _tmp$27;
  const _tmp$28 = self.digits;
  $bound_check(_tmp$28, d);
  if (_tmp$28[d] === 5) {
    _tmp$27 = (d + 1 | 0) === self.digits_num;
  } else {
    _tmp$27 = false;
  }
  if (_tmp$27) {
    if (self.truncated) {
      return true;
    }
    let _tmp$29;
    if (d > 0) {
      const _tmp$30 = self.digits;
      const _tmp$31 = d - 1 | 0;
      $bound_check(_tmp$30, _tmp$31);
      _tmp$29 = (_tmp$30[_tmp$31] % 2 | 0) !== 0;
    } else {
      _tmp$29 = false;
    }
    return _tmp$29;
  }
  const _tmp$29 = self.digits;
  $bound_check(_tmp$29, d);
  return _tmp$29[d] >= 5;
}
function moonbitlang$core$strconv$$Decimal$rounded_integer(self) {
  if (self.decimal_point > 20) {
    return $_1L;
  }
  let n = $0L;
  let i = 0;
  while (true) {
    if (i < self.decimal_point && i < self.digits_num) {
      const _tmp$27 = moonbitlang$core$builtin$$Mul$mul$7$(n, $10L);
      const _tmp$28 = self.digits;
      const _tmp$29 = i;
      $bound_check(_tmp$28, _tmp$29);
      n = moonbitlang$core$builtin$$Add$add$7$(_tmp$27, moonbitlang$core$byte$$Byte$to_int64(_tmp$28[_tmp$29]));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (i < self.decimal_point) {
      n = moonbitlang$core$builtin$$Mul$mul$7$(n, $10L);
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (moonbitlang$core$strconv$$Decimal$should_round_up(self, self.decimal_point)) {
    n = moonbitlang$core$builtin$$Add$add$7$(n, $1L);
  }
  return n;
}
function moonbitlang$core$strconv$$Decimal$new_digits(self, s) {
  $bound_check(moonbitlang$core$strconv$$left_shift_cheats, s);
  const new_digits = moonbitlang$core$strconv$$left_shift_cheats[s]._0;
  $bound_check(moonbitlang$core$strconv$$left_shift_cheats, s);
  const cheat_num = moonbitlang$core$strconv$$left_shift_cheats[s]._1;
  let less = false;
  const _end73 = cheat_num.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end73) {
      if (i >= self.digits_num) {
        less = true;
        break;
      }
      const d = cheat_num.charCodeAt(i) - 48 | 0;
      const _tmp$28 = self.digits;
      $bound_check(_tmp$28, i);
      if (_tmp$28[i] !== d) {
        const _tmp$29 = self.digits;
        $bound_check(_tmp$29, i);
        less = _tmp$29[i] < d;
        break;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return less ? new_digits - 1 | 0 : new_digits;
}
function moonbitlang$core$strconv$$Decimal$left_shift(self, s) {
  const new_digits = moonbitlang$core$strconv$$Decimal$new_digits(self, s);
  let read_index = self.digits_num;
  let write_index = self.digits_num + new_digits | 0;
  let acc = $0L;
  read_index = read_index - 1 | 0;
  while (true) {
    if (read_index >= 0) {
      const _tmp$27 = self.digits;
      const _tmp$28 = read_index;
      $bound_check(_tmp$27, _tmp$28);
      const d = moonbitlang$core$byte$$Byte$to_int64(_tmp$27[_tmp$28]);
      acc = moonbitlang$core$builtin$$Add$add$7$(acc, moonbitlang$core$builtin$$Shl$shl$7$(d, s));
      const quo = moonbitlang$core$builtin$$Div$div$7$(acc, $10L);
      const rem = moonbitlang$core$int64$$Int64$to_int(moonbitlang$core$builtin$$Sub$sub$7$(acc, moonbitlang$core$builtin$$Mul$mul$7$(quo, $10L)));
      write_index = write_index - 1 | 0;
      if (write_index < self.digits.length) {
        const _tmp$29 = self.digits;
        const _tmp$30 = write_index;
        $bound_check(_tmp$29, _tmp$30);
        _tmp$29[_tmp$30] = rem & 255;
      } else {
        if (rem !== 0) {
          self.truncated = true;
        }
      }
      acc = quo;
      read_index = read_index - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (moonbitlang$core$builtin$$Compare$op_gt$81$(acc, $0L)) {
      const quo = moonbitlang$core$builtin$$Div$div$7$(acc, $10L);
      const rem = moonbitlang$core$int64$$Int64$to_int(moonbitlang$core$builtin$$Sub$sub$7$(acc, moonbitlang$core$builtin$$Mul$mul$7$($10L, quo)));
      write_index = write_index - 1 | 0;
      if (write_index < self.digits.length) {
        const _tmp$27 = self.digits;
        const _tmp$28 = write_index;
        $bound_check(_tmp$27, _tmp$28);
        _tmp$27[_tmp$28] = rem & 255;
      } else {
        if (rem !== 0) {
          self.truncated = true;
        }
      }
      acc = quo;
      continue;
    } else {
      break;
    }
  }
  self.digits_num = self.digits_num + new_digits | 0;
  if (self.digits_num > self.digits.length) {
    self.digits_num = self.digits.length;
  }
  self.decimal_point = self.decimal_point + new_digits | 0;
  moonbitlang$core$strconv$$Decimal$trim(self);
}
function moonbitlang$core$strconv$$Decimal$right_shift(self, s) {
  let read_index = 0;
  let write_index = 0;
  let acc = $0L;
  while (true) {
    if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(acc, s), $0L)) {
      if (read_index >= self.digits_num) {
        while (true) {
          if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(acc, s), $0L)) {
            acc = moonbitlang$core$builtin$$Mul$mul$6$(acc, $10L);
            read_index = read_index + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        break;
      }
      const _tmp$27 = self.digits;
      const _tmp$28 = read_index;
      $bound_check(_tmp$27, _tmp$28);
      const d = _tmp$27[_tmp$28];
      acc = moonbitlang$core$builtin$$Add$add$6$(moonbitlang$core$builtin$$Mul$mul$6$(acc, $10L), moonbitlang$core$byte$$Byte$to_int64(d));
      read_index = read_index + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  self.decimal_point = self.decimal_point - (read_index - 1 | 0) | 0;
  const mask = moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, s), $1L);
  while (true) {
    if (read_index < self.digits_num) {
      const out = moonbitlang$core$builtin$$Shr$shr$6$(acc, s);
      const _tmp$27 = self.digits;
      const _tmp$28 = write_index;
      $bound_check(_tmp$27, _tmp$28);
      _tmp$27[_tmp$28] = moonbitlang$core$uint64$$UInt64$to_byte(out);
      write_index = write_index + 1 | 0;
      acc = moonbitlang$core$builtin$$BitAnd$land$6$(acc, mask);
      const _tmp$29 = self.digits;
      const _tmp$30 = read_index;
      $bound_check(_tmp$29, _tmp$30);
      const d = _tmp$29[_tmp$30];
      acc = moonbitlang$core$builtin$$Add$add$6$(moonbitlang$core$builtin$$Mul$mul$6$(acc, $10L), moonbitlang$core$byte$$Byte$to_int64(d));
      read_index = read_index + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (moonbitlang$core$builtin$$Compare$op_gt$80$(acc, $0L)) {
      const out = moonbitlang$core$builtin$$Shr$shr$6$(acc, s);
      if (write_index < self.digits.length) {
        const _tmp$27 = self.digits;
        const _tmp$28 = write_index;
        $bound_check(_tmp$27, _tmp$28);
        _tmp$27[_tmp$28] = moonbitlang$core$uint64$$UInt64$to_byte(out);
        write_index = write_index + 1 | 0;
      } else {
        if (moonbitlang$core$builtin$$Compare$op_gt$80$(out, $0L)) {
          self.truncated = true;
        }
      }
      acc = moonbitlang$core$builtin$$BitAnd$land$6$(acc, mask);
      acc = moonbitlang$core$builtin$$Mul$mul$6$(acc, $10L);
      continue;
    } else {
      break;
    }
  }
  self.digits_num = write_index;
  moonbitlang$core$strconv$$Decimal$trim(self);
}
function moonbitlang$core$strconv$$Decimal$shift_priv(self, s) {
  if (self.digits_num === 0) {
    return undefined;
  }
  let s$2 = s;
  if (s$2 > 0) {
    while (true) {
      if (s$2 > 59) {
        moonbitlang$core$strconv$$Decimal$left_shift(self, 59);
        s$2 = s$2 - 59 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$strconv$$Decimal$left_shift(self, s$2);
  }
  if (s$2 < 0) {
    while (true) {
      if (s$2 < -59) {
        moonbitlang$core$strconv$$Decimal$right_shift(self, 59);
        s$2 = s$2 + 59 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$strconv$$Decimal$right_shift(self, -s$2 | 0);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$strconv$$Decimal$to_double_priv(self) {
  let exponent = 0;
  let mantissa = $0L;
  if (self.digits_num === 0 || self.decimal_point < -330) {
    mantissa = $0L;
    exponent = moonbitlang$core$strconv$$double_info.bias;
    const bits = moonbitlang$core$strconv$$assemble_bits(mantissa, exponent, self.negative);
    return new Result$Ok$15$(moonbitlang$core$int64$$Int64$reinterpret_as_double(bits));
  }
  if (self.decimal_point > 310) {
    const _bind = moonbitlang$core$strconv$$range_err$8$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  while (true) {
    if (self.decimal_point > 0) {
      let n = 0;
      if (self.decimal_point >= moonbitlang$core$strconv$$powtab.length) {
        n = 60;
      } else {
        const _p$28 = self.decimal_point;
        $bound_check(moonbitlang$core$strconv$$powtab, _p$28);
        n = moonbitlang$core$strconv$$powtab[_p$28];
      }
      moonbitlang$core$strconv$$Decimal$shift_priv(self, -n | 0);
      exponent = exponent + n | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    let _tmp$27;
    if (self.decimal_point < 0) {
      _tmp$27 = true;
    } else {
      let _tmp$28;
      if (self.decimal_point === 0) {
        const _tmp$29 = self.digits;
        $bound_check(_tmp$29, 0);
        _tmp$28 = _tmp$29[0] < 5;
      } else {
        _tmp$28 = false;
      }
      _tmp$27 = _tmp$28;
    }
    if (_tmp$27) {
      let n = 0;
      if ((-self.decimal_point | 0) >= moonbitlang$core$strconv$$powtab.length) {
        n = 60;
      } else {
        const _p$28 = -self.decimal_point | 0;
        $bound_check(moonbitlang$core$strconv$$powtab, _p$28);
        n = moonbitlang$core$strconv$$powtab[_p$28];
      }
      moonbitlang$core$strconv$$Decimal$shift_priv(self, n);
      exponent = exponent - n | 0;
      continue;
    } else {
      break;
    }
  }
  exponent = exponent - 1 | 0;
  if (exponent < (moonbitlang$core$strconv$$double_info.bias + 1 | 0)) {
    const n = (moonbitlang$core$strconv$$double_info.bias + 1 | 0) - exponent | 0;
    moonbitlang$core$strconv$$Decimal$shift_priv(self, -n | 0);
    exponent = exponent + n | 0;
  }
  if ((exponent - moonbitlang$core$strconv$$double_info.bias | 0) >= ((1 << moonbitlang$core$strconv$$double_info.exponent_bits) - 1 | 0)) {
    const _bind = moonbitlang$core$strconv$$range_err$8$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  moonbitlang$core$strconv$$Decimal$shift_priv(self, moonbitlang$core$strconv$$double_info.mantissa_bits + 1 | 0);
  mantissa = moonbitlang$core$strconv$$Decimal$rounded_integer(self);
  if (moonbitlang$core$builtin$$Eq$equal$7$(mantissa, moonbitlang$core$builtin$$Shl$shl$7$($2L, moonbitlang$core$strconv$$double_info.mantissa_bits))) {
    mantissa = moonbitlang$core$builtin$$Shr$shr$7$(mantissa, 1);
    exponent = exponent + 1 | 0;
    if ((exponent - moonbitlang$core$strconv$$double_info.bias | 0) >= ((1 << moonbitlang$core$strconv$$double_info.exponent_bits) - 1 | 0)) {
      const _bind = moonbitlang$core$strconv$$range_err$8$();
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        return _bind;
      }
    }
  }
  if (moonbitlang$core$builtin$$Eq$equal$7$(moonbitlang$core$builtin$$BitAnd$land$7$(mantissa, moonbitlang$core$builtin$$Shl$shl$7$($1L, moonbitlang$core$strconv$$double_info.mantissa_bits)), $0L)) {
    exponent = moonbitlang$core$strconv$$double_info.bias;
  }
  const bits = moonbitlang$core$strconv$$assemble_bits(mantissa, exponent, self.negative);
  return new Result$Ok$15$(moonbitlang$core$int64$$Int64$reinterpret_as_double(bits));
}
function moonbitlang$core$strconv$$checked_mul(a, b) {
  if (moonbitlang$core$builtin$$Eq$equal$6$(a, $0L) || moonbitlang$core$builtin$$Eq$equal$6$(b, $0L)) {
    return moonbitlang$core$strconv$$checked_mul$46$constr$47$2613;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(a, $1L)) {
    return b;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(b, $1L)) {
    return a;
  }
  if (moonbitlang$core$uint64$$UInt64$clz(b) === 0 || moonbitlang$core$uint64$$UInt64$clz(a) === 0) {
    return undefined;
  }
  const quotient = moonbitlang$core$builtin$$Div$div$6$(moonbitlang$core$uint64$$max_value, b);
  if (moonbitlang$core$builtin$$Compare$op_gt$80$(a, quotient)) {
    return undefined;
  }
  return moonbitlang$core$builtin$$Mul$mul$6$(a, b);
}
function moonbitlang$core$strconv$$pow10_fast_path(exponent) {
  const _p$28 = exponent & 31;
  $bound_check(moonbitlang$core$strconv$$table, _p$28);
  return moonbitlang$core$strconv$$table[_p$28];
}
function moonbitlang$core$strconv$$Number$is_fast_path(self) {
  return moonbitlang$core$builtin$$Compare$op_le$81$(moonbitlang$core$strconv$$min_exponent_fast_path, self.exponent) && (moonbitlang$core$builtin$$Compare$op_le$81$(self.exponent, moonbitlang$core$strconv$$max_exponent_disguised_fast_path) && (moonbitlang$core$builtin$$Compare$op_le$80$(self.mantissa, moonbitlang$core$strconv$$max_mantissa_fast_path) && !self.many_digits));
}
function moonbitlang$core$strconv$$Number$try_fast_path(self) {
  if (moonbitlang$core$strconv$$Number$is_fast_path(self)) {
    let value;
    if (moonbitlang$core$builtin$$Compare$op_le$81$(self.exponent, moonbitlang$core$strconv$$max_exponent_fast_path)) {
      const value$2 = moonbitlang$core$double$$Double$convert_uint64(self.mantissa);
      value = moonbitlang$core$builtin$$Compare$op_lt$81$(self.exponent, $0L) ? value$2 / moonbitlang$core$strconv$$pow10_fast_path(-moonbitlang$core$int64$$Int64$to_int(self.exponent) | 0) : value$2 * moonbitlang$core$strconv$$pow10_fast_path(moonbitlang$core$int64$$Int64$to_int(self.exponent));
    } else {
      const shift = moonbitlang$core$builtin$$Sub$sub$7$(self.exponent, moonbitlang$core$strconv$$max_exponent_fast_path);
      const _tmp$27 = self.mantissa;
      const _p$28 = moonbitlang$core$int64$$Int64$to_int(shift);
      $bound_check(moonbitlang$core$strconv$$int_pow10, _p$28);
      const _bind = moonbitlang$core$strconv$$checked_mul(_tmp$27, moonbitlang$core$strconv$$int_pow10[_p$28]);
      let mantissa;
      if (_bind === undefined) {
        return Option$None$20$;
      } else {
        const _Some = _bind;
        mantissa = _Some;
      }
      if (moonbitlang$core$builtin$$Compare$op_gt$80$(mantissa, moonbitlang$core$strconv$$max_mantissa_fast_path)) {
        return Option$None$20$;
      }
      value = moonbitlang$core$double$$Double$convert_uint64(mantissa) * moonbitlang$core$strconv$$pow10_fast_path(moonbitlang$core$int64$$Int64$to_int(moonbitlang$core$strconv$$max_exponent_fast_path));
    }
    if (self.negative) {
      value = -value;
    }
    return new Option$Some$20$(value);
  } else {
    return Option$None$20$;
  }
}
function moonbitlang$core$strconv$$parse_double(str) {
  if ((str.end - str.start | 0) > 0) {
    if (moonbitlang$core$strconv$$check_underscore(str)) {
      const _bind = moonbitlang$core$strconv$$parse_number(str);
      let _bind$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _bind$2 = _ok._0;
      } else {
        return _bind;
      }
      if (_bind$2 === undefined) {
        return moonbitlang$core$strconv$$parse_inf_nan(str);
      } else {
        const _Some = _bind$2;
        const _num = _Some;
        const _bind$3 = moonbitlang$core$strconv$$Number$try_fast_path(_num);
        if (_bind$3.$tag === 1) {
          const _Some$2 = _bind$3;
          const _value = _Some$2._0;
          return new Result$Ok$15$(_value);
        } else {
          const _bind$4 = moonbitlang$core$strconv$$parse_decimal_priv(str);
          let _tmp$27;
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _tmp$27 = _ok._0;
          } else {
            return _bind$4;
          }
          return moonbitlang$core$strconv$$Decimal$to_double_priv(_tmp$27);
        }
      }
    } else {
      return moonbitlang$core$strconv$$syntax_err$151$();
    }
  } else {
    return moonbitlang$core$strconv$$syntax_err$151$();
  }
}
function moonbitlang$core$builtin$$Show$output$94$(self, logger) {
  const _StrConvError = self;
  const _err = _StrConvError._0;
  logger.method_table.method_0(logger.self, _err);
}
function moonbitlang$core$hashmap$$HashMap$iter$136$(self) {
  const i = { val: 0 };
  const len = self.entries.length;
  const _p$28 = () => {
    while (true) {
      if (i.val < len) {
        const entry = self.entries[i.val];
        i.val = i.val + 1 | 0;
        if (entry === undefined) {
        } else {
          const _Some = entry;
          const _x = _Some;
          const _key = _x.key;
          const _value = _x.value;
          return { _0: _key, _1: _value };
        }
        continue;
      } else {
        return undefined;
      }
    }
  };
  return _p$28;
}
function moonbitlang$core$hashmap$$HashMap$iter$137$(self) {
  const i = { val: 0 };
  const len = self.entries.length;
  const _p$28 = () => {
    while (true) {
      if (i.val < len) {
        const entry = self.entries[i.val];
        i.val = i.val + 1 | 0;
        if (entry === undefined) {
        } else {
          const _Some = entry;
          const _x = _Some;
          const _key = _x.key;
          const _value = _x.value;
          return { _0: _key, _1: _value };
        }
        continue;
      } else {
        return undefined;
      }
    }
  };
  return _p$28;
}
function moonbitlang$core$hashmap$$HashMap$iter2$136$(self) {
  return moonbitlang$core$hashmap$$HashMap$iter$136$(self);
}
function moonbitlang$core$hashmap$$HashMap$iter2$137$(self) {
  return moonbitlang$core$hashmap$$HashMap$iter$137$(self);
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$154$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$155$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$156$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$157$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$158$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$159$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$160$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$161$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$162$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$163$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$164$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$165$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$166$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$167$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$168$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$169$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$170$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$171$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$172$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$173$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$174$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$175$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$136$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$new$46$inner$137$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = $make_array_len_and_init(capacity$2, undefined);
  const _bind$2 = capacity$2 - 1 | 0;
  return { entries: _bind, capacity: capacity$2, capacity_mask: _bind$2, size: 0 };
}
function moonbitlang$core$hashmap$$HashMap$push_away$154$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$170$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$158$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$156$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$157$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$166$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$173$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$159$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$155$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$175$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$174$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$165$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$164$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$161$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$162$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$168$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$160$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$171$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$172$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$163$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$169$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$167$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$136$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$push_away$137$(self, idx, entry) {
  let _tmp$27 = entry.psl + 1 | 0;
  let _tmp$28 = idx + 1 & self.capacity_mask;
  let _tmp$29 = entry;
  while (true) {
    const psl = _tmp$27;
    const idx$2 = _tmp$28;
    const entry$2 = _tmp$29;
    const _tmp$30 = self.entries;
    $bound_check(_tmp$30, idx$2);
    const _bind = _tmp$30[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      const _tmp$31 = self.entries;
      $bound_check(_tmp$31, idx$2);
      _tmp$31[idx$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        const _tmp$31 = self.entries;
        $bound_check(_tmp$31, idx$2);
        _tmp$31[idx$2] = entry$2;
        _tmp$27 = _curr_entry.psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        _tmp$29 = _curr_entry;
        continue;
      } else {
        _tmp$27 = psl + 1 | 0;
        _tmp$28 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$154$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$154$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$154$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$170$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$170$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$170$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$158$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$158$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$158$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$156$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$156$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$156$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$157$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$157$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$157$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$166$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$166$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$166$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$173$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$173$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$173$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$159$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$159$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$159$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$155$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$155$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$155$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$175$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$175$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$175$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$174$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$174$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$174$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$165$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$165$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$165$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$164$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$164$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$164$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$161$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$161$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$161$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$162$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$162$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$162$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$168$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$168$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$168$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$160$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$160$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$160$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$171$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$171$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$171$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$172$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$172$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$172$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$163$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$163$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$163$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$169$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$169$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$169$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$167$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$167$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$167$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$136$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$136$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$136$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$set_with_hash$137$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$HashMap$grow$137$(self);
  }
  let _bind;
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind$2 = _tmp$29[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$hashmap$$HashMap$push_away$137$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp$27 = psl + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const entry = { psl: _psl, hash: hash, key: key, value: value };
  const _tmp$29 = self.entries;
  $bound_check(_tmp$29, _idx);
  _tmp$29[_idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$hashmap$$HashMap$grow$154$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$154$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$170$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$170$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$158$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$158$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$156$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$156$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$157$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$157$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$166$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$166$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$173$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$173$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$159$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$159$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$155$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$155$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$175$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$175$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$174$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$174$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$165$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$165$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$164$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$164$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$161$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$161$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$162$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$162$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$168$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$168$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$160$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$160$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$171$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$171$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$172$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$172$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$163$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$163$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$169$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$169$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$167$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$167$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$136$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$136$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$grow$137$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.size = 0;
  const _end78 = old_entries.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end78) {
      $bound_check(old_entries, i);
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _key = _x.key;
        const _value = _x.value;
        const _hash = _x.hash;
        moonbitlang$core$hashmap$$HashMap$set_with_hash$137$(self, _key, _value, _hash);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$set$154$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$154$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$170$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$170$(self, key, value, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$158$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$158$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$156$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$156$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$157$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$157$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$166$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$166$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$173$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$173$(self, key, value, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$159$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$159$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$155$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$155$(self, key, value, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$175$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$175$(self, key, value, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$174$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$174$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$165$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$165$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$164$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$164$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$161$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$161$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$162$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$162$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$168$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$168$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$160$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$160$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$171$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$171$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$172$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$172$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$163$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$163$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$169$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$169$(self, key, value, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$167$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$167$(self, key, value, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$136$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$136$(self, key, value, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$set$137$(self, key, value) {
  moonbitlang$core$hashmap$$HashMap$set_with_hash$137$(self, key, value, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$shift_back$174$(self, idx) {
  let _tmp$27 = idx;
  while (true) {
    const idx$2 = _tmp$27;
    const next = idx$2 + 1 & self.capacity_mask;
    _L: {
      const _tmp$28 = self.entries;
      $bound_check(_tmp$28, next);
      const _bind = _tmp$28[next];
      if (_bind === undefined) {
        break _L;
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _x$2 = _x.psl;
        if (_x$2 === 0) {
          break _L;
        } else {
          _x.psl = _x.psl - 1 | 0;
          const _tmp$29 = self.entries;
          $bound_check(_tmp$29, idx$2);
          _tmp$29[idx$2] = _x;
          _tmp$27 = next;
          continue;
        }
      }
    }
    const _tmp$28 = self.entries;
    $bound_check(_tmp$28, idx$2);
    _tmp$28[idx$2] = undefined;
    return;
  }
}
function moonbitlang$core$hashmap$$HashMap$shift_back$175$(self, idx) {
  let _tmp$27 = idx;
  while (true) {
    const idx$2 = _tmp$27;
    const next = idx$2 + 1 & self.capacity_mask;
    _L: {
      const _tmp$28 = self.entries;
      $bound_check(_tmp$28, next);
      const _bind = _tmp$28[next];
      if (_bind === undefined) {
        break _L;
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _x$2 = _x.psl;
        if (_x$2 === 0) {
          break _L;
        } else {
          _x.psl = _x.psl - 1 | 0;
          const _tmp$29 = self.entries;
          $bound_check(_tmp$29, idx$2);
          _tmp$29[idx$2] = _x;
          _tmp$27 = next;
          continue;
        }
      }
    }
    const _tmp$28 = self.entries;
    $bound_check(_tmp$28, idx$2);
    _tmp$28[idx$2] = undefined;
    return;
  }
}
function moonbitlang$core$hashmap$$HashMap$shift_back$166$(self, idx) {
  let _tmp$27 = idx;
  while (true) {
    const idx$2 = _tmp$27;
    const next = idx$2 + 1 & self.capacity_mask;
    _L: {
      const _tmp$28 = self.entries;
      $bound_check(_tmp$28, next);
      const _bind = _tmp$28[next];
      if (_bind === undefined) {
        break _L;
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _x$2 = _x.psl;
        if (_x$2 === 0) {
          break _L;
        } else {
          _x.psl = _x.psl - 1 | 0;
          const _tmp$29 = self.entries;
          $bound_check(_tmp$29, idx$2);
          _tmp$29[idx$2] = _x;
          _tmp$27 = next;
          continue;
        }
      }
    }
    const _tmp$28 = self.entries;
    $bound_check(_tmp$28, idx$2);
    _tmp$28[idx$2] = undefined;
    return;
  }
}
function moonbitlang$core$hashmap$$HashMap$get$161$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return -1;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return -1;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$154$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$156$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$159$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$157$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$158$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$166$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return Option$None$21$;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return new Option$Some$21$(_entry.value);
      }
      if (i > _entry.psl) {
        return Option$None$21$;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$173$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$167$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$165$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$174$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$175$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$155$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$137$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$164$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$136$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$162$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$168$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return Option$None$22$;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return new Option$Some$22$(_entry.value);
      }
      if (i > _entry.psl) {
        return Option$None$22$;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$160$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$171$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$172$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$169$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$163$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$get$170$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return -1;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return -1;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$158$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$166$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$155$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$175$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$160$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$162$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$156$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$161$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$159$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$167$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$173$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$136$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$89$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$137$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$contains$169$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$90$(key);
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$remove_with_hash$174$(self, key, hash) {
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        moonbitlang$core$hashmap$$HashMap$shift_back$174$(self, idx);
        self.size = self.size - 1 | 0;
        break;
      }
      if (i > _entry.psl) {
        break;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$remove_with_hash$175$(self, key, hash) {
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        moonbitlang$core$hashmap$$HashMap$shift_back$175$(self, idx);
        self.size = self.size - 1 | 0;
        break;
      }
      if (i > _entry.psl) {
        break;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$remove_with_hash$166$(self, key, hash) {
  let _tmp$27 = 0;
  let _tmp$28 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp$27;
    const idx = _tmp$28;
    const _tmp$29 = self.entries;
    $bound_check(_tmp$29, idx);
    const _bind = _tmp$29[idx];
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        moonbitlang$core$hashmap$$HashMap$shift_back$166$(self, idx);
        self.size = self.size - 1 | 0;
        break;
      }
      if (i > _entry.psl) {
        break;
      }
      _tmp$27 = i + 1 | 0;
      _tmp$28 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$HashMap$remove$174$(self, key) {
  moonbitlang$core$hashmap$$HashMap$remove_with_hash$174$(self, key, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$hashmap$$HashMap$remove$175$(self, key) {
  moonbitlang$core$hashmap$$HashMap$remove_with_hash$175$(self, key, moonbitlang$core$builtin$$Hash$hash$90$(key));
}
function moonbitlang$core$hashmap$$HashMap$remove$166$(self, key) {
  moonbitlang$core$hashmap$$HashMap$remove_with_hash$166$(self, key, moonbitlang$core$builtin$$Hash$hash$89$(key));
}
function moonbitlang$core$encoding$utf8$$encode$46$inner(str, bom) {
  const buffer = moonbitlang$core$buffer$$new$46$inner(Math.imul(str.end - str.start | 0, 4) | 0);
  if (bom === true) {
    moonbitlang$core$buffer$$Buffer$write_char_utf8(buffer, 65279);
  }
  moonbitlang$core$buffer$$Buffer$write_string_utf8(buffer, str);
  return moonbitlang$core$buffer$$Buffer$to_bytes(buffer);
}
function moonbitlang$core$encoding$utf8$$decode$46$inner(bytes, ignore_bom) {
  let bytes$2;
  _L: {
    _L$2: {
      if (ignore_bom) {
        _L$3: {
          _L$4: {
            if ((bytes.end - bytes.start | 0) >= 3) {
              const _x = bytes.bytes[bytes.start];
              if (_x === 239) {
                const _x$2 = bytes.bytes[bytes.start + 1 | 0];
                if (_x$2 === 187) {
                  const _x$3 = bytes.bytes[bytes.start + 2 | 0];
                  if (_x$3 === 191) {
                    bytes$2 = { bytes: bytes.bytes, start: bytes.start + 3 | 0, end: bytes.end };
                  } else {
                    break _L$4;
                  }
                } else {
                  break _L$4;
                }
              } else {
                break _L$4;
              }
            } else {
              break _L$4;
            }
            break _L$3;
          }
          break _L$2;
        }
      } else {
        break _L$2;
      }
      break _L;
    }
    bytes$2 = bytes;
  }
  const t = $makebytes(Math.imul(bytes$2.end - bytes$2.start | 0, 2) | 0, 0);
  let tlen;
  let _tmp$27 = 0;
  let _tmp$28 = bytes$2;
  while (true) {
    const _param_0 = _tmp$27;
    const _param_1 = _tmp$28;
    let bytes$3;
    _L$2: {
      let tlen$2;
      let b0;
      let b1;
      let b2;
      let b3;
      let rest;
      _L$3: {
        let tlen$3;
        let b0$2;
        let b1$2;
        let b2$2;
        let rest$2;
        _L$4: {
          let tlen$4;
          let rest$3;
          let b0$3;
          let b1$3;
          _L$5: {
            let tlen$5;
            let rest$4;
            let b;
            _L$6: {
              if ((_param_1.end - _param_1.start | 0) === 0) {
                tlen = _param_0;
                break;
              } else {
                if ((_param_1.end - _param_1.start | 0) >= 8) {
                  const _x = _param_1.bytes[_param_1.start];
                  if (_x <= 127) {
                    const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                    if (_x$2 <= 127) {
                      const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                      if (_x$3 <= 127) {
                        const _x$4 = _param_1.bytes[_param_1.start + 3 | 0];
                        if (_x$4 <= 127) {
                          const _x$5 = _param_1.bytes[_param_1.start + 4 | 0];
                          if (_x$5 <= 127) {
                            const _x$6 = _param_1.bytes[_param_1.start + 5 | 0];
                            if (_x$6 <= 127) {
                              const _x$7 = _param_1.bytes[_param_1.start + 6 | 0];
                              if (_x$7 <= 127) {
                                const _x$8 = _param_1.bytes[_param_1.start + 7 | 0];
                                if (_x$8 <= 127) {
                                  const _x$9 = { bytes: _param_1.bytes, start: _param_1.start + 8 | 0, end: _param_1.end };
                                  t[_param_0] = _x;
                                  t[_param_0 + 2 | 0] = _x$2;
                                  t[_param_0 + 4 | 0] = _x$3;
                                  t[_param_0 + 6 | 0] = _x$4;
                                  t[_param_0 + 8 | 0] = _x$5;
                                  t[_param_0 + 10 | 0] = _x$6;
                                  t[_param_0 + 12 | 0] = _x$7;
                                  t[_param_0 + 14 | 0] = _x$8;
                                  _tmp$27 = _param_0 + 16 | 0;
                                  _tmp$28 = _x$9;
                                  continue;
                                } else {
                                  const _x$9 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                                  tlen$5 = _param_0;
                                  rest$4 = _x$9;
                                  b = _x;
                                  break _L$6;
                                }
                              } else {
                                const _x$8 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                                tlen$5 = _param_0;
                                rest$4 = _x$8;
                                b = _x;
                                break _L$6;
                              }
                            } else {
                              const _x$7 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                              tlen$5 = _param_0;
                              rest$4 = _x$7;
                              b = _x;
                              break _L$6;
                            }
                          } else {
                            const _x$6 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                            tlen$5 = _param_0;
                            rest$4 = _x$6;
                            b = _x;
                            break _L$6;
                          }
                        } else {
                          const _x$5 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                          tlen$5 = _param_0;
                          rest$4 = _x$5;
                          b = _x;
                          break _L$6;
                        }
                      } else {
                        const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                        tlen$5 = _param_0;
                        rest$4 = _x$4;
                        b = _x;
                        break _L$6;
                      }
                    } else {
                      const _x$3 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                      tlen$5 = _param_0;
                      rest$4 = _x$3;
                      b = _x;
                      break _L$6;
                    }
                  } else {
                    if (_x >= 194 && _x <= 223) {
                      const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                      if (_x$2 >= 128 && _x$2 <= 191) {
                        const _x$3 = { bytes: _param_1.bytes, start: _param_1.start + 2 | 0, end: _param_1.end };
                        tlen$4 = _param_0;
                        rest$3 = _x$3;
                        b0$3 = _x;
                        b1$3 = _x$2;
                        break _L$5;
                      } else {
                        bytes$3 = _param_1;
                        break _L$2;
                      }
                    } else {
                      if (_x === 224) {
                        const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                        if (_x$2 >= 160 && _x$2 <= 191) {
                          const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                          if (_x$3 >= 128 && _x$3 <= 191) {
                            const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                            tlen$3 = _param_0;
                            b0$2 = _x;
                            b1$2 = _x$2;
                            b2$2 = _x$3;
                            rest$2 = _x$4;
                            break _L$4;
                          } else {
                            bytes$3 = _param_1;
                            break _L$2;
                          }
                        } else {
                          bytes$3 = _param_1;
                          break _L$2;
                        }
                      } else {
                        if (_x >= 225 && _x <= 236) {
                          const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                          if (_x$2 >= 128 && _x$2 <= 191) {
                            const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                            if (_x$3 >= 128 && _x$3 <= 191) {
                              const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                              tlen$3 = _param_0;
                              b0$2 = _x;
                              b1$2 = _x$2;
                              b2$2 = _x$3;
                              rest$2 = _x$4;
                              break _L$4;
                            } else {
                              bytes$3 = _param_1;
                              break _L$2;
                            }
                          } else {
                            bytes$3 = _param_1;
                            break _L$2;
                          }
                        } else {
                          if (_x === 237) {
                            const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                            if (_x$2 >= 128 && _x$2 <= 159) {
                              const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                              if (_x$3 >= 128 && _x$3 <= 191) {
                                const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                                tlen$3 = _param_0;
                                b0$2 = _x;
                                b1$2 = _x$2;
                                b2$2 = _x$3;
                                rest$2 = _x$4;
                                break _L$4;
                              } else {
                                bytes$3 = _param_1;
                                break _L$2;
                              }
                            } else {
                              bytes$3 = _param_1;
                              break _L$2;
                            }
                          } else {
                            if (_x >= 238 && _x <= 239) {
                              const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                              if (_x$2 >= 128 && _x$2 <= 191) {
                                const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                if (_x$3 >= 128 && _x$3 <= 191) {
                                  const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                                  tlen$3 = _param_0;
                                  b0$2 = _x;
                                  b1$2 = _x$2;
                                  b2$2 = _x$3;
                                  rest$2 = _x$4;
                                  break _L$4;
                                } else {
                                  bytes$3 = _param_1;
                                  break _L$2;
                                }
                              } else {
                                bytes$3 = _param_1;
                                break _L$2;
                              }
                            } else {
                              if (_x === 240) {
                                const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                if (_x$2 >= 144 && _x$2 <= 191) {
                                  const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                  if (_x$3 >= 128 && _x$3 <= 191) {
                                    const _x$4 = _param_1.bytes[_param_1.start + 3 | 0];
                                    if (_x$4 >= 128 && _x$4 <= 191) {
                                      const _x$5 = { bytes: _param_1.bytes, start: _param_1.start + 4 | 0, end: _param_1.end };
                                      tlen$2 = _param_0;
                                      b0 = _x;
                                      b1 = _x$2;
                                      b2 = _x$3;
                                      b3 = _x$4;
                                      rest = _x$5;
                                      break _L$3;
                                    } else {
                                      bytes$3 = _param_1;
                                      break _L$2;
                                    }
                                  } else {
                                    bytes$3 = _param_1;
                                    break _L$2;
                                  }
                                } else {
                                  bytes$3 = _param_1;
                                  break _L$2;
                                }
                              } else {
                                if (_x >= 241 && _x <= 243) {
                                  const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                  if (_x$2 >= 128 && _x$2 <= 191) {
                                    const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                    if (_x$3 >= 128 && _x$3 <= 191) {
                                      const _x$4 = _param_1.bytes[_param_1.start + 3 | 0];
                                      if (_x$4 >= 128 && _x$4 <= 191) {
                                        const _x$5 = { bytes: _param_1.bytes, start: _param_1.start + 4 | 0, end: _param_1.end };
                                        tlen$2 = _param_0;
                                        b0 = _x;
                                        b1 = _x$2;
                                        b2 = _x$3;
                                        b3 = _x$4;
                                        rest = _x$5;
                                        break _L$3;
                                      } else {
                                        bytes$3 = _param_1;
                                        break _L$2;
                                      }
                                    } else {
                                      bytes$3 = _param_1;
                                      break _L$2;
                                    }
                                  } else {
                                    bytes$3 = _param_1;
                                    break _L$2;
                                  }
                                } else {
                                  if (_x === 244) {
                                    const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                    if (_x$2 >= 128 && _x$2 <= 143) {
                                      const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                      if (_x$3 >= 128 && _x$3 <= 191) {
                                        const _x$4 = _param_1.bytes[_param_1.start + 3 | 0];
                                        if (_x$4 >= 128 && _x$4 <= 191) {
                                          const _x$5 = { bytes: _param_1.bytes, start: _param_1.start + 4 | 0, end: _param_1.end };
                                          tlen$2 = _param_0;
                                          b0 = _x;
                                          b1 = _x$2;
                                          b2 = _x$3;
                                          b3 = _x$4;
                                          rest = _x$5;
                                          break _L$3;
                                        } else {
                                          bytes$3 = _param_1;
                                          break _L$2;
                                        }
                                      } else {
                                        bytes$3 = _param_1;
                                        break _L$2;
                                      }
                                    } else {
                                      bytes$3 = _param_1;
                                      break _L$2;
                                    }
                                  } else {
                                    bytes$3 = _param_1;
                                    break _L$2;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  const _x = _param_1.bytes[_param_1.start];
                  if (_x >= 0 && _x <= 127) {
                    const _x$2 = { bytes: _param_1.bytes, start: _param_1.start + 1 | 0, end: _param_1.end };
                    tlen$5 = _param_0;
                    rest$4 = _x$2;
                    b = _x;
                    break _L$6;
                  } else {
                    if ((_param_1.end - _param_1.start | 0) >= 2) {
                      if (_x >= 194 && _x <= 223) {
                        const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                        if (_x$2 >= 128 && _x$2 <= 191) {
                          const _x$3 = { bytes: _param_1.bytes, start: _param_1.start + 2 | 0, end: _param_1.end };
                          tlen$4 = _param_0;
                          rest$3 = _x$3;
                          b0$3 = _x;
                          b1$3 = _x$2;
                          break _L$5;
                        } else {
                          if ((_param_1.end - _param_1.start | 0) >= 3) {
                            (_param_1.end - _param_1.start | 0) >= 4;
                            bytes$3 = _param_1;
                            break _L$2;
                          } else {
                            bytes$3 = _param_1;
                            break _L$2;
                          }
                        }
                      } else {
                        if ((_param_1.end - _param_1.start | 0) >= 3) {
                          if (_x === 224) {
                            const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                            if (_x$2 >= 160 && _x$2 <= 191) {
                              const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                              if (_x$3 >= 128 && _x$3 <= 191) {
                                const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                                tlen$3 = _param_0;
                                b0$2 = _x;
                                b1$2 = _x$2;
                                b2$2 = _x$3;
                                rest$2 = _x$4;
                                break _L$4;
                              } else {
                                (_param_1.end - _param_1.start | 0) >= 4;
                                bytes$3 = _param_1;
                                break _L$2;
                              }
                            } else {
                              (_param_1.end - _param_1.start | 0) >= 4;
                              bytes$3 = _param_1;
                              break _L$2;
                            }
                          } else {
                            if (_x >= 225 && _x <= 236) {
                              const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                              if (_x$2 >= 128 && _x$2 <= 191) {
                                const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                if (_x$3 >= 128 && _x$3 <= 191) {
                                  const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                                  tlen$3 = _param_0;
                                  b0$2 = _x;
                                  b1$2 = _x$2;
                                  b2$2 = _x$3;
                                  rest$2 = _x$4;
                                  break _L$4;
                                } else {
                                  (_param_1.end - _param_1.start | 0) >= 4;
                                  bytes$3 = _param_1;
                                  break _L$2;
                                }
                              } else {
                                (_param_1.end - _param_1.start | 0) >= 4;
                                bytes$3 = _param_1;
                                break _L$2;
                              }
                            } else {
                              if (_x === 237) {
                                const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                if (_x$2 >= 128 && _x$2 <= 159) {
                                  const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                  if (_x$3 >= 128 && _x$3 <= 191) {
                                    const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                                    tlen$3 = _param_0;
                                    b0$2 = _x;
                                    b1$2 = _x$2;
                                    b2$2 = _x$3;
                                    rest$2 = _x$4;
                                    break _L$4;
                                  } else {
                                    (_param_1.end - _param_1.start | 0) >= 4;
                                    bytes$3 = _param_1;
                                    break _L$2;
                                  }
                                } else {
                                  (_param_1.end - _param_1.start | 0) >= 4;
                                  bytes$3 = _param_1;
                                  break _L$2;
                                }
                              } else {
                                if (_x >= 238 && _x <= 239) {
                                  const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                  if (_x$2 >= 128 && _x$2 <= 191) {
                                    const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                    if (_x$3 >= 128 && _x$3 <= 191) {
                                      const _x$4 = { bytes: _param_1.bytes, start: _param_1.start + 3 | 0, end: _param_1.end };
                                      tlen$3 = _param_0;
                                      b0$2 = _x;
                                      b1$2 = _x$2;
                                      b2$2 = _x$3;
                                      rest$2 = _x$4;
                                      break _L$4;
                                    } else {
                                      (_param_1.end - _param_1.start | 0) >= 4;
                                      bytes$3 = _param_1;
                                      break _L$2;
                                    }
                                  } else {
                                    (_param_1.end - _param_1.start | 0) >= 4;
                                    bytes$3 = _param_1;
                                    break _L$2;
                                  }
                                } else {
                                  if ((_param_1.end - _param_1.start | 0) >= 4) {
                                    if (_x === 240) {
                                      const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                      if (_x$2 >= 144 && _x$2 <= 191) {
                                        const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                        if (_x$3 >= 128 && _x$3 <= 191) {
                                          const _x$4 = _param_1.bytes[_param_1.start + 3 | 0];
                                          if (_x$4 >= 128 && _x$4 <= 191) {
                                            const _x$5 = { bytes: _param_1.bytes, start: _param_1.start + 4 | 0, end: _param_1.end };
                                            tlen$2 = _param_0;
                                            b0 = _x;
                                            b1 = _x$2;
                                            b2 = _x$3;
                                            b3 = _x$4;
                                            rest = _x$5;
                                            break _L$3;
                                          } else {
                                            bytes$3 = _param_1;
                                            break _L$2;
                                          }
                                        } else {
                                          bytes$3 = _param_1;
                                          break _L$2;
                                        }
                                      } else {
                                        bytes$3 = _param_1;
                                        break _L$2;
                                      }
                                    } else {
                                      if (_x >= 241 && _x <= 243) {
                                        const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                        if (_x$2 >= 128 && _x$2 <= 191) {
                                          const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                          if (_x$3 >= 128 && _x$3 <= 191) {
                                            const _x$4 = _param_1.bytes[_param_1.start + 3 | 0];
                                            if (_x$4 >= 128 && _x$4 <= 191) {
                                              const _x$5 = { bytes: _param_1.bytes, start: _param_1.start + 4 | 0, end: _param_1.end };
                                              tlen$2 = _param_0;
                                              b0 = _x;
                                              b1 = _x$2;
                                              b2 = _x$3;
                                              b3 = _x$4;
                                              rest = _x$5;
                                              break _L$3;
                                            } else {
                                              bytes$3 = _param_1;
                                              break _L$2;
                                            }
                                          } else {
                                            bytes$3 = _param_1;
                                            break _L$2;
                                          }
                                        } else {
                                          bytes$3 = _param_1;
                                          break _L$2;
                                        }
                                      } else {
                                        if (_x === 244) {
                                          const _x$2 = _param_1.bytes[_param_1.start + 1 | 0];
                                          if (_x$2 >= 128 && _x$2 <= 143) {
                                            const _x$3 = _param_1.bytes[_param_1.start + 2 | 0];
                                            if (_x$3 >= 128 && _x$3 <= 191) {
                                              const _x$4 = _param_1.bytes[_param_1.start + 3 | 0];
                                              if (_x$4 >= 128 && _x$4 <= 191) {
                                                const _x$5 = { bytes: _param_1.bytes, start: _param_1.start + 4 | 0, end: _param_1.end };
                                                tlen$2 = _param_0;
                                                b0 = _x;
                                                b1 = _x$2;
                                                b2 = _x$3;
                                                b3 = _x$4;
                                                rest = _x$5;
                                                break _L$3;
                                              } else {
                                                bytes$3 = _param_1;
                                                break _L$2;
                                              }
                                            } else {
                                              bytes$3 = _param_1;
                                              break _L$2;
                                            }
                                          } else {
                                            bytes$3 = _param_1;
                                            break _L$2;
                                          }
                                        } else {
                                          bytes$3 = _param_1;
                                          break _L$2;
                                        }
                                      }
                                    }
                                  } else {
                                    bytes$3 = _param_1;
                                    break _L$2;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          bytes$3 = _param_1;
                          break _L$2;
                        }
                      }
                    } else {
                      bytes$3 = _param_1;
                      break _L$2;
                    }
                  }
                }
              }
            }
            t[tlen$5] = b;
            _tmp$27 = tlen$5 + 2 | 0;
            _tmp$28 = rest$4;
            continue;
          }
          const ch = (b0$3 & 31) << 6 | b1$3 & 63;
          t[tlen$4] = ch & 255;
          t[tlen$4 + 1 | 0] = ch >> 8 & 255;
          _tmp$27 = tlen$4 + 2 | 0;
          _tmp$28 = rest$3;
          continue;
        }
        const ch = (b0$2 & 15) << 12 | (b1$2 & 63) << 6 | b2$2 & 63;
        t[tlen$3] = ch & 255;
        t[tlen$3 + 1 | 0] = ch >> 8 & 255;
        _tmp$27 = tlen$3 + 2 | 0;
        _tmp$28 = rest$2;
        continue;
      }
      const ch = (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
      const chm = ch - 65536 | 0;
      const ch1 = (chm >> 10) + 55296 | 0;
      const ch2 = (chm & 1023) + 56320 | 0;
      t[tlen$2] = ch1 & 255;
      t[tlen$2 + 1 | 0] = ch1 >> 8 & 255;
      t[tlen$2 + 2 | 0] = ch2 & 255;
      t[tlen$2 + 3 | 0] = ch2 >> 8 & 255;
      _tmp$27 = tlen$2 + 4 | 0;
      _tmp$28 = rest;
      continue;
    }
    return new Result$Err$23$(new Error$moonbitlang$47$core$47$encoding$47$utf8$46$Malformed$46$Malformed(bytes$3));
  }
  return new Result$Ok$23$(moonbitlang$core$bytes$$Bytes$to_unchecked_string$46$inner(t, 0, tlen));
}
function moonbitlang$core$env$$now() {
  return moonbitlang$core$env$$now_internal();
}
function moonbitlang$core$builtin$$Show$output$93$(self, logger) {
  logger.method_table.method_0(logger.self, Error$$to_string(self));
}
function moonbitlang$core$math$$scalbn(x, exp) {
  let n = exp;
  let y = x;
  if (n > 1023) {
    y = y * 8.98846567431158e+307;
    n = n - 1023 | 0;
    if (n > 1023) {
      y = y * 8.98846567431158e+307;
      n = n - 1023 | 0;
      if (n > 1023) {
        n = 1023;
      }
    }
  } else {
    if (n < -1022) {
      y = y * 2.00416836000897278e-292;
      n = n + 969 | 0;
      if (n < -1022) {
        y = y * 2.00416836000897278e-292;
        n = n + 969 | 0;
        if (n < -1022) {
          n = -1022;
        }
      }
    }
  }
  const ui = moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(1023 + n | 0), 52);
  return y * moonbitlang$core$uint64$$UInt64$reinterpret_as_double(ui);
}
function hackwaly$tinycc$backend$object$$new_section(name) {
  return { name: name, data: [], relocs: [], align: 4, size_bytes: 0 };
}
function hackwaly$tinycc$backend$object$$reloc_addend(rel) {
  return rel.addend;
}
function hackwaly$tinycc$backend$arm64$$vpushi(value) {
  moonbitlang$core$array$$Array$push$25$(hackwaly$tinycc$backend$arm64$$vstack, { type_t: 3, r: 48, r2: 48, jtrue: 0, jfalse: 0, c_i: moonbitlang$core$int$$Int$to_int64(value), sym: undefined, cmp_op: 0, cmp_r: 0 });
}
function hackwaly$tinycc$backend$arm64$$vpop() {
  if (hackwaly$tinycc$backend$arm64$$vstack.length > 0) {
    moonbitlang$core$array$$Array$pop$25$(hackwaly$tinycc$backend$arm64$$vstack);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$arm64$$vpop_value() {
  const _bind = moonbitlang$core$array$$Array$pop$25$(hackwaly$tinycc$backend$arm64$$vstack);
  if (_bind === undefined) {
    return moonbitlang$core$builtin$$fail$25$("vstack underflow", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:210:13-210:37");
  } else {
    const _Some = _bind;
    const _value = _Some;
    return new Result$Ok$24$(_value);
  }
}
function hackwaly$tinycc$backend$arm64$$vdup() {
  const idx = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
  if (idx >= 0) {
    const val = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx);
    ({ _0: val.jtrue, _1: val.jfalse, _2: val.cmp_op });
    moonbitlang$core$array$$Array$push$25$(hackwaly$tinycc$backend$arm64$$vstack, val);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$arm64$$vswap() {
  const len = hackwaly$tinycc$backend$arm64$$vstack.length;
  if (len < 2) {
    return undefined;
  }
  const idx = len - 1 | 0;
  const tmp = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx);
  moonbitlang$core$array$$Array$set$25$(hackwaly$tinycc$backend$arm64$$vstack, idx, moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx - 1 | 0));
  moonbitlang$core$array$$Array$set$25$(hackwaly$tinycc$backend$arm64$$vstack, idx - 1 | 0, tmp);
}
function hackwaly$tinycc$backend$arm64$$vset_VT_CMP(op) {
  const idx = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
  if (idx >= 0) {
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r = 51;
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).cmp_op = op;
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).jfalse = 0;
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).jtrue = 0;
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$arm64$$get_reg(rc) {
  let r = 0;
  while (true) {
    if (r < 28) {
      if ((moonbitlang$core$array$$Array$at$26$(hackwaly$tinycc$backend$arm64$$reg_classes, r) & rc) !== 0) {
        let used = false;
        const _len = hackwaly$tinycc$backend$arm64$$vstack.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const sv = hackwaly$tinycc$backend$arm64$$vstack[_i];
            const vr = sv.r & 63;
            if (vr === r || sv.r2 === r) {
              used = true;
              break;
            }
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (!used) {
          return new Result$Ok$25$(r);
        }
      }
      r = r + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$builtin$$fail$26$("no free register", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:284:3-284:27");
}
function hackwaly$tinycc$backend$arm64$$arm64_check_offset(invert, sz_, off) {
  const mask32 = 4095 << sz_;
  const mask32_u64 = moonbitlang$core$uint$$UInt$to_uint64(mask32);
  const mask32_not_u64 = moonbitlang$core$uint$$UInt$to_uint64(~mask32);
  const neg_off = moonbitlang$core$builtin$$Sub$sub$6$($0L, off);
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_not_u64), $0L) || (moonbitlang$core$builtin$$Compare$op_lt$80$(off, $256L) || moonbitlang$core$builtin$$Compare$op_le$80$(neg_off, $256L))) {
    return invert ? off : $0L;
  } else {
    if (moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_u64), $0L)) {
      return invert ? moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_u64) : moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_not_u64);
    } else {
      const mask9_u64 = moonbitlang$core$uint$$UInt$to_uint64(511);
      const mask9_not_u64 = moonbitlang$core$uint$$UInt$to_uint64(~511);
      if (moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask9_u64), $0L)) {
        return invert ? moonbitlang$core$builtin$$BitAnd$land$6$(off, mask9_u64) : moonbitlang$core$builtin$$BitAnd$land$6$(off, mask9_not_u64);
      }
    }
  }
  return invert ? $0L : off;
}
function hackwaly$tinycc$backend$arm64$$u64_mask(bits) {
  if (bits <= 0) {
    return $0L;
  }
  return moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$u64_mask$46$one$124$203, bits), $1L);
}
function hackwaly$tinycc$backend$arm64$$arm64_encode_bimm64(value) {
  let x = value;
  const neg = moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(x, $1L), $0L);
  if (neg) {
    x = moonbitlang$core$uint64$$UInt64$lnot(x);
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(x, $0L)) {
    return -1;
  }
  let rep = 64;
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(x, 2), moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(62)))) {
    rep = 2;
    x = moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(2));
  } else {
    if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(x, 4), moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(60)))) {
      rep = 4;
      x = moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(4));
    } else {
      if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(x, 8), moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(56)))) {
        rep = 8;
        x = moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(8));
      } else {
        if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(x, 16), moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(48)))) {
          rep = 16;
          x = moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(16));
        } else {
          if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(x, 32), moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(32)))) {
            rep = 32;
            x = moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(32));
          }
        }
      }
    }
  }
  let pos = 0;
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(32)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 32);
    pos = pos + 32 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(16)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 16);
    pos = pos + 16 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(8)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 8);
    pos = pos + 8 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(4)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 4);
    pos = pos + 4 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(2)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 2);
    pos = pos + 2 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(x, hackwaly$tinycc$backend$arm64$$u64_mask(1)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 1);
    pos = pos + 1 | 0;
  }
  let len = 0;
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$uint64$$UInt64$lnot(x), hackwaly$tinycc$backend$arm64$$u64_mask(32)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 32);
    len = len + 32 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$uint64$$UInt64$lnot(x), hackwaly$tinycc$backend$arm64$$u64_mask(16)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 16);
    len = len + 16 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$uint64$$UInt64$lnot(x), hackwaly$tinycc$backend$arm64$$u64_mask(8)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 8);
    len = len + 8 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$uint64$$UInt64$lnot(x), hackwaly$tinycc$backend$arm64$$u64_mask(4)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 4);
    len = len + 4 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$uint64$$UInt64$lnot(x), hackwaly$tinycc$backend$arm64$$u64_mask(2)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 2);
    len = len + 2 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$uint64$$UInt64$lnot(x), hackwaly$tinycc$backend$arm64$$u64_mask(1)), $0L)) {
    x = moonbitlang$core$builtin$$Shr$shr$6$(x, 1);
    len = len + 1 | 0;
  }
  if (moonbitlang$core$builtin$$Eq$not_equal$80$(x, $0L)) {
    return -1;
  }
  let pos1 = pos;
  let len1 = len;
  if (neg) {
    pos1 = pos1 + len1 & (rep - 1 | 0);
    len1 = rep - len1 | 0;
  }
  return 4096 & rep << 6 | (rep - 1 ^ 31) << 1 & 63 | (rep - pos1 & (rep - 1 | 0)) << 6 | (len1 - 1 | 0);
}
function hackwaly$tinycc$backend$arm64$$arm64_movi(reg, value) {
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(value, moonbitlang$core$uint64$$UInt64$lnot(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191)), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1384120320L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(value, 5)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(value, moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 16))), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1386217472L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shr$shr$6$(value, 11)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(value, moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 32))), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3535798272L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shr$shr$6$(value, 27)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(value, moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 48))), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3537895424L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shr$shr$6$(value, 43)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(value, moonbitlang$core$uint64$$UInt64$lnot(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191)), moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 16))) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($310378496L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint64$$UInt64$lnot(value), 5), $2097120L)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(value, moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 16))), hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($312475648L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(moonbitlang$core$uint64$$UInt64$lnot(value), 11), $2097120L)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$BitOr$lor$6$(value, hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191)), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2457862144L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint64$$UInt64$lnot(value), 5), $2097120L)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$BitOr$lor$6$(value, moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 16))), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2459959296L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(moonbitlang$core$uint64$$UInt64$lnot(value), 11), $2097120L)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$BitOr$lor$6$(value, moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 32))), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2462056448L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(moonbitlang$core$uint64$$UInt64$lnot(value), 27), $2097120L)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$uint64$$UInt64$lnot(moonbitlang$core$builtin$$BitOr$lor$6$(value, moonbitlang$core$builtin$$Shl$shl$6$(hackwaly$tinycc$backend$arm64$$arm64_movi$46$m$124$191, 48))), $0L)) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2464153600L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(moonbitlang$core$uint64$$UInt64$lnot(value), 43), $2097120L)));
  }
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$Shr$shr$6$(value, 32), $0L)) {
    const e = hackwaly$tinycc$backend$arm64$$arm64_encode_bimm64(moonbitlang$core$builtin$$BitOr$lor$6$(value, moonbitlang$core$builtin$$Shl$shl$6$(value, 32)));
    if (e >= 0) {
      return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($838861792L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(e), 10)));
    }
  }
  const e64 = hackwaly$tinycc$backend$arm64$$arm64_encode_bimm64(value);
  if (e64 >= 0) {
    return moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2986345440L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(e64), 10)));
  }
  return 0;
}
function hackwaly$tinycc$backend$arm64$$emit32(emitter, insn) {
  const idx = emitter.code_len;
  if (idx >= emitter.code.length) {
    const current = emitter.code.length;
    let next = current > 0 ? Math.imul(current, 2) | 0 : 64;
    if (next < (idx + 1 | 0)) {
      next = idx + 1 | 0;
    }
    const expanded = moonbitlang$core$array$$Array$make$24$(next, 0);
    let i = 0;
    while (true) {
      if (i < idx) {
        moonbitlang$core$array$$Array$set$24$(expanded, i, moonbitlang$core$array$$Array$at$24$(emitter.code, i));
        i = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    emitter.code = expanded;
  }
  moonbitlang$core$array$$Array$set$24$(emitter.code, idx, insn);
  emitter.code_len = idx + 1 | 0;
}
function hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, reg, value) {
  const insn = hackwaly$tinycc$backend$arm64$$arm64_movi(reg, value);
  if (insn !== 0) {
    hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    return undefined;
  }
  let z = 0;
  let m = 0;
  let mov1 = $3531603968L;
  let x1 = value;
  let i = 0;
  while (true) {
    if (i < 64) {
      if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(value, i), hackwaly$tinycc$backend$arm64$$arm64_movimm$46$mask16$124$183), $0L)) {
        z = z + 1 | 0;
      }
      if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(moonbitlang$core$uint64$$UInt64$lnot(value), i), hackwaly$tinycc$backend$arm64$$arm64_movimm$46$mask16$124$183), $0L)) {
        m = m + 1 | 0;
      }
      i = i + 16 | 0;
      continue;
    } else {
      break;
    }
  }
  if (m > z) {
    x1 = moonbitlang$core$uint64$$UInt64$lnot(value);
    mov1 = $2457862144L;
  }
  i = 0;
  while (true) {
    if (i < 64) {
      const chunk = moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(x1, i), hackwaly$tinycc$backend$arm64$$arm64_movimm$46$mask16$124$183);
      if (moonbitlang$core$builtin$$Eq$not_equal$80$(chunk, $0L)) {
        const insn1 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(mov1, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(chunk, 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(i), 17)));
        hackwaly$tinycc$backend$arm64$$emit32(emitter, insn1);
        i = i + 16 | 0;
        break;
      }
      i = i + 16 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (i < 64) {
      const chunk = moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(value, i), hackwaly$tinycc$backend$arm64$$arm64_movimm$46$mask16$124$183);
      if (moonbitlang$core$builtin$$Eq$not_equal$80$(chunk, $0L)) {
        const insn1 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($4068474880L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(chunk, 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(i), 17)));
        hackwaly$tinycc$backend$arm64$$emit32(emitter, insn1);
      }
      i = i + 16 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$arm64$$arm64_ldrv(emitter, sz_, dst, bas, off) {
  const mask32 = 4095 << sz_;
  const mask32_not_u64 = moonbitlang$core$uint$$UInt$to_uint64(~mask32);
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_not_u64), $0L)) {
    const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1027604480L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(off, 10 - sz_ | 0)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 4), 21)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 3), 30)));
    hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    return;
  } else {
    if (moonbitlang$core$builtin$$Compare$op_lt$80$(off, $256L) || moonbitlang$core$builtin$$Compare$op_le$80$(moonbitlang$core$builtin$$Sub$sub$6$($0L, off), $256L)) {
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1010827264L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, $511L), 12)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 4), 21)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 3), 30)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, off);
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1012951040L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$($30L, 16)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 4), 21)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    }
  }
}
function hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, sg, sz_, dst, bas, off) {
  if (sg && sz_ === 2) {
    const mask32 = 4095 << sz_;
    const mask32_not_u64 = moonbitlang$core$uint$$UInt$to_uint64(~mask32);
    if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_not_u64), $0L)) {
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3112173568L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(off, 10 - sz_ | 0)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    } else {
      if (moonbitlang$core$builtin$$Compare$op_lt$80$(off, $256L) || moonbitlang$core$builtin$$Compare$op_le$80$(moonbitlang$core$builtin$$Sub$sub$6$($0L, off), $256L)) {
        const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3095396352L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, $511L), 12)));
        hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      } else {
        hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, off);
        const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3097520128L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$($30L, 16)));
        hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      }
    }
    return undefined;
  }
  const sg1 = sz_ >= 2 ? false : sg;
  const sg_bit = sg1 ? $1L : $0L;
  const mask32 = 4095 << sz_;
  const mask32_not_u64 = moonbitlang$core$uint$$UInt$to_uint64(~mask32);
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_not_u64), $0L)) {
    const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($960495616L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(off, 10 - sz_ | 0)), moonbitlang$core$builtin$$Shl$shl$6$(sg_bit, 23)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)));
    hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    return;
  } else {
    if (moonbitlang$core$builtin$$Compare$op_lt$80$(off, $256L) || moonbitlang$core$builtin$$Compare$op_le$80$(moonbitlang$core$builtin$$Sub$sub$6$($0L, off), $256L)) {
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($943718400L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, $511L), 12)), moonbitlang$core$builtin$$Shl$shl$6$(sg_bit, 23)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, off);
      const sg_enc = sg1 ? $2L : $1L;
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($941647872L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$($30L, 16)), moonbitlang$core$builtin$$Shl$shl$6$(sg_enc, 22)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    }
  }
}
function hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, op, l, rev, val, x, a) {
  let op1 = op;
  let val1 = val;
  if (op1 === 45 && !rev) {
    val1 = moonbitlang$core$builtin$$Sub$sub$6$($0L, val1);
    op1 = 43;
  }
  if (l === 0) {
    val1 = moonbitlang$core$builtin$$BitAnd$land$6$(val1, $4294967295L);
  }
  _L: {
    const _bind = op1;
    switch (_bind) {
      case 43: {
        const s = l !== 0 ? moonbitlang$core$builtin$$Shr$shr$6$(val1, 63) : moonbitlang$core$builtin$$Shr$shr$6$(val1, 31);
        const s_bit = moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(s, $1L), $0L) ? 1 : 0;
        if (s_bit !== 0) {
          val1 = moonbitlang$core$builtin$$Sub$sub$6$($0L, val1);
        }
        if (l === 0) {
          val1 = moonbitlang$core$builtin$$BitAnd$land$6$(val1, $4294967295L);
        }
        if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(val1, moonbitlang$core$uint64$$UInt64$lnot($4095L)), $0L)) {
          hackwaly$tinycc$backend$arm64$$emit32(emitter, 285212672 | l << 31 | s_bit << 30 | x | a << 5 | moonbitlang$core$uint64$$UInt64$to_int(val1) << 10);
        } else {
          if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(val1, moonbitlang$core$uint64$$UInt64$lnot($16773120L)), $0L)) {
            hackwaly$tinycc$backend$arm64$$emit32(emitter, 289406976 | l << 31 | s_bit << 30 | x | a << 5 | moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$Shr$shr$6$(val1, 12)) << 10);
          } else {
            hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, val1);
            hackwaly$tinycc$backend$arm64$$emit32(emitter, 186515456 | l << 31 | s_bit << 30 | x | a << 5);
          }
        }
        return true;
      }
      case 45: {
        const minus_one = l !== 0 ? moonbitlang$core$uint64$$UInt64$lnot($0L) : $4294967295L;
        if (moonbitlang$core$builtin$$Eq$equal$6$(val1, $0L)) {
          hackwaly$tinycc$backend$arm64$$emit32(emitter, 1258292192 | l << 31 | x | a << 16);
        } else {
          if (moonbitlang$core$builtin$$Eq$equal$6$(val1, minus_one)) {
            hackwaly$tinycc$backend$arm64$$emit32(emitter, 706741216 | l << 31 | x | a << 16);
          } else {
            hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, val1);
            hackwaly$tinycc$backend$arm64$$emit32(emitter, 1258292160 | l << 31 | x | a << 16);
          }
        }
        return true;
      }
      case 94: {
        if (moonbitlang$core$builtin$$Eq$equal$6$(val1, moonbitlang$core$uint64$$UInt64$lnot($0L)) || l === 0 && moonbitlang$core$builtin$$Eq$equal$6$(val1, $4294967295L)) {
          hackwaly$tinycc$backend$arm64$$emit32(emitter, 706741216 | l << 31 | x | a << 16);
          return true;
        }
        const e = hackwaly$tinycc$backend$arm64$$arm64_encode_bimm64(l !== 0 ? val1 : moonbitlang$core$builtin$$BitOr$lor$6$(val1, moonbitlang$core$builtin$$Shl$shl$6$(val1, 32)));
        if (e < 0) {
          return false;
        }
        hackwaly$tinycc$backend$arm64$$emit32(emitter, 1375731712 | l << 31 | x | a << 5 | e << 10);
        return true;
      }
      case 38: {
        const e$2 = hackwaly$tinycc$backend$arm64$$arm64_encode_bimm64(l !== 0 ? val1 : moonbitlang$core$builtin$$BitOr$lor$6$(val1, moonbitlang$core$builtin$$Shl$shl$6$(val1, 32)));
        if (e$2 < 0) {
          return false;
        }
        hackwaly$tinycc$backend$arm64$$emit32(emitter, 301989888 | l << 31 | x | a << 5 | e$2 << 10);
        return true;
      }
      case 124: {
        const e$3 = hackwaly$tinycc$backend$arm64$$arm64_encode_bimm64(l !== 0 ? val1 : moonbitlang$core$builtin$$BitOr$lor$6$(val1, moonbitlang$core$builtin$$Shl$shl$6$(val1, 32)));
        if (e$3 < 0) {
          return false;
        }
        hackwaly$tinycc$backend$arm64$$emit32(emitter, 838860800 | l << 31 | x | a << 5 | e$3 << 10);
        return true;
      }
      case 62: {
        break _L;
      }
      case 60: {
        break _L;
      }
      case 139: {
        break _L;
      }
      default: {
        return false;
      }
    }
  }
  const n = 32 << l;
  if (rev) {
    return false;
  }
  const val2 = moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$BitAnd$land$6$(val1, moonbitlang$core$int$$Int$to_uint64(n - 1 | 0)));
  if (val2 === 0) {
    const base = l !== 0 ? -1442839584 : 704644064;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, base | x | a << 16);
    return true;
  }
  if (op1 === 60) {
    hackwaly$tinycc$backend$arm64$$emit32(emitter, 1392508928 | l << 31 | l << 22 | x | a << 5 | n - val2 << 16 | (n - 1 | 0) - val2 << 10);
  } else {
    hackwaly$tinycc$backend$arm64$$emit32(emitter, 318767104 | (op1 === 139 ? 1 : 0) << 30 | l << 31 | l << 22 | x | a << 5 | val2 << 16 | n - 1 << 10);
  }
  return true;
}
function hackwaly$tinycc$backend$arm64$$arm64_iconst(sv_index) {
  const sv = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, sv_index);
  if ((sv.r & 831) !== 48) {
    return undefined;
  }
  const t = sv.type_t;
  const bt = t & 15;
  if (bt === 4 || bt === 5) {
    return sv.c_i;
  }
  const low = moonbitlang$core$builtin$$BitAnd$land$6$(sv.c_i, $4294967295L);
  if ((t & 16) !== 0) {
    return low;
  }
  const low_u32 = moonbitlang$core$uint64$$UInt64$to_uint(low);
  if ((low_u32 & -2147483648) !== 0) {
    const upper = moonbitlang$core$builtin$$Shl$shl$6$($4294967295L, 32);
    return moonbitlang$core$builtin$$BitOr$lor$6$(low, upper);
  }
  return low;
}
function hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, offset, kind, addend) {
  moonbitlang$core$array$$Array$push$104$(emitter.relocs, { offset: offset, kind: kind, sym: sym, addend: addend });
}
function hackwaly$tinycc$backend$arm64$$arm64_sym(emitter, r, sym, addend) {
  const ind0 = emitter.code_len << 2;
  hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, ind0, 311, $0L);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$($2415919104L, moonbitlang$core$uint$$UInt$to_uint64(r))));
  const ind1 = emitter.code_len << 2;
  hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, ind1, 312, $0L);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($4181721088L, moonbitlang$core$uint$$UInt$to_uint64(r)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(r), 5))));
  if (moonbitlang$core$builtin$$Eq$not_equal$80$(addend, $0L)) {
    if (moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(addend, $4095L), $0L)) {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2432696320L, moonbitlang$core$uint$$UInt$to_uint64(r)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(r), 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$BitAnd$land$6$(addend, $4095L), 10))));
    }
    if (moonbitlang$core$builtin$$Compare$op_gt$80$(addend, $4095L)) {
      if (moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(addend, $16773120L), $0L)) {
        hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2436890624L, moonbitlang$core$uint$$UInt$to_uint64(r)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(r), 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(addend, 12), $4095L), 10))));
      }
      if (moonbitlang$core$builtin$$Compare$op_gt$80$(addend, $16777215L)) {
        const t = r !== 0 ? 0 : 1;
        hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$($4162785248L, moonbitlang$core$uint$$UInt$to_uint64(t))));
        hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, t, moonbitlang$core$builtin$$BitAnd$land$6$(addend, moonbitlang$core$uint64$$UInt64$lnot($16777215L)));
        hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2332033024L, moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(t), 16)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(r), 5)), moonbitlang$core$uint$$UInt$to_uint64(r))));
        hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$($4165011424L, moonbitlang$core$uint$$UInt$to_uint64(t))));
        return;
      } else {
        return;
      }
    } else {
      return;
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$arm64$$arm64_type_size(t) {
  const _bind = t & 15;
  switch (_bind) {
    case 1: {
      return 0;
    }
    case 2: {
      return 1;
    }
    case 3: {
      return 2;
    }
    case 4: {
      return 3;
    }
    case 5: {
      return 3;
    }
    case 6: {
      return 3;
    }
    case 7: {
      return 3;
    }
    case 8: {
      return 2;
    }
    case 9: {
      return 3;
    }
    case 10: {
      return 4;
    }
    case 11: {
      return 0;
    }
    case 0: {
      return 0;
    }
    default: {
      return 0;
    }
  }
}
function hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, t_, a_) {
  let t = t_;
  while (true) {
    if (t !== 0) {
      const idx = t >> 2;
      const next = moonbitlang$core$array$$Array$at$24$(emitter.code, idx);
      const diff = a_ - t | 0;
      if ((diff + 134217728 | 0) >= 268435456) {
        const _bind = moonbitlang$core$builtin$$fail$8$("branch out of range", "@hackwaly/tinycc/backend/arm64:arm64.mbt:487:7-487:34");
        if (_bind.$tag === 1) {
          const _ok = _bind;
          _ok._0;
        } else {
          return _bind;
        }
      }
      let insn;
      if (diff === 4) {
        insn = -721215457;
      } else {
        const imm = diff >> 2 & 67108863;
        insn = 335544320 | imm;
      }
      moonbitlang$core$array$$Array$set$24$(emitter.code, idx, insn);
      t = next;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$26$(undefined);
}
function hackwaly$tinycc$backend$arm64$$gsym(emitter, t) {
  return t !== 0 ? hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, t, emitter.code_len << 2) : new Result$Ok$26$(undefined);
}
function hackwaly$tinycc$backend$arm64$$gv(emitter, rc) {
  const idx = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
  if (idx < 0) {
    const _bind = moonbitlang$core$builtin$$fail$8$("gv empty", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:251:5-251:21");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  const sv = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx);
  const r = sv.r & 63;
  const r_ok = (sv.r & 256) === 0 && (r < 48 && (moonbitlang$core$array$$Array$at$26$(hackwaly$tinycc$backend$arm64$$reg_classes, r) & rc) !== 0);
  if (!r_ok) {
    const _bind = hackwaly$tinycc$backend$arm64$$get_reg(rc);
    let r1;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      r1 = _ok._0;
    } else {
      return _bind;
    }
    const _bind$2 = hackwaly$tinycc$backend$arm64$$load(emitter, r1, idx);
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r = r1;
    return new Result$Ok$25$(r1);
  }
  return new Result$Ok$25$(r);
}
function hackwaly$tinycc$backend$arm64$$load(emitter, r, sv_index) {
  const sv = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, sv_index);
  const svtt = sv.type_t;
  const svr = sv.r;
  const svrv = svr & 63;
  let svcul = moonbitlang$core$builtin$$BitAnd$land$6$(sv.c_i, $4294967295L);
  if (moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shr$shr$6$(svcul, 31), $1L), $0L)) {
    svcul = moonbitlang$core$builtin$$Sub$sub$6$(svcul, moonbitlang$core$builtin$$Shl$shl$6$($1L, 32));
  }
  if (svr === 306) {
    if (r >= 20) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrv(emitter, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r - 20 | 0, 29, svcul);
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, (svtt & 16) === 0, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r < 19 ? r : 30, 29, svcul);
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr === 304) {
    let i = sv.c_i;
    const _bind = sv.sym;
    if (_bind === undefined) {
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, i);
      i = $0L;
    } else {
      const _Some = _bind;
      const _sym = _Some;
      const off = hackwaly$tinycc$backend$arm64$$arm64_check_offset(false, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), i);
      hackwaly$tinycc$backend$arm64$$arm64_sym(emitter, 30, _sym, off);
    }
    if (r >= 20) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrv(emitter, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r - 20 | 0, 30, hackwaly$tinycc$backend$arm64$$arm64_check_offset(true, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), i));
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, (svtt & 16) === 0, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r < 19 ? r : 30, 30, hackwaly$tinycc$backend$arm64$$arm64_check_offset(true, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), i));
    }
    return new Result$Ok$26$(undefined);
  }
  if ((svr & ~63) === 256 && svrv < 48) {
    if ((svtt & 15) !== 0) {
      if (r >= 20) {
        hackwaly$tinycc$backend$arm64$$arm64_ldrv(emitter, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r - 20 | 0, svrv < 19 ? svrv : 30, $0L);
      } else {
        hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, (svtt & 16) === 0, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r < 19 ? r : 30, svrv < 19 ? svrv : 30, $0L);
      }
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr === 816) {
    const off = hackwaly$tinycc$backend$arm64$$arm64_check_offset(false, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), svcul);
    const _bind = sv.sym;
    if (_bind === undefined) {
      const _bind$2 = moonbitlang$core$builtin$$fail$8$("missing symbol for VT_SYM", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:717:15-717:48");
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _ok._0;
      } else {
        return _bind$2;
      }
    } else {
      const _Some = _bind;
      const _sym = _Some;
      hackwaly$tinycc$backend$arm64$$arm64_sym(emitter, 30, _sym, off);
    }
    if (r >= 20) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrv(emitter, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r - 20 | 0, 30, hackwaly$tinycc$backend$arm64$$arm64_check_offset(true, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), svcul));
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, (svtt & 16) === 0, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r < 19 ? r : 30, 30, hackwaly$tinycc$backend$arm64$$arm64_check_offset(true, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), svcul));
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr === 560) {
    const _bind = sv.sym;
    if (_bind === undefined) {
      const _bind$2 = moonbitlang$core$builtin$$fail$8$("missing symbol for VT_SYM", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:742:15-742:48");
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _ok._0;
      } else {
        return _bind$2;
      }
    } else {
      const _Some = _bind;
      const _sym = _Some;
      hackwaly$tinycc$backend$arm64$$arm64_sym(emitter, r < 19 ? r : 30, _sym, svcul);
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr === 48) {
    if ((svtt & 15) !== 0) {
      const value = hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt) === 3 ? sv.c_i : svcul;
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, r < 19 ? r : 30, value);
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr < 48) {
    if (r >= 20 && svr >= 20) {
      if (svtt === 10) {
        hackwaly$tinycc$backend$arm64$$emit32(emitter, 1319115776 | (r - 20 | svr - 20 << 5));
      } else {
        hackwaly$tinycc$backend$arm64$$emit32(emitter, 509624320 | (r - 20 | svr - 20 << 5));
      }
    } else {
      if (!(r >= 20) && !(svr >= 20)) {
        hackwaly$tinycc$backend$arm64$$emit32(emitter, -1442839584 | (r < 19 ? r : 30) | (svr < 19 ? svr : 30) << 16);
      } else {
        const _bind = moonbitlang$core$builtin$$fail$8$("mismatched register class", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:783:7-783:40");
        if (_bind.$tag === 1) {
          const _ok = _bind;
          _ok._0;
        } else {
          return _bind;
        }
      }
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr === 50) {
    const neg = moonbitlang$core$builtin$$Sub$sub$6$($0L, svcul);
    if (moonbitlang$core$builtin$$Compare$op_lt$80$(neg, $4096L)) {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, -788528224 | (r < 19 ? r : 30) | moonbitlang$core$int64$$Int64$to_int(neg) << 10);
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, neg);
      hackwaly$tinycc$backend$arm64$$emit32(emitter, -889191520 | (r < 19 ? r : 30) | 1966080);
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr === 52 || svr === 53) {
    const t = svr === 53 ? 1 : 0;
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, r < 19 ? r : 30, moonbitlang$core$int$$Int$to_uint64(t));
    hackwaly$tinycc$backend$arm64$$emit32(emitter, 335544322);
    const _bind = hackwaly$tinycc$backend$arm64$$gsym(emitter, moonbitlang$core$int64$$Int64$to_int(svcul));
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, r < 19 ? r : 30, moonbitlang$core$int$$Int$to_uint64(1 - t | 0));
    return new Result$Ok$26$(undefined);
  }
  if (svr === 305) {
    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, 30, 29, svcul);
    if (r >= 20) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrv(emitter, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r - 20 | 0, 30, $0L);
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, (svtt & 16) === 0, hackwaly$tinycc$backend$arm64$$arm64_type_size(svtt), r < 19 ? r : 30, 30, $0L);
    }
    return new Result$Ok$26$(undefined);
  }
  if (svr === 51) {
    const _bind = hackwaly$tinycc$backend$arm64$$arm64_load_cmp(emitter, r, sv_index);
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
    return new Result$Ok$26$(undefined);
  }
  return moonbitlang$core$builtin$$fail$8$("unsupported load", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:840:3-840:27");
}
function hackwaly$tinycc$backend$arm64$$arm64_load_cmp(emitter, r, sv_index) {
  moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, sv_index).r = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, sv_index).cmp_r;
  if (moonbitlang$core$builtin$$Eq$not_equal$81$(moonbitlang$core$builtin$$BitAnd$land$7$(moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, sv_index).c_i, $1L), $0L)) {
    hackwaly$tinycc$backend$arm64$$vpushi(1);
    const _bind = hackwaly$tinycc$backend$arm64$$arm64_gen_opil(emitter, 94, 0);
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  if (r !== moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, sv_index).r) {
    const _bind = hackwaly$tinycc$backend$arm64$$load(emitter, r, sv_index);
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, sv_index).r = r;
  }
  return new Result$Ok$26$(undefined);
}
function hackwaly$tinycc$backend$arm64$$arm64_gen_opil(emitter, op, l) {
  let rev = true;
  if ((hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0) >= 0) {
    const _bind = hackwaly$tinycc$backend$arm64$$arm64_iconst(hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0);
    if (_bind === undefined) {
    } else {
      hackwaly$tinycc$backend$arm64$$vswap();
      rev = false;
    }
  }
  const idx = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
  if (idx >= 1) {
    const left_idx = idx - 1 | 0;
    const _bind = hackwaly$tinycc$backend$arm64$$arm64_iconst(left_idx);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _val = _Some;
      const _bind$2 = hackwaly$tinycc$backend$arm64$$gv(emitter, 1);
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _ok._0;
      } else {
        return _bind$2;
      }
      const _p$28 = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r;
      const a = _p$28 < 19 ? _p$28 : 30;
      const _bind$3 = hackwaly$tinycc$backend$arm64$$vpop_value();
      let saved;
      if (_bind$3.$tag === 1) {
        const _ok = _bind$3;
        saved = _ok._0;
      } else {
        return _bind$3;
      }
      const _bind$4 = hackwaly$tinycc$backend$arm64$$get_reg(1);
      let x;
      if (_bind$4.$tag === 1) {
        const _ok = _bind$4;
        x = _ok._0;
      } else {
        return _bind$4;
      }
      moonbitlang$core$array$$Array$push$25$(hackwaly$tinycc$backend$arm64$$vstack, saved);
      if (hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, op, l, rev, _val, x < 19 ? x : 30, a)) {
        moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r = x;
        hackwaly$tinycc$backend$arm64$$vswap();
        hackwaly$tinycc$backend$arm64$$vpop();
        return new Result$Ok$26$(undefined);
      }
    }
  }
  if (!rev) {
    hackwaly$tinycc$backend$arm64$$vswap();
  }
  const _bind = hackwaly$tinycc$backend$arm64$$gv2(emitter, 1, 1);
  if (_bind.$tag === 1) {
    const _ok = _bind;
    _ok._0;
  } else {
    return _bind;
  }
  const idx2 = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
  const _p$28 = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx2 - 1 | 0).r;
  const a = _p$28 < 19 ? _p$28 : 30;
  const _p$29 = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx2).r;
  const b = _p$29 < 19 ? _p$29 : 30;
  const _bind$2 = hackwaly$tinycc$backend$arm64$$vpop_value();
  if (_bind$2.$tag === 1) {
    const _ok = _bind$2;
    _ok._0;
  } else {
    return _bind$2;
  }
  const _bind$3 = hackwaly$tinycc$backend$arm64$$vpop_value();
  let left;
  if (_bind$3.$tag === 1) {
    const _ok = _bind$3;
    left = _ok._0;
  } else {
    return _bind$3;
  }
  const _bind$4 = hackwaly$tinycc$backend$arm64$$get_reg(1);
  let x;
  if (_bind$4.$tag === 1) {
    const _ok = _bind$4;
    x = _ok._0;
  } else {
    return _bind$4;
  }
  left.r = x;
  moonbitlang$core$array$$Array$push$25$(hackwaly$tinycc$backend$arm64$$vstack, left);
  const x1 = x < 19 ? x : 30;
  switch (op) {
    case 37: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 448793600 | l << 31 | 30 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 453017600 | l << 31 | x1 | 960 | b << 16 | a << 10));
    }
    case 38: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 167772160 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 42: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 453016576 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 43: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 184549376 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 45: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 1258291200 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 47: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 448793600 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 133: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 448793600 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 94: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 1241513984 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 124: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 704643072 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 148: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446633952 | x1));
    }
    case 157: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446674912 | x1));
    }
    case 159: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446683104 | x1));
    }
    case 158: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446679008 | x1));
    }
    case 156: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446670816 | x1));
    }
    case 149: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446629856 | x1));
    }
    case 62: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 448800768 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 60: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 448798720 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 139: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 448799744 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 131: {
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 448792576 | l << 31 | x1 | a << 5 | b << 16));
    }
    case 147: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446642144 | x1));
    }
    case 151: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446666720 | x1));
    }
    case 146: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446638048 | x1));
    }
    case 150: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1795162143 | l << 31 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 446662624 | x1));
    }
    case 132: {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 448792576 | l << 31 | 30 | a << 5 | b << 16);
      return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, 453017600 | l << 31 | x1 | 960 | b << 16 | a << 10));
    }
    default: {
      return moonbitlang$core$builtin$$fail$8$("unsupported op", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:626:10-626:32");
    }
  }
}
function hackwaly$tinycc$backend$arm64$$gv2(emitter, rc1, rc2) {
  const idx = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
  if (idx < 1) {
    const _bind = moonbitlang$core$builtin$$fail$8$("gv2 stack underflow", "@hackwaly/tinycc/backend/arm64:codegen_state.mbt:291:5-291:32");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  if (moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r !== 51 && rc1 <= rc2) {
    hackwaly$tinycc$backend$arm64$$vswap();
    const _bind = hackwaly$tinycc$backend$arm64$$gv(emitter, rc1);
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
    hackwaly$tinycc$backend$arm64$$vswap();
    const _bind$2 = hackwaly$tinycc$backend$arm64$$gv(emitter, rc2);
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
    if ((moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx - 1 | 0).r & 63) >= 48) {
      hackwaly$tinycc$backend$arm64$$vswap();
      const _bind$3 = hackwaly$tinycc$backend$arm64$$gv(emitter, rc1);
      if (_bind$3.$tag === 1) {
        const _ok = _bind$3;
        _ok._0;
      } else {
        return _bind$3;
      }
      hackwaly$tinycc$backend$arm64$$vswap();
    }
  } else {
    const _bind = hackwaly$tinycc$backend$arm64$$gv(emitter, rc2);
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
    hackwaly$tinycc$backend$arm64$$vswap();
    const _bind$2 = hackwaly$tinycc$backend$arm64$$gv(emitter, rc1);
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
    hackwaly$tinycc$backend$arm64$$vswap();
    if ((moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r & 63) >= 48) {
      const _bind$3 = hackwaly$tinycc$backend$arm64$$gv(emitter, rc2);
      if (_bind$3.$tag === 1) {
        const _ok = _bind$3;
        _ok._0;
      } else {
        return _bind$3;
      }
    }
  }
  return new Result$Ok$26$(undefined);
}
function hackwaly$tinycc$backend$arm64$$treg_r(x) {
  return x;
}
function hackwaly$tinycc$backend$arm64$$treg_f(x) {
  return 20 + x | 0;
}
function hackwaly$tinycc$backend$arm64$$new_arm64_emitter() {
  return { code: [], code_len: 0, relocs: [] };
}
function hackwaly$tinycc$backend$arm64$$new_arm64_emitter_with_capacity(code_capacity, reloc_capacity) {
  if (code_capacity <= 0 && reloc_capacity <= 0) {
    return hackwaly$tinycc$backend$arm64$$new_arm64_emitter();
  }
  const code_cap = code_capacity > 0 ? code_capacity : 0;
  const reloc_cap = reloc_capacity > 0 ? reloc_capacity : 0;
  return { code: code_cap > 0 ? moonbitlang$core$array$$Array$make$24$(code_cap, 0) : [], code_len: 0, relocs: moonbitlang$core$array$$Array$new$46$inner$104$(reloc_cap) };
}
function hackwaly$tinycc$backend$arm64$$section_from_emitter(name, emitter) {
  const code_len = emitter.code_len;
  const data = moonbitlang$core$array$$Array$make$24$(code_len, 0);
  let i = 0;
  while (true) {
    if (i < code_len) {
      moonbitlang$core$array$$Array$set$24$(data, i, moonbitlang$core$array$$Array$at$24$(emitter.code, i));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { name: name, data: data, relocs: moonbitlang$core$array$$Array$copy$104$(emitter.relocs), align: 4, size_bytes: code_len << 2 };
}
function hackwaly$tinycc$backend$arm64$$section_from_emitter_take(name, emitter) {
  const code_len = emitter.code_len;
  return { name: name, data: emitter.code, relocs: emitter.relocs, align: 4, size_bytes: code_len << 2 };
}
function hackwaly$tinycc$backend$arm64$$greloc(emitter, sym, offset, kind) {
  hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, offset, kind, $0L);
}
function hackwaly$tinycc$backend$arm64$$gind(emitter) {
  return emitter.code_len << 2;
}
function hackwaly$tinycc$backend$arm64$$gjmp(emitter, t) {
  const r = emitter.code_len << 2;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, t);
  return r;
}
function hackwaly$tinycc$backend$arm64$$gjmp_addr(emitter, a) {
  const ind = emitter.code_len << 2;
  if (((a - ind | 0) + 134217728 | 0) >= 268435456) {
    const _bind = moonbitlang$core$builtin$$fail$8$("branch out of range", "@hackwaly/tinycc/backend/arm64:arm64.mbt:523:5-523:32");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  const imm = a - ind >> 2 & 67108863;
  const insn = 335544320 | imm;
  return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, insn));
}
function hackwaly$tinycc$backend$arm64$$gjmp_append(emitter, n, t) {
  let t1 = t;
  let n1 = n;
  if (n1 !== 0) {
    while (true) {
      const idx = n1 >> 2;
      const next = moonbitlang$core$array$$Array$at$24$(emitter.code, idx);
      if (next === 0) {
        moonbitlang$core$array$$Array$set$24$(emitter.code, idx, t1);
        break;
      }
      n1 = next;
      continue;
    }
    t1 = n;
  }
  return t1;
}
function hackwaly$tinycc$backend$arm64$$gen_fill_nops(emitter, bytes) {
  let remaining = bytes;
  if ((remaining & 3) !== 0) {
    const _bind = moonbitlang$core$builtin$$fail$8$("alignment of code section not multiple of 4", "@hackwaly/tinycc/backend/arm64:arm64.mbt:553:5-553:56");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  while (true) {
    if (remaining > 0) {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, -721215457);
      remaining = remaining - 4 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$26$(undefined);
}
function hackwaly$tinycc$backend$arm64$$arm64_vset_VT_CMP(op) {
  if (op >= 146 && op <= 159) {
    const idx = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).cmp_r = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r;
    hackwaly$tinycc$backend$arm64$$vset_VT_CMP(128);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$arm64$$gjmp_cond(emitter, op, t) {
  const idx = hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0;
  const bt = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).type_t & 15;
  const inv = op & 1;
  moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).r = moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, idx).cmp_r;
  if (bt === 10) {
    const _bind = hackwaly$tinycc$backend$arm64$$gv(emitter, 2);
    let _p$28;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _p$28 = _ok._0;
    } else {
      return _bind;
    }
    const f = _p$28 - 20 | 0;
    const _bind$2 = hackwaly$tinycc$backend$arm64$$get_reg(1);
    let a0;
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      a0 = _ok._0;
    } else {
      return _bind$2;
    }
    hackwaly$tinycc$backend$arm64$$vpushi(0);
    moonbitlang$core$array$$Array$at$25$(hackwaly$tinycc$backend$arm64$$vstack, hackwaly$tinycc$backend$arm64$$vstack.length - 1 | 0).r = a0;
    const _bind$3 = hackwaly$tinycc$backend$arm64$$get_reg(1);
    let b0;
    if (_bind$3.$tag === 1) {
      const _ok = _bind$3;
      b0 = _ok._0;
    } else {
      return _bind$3;
    }
    const a = a0 < 19 ? a0 : 30;
    const b = b0 < 19 ? b0 : 30;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, 1309162496 | a | f << 5);
    hackwaly$tinycc$backend$arm64$$emit32(emitter, 1310211072 | b | f << 5);
    hackwaly$tinycc$backend$arm64$$emit32(emitter, -1442839552 | a | a << 5 | b << 16);
    const inv_bit = inv !== 0 ? 1 : 0;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, -1275068352 | a | inv_bit << 24);
    hackwaly$tinycc$backend$arm64$$vpop();
  } else {
    if (bt === 8 || bt === 9) {
      const _bind = hackwaly$tinycc$backend$arm64$$gv(emitter, 2);
      let _p$28;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _p$28 = _ok._0;
      } else {
        return _bind;
      }
      const a = _p$28 - 20 | 0;
      const is_double = bt !== 8 ? 1 : 0;
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 505421832 | a << 5 | is_double << 22);
      const inv_bit = inv !== 0 ? 1 : 0;
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 1409286208 | inv_bit);
    } else {
      const ll = bt === 5 || bt === 4;
      const _bind = hackwaly$tinycc$backend$arm64$$gv(emitter, 1);
      let _p$28;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _p$28 = _ok._0;
      } else {
        return _bind;
      }
      const a = _p$28 < 19 ? _p$28 : 30;
      const inv_bit = inv !== 0 ? 1 : 0;
      const ll_bit = ll ? 1 : 0;
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 872415296 | a | inv_bit << 24 | ll_bit << 31);
    }
  }
  return new Result$Ok$25$(hackwaly$tinycc$backend$arm64$$gjmp(emitter, t));
}
function hackwaly$tinycc$backend$arm64$$arm64_spoff(emitter, reg, off) {
  const sub = moonbitlang$core$builtin$$Shr$shr$6$(off, 63);
  let off1 = off;
  if (moonbitlang$core$builtin$$Eq$not_equal$80$(sub, $0L)) {
    off1 = moonbitlang$core$builtin$$Sub$sub$6$($0L, off);
  }
  if (moonbitlang$core$builtin$$Compare$op_lt$80$(off1, $4096L)) {
    const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2432697312L, moonbitlang$core$builtin$$Shl$shl$6$(sub, 30)), moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(off1, 10)));
    hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    return;
  } else {
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, off1);
    const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2336121824L, moonbitlang$core$builtin$$Shl$shl$6$(sub, 30)), moonbitlang$core$uint$$UInt$to_uint64(reg)));
    hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    return;
  }
}
function hackwaly$tinycc$backend$arm64$$arm64_ldrs(emitter, reg, size) {
  switch (size) {
    case 0: {
      return;
    }
    case 1: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, reg, reg, $0L);
      return;
    }
    case 2: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 1, reg, reg, $0L);
      return;
    }
    case 3: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 1, 30, reg, $0L);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, reg, reg, $2L);
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($704660416L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(reg), 16)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    }
    case 4: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, reg, reg, $0L);
      return;
    }
    case 5: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, 30, reg, $0L);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, reg, reg, $4L);
      const insn$2 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2852160448L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(reg), 16)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn$2);
      return;
    }
    case 6: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, 30, reg, $0L);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 1, reg, reg, $4L);
      const insn$3 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2852160448L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(reg), 16)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn$3);
      return;
    }
    case 7: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, 30, reg, $0L);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, reg, reg, $3L);
      const insn1 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1393064960L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(reg), 5)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn1);
      const insn2 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2852160448L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(reg), 16)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn2);
      return;
    }
    case 8: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 9: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, (reg >>> 0) + (1 >>> 0) | 0, reg, $8L);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 10: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 1, (reg >>> 0) + (1 >>> 0) | 0, reg, $8L);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 11: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, (reg >>> 0) + (1 >>> 0) | 0, reg, $7L);
      const insn$4 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1393064960L, moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0), 5)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn$4);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 12: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, (reg >>> 0) + (1 >>> 0) | 0, reg, $8L);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 13: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, (reg >>> 0) + (1 >>> 0) | 0, reg, $5L);
      const insn$5 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3545824256L, moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0), 5)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn$5);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 14: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, (reg >>> 0) + (1 >>> 0) | 0, reg, $6L);
      const insn$6 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3545299968L, moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0), 5)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn$6);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 15: {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, (reg >>> 0) + (1 >>> 0) | 0, reg, $7L);
      const insn$7 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($3544775680L, moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0), 5)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn$7);
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, reg, $0L);
      return;
    }
    case 16: {
      const insn$8 = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2839543808L, moonbitlang$core$uint$$UInt$to_uint64(reg)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64((reg >>> 0) + (1 >>> 0) | 0), 10)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(reg), 5)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn$8);
      return;
    }
    default: {
      return;
    }
  }
}
function hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz_, dst, bas, off) {
  const mask32 = 4095 << sz_;
  const mask32_not_u64 = moonbitlang$core$uint$$UInt$to_uint64(~mask32);
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_not_u64), $0L)) {
    const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($956301312L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(off, 10 - sz_ | 0)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)));
    hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    return;
  } else {
    if (moonbitlang$core$builtin$$Compare$op_lt$80$(off, $256L) || moonbitlang$core$builtin$$Compare$op_le$80$(moonbitlang$core$builtin$$Sub$sub$6$($0L, off), $256L)) {
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($939524096L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, $511L), 12)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, off);
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($941647872L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$($30L, 16)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    }
  }
}
function hackwaly$tinycc$backend$arm64$$arm64_strv(emitter, sz_, dst, bas, off) {
  const mask32 = 4095 << sz_;
  const mask32_not_u64 = moonbitlang$core$uint$$UInt$to_uint64(~mask32);
  if (moonbitlang$core$builtin$$Eq$equal$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, mask32_not_u64), $0L)) {
    const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1023410176L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(off, 10 - sz_ | 0)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 4), 21)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 3), 30)));
    hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
    return;
  } else {
    if (moonbitlang$core$builtin$$Compare$op_lt$80$(off, $256L) || moonbitlang$core$builtin$$Compare$op_le$80$(moonbitlang$core$builtin$$Sub$sub$6$($0L, off), $256L)) {
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1006632960L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$BitAnd$land$6$(off, $511L), 12)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 4), 21)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 3), 30)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 30, off);
      const insn = moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($1008756736L, moonbitlang$core$uint$$UInt$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$uint$$UInt$to_uint64(bas), 5)), moonbitlang$core$builtin$$Shl$shl$6$($30L, 16)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_), 30)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(sz_ & 4), 21)));
      hackwaly$tinycc$backend$arm64$$emit32(emitter, insn);
      return;
    }
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$154$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$154$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$154$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$155$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$155$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$155$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$156$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$156$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$156$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$157$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$157$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$157$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$158$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$158$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$158$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$159$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$159$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$159$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$160$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$160$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$160$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$161$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$161$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$161$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$162$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$162$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$162$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$163$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$163$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$163$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$164$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$164$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$164$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$165$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$165$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$165$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$166$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$166$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$166$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$167$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$167$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$167$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$168$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$168$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$168$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$169$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$169$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$169$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$170$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$170$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$170$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$171$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$171$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$171$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$172$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$172$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$172$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$173$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$173$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$173$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$174$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$174$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$174$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$175$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$175$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$175$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$136$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$136$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$136$(_value);
  }
}
function hackwaly$tinycc$support$util$fast_map$$fast_map_new$137$(capacity) {
  if (capacity === undefined) {
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$137$(8);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return moonbitlang$core$hashmap$$HashMap$new$46$inner$137$(_value);
  }
}
function hackwaly$tinycc$support$util$string_utils$$slice_string(text, start, end) {
  return moonbitlang$core$builtin$$Show$to_string$12$(moonbitlang$core$string$$String$view$46$inner(text, start, end));
}
function hackwaly$tinycc$support$util$string_utils$$hex_digit_value(code) {
  if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 57)) {
    return code - 48 | 0;
  }
  if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 70)) {
    return (code - 65 | 0) + 10 | 0;
  }
  if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 102)) {
    return (code - 97 | 0) + 10 | 0;
  }
  return undefined;
}
function hackwaly$tinycc$support$util$int_literals$$is_bin_digit_code(code) {
  const _p$28 = 48;
  if (code === _p$28) {
    return true;
  } else {
    const _p$29 = 49;
    return code === _p$29;
  }
}
function hackwaly$tinycc$support$util$int_literals$$is_dec_digit_code(code) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 57);
}
function hackwaly$tinycc$support$util$int_literals$$is_hex_digit_code(code) {
  return hackwaly$tinycc$support$util$int_literals$$is_dec_digit_code(code) || (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 70) || moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 102));
}
function hackwaly$tinycc$support$util$int_literals$$is_oct_digit_code(code) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 55);
}
function hackwaly$tinycc$support$util$int_literals$$scan_digits(text, start, accept) {
  let i = start;
  while (true) {
    if (i < text.length) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      if (!accept(text.charCodeAt(_tmp$27))) {
        break;
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return i;
}
function hackwaly$tinycc$support$util$int_literals$$int_literal_end(text) {
  const len = text.length;
  if (len === 0) {
    return 0;
  }
  $bound_check(text, 0);
  const first = text.charCodeAt(0);
  const _p$28 = 48;
  if (first === _p$28) {
    if (len >= 2) {
      $bound_check(text, 1);
      const next = text.charCodeAt(1);
      let _tmp$27;
      const _p$29 = 120;
      if (next === _p$29) {
        _tmp$27 = true;
      } else {
        const _p$30 = 88;
        _tmp$27 = next === _p$30;
      }
      if (_tmp$27) {
        return hackwaly$tinycc$support$util$int_literals$$scan_digits(text, 2, hackwaly$tinycc$support$util$int_literals$$is_hex_digit_code);
      }
      let _tmp$28;
      const _p$30 = 98;
      if (next === _p$30) {
        _tmp$28 = true;
      } else {
        const _p$31 = 66;
        _tmp$28 = next === _p$31;
      }
      if (_tmp$28) {
        return hackwaly$tinycc$support$util$int_literals$$scan_digits(text, 2, hackwaly$tinycc$support$util$int_literals$$is_bin_digit_code);
      }
      return hackwaly$tinycc$support$util$int_literals$$scan_digits(text, 1, hackwaly$tinycc$support$util$int_literals$$is_oct_digit_code);
    }
    return 1;
  }
  return hackwaly$tinycc$support$util$int_literals$$scan_digits(text, 0, hackwaly$tinycc$support$util$int_literals$$is_dec_digit_code);
}
function hackwaly$tinycc$support$util$int_literals$$int_literal_base(text) {
  const trimmed = hackwaly$tinycc$support$util$string_utils$$slice_string(text, 0, hackwaly$tinycc$support$util$int_literals$$int_literal_end(text));
  let _tmp$27;
  if (trimmed.length >= 2) {
    $bound_check(trimmed, 0);
    const _p$28 = trimmed.charCodeAt(0);
    const _p$29 = 48;
    _tmp$27 = _p$28 === _p$29;
  } else {
    _tmp$27 = false;
  }
  if (_tmp$27) {
    $bound_check(trimmed, 1);
    const next = trimmed.charCodeAt(1);
    let _tmp$28;
    const _p$28 = 120;
    if (next === _p$28) {
      _tmp$28 = true;
    } else {
      const _p$29 = 88;
      _tmp$28 = next === _p$29;
    }
    if (_tmp$28) {
      return 16;
    }
    let _tmp$29;
    const _p$29 = 98;
    if (next === _p$29) {
      _tmp$29 = true;
    } else {
      const _p$30 = 66;
      _tmp$29 = next === _p$30;
    }
    if (_tmp$29) {
      return 2;
    }
    return 8;
  }
  return 10;
}
function hackwaly$tinycc$support$util$int_literals$$digit_value(code) {
  return hackwaly$tinycc$support$util$int_literals$$is_dec_digit_code(code) ? code - 48 | 0 : moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 70) ? (code - 65 | 0) + 10 | 0 : moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 102) ? (code - 97 | 0) + 10 | 0 : undefined;
}
function hackwaly$tinycc$support$util$int_literals$$parse_uint64_literal(text, base) {
  let value = $0L;
  let i = 0;
  let _tmp$27;
  if (base === 16) {
    let _tmp$28;
    if (text.length >= 2) {
      let _tmp$29;
      $bound_check(text, 0);
      const _p$28 = text.charCodeAt(0);
      const _p$29 = 48;
      if (_p$28 === _p$29) {
        let _tmp$30;
        $bound_check(text, 1);
        const _p$30 = text.charCodeAt(1);
        const _p$31 = 120;
        if (_p$30 === _p$31) {
          _tmp$30 = true;
        } else {
          $bound_check(text, 1);
          const _p$32 = text.charCodeAt(1);
          const _p$33 = 88;
          _tmp$30 = _p$32 === _p$33;
        }
        _tmp$29 = _tmp$30;
      } else {
        _tmp$29 = false;
      }
      _tmp$28 = _tmp$29;
    } else {
      _tmp$28 = false;
    }
    _tmp$27 = _tmp$28;
  } else {
    _tmp$27 = false;
  }
  if (_tmp$27) {
    i = 2;
  } else {
    let _tmp$28;
    if (base === 2) {
      let _tmp$29;
      if (text.length >= 2) {
        let _tmp$30;
        $bound_check(text, 0);
        const _p$28 = text.charCodeAt(0);
        const _p$29 = 48;
        if (_p$28 === _p$29) {
          let _tmp$31;
          $bound_check(text, 1);
          const _p$30 = text.charCodeAt(1);
          const _p$31 = 98;
          if (_p$30 === _p$31) {
            _tmp$31 = true;
          } else {
            $bound_check(text, 1);
            const _p$32 = text.charCodeAt(1);
            const _p$33 = 66;
            _tmp$31 = _p$32 === _p$33;
          }
          _tmp$30 = _tmp$31;
        } else {
          _tmp$30 = false;
        }
        _tmp$29 = _tmp$30;
      } else {
        _tmp$29 = false;
      }
      _tmp$28 = _tmp$29;
    } else {
      _tmp$28 = false;
    }
    if (_tmp$28) {
      i = 2;
    } else {
      let _tmp$29;
      if (base === 8) {
        let _tmp$30;
        if (text.length > 1) {
          $bound_check(text, 0);
          const _p$28 = text.charCodeAt(0);
          const _p$29 = 48;
          _tmp$30 = _p$28 === _p$29;
        } else {
          _tmp$30 = false;
        }
        _tmp$29 = _tmp$30;
      } else {
        _tmp$29 = false;
      }
      if (_tmp$29) {
        i = 1;
      }
    }
  }
  while (true) {
    if (i < text.length) {
      const _tmp$28 = i;
      $bound_check(text, _tmp$28);
      const code = text.charCodeAt(_tmp$28);
      const _bind = hackwaly$tinycc$support$util$int_literals$$digit_value(code);
      let digit;
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        digit = _Some;
      }
      if (digit >= base) {
        break;
      }
      value = moonbitlang$core$builtin$$Add$add$6$(moonbitlang$core$builtin$$Mul$mul$6$(value, moonbitlang$core$int$$Int$to_uint64(base)), moonbitlang$core$int$$Int$to_uint64(digit));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return value;
}
function hackwaly$tinycc$support$util$int_literals$$parse_int_suffix(suffix) {
  let long_count = 0;
  let unsigned = false;
  const _it = moonbitlang$core$string$$String$iter(moonbitlang$core$string$$String$to_lower(suffix));
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$115$(_it);
    if (_bind === -1) {
      break;
    } else {
      const _Some = _bind;
      const _code = _Some;
      if (_code === 108) {
        long_count = long_count + 1 | 0;
      } else {
        if (_code === 117) {
          unsigned = true;
        }
      }
      continue;
    }
  }
  if (long_count > 2) {
    long_count = 2;
  }
  return { _0: long_count, _1: unsigned };
}
function hackwaly$tinycc$support$util$$fast_map_new$154$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$154$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$154$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$155$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$155$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$155$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$156$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$156$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$156$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$157$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$157$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$157$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$158$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$158$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$158$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$159$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$159$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$159$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$160$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$160$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$160$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$161$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$161$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$161$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$162$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$162$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$162$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$163$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$163$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$163$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$164$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$164$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$164$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$165$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$165$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$165$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$166$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$166$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$166$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$167$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$167$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$167$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$168$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$168$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$168$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$169$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$169$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$169$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$170$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$170$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$170$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$171$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$171$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$171$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$172$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$172$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$172$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$173$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$173$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$173$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$174$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$174$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$174$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$175$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$175$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$175$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$136$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$136$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$136$(_value);
  }
}
function hackwaly$tinycc$support$util$$fast_map_new$137$(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$137$(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$util$fast_map$$fast_map_new$137$(_value);
  }
}
function hackwaly$tinycc$support$util$$int_literal_end(text) {
  return hackwaly$tinycc$support$util$int_literals$$int_literal_end(text);
}
function hackwaly$tinycc$support$util$$int_literal_base(text) {
  return hackwaly$tinycc$support$util$int_literals$$int_literal_base(text);
}
function hackwaly$tinycc$support$util$$parse_uint64_literal(text, base) {
  return hackwaly$tinycc$support$util$int_literals$$parse_uint64_literal(text, base);
}
function hackwaly$tinycc$support$util$$parse_int_suffix(suffix) {
  return hackwaly$tinycc$support$util$int_literals$$parse_int_suffix(suffix);
}
function hackwaly$tinycc$support$util$$slice_string(text, start, end) {
  return hackwaly$tinycc$support$util$string_utils$$slice_string(text, start, end);
}
function hackwaly$tinycc$support$util$$hex_digit_value(code) {
  return hackwaly$tinycc$support$util$string_utils$$hex_digit_value(code);
}
function hackwaly$tinycc$backend$macho$$fast_map_new$166$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$166$(capacity);
}
function hackwaly$tinycc$backend$macho$$fast_map_new$173$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$173$(capacity);
}
function hackwaly$tinycc$backend$macho$$fast_map_new$156$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$156$(capacity);
}
function hackwaly$tinycc$backend$macho$$align_up(value, align) {
  if (align <= 0) {
    return value;
  } else {
    const mask = align - 1 | 0;
    return value + mask & ~mask;
  }
}
function hackwaly$tinycc$backend$macho$$align_log2(value) {
  let v = value <= 0 ? 1 : value;
  let log = 0;
  while (true) {
    if (v > 1) {
      v = v >> 1;
      log = log + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return log;
}
function hackwaly$tinycc$backend$macho$$write_padded_name(buf, name, len) {
  const name_len = name.length;
  let ascii = name_len <= len;
  if (ascii) {
    let i = 0;
    while (true) {
      if (i < name_len && ascii) {
        const _tmp$27 = i;
        $bound_check(name, _tmp$27);
        if (moonbitlang$core$builtin$$Compare$op_gt$23$(name.charCodeAt(_tmp$27), 127)) {
          ascii = false;
        }
        i = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  if (ascii) {
    const start = buf.len;
    moonbitlang$core$buffer$$Buffer$write_string_utf8(buf, { str: name, start: 0, end: name.length });
    const written = buf.len - start | 0;
    let i = written;
    while (true) {
      if (i < len) {
        moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
        i = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    const bytes = moonbitlang$core$encoding$utf8$$encode$46$inner({ str: name, start: 0, end: name.length }, false);
    let i = 0;
    while (true) {
      if (i < len) {
        if (i < bytes.length) {
          const _tmp$27 = i;
          $bound_check(bytes, _tmp$27);
          moonbitlang$core$buffer$$Buffer$write_byte(buf, bytes[_tmp$27]);
        } else {
          moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
        }
        i = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$macho$$macho_section_info(name) {
  switch (name) {
    case ".text": {
      return hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4747;
    }
    case ".rodata": {
      return hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4748;
    }
    case ".cstring": {
      return hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4749;
    }
    case ".data": {
      return hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4750;
    }
    case ".bss": {
      return hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4751;
    }
    default: {
      return hackwaly$tinycc$backend$macho$$macho_section_info$46$record$47$4752;
    }
  }
}
function hackwaly$tinycc$backend$macho$$build_strtab(symbols) {
  const buf = moonbitlang$core$buffer$$new$46$inner(8 + (Math.imul(symbols.length, 8) | 0) | 0);
  moonbitlang$core$buffer$$Buffer$write_string_utf8(buf, { str: hackwaly$tinycc$backend$macho$$build_strtab$46$42$bind$124$199, start: 0, end: hackwaly$tinycc$backend$macho$$build_strtab$46$42$bind$124$199.length });
  moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
  const offsets = moonbitlang$core$array$$Array$new$46$inner$26$(symbols.length);
  const _len = symbols.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const sym = symbols[_i];
      const off = buf.len;
      moonbitlang$core$array$$Array$push$26$(offsets, off);
      const _bind = sym.name;
      moonbitlang$core$buffer$$Buffer$write_string_utf8(buf, { str: _bind, start: 0, end: _bind.length });
      moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const pad = -buf.len & 7;
  let i = 0;
  while (true) {
    if (i < pad) {
      moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: moonbitlang$core$buffer$$Buffer$to_bytes(buf), _1: offsets };
}
function hackwaly$tinycc$backend$macho$$build_symtab(symbols, offsets, section_index) {
  const buf = moonbitlang$core$buffer$$new$46$inner(Math.imul(symbols.length, 16) | 0);
  let idx = 0;
  while (true) {
    if (idx < symbols.length) {
      const sym = moonbitlang$core$array$$Array$at$31$(symbols, idx);
      const strx = moonbitlang$core$array$$Array$at$26$(offsets, idx);
      let n_type = sym.is_external ? 1 : 0;
      const _bind = sym.section;
      let _bind$2;
      if (_bind === undefined) {
        _bind$2 = hackwaly$tinycc$backend$macho$$build_symtab$46$tuple$47$4766;
      } else {
        const _Some = _bind;
        const _sec_name = _Some;
        const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$156$(section_index, _sec_name);
        if (_bind$3 === undefined) {
          _bind$2 = hackwaly$tinycc$backend$macho$$build_symtab$46$tuple$47$4767;
        } else {
          const _Some$2 = _bind$3;
          const _sec_idx = _Some$2;
          n_type = n_type | 14;
          _bind$2 = { _0: _sec_idx, _1: sym.value };
        }
      }
      const _n_sect = _bind$2._0;
      const _n_value = _bind$2._1;
      if (_n_sect === 0) {
        n_type = n_type | 0;
      }
      moonbitlang$core$buffer$$Buffer$write_uint_le(buf, strx);
      moonbitlang$core$buffer$$Buffer$write_byte(buf, n_type & 255);
      moonbitlang$core$buffer$$Buffer$write_byte(buf, _n_sect & 255);
      moonbitlang$core$buffer$$Buffer$write_uint16_le(buf, 0 & 65535);
      moonbitlang$core$buffer$$Buffer$write_uint64_le(buf, moonbitlang$core$int$$Int$to_uint64(_n_value));
      idx = idx + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$buffer$$Buffer$to_bytes(buf);
}
function hackwaly$tinycc$backend$macho$$macho_reloc_type(kind) {
  switch (kind) {
    case 311: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4786;
    }
    case 312: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4787;
    }
    case 283: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4788;
    }
    case 282: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4789;
    }
    case 275: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4790;
    }
    case 276: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4791;
    }
    case 277: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4792;
    }
    case 278: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4793;
    }
    case 257: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4794;
    }
    default: {
      return hackwaly$tinycc$backend$macho$$macho_reloc_type$46$tuple$47$4795;
    }
  }
}
function hackwaly$tinycc$backend$macho$$reloc_length(kind) {
  if (kind === 257) {
    return 3;
  } else {
    return 2;
  }
}
function hackwaly$tinycc$backend$macho$$pack_reloc_info(symbolnum, pcrel, length, is_extern, r_type) {
  let info = symbolnum & 16777215;
  if (pcrel) {
    info = info | 16777216;
  }
  info = info | (length & 3) << 25;
  if (is_extern) {
    info = info | 134217728;
  }
  info = info | (r_type & 15) << 28;
  return info;
}
function hackwaly$tinycc$backend$macho$$collect_section_indices(layouts) {
  const map = hackwaly$tinycc$backend$macho$$fast_map_new$156$(undefined);
  const _len = layouts.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const layout = layouts[_i];
      moonbitlang$core$hashmap$$HashMap$set$156$(map, layout.section.name, layout.index);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return map;
}
function hackwaly$tinycc$backend$macho$$segment_file_range(indices, layouts) {
  let start = -1;
  let end = 0;
  const _len = indices.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      _L: {
        const idx = indices[_i];
        const layout = moonbitlang$core$array$$Array$at$30$(layouts, idx);
        if (layout.info.is_zerofill) {
          break _L;
        }
        if (start < 0 || layout.offset < start) {
          start = layout.offset;
        }
        const end_here = layout.offset + layout.size | 0;
        if (end_here > end) {
          end = end_here;
        }
        break _L;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return start < 0 ? hackwaly$tinycc$backend$macho$$segment_file_range$46$tuple$47$4810 : { _0: start, _1: end - start | 0 };
}
function hackwaly$tinycc$backend$macho$$encode_macho_object(sections, symbols) {
  const _bind = hackwaly$tinycc$backend$macho$$build_strtab(symbols);
  const _strtab = _bind._0;
  const _str_offsets = _bind._1;
  const segment_order = [];
  const segment_sections = hackwaly$tinycc$backend$macho$$fast_map_new$166$(undefined);
  const layouts = [];
  const _len = sections.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const sec = sections[_i];
      const info = hackwaly$tinycc$backend$macho$$macho_section_info(sec.name);
      if (!moonbitlang$core$hashmap$$HashMap$contains$166$(segment_sections, info.segname)) {
        moonbitlang$core$hashmap$$HashMap$set$166$(segment_sections, info.segname, []);
        moonbitlang$core$array$$Array$push$19$(segment_order, info.segname);
      }
      const align = sec.align > 0 ? sec.align : info.align;
      const layout = { section: sec, info: info, align_log2: hackwaly$tinycc$backend$macho$$align_log2(align), offset: 0, size: sec.size_bytes > 0 ? sec.size_bytes : sec.data.length << 2, reloff: 0, nreloc: 0, index: 0 };
      moonbitlang$core$array$$Array$push$30$(layouts, layout);
      const idx = layouts.length - 1 | 0;
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(segment_sections, info.segname);
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _list = _Some._0;
        moonbitlang$core$array$$Array$push$26$(_list, idx);
        moonbitlang$core$hashmap$$HashMap$set$166$(segment_sections, info.segname, _list);
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let sizeofcmds = 24;
  const _len$2 = segment_order.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len$2) {
      const seg = segment_order[_i];
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(segment_sections, seg);
      let count;
      if (_bind$2.$tag === 0) {
        count = 0;
      } else {
        const _Some = _bind$2;
        const _list = _Some._0;
        count = _list.length;
      }
      sizeofcmds = (sizeofcmds + 72 | 0) + (Math.imul(count, 80) | 0) | 0;
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  sizeofcmds = (sizeofcmds + 24 | 0) + 16 | 0;
  let offset = 32 + sizeofcmds | 0;
  let section_index = 1;
  const _len$3 = segment_order.length;
  let _tmp$29 = 0;
  while (true) {
    const _i = _tmp$29;
    if (_i < _len$3) {
      const seg = segment_order[_i];
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(segment_sections, seg);
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _list = _Some._0;
        const _len$4 = _list.length;
        let _tmp$30 = 0;
        while (true) {
          const _i$2 = _tmp$30;
          if (_i$2 < _len$4) {
            const idx = _list[_i$2];
            const layout = moonbitlang$core$array$$Array$at$30$(layouts, idx);
            const align = layout.section.align > 0 ? layout.section.align : layout.info.align;
            const aligned = layout.info.is_zerofill ? offset : hackwaly$tinycc$backend$macho$$align_up(offset, align);
            const data_off = layout.info.is_zerofill ? 0 : aligned;
            const size = layout.size;
            if (!layout.info.is_zerofill) {
              offset = aligned + size | 0;
            }
            moonbitlang$core$array$$Array$set$30$(layouts, idx, { section: layout.section, info: layout.info, align_log2: hackwaly$tinycc$backend$macho$$align_log2(align), offset: data_off, size: size, reloff: 0, nreloc: 0, index: section_index });
            section_index = section_index + 1 | 0;
            _tmp$30 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      _tmp$29 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let reloc_offset = hackwaly$tinycc$backend$macho$$align_up(offset, 4);
  const _len$4 = segment_order.length;
  let _tmp$30 = 0;
  while (true) {
    const _i = _tmp$30;
    if (_i < _len$4) {
      const seg = segment_order[_i];
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(segment_sections, seg);
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _list = _Some._0;
        const _len$5 = _list.length;
        let _tmp$31 = 0;
        while (true) {
          const _i$2 = _tmp$31;
          if (_i$2 < _len$5) {
            const idx = _list[_i$2];
            const layout = moonbitlang$core$array$$Array$at$30$(layouts, idx);
            const rel_count = layout.section.relocs.length;
            const reloff = rel_count > 0 ? reloc_offset : 0;
            if (rel_count > 0) {
              reloc_offset = reloc_offset + (Math.imul(rel_count, 8) | 0) | 0;
            }
            moonbitlang$core$array$$Array$set$30$(layouts, idx, { section: layout.section, info: layout.info, align_log2: layout.align_log2, offset: layout.offset, size: layout.size, reloff: reloff, nreloc: rel_count, index: layout.index });
            _tmp$31 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      _tmp$30 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const symoff = hackwaly$tinycc$backend$macho$$align_up(reloc_offset, 4);
  const section_index_map = hackwaly$tinycc$backend$macho$$collect_section_indices(layouts);
  const symtab = hackwaly$tinycc$backend$macho$$build_symtab(symbols, _str_offsets, section_index_map);
  const id_to_index = hackwaly$tinycc$backend$macho$$fast_map_new$173$(undefined);
  let i = 0;
  while (true) {
    if (i < symbols.length) {
      moonbitlang$core$hashmap$$HashMap$set$173$(id_to_index, moonbitlang$core$array$$Array$at$31$(symbols, i).id, i);
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const stroff = symoff + symtab.length | 0;
  const ncmds = segment_order.length + 3 | 0;
  const out = moonbitlang$core$buffer$$new$46$inner(stroff + _strtab.length | 0);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, -17958193);
  moonbitlang$core$buffer$$Buffer$write_int_le(out, 16777228);
  moonbitlang$core$buffer$$Buffer$write_int_le(out, 0);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 1);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, ncmds);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, sizeofcmds);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 0);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 0);
  const _len$5 = segment_order.length;
  let _tmp$31 = 0;
  while (true) {
    const _i = _tmp$31;
    if (_i < _len$5) {
      const seg = segment_order[_i];
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(segment_sections, seg);
      let indices;
      if (_bind$2.$tag === 0) {
        indices = [];
      } else {
        const _Some = _bind$2;
        indices = _Some._0;
      }
      const cmdsize = 72 + (Math.imul(indices.length, 80) | 0) | 0;
      const _bind$3 = hackwaly$tinycc$backend$macho$$segment_file_range(indices, layouts);
      const _fileoff = _bind$3._0;
      const _filesize = _bind$3._1;
      const _bind$4 = seg === "__TEXT" ? hackwaly$tinycc$backend$macho$$segment_prot$46$tuple$47$4822 : hackwaly$tinycc$backend$macho$$segment_prot$46$tuple$47$4823;
      const _maxprot = _bind$4._0;
      const _initprot = _bind$4._1;
      moonbitlang$core$buffer$$Buffer$write_uint_le(out, 25);
      moonbitlang$core$buffer$$Buffer$write_uint_le(out, cmdsize);
      hackwaly$tinycc$backend$macho$$write_padded_name(out, seg, 16);
      moonbitlang$core$buffer$$Buffer$write_uint64_le(out, $0L);
      moonbitlang$core$buffer$$Buffer$write_uint64_le(out, $0L);
      moonbitlang$core$buffer$$Buffer$write_uint64_le(out, moonbitlang$core$int$$Int$to_uint64(_fileoff));
      moonbitlang$core$buffer$$Buffer$write_uint64_le(out, moonbitlang$core$int$$Int$to_uint64(_filesize));
      moonbitlang$core$buffer$$Buffer$write_int_le(out, _maxprot);
      moonbitlang$core$buffer$$Buffer$write_int_le(out, _initprot);
      moonbitlang$core$buffer$$Buffer$write_uint_le(out, indices.length);
      moonbitlang$core$buffer$$Buffer$write_uint_le(out, 0);
      const _len$6 = indices.length;
      let _tmp$32 = 0;
      while (true) {
        const _i$2 = _tmp$32;
        if (_i$2 < _len$6) {
          const idx = indices[_i$2];
          const layout = moonbitlang$core$array$$Array$at$30$(layouts, idx);
          hackwaly$tinycc$backend$macho$$write_padded_name(out, layout.info.sectname, 16);
          hackwaly$tinycc$backend$macho$$write_padded_name(out, layout.info.segname, 16);
          moonbitlang$core$buffer$$Buffer$write_uint64_le(out, $0L);
          moonbitlang$core$buffer$$Buffer$write_uint64_le(out, moonbitlang$core$int$$Int$to_uint64(layout.size));
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, layout.offset);
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, layout.align_log2);
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, layout.reloff);
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, layout.nreloc);
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, layout.info.flags);
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, 0);
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, 0);
          moonbitlang$core$buffer$$Buffer$write_uint_le(out, 0);
          _tmp$32 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp$31 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 2);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 24);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, symoff);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, symbols.length);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, stroff);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, _strtab.length);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 50);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 24);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 1);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 656896);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 656896);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 0);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 42);
  moonbitlang$core$buffer$$Buffer$write_uint_le(out, 16);
  moonbitlang$core$buffer$$Buffer$write_uint64_le(out, $0L);
  let fileoff = out.len;
  const _len$6 = segment_order.length;
  let _tmp$32 = 0;
  while (true) {
    const _i = _tmp$32;
    if (_i < _len$6) {
      const seg = segment_order[_i];
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(segment_sections, seg);
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _list = _Some._0;
        const _len$7 = _list.length;
        let _tmp$33 = 0;
        while (true) {
          const _i$2 = _tmp$33;
          if (_i$2 < _len$7) {
            _L: {
              const idx = _list[_i$2];
              const layout = moonbitlang$core$array$$Array$at$30$(layouts, idx);
              if (layout.info.is_zerofill) {
                break _L;
              }
              const align = 1 << layout.align_log2;
              const aligned = hackwaly$tinycc$backend$macho$$align_up(fileoff, align);
              while (true) {
                if (fileoff < aligned) {
                  moonbitlang$core$buffer$$Buffer$write_byte(out, 0);
                  fileoff = fileoff + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              const _p$28 = layout.section;
              const word_len = _p$28.size_bytes > 0 ? _p$28.size_bytes >> 2 : _p$28.data.length;
              let i$2 = 0;
              while (true) {
                if (i$2 < word_len) {
                  moonbitlang$core$buffer$$Buffer$write_uint_le(out, moonbitlang$core$array$$Array$at$24$(layout.section.data, i$2));
                  fileoff = fileoff + 4 | 0;
                  i$2 = i$2 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              break _L;
            }
            _tmp$33 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      _tmp$32 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const reloc_aligned = hackwaly$tinycc$backend$macho$$align_up(fileoff, 4);
  while (true) {
    if (fileoff < reloc_aligned) {
      moonbitlang$core$buffer$$Buffer$write_byte(out, 0);
      fileoff = fileoff + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _len$7 = segment_order.length;
  let _tmp$33 = 0;
  while (true) {
    const _i = _tmp$33;
    if (_i < _len$7) {
      const seg = segment_order[_i];
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(segment_sections, seg);
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _list = _Some._0;
        const _len$8 = _list.length;
        let _tmp$34 = 0;
        while (true) {
          const _i$2 = _tmp$34;
          if (_i$2 < _len$8) {
            const idx = _list[_i$2];
            const layout = moonbitlang$core$array$$Array$at$30$(layouts, idx);
            const _arr = layout.section.relocs;
            const _len$9 = _arr.length;
            let _tmp$35 = 0;
            while (true) {
              const _i$3 = _tmp$35;
              if (_i$3 < _len$9) {
                const rel = _arr[_i$3];
                const _bind$3 = hackwaly$tinycc$backend$macho$$macho_reloc_type(rel.kind);
                const _rtype = _bind$3._0;
                const _pcrel = _bind$3._1;
                const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$173$(id_to_index, rel.sym.id);
                let symbolnum;
                if (_bind$4 === undefined) {
                  symbolnum = 0;
                } else {
                  const _Some$2 = _bind$4;
                  symbolnum = _Some$2;
                }
                const len = hackwaly$tinycc$backend$macho$$reloc_length(rel.kind);
                const info = hackwaly$tinycc$backend$macho$$pack_reloc_info(symbolnum, _pcrel, len, true, _rtype);
                moonbitlang$core$buffer$$Buffer$write_uint_le(out, rel.offset);
                moonbitlang$core$buffer$$Buffer$write_uint_le(out, info);
                fileoff = fileoff + 8 | 0;
                _tmp$35 = _i$3 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            _tmp$34 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      _tmp$33 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const sym_aligned = hackwaly$tinycc$backend$macho$$align_up(fileoff, 4);
  while (true) {
    if (fileoff < sym_aligned) {
      moonbitlang$core$buffer$$Buffer$write_byte(out, 0);
      fileoff = fileoff + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$buffer$$Buffer$write_bytes(out, symtab);
  fileoff = fileoff + symtab.length | 0;
  moonbitlang$core$buffer$$Buffer$write_bytes(out, _strtab);
  return moonbitlang$core$buffer$$Buffer$to_bytes(out);
}
function moonbitlang$core$builtin$$Eq$equal$176$(_x_10, _x_11) {
  return _x_10.file_id === _x_11.file_id && _x_10.line === _x_11.line && _x_10.col === _x_11.col && _x_10.offset === _x_11.offset;
}
function hackwaly$tinycc$support$source$source_core$$new_source_map() {
  return { files: [] };
}
function hackwaly$tinycc$support$source$source_core$$add_file(map, path, text) {
  const id = map.files.length;
  const file = { id: id, path: path, text: text };
  moonbitlang$core$array$$Array$push$27$(map.files, file);
  return file;
}
function hackwaly$tinycc$support$source$source_core$$dummy_loc(file_id) {
  return { file_id: file_id, line: 1, col: 1, offset: 0 };
}
function hackwaly$tinycc$support$source$$new_source_map() {
  return hackwaly$tinycc$support$source$source_core$$new_source_map();
}
function hackwaly$tinycc$support$source$$add_file(map, path, text) {
  return hackwaly$tinycc$support$source$source_core$$add_file(map, path, text);
}
function hackwaly$tinycc$support$source$$dummy_loc(file_id) {
  return hackwaly$tinycc$support$source$source_core$$dummy_loc(file_id);
}
function moonbitlang$core$builtin$$Eq$equal$37$(_x_1968, _x_1969) {
  switch (_x_1968.$tag) {
    case 0: {
      const _Index = _x_1968;
      const _$42$x0_1970 = _Index._0;
      const _$42$x1_1971 = _Index._1;
      if (_x_1969.$tag === 0) {
        const _Index$2 = _x_1969;
        const _$42$y0_1972 = _Index$2._0;
        const _$42$y1_1973 = _Index$2._1;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1970, _$42$y0_1972) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_1971, _$42$y1_1973);
      } else {
        return false;
      }
    }
    case 1: {
      const _IndexRange = _x_1968;
      const _$42$x0_1974 = _IndexRange._0;
      const _$42$x1_1975 = _IndexRange._1;
      const _$42$x2_1976 = _IndexRange._2;
      if (_x_1969.$tag === 1) {
        const _IndexRange$2 = _x_1969;
        const _$42$y0_1977 = _IndexRange$2._0;
        const _$42$y1_1978 = _IndexRange$2._1;
        const _$42$y2_1979 = _IndexRange$2._2;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1974, _$42$y0_1977) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x1_1975, _$42$y1_1978) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1976, _$42$y2_1979));
      } else {
        return false;
      }
    }
    default: {
      const _Field = _x_1968;
      const _$42$x0_1980 = _Field._0;
      const _$42$x1_1981 = _Field._1;
      const _$42$x2_1982 = _Field._2;
      if (_x_1969.$tag === 2) {
        const _Field$2 = _x_1969;
        const _$42$y0_1983 = _Field$2._0;
        const _$42$y1_1984 = _Field$2._1;
        const _$42$y2_1985 = _Field$2._2;
        return _$42$x0_1980 === _$42$y0_1983 && (_$42$x1_1981 === _$42$y1_1984 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1982, _$42$y2_1985));
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$99$(_x_1928, _x_1929) {
  return _x_1928.name === _x_1929.name && _x_1928.id === _x_1929.id && moonbitlang$core$builtin$$Eq$equal$29$(_x_1928.ty, _x_1929.ty) && moonbitlang$core$builtin$$Eq$equal$133$(_x_1928.init, _x_1929.init) && moonbitlang$core$builtin$$Eq$equal$79$(_x_1928.storage, _x_1929.storage) && moonbitlang$core$builtin$$Eq$equal$177$(_x_1928.attrs, _x_1929.attrs) && moonbitlang$core$builtin$$Eq$equal$176$(_x_1928.loc, _x_1929.loc);
}
function moonbitlang$core$builtin$$Eq$equal$178$(_x_1916, _x_1917) {
  switch (_x_1916) {
    case 0: {
      if (_x_1917 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_1917 === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_1917 === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_1917 === 3) {
        return true;
      } else {
        return false;
      }
    }
    case 4: {
      if (_x_1917 === 4) {
        return true;
      } else {
        return false;
      }
    }
    case 5: {
      if (_x_1917 === 5) {
        return true;
      } else {
        return false;
      }
    }
    case 6: {
      if (_x_1917 === 6) {
        return true;
      } else {
        return false;
      }
    }
    case 7: {
      if (_x_1917 === 7) {
        return true;
      } else {
        return false;
      }
    }
    case 8: {
      if (_x_1917 === 8) {
        return true;
      } else {
        return false;
      }
    }
    case 9: {
      if (_x_1917 === 9) {
        return true;
      } else {
        return false;
      }
    }
    case 10: {
      if (_x_1917 === 10) {
        return true;
      } else {
        return false;
      }
    }
    case 11: {
      if (_x_1917 === 11) {
        return true;
      } else {
        return false;
      }
    }
    case 12: {
      if (_x_1917 === 12) {
        return true;
      } else {
        return false;
      }
    }
    case 13: {
      if (_x_1917 === 13) {
        return true;
      } else {
        return false;
      }
    }
    case 14: {
      if (_x_1917 === 14) {
        return true;
      } else {
        return false;
      }
    }
    case 15: {
      if (_x_1917 === 15) {
        return true;
      } else {
        return false;
      }
    }
    case 16: {
      if (_x_1917 === 16) {
        return true;
      } else {
        return false;
      }
    }
    case 17: {
      if (_x_1917 === 17) {
        return true;
      } else {
        return false;
      }
    }
    case 18: {
      if (_x_1917 === 18) {
        return true;
      } else {
        return false;
      }
    }
    case 19: {
      if (_x_1917 === 19) {
        return true;
      } else {
        return false;
      }
    }
    case 20: {
      if (_x_1917 === 20) {
        return true;
      } else {
        return false;
      }
    }
    case 21: {
      if (_x_1917 === 21) {
        return true;
      } else {
        return false;
      }
    }
    case 22: {
      if (_x_1917 === 22) {
        return true;
      } else {
        return false;
      }
    }
    case 23: {
      if (_x_1917 === 23) {
        return true;
      } else {
        return false;
      }
    }
    case 24: {
      if (_x_1917 === 24) {
        return true;
      } else {
        return false;
      }
    }
    case 25: {
      if (_x_1917 === 25) {
        return true;
      } else {
        return false;
      }
    }
    case 26: {
      if (_x_1917 === 26) {
        return true;
      } else {
        return false;
      }
    }
    case 27: {
      if (_x_1917 === 27) {
        return true;
      } else {
        return false;
      }
    }
    case 28: {
      if (_x_1917 === 28) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_1917 === 29) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$39$(_x_1906, _x_1907) {
  return _x_1906.name === _x_1907.name && _x_1906.id === _x_1907.id && moonbitlang$core$builtin$$Eq$equal$29$(_x_1906.ty, _x_1907.ty) && moonbitlang$core$builtin$$Eq$equal$126$(_x_1906.bit_width, _x_1907.bit_width) && moonbitlang$core$builtin$$Eq$equal$177$(_x_1906.attrs, _x_1907.attrs) && moonbitlang$core$builtin$$Eq$equal$176$(_x_1906.loc, _x_1907.loc);
}
function moonbitlang$core$builtin$$Eq$equal$79$(_x_1894, _x_1895) {
  switch (_x_1894) {
    case 0: {
      if (_x_1895 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_1895 === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_1895 === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_1895 === 3) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_1895 === 4) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$114$(_x_1884, _x_1885) {
  return _x_1884.name === _x_1885.name && _x_1884.id === _x_1885.id && moonbitlang$core$builtin$$Eq$equal$126$(_x_1884.value, _x_1885.value) && moonbitlang$core$builtin$$Eq$equal$176$(_x_1884.loc, _x_1885.loc);
}
function moonbitlang$core$builtin$$Eq$equal$55$(_x_1368, _x_1369) {
  switch (_x_1368.$tag) {
    case 0: {
      const _IntLit = _x_1368;
      const _$42$x0_1370 = _IntLit._0;
      const _$42$x1_1371 = _IntLit._1;
      const _$42$x2_1372 = _IntLit._2;
      if (_x_1369.$tag === 0) {
        const _IntLit$2 = _x_1369;
        const _$42$y0_1373 = _IntLit$2._0;
        const _$42$y1_1374 = _IntLit$2._1;
        const _$42$y2_1375 = _IntLit$2._2;
        return _$42$x0_1370 === _$42$y0_1373 && (_$42$x1_1371 === _$42$y1_1374 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1372, _$42$y2_1375));
      } else {
        return false;
      }
    }
    case 1: {
      const _FloatLit = _x_1368;
      const _$42$x0_1376 = _FloatLit._0;
      const _$42$x1_1377 = _FloatLit._1;
      const _$42$x2_1378 = _FloatLit._2;
      if (_x_1369.$tag === 1) {
        const _FloatLit$2 = _x_1369;
        const _$42$y0_1379 = _FloatLit$2._0;
        const _$42$y1_1380 = _FloatLit$2._1;
        const _$42$y2_1381 = _FloatLit$2._2;
        return _$42$x0_1376 === _$42$y0_1379 && (_$42$x1_1377 === _$42$y1_1380 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1378, _$42$y2_1381));
      } else {
        return false;
      }
    }
    case 2: {
      const _CharLit = _x_1368;
      const _$42$x0_1382 = _CharLit._0;
      const _$42$x1_1383 = _CharLit._1;
      const _$42$x2_1384 = _CharLit._2;
      if (_x_1369.$tag === 2) {
        const _CharLit$2 = _x_1369;
        const _$42$y0_1385 = _CharLit$2._0;
        const _$42$y1_1386 = _CharLit$2._1;
        const _$42$y2_1387 = _CharLit$2._2;
        return _$42$x0_1382 === _$42$y0_1385 && (_$42$x1_1383 === _$42$y1_1386 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1384, _$42$y2_1387));
      } else {
        return false;
      }
    }
    case 3: {
      const _StringLit = _x_1368;
      const _$42$x0_1388 = _StringLit._0;
      const _$42$x1_1389 = _StringLit._1;
      const _$42$x2_1390 = _StringLit._2;
      const _$42$x3_1391 = _StringLit._3;
      if (_x_1369.$tag === 3) {
        const _StringLit$2 = _x_1369;
        const _$42$y0_1392 = _StringLit$2._0;
        const _$42$y1_1393 = _StringLit$2._1;
        const _$42$y2_1394 = _StringLit$2._2;
        const _$42$y3_1395 = _StringLit$2._3;
        return _$42$x0_1388 === _$42$y0_1392 && (_$42$x1_1389 === _$42$y1_1393 && (_$42$x2_1390 === _$42$y2_1394 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1391, _$42$y3_1395)));
      } else {
        return false;
      }
    }
    case 4: {
      const _Ident = _x_1368;
      const _$42$x0_1396 = _Ident._0;
      const _$42$x1_1397 = _Ident._1;
      const _$42$x2_1398 = _Ident._2;
      const _$42$x3_1399 = _Ident._3;
      if (_x_1369.$tag === 4) {
        const _Ident$2 = _x_1369;
        const _$42$y0_1400 = _Ident$2._0;
        const _$42$y1_1401 = _Ident$2._1;
        const _$42$y2_1402 = _Ident$2._2;
        const _$42$y3_1403 = _Ident$2._3;
        return _$42$x0_1396 === _$42$y0_1400 && (_$42$x1_1397 === _$42$y1_1401 && (_$42$x2_1398 === _$42$y2_1402 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1399, _$42$y3_1403)));
      } else {
        return false;
      }
    }
    case 5: {
      const _LabelAddr = _x_1368;
      const _$42$x0_1404 = _LabelAddr._0;
      const _$42$x1_1405 = _LabelAddr._1;
      const _$42$x2_1406 = _LabelAddr._2;
      const _$42$x3_1407 = _LabelAddr._3;
      if (_x_1369.$tag === 5) {
        const _LabelAddr$2 = _x_1369;
        const _$42$y0_1408 = _LabelAddr$2._0;
        const _$42$y1_1409 = _LabelAddr$2._1;
        const _$42$y2_1410 = _LabelAddr$2._2;
        const _$42$y3_1411 = _LabelAddr$2._3;
        return _$42$x0_1404 === _$42$y0_1408 && (_$42$x1_1405 === _$42$y1_1409 && (_$42$x2_1406 === _$42$y2_1410 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1407, _$42$y3_1411)));
      } else {
        return false;
      }
    }
    case 6: {
      const _BuiltinTypesCompatibleP = _x_1368;
      const _$42$x0_1412 = _BuiltinTypesCompatibleP._0;
      const _$42$x1_1413 = _BuiltinTypesCompatibleP._1;
      const _$42$x2_1414 = _BuiltinTypesCompatibleP._2;
      const _$42$x3_1415 = _BuiltinTypesCompatibleP._3;
      if (_x_1369.$tag === 6) {
        const _BuiltinTypesCompatibleP$2 = _x_1369;
        const _$42$y0_1416 = _BuiltinTypesCompatibleP$2._0;
        const _$42$y1_1417 = _BuiltinTypesCompatibleP$2._1;
        const _$42$y2_1418 = _BuiltinTypesCompatibleP$2._2;
        const _$42$y3_1419 = _BuiltinTypesCompatibleP$2._3;
        return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_1412, _$42$y0_1416) && (moonbitlang$core$builtin$$Eq$equal$29$(_$42$x1_1413, _$42$y1_1417) && (_$42$x2_1414 === _$42$y2_1418 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1415, _$42$y3_1419)));
      } else {
        return false;
      }
    }
    case 7: {
      const _BuiltinOffsetof = _x_1368;
      const _$42$x0_1420 = _BuiltinOffsetof._0;
      const _$42$x1_1421 = _BuiltinOffsetof._1;
      const _$42$x2_1422 = _BuiltinOffsetof._2;
      const _$42$x3_1423 = _BuiltinOffsetof._3;
      if (_x_1369.$tag === 7) {
        const _BuiltinOffsetof$2 = _x_1369;
        const _$42$y0_1424 = _BuiltinOffsetof$2._0;
        const _$42$y1_1425 = _BuiltinOffsetof$2._1;
        const _$42$y2_1426 = _BuiltinOffsetof$2._2;
        const _$42$y3_1427 = _BuiltinOffsetof$2._3;
        return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_1420, _$42$y0_1424) && (moonbitlang$core$builtin$$Eq$equal$143$(_$42$x1_1421, _$42$y1_1425) && (_$42$x2_1422 === _$42$y2_1426 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1423, _$42$y3_1427)));
      } else {
        return false;
      }
    }
    case 8: {
      const _BuiltinVaArg = _x_1368;
      const _$42$x0_1428 = _BuiltinVaArg._0;
      const _$42$x1_1429 = _BuiltinVaArg._1;
      const _$42$x2_1430 = _BuiltinVaArg._2;
      const _$42$x3_1431 = _BuiltinVaArg._3;
      if (_x_1369.$tag === 8) {
        const _BuiltinVaArg$2 = _x_1369;
        const _$42$y0_1432 = _BuiltinVaArg$2._0;
        const _$42$y1_1433 = _BuiltinVaArg$2._1;
        const _$42$y2_1434 = _BuiltinVaArg$2._2;
        const _$42$y3_1435 = _BuiltinVaArg$2._3;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1428, _$42$y0_1432) && (moonbitlang$core$builtin$$Eq$equal$29$(_$42$x1_1429, _$42$y1_1433) && (_$42$x2_1430 === _$42$y2_1434 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1431, _$42$y3_1435)));
      } else {
        return false;
      }
    }
    case 9: {
      const _Unary = _x_1368;
      const _$42$x0_1436 = _Unary._0;
      const _$42$x1_1437 = _Unary._1;
      const _$42$x2_1438 = _Unary._2;
      const _$42$x3_1439 = _Unary._3;
      if (_x_1369.$tag === 9) {
        const _Unary$2 = _x_1369;
        const _$42$y0_1440 = _Unary$2._0;
        const _$42$y1_1441 = _Unary$2._1;
        const _$42$y2_1442 = _Unary$2._2;
        const _$42$y3_1443 = _Unary$2._3;
        return moonbitlang$core$builtin$$Eq$equal$179$(_$42$x0_1436, _$42$y0_1440) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x1_1437, _$42$y1_1441) && (_$42$x2_1438 === _$42$y2_1442 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1439, _$42$y3_1443)));
      } else {
        return false;
      }
    }
    case 10: {
      const _Cast = _x_1368;
      const _$42$x0_1444 = _Cast._0;
      const _$42$x1_1445 = _Cast._1;
      const _$42$x2_1446 = _Cast._2;
      const _$42$x3_1447 = _Cast._3;
      if (_x_1369.$tag === 10) {
        const _Cast$2 = _x_1369;
        const _$42$y0_1448 = _Cast$2._0;
        const _$42$y1_1449 = _Cast$2._1;
        const _$42$y2_1450 = _Cast$2._2;
        const _$42$y3_1451 = _Cast$2._3;
        return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_1444, _$42$y0_1448) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x1_1445, _$42$y1_1449) && (_$42$x2_1446 === _$42$y2_1450 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1447, _$42$y3_1451)));
      } else {
        return false;
      }
    }
    case 11: {
      const _CompoundLiteral = _x_1368;
      const _$42$x0_1452 = _CompoundLiteral._0;
      const _$42$x1_1453 = _CompoundLiteral._1;
      const _$42$x2_1454 = _CompoundLiteral._2;
      const _$42$x3_1455 = _CompoundLiteral._3;
      if (_x_1369.$tag === 11) {
        const _CompoundLiteral$2 = _x_1369;
        const _$42$y0_1456 = _CompoundLiteral$2._0;
        const _$42$y1_1457 = _CompoundLiteral$2._1;
        const _$42$y2_1458 = _CompoundLiteral$2._2;
        const _$42$y3_1459 = _CompoundLiteral$2._3;
        return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_1452, _$42$y0_1456) && (moonbitlang$core$builtin$$Eq$equal$134$(_$42$x1_1453, _$42$y1_1457) && (_$42$x2_1454 === _$42$y2_1458 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1455, _$42$y3_1459)));
      } else {
        return false;
      }
    }
    case 12: {
      const _StmtExpr = _x_1368;
      const _$42$x0_1460 = _StmtExpr._0;
      const _$42$x1_1461 = _StmtExpr._1;
      const _$42$x2_1462 = _StmtExpr._2;
      if (_x_1369.$tag === 12) {
        const _StmtExpr$2 = _x_1369;
        const _$42$y0_1463 = _StmtExpr$2._0;
        const _$42$y1_1464 = _StmtExpr$2._1;
        const _$42$y2_1465 = _StmtExpr$2._2;
        return moonbitlang$core$builtin$$Eq$equal$144$(_$42$x0_1460, _$42$y0_1463) && (_$42$x1_1461 === _$42$y1_1464 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1462, _$42$y2_1465));
      } else {
        return false;
      }
    }
    case 13: {
      const _SizeofExpr = _x_1368;
      const _$42$x0_1466 = _SizeofExpr._0;
      const _$42$x1_1467 = _SizeofExpr._1;
      const _$42$x2_1468 = _SizeofExpr._2;
      if (_x_1369.$tag === 13) {
        const _SizeofExpr$2 = _x_1369;
        const _$42$y0_1469 = _SizeofExpr$2._0;
        const _$42$y1_1470 = _SizeofExpr$2._1;
        const _$42$y2_1471 = _SizeofExpr$2._2;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1466, _$42$y0_1469) && (_$42$x1_1467 === _$42$y1_1470 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1468, _$42$y2_1471));
      } else {
        return false;
      }
    }
    case 14: {
      const _SizeofType = _x_1368;
      const _$42$x0_1472 = _SizeofType._0;
      const _$42$x1_1473 = _SizeofType._1;
      const _$42$x2_1474 = _SizeofType._2;
      if (_x_1369.$tag === 14) {
        const _SizeofType$2 = _x_1369;
        const _$42$y0_1475 = _SizeofType$2._0;
        const _$42$y1_1476 = _SizeofType$2._1;
        const _$42$y2_1477 = _SizeofType$2._2;
        return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_1472, _$42$y0_1475) && (_$42$x1_1473 === _$42$y1_1476 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1474, _$42$y2_1477));
      } else {
        return false;
      }
    }
    case 15: {
      const _AlignofExpr = _x_1368;
      const _$42$x0_1478 = _AlignofExpr._0;
      const _$42$x1_1479 = _AlignofExpr._1;
      const _$42$x2_1480 = _AlignofExpr._2;
      if (_x_1369.$tag === 15) {
        const _AlignofExpr$2 = _x_1369;
        const _$42$y0_1481 = _AlignofExpr$2._0;
        const _$42$y1_1482 = _AlignofExpr$2._1;
        const _$42$y2_1483 = _AlignofExpr$2._2;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1478, _$42$y0_1481) && (_$42$x1_1479 === _$42$y1_1482 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1480, _$42$y2_1483));
      } else {
        return false;
      }
    }
    case 16: {
      const _AlignofType = _x_1368;
      const _$42$x0_1484 = _AlignofType._0;
      const _$42$x1_1485 = _AlignofType._1;
      const _$42$x2_1486 = _AlignofType._2;
      if (_x_1369.$tag === 16) {
        const _AlignofType$2 = _x_1369;
        const _$42$y0_1487 = _AlignofType$2._0;
        const _$42$y1_1488 = _AlignofType$2._1;
        const _$42$y2_1489 = _AlignofType$2._2;
        return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_1484, _$42$y0_1487) && (_$42$x1_1485 === _$42$y1_1488 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_1486, _$42$y2_1489));
      } else {
        return false;
      }
    }
    case 17: {
      const _Binary = _x_1368;
      const _$42$x0_1490 = _Binary._0;
      const _$42$x1_1491 = _Binary._1;
      const _$42$x2_1492 = _Binary._2;
      const _$42$x3_1493 = _Binary._3;
      const _$42$x4_1494 = _Binary._4;
      if (_x_1369.$tag === 17) {
        const _Binary$2 = _x_1369;
        const _$42$y0_1495 = _Binary$2._0;
        const _$42$y1_1496 = _Binary$2._1;
        const _$42$y2_1497 = _Binary$2._2;
        const _$42$y3_1498 = _Binary$2._3;
        const _$42$y4_1499 = _Binary$2._4;
        return moonbitlang$core$builtin$$Eq$equal$178$(_$42$x0_1490, _$42$y0_1495) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x1_1491, _$42$y1_1496) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x2_1492, _$42$y2_1497) && (_$42$x3_1493 === _$42$y3_1498 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x4_1494, _$42$y4_1499))));
      } else {
        return false;
      }
    }
    case 18: {
      const _Conditional = _x_1368;
      const _$42$x0_1500 = _Conditional._0;
      const _$42$x1_1501 = _Conditional._1;
      const _$42$x2_1502 = _Conditional._2;
      const _$42$x3_1503 = _Conditional._3;
      const _$42$x4_1504 = _Conditional._4;
      if (_x_1369.$tag === 18) {
        const _Conditional$2 = _x_1369;
        const _$42$y0_1505 = _Conditional$2._0;
        const _$42$y1_1506 = _Conditional$2._1;
        const _$42$y2_1507 = _Conditional$2._2;
        const _$42$y3_1508 = _Conditional$2._3;
        const _$42$y4_1509 = _Conditional$2._4;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1500, _$42$y0_1505) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x1_1501, _$42$y1_1506) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x2_1502, _$42$y2_1507) && (_$42$x3_1503 === _$42$y3_1508 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x4_1504, _$42$y4_1509))));
      } else {
        return false;
      }
    }
    case 19: {
      const _Call = _x_1368;
      const _$42$x0_1510 = _Call._0;
      const _$42$x1_1511 = _Call._1;
      const _$42$x2_1512 = _Call._2;
      const _$42$x3_1513 = _Call._3;
      if (_x_1369.$tag === 19) {
        const _Call$2 = _x_1369;
        const _$42$y0_1514 = _Call$2._0;
        const _$42$y1_1515 = _Call$2._1;
        const _$42$y2_1516 = _Call$2._2;
        const _$42$y3_1517 = _Call$2._3;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1510, _$42$y0_1514) && (moonbitlang$core$builtin$$Eq$equal$145$(_$42$x1_1511, _$42$y1_1515) && (_$42$x2_1512 === _$42$y2_1516 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1513, _$42$y3_1517)));
      } else {
        return false;
      }
    }
    case 20: {
      const _Index = _x_1368;
      const _$42$x0_1518 = _Index._0;
      const _$42$x1_1519 = _Index._1;
      const _$42$x2_1520 = _Index._2;
      const _$42$x3_1521 = _Index._3;
      if (_x_1369.$tag === 20) {
        const _Index$2 = _x_1369;
        const _$42$y0_1522 = _Index$2._0;
        const _$42$y1_1523 = _Index$2._1;
        const _$42$y2_1524 = _Index$2._2;
        const _$42$y3_1525 = _Index$2._3;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1518, _$42$y0_1522) && (moonbitlang$core$builtin$$Eq$equal$55$(_$42$x1_1519, _$42$y1_1523) && (_$42$x2_1520 === _$42$y2_1524 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_1521, _$42$y3_1525)));
      } else {
        return false;
      }
    }
    default: {
      const _Member = _x_1368;
      const _$42$x0_1526 = _Member._0;
      const _$42$x1_1527 = _Member._1;
      const _$42$x2_1528 = _Member._2;
      const _$42$x3_1529 = _Member._3;
      const _$42$x4_1530 = _Member._4;
      const _$42$x5_1531 = _Member._5;
      if (_x_1369.$tag === 21) {
        const _Member$2 = _x_1369;
        const _$42$y0_1532 = _Member$2._0;
        const _$42$y1_1533 = _Member$2._1;
        const _$42$y2_1534 = _Member$2._2;
        const _$42$y3_1535 = _Member$2._3;
        const _$42$y4_1536 = _Member$2._4;
        const _$42$y5_1537 = _Member$2._5;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_1526, _$42$y0_1532) && (_$42$x1_1527 === _$42$y1_1533 && (_$42$x2_1528 === _$42$y2_1534 && (_$42$x3_1529 === _$42$y3_1535 && (_$42$x4_1530 === _$42$y4_1536 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x5_1531, _$42$y5_1537)))));
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$123$(_x_1168, _x_1169) {
  switch (_x_1168) {
    case 0: {
      if (_x_1169 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_1169 === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_1169 === 2) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_1169 === 3) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$83$(_x_1158, _x_1159) {
  switch (_x_1158) {
    case 0: {
      if (_x_1159 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_1159 === 1) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_1159 === 2) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$87$(_x_1142, _x_1143) {
  switch (_x_1142.$tag) {
    case 0: {
      if (_x_1143.$tag === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_1143.$tag === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_1143.$tag === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_1143.$tag === 3) {
        return true;
      } else {
        return false;
      }
    }
    case 4: {
      if (_x_1143.$tag === 4) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      const _Regparm = _x_1142;
      const _$42$x0_1144 = _Regparm._0;
      if (_x_1143.$tag === 5) {
        const _Regparm$2 = _x_1143;
        const _$42$y0_1145 = _Regparm$2._0;
        return _$42$x0_1144 === _$42$y0_1145;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$179$(_x_1129, _x_1130) {
  switch (_x_1129) {
    case 0: {
      if (_x_1130 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_1130 === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_1130 === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_1130 === 3) {
        return true;
      } else {
        return false;
      }
    }
    case 4: {
      if (_x_1130 === 4) {
        return true;
      } else {
        return false;
      }
    }
    case 5: {
      if (_x_1130 === 5) {
        return true;
      } else {
        return false;
      }
    }
    case 6: {
      if (_x_1130 === 6) {
        return true;
      } else {
        return false;
      }
    }
    case 7: {
      if (_x_1130 === 7) {
        return true;
      } else {
        return false;
      }
    }
    case 8: {
      if (_x_1130 === 8) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_1130 === 9) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$29$(_x_940, _x_941) {
  let _tmp$27 = _x_940;
  let _tmp$28 = _x_941;
  _L: while (true) {
    const _x_940$2 = _tmp$27;
    const _x_941$2 = _tmp$28;
    switch (_x_940$2.$tag) {
      case 0: {
        if (_x_941$2.$tag === 0) {
          return true;
        } else {
          return false;
        }
      }
      case 1: {
        if (_x_941$2.$tag === 1) {
          return true;
        } else {
          return false;
        }
      }
      case 2: {
        const _Int = _x_940$2;
        const _$42$x0_942 = _Int._0;
        const _$42$x1_943 = _Int._1;
        if (_x_941$2.$tag === 2) {
          const _Int$2 = _x_941$2;
          const _$42$y0_944 = _Int$2._0;
          const _$42$y1_945 = _Int$2._1;
          return moonbitlang$core$builtin$$Eq$equal$180$(_$42$x0_942, _$42$y0_944) && _$42$x1_943 === _$42$y1_945;
        } else {
          return false;
        }
      }
      case 3: {
        const _Float = _x_940$2;
        const _$42$x0_946 = _Float._0;
        if (_x_941$2.$tag === 3) {
          const _Float$2 = _x_941$2;
          const _$42$y0_947 = _Float$2._0;
          return moonbitlang$core$builtin$$Eq$equal$83$(_$42$x0_946, _$42$y0_947);
        } else {
          return false;
        }
      }
      case 4: {
        const _Pointer = _x_940$2;
        const _$42$x0_948 = _Pointer._0;
        if (_x_941$2.$tag === 4) {
          const _Pointer$2 = _x_941$2;
          const _$42$y0_949 = _Pointer$2._0;
          _tmp$27 = _$42$x0_948;
          _tmp$28 = _$42$y0_949;
          continue _L;
        } else {
          return false;
        }
      }
      case 5: {
        const _Array = _x_940$2;
        const _$42$x0_950 = _Array._0;
        const _$42$x1_951 = _Array._1;
        const _$42$x2_952 = _Array._2;
        if (_x_941$2.$tag === 5) {
          const _Array$2 = _x_941$2;
          const _$42$y0_953 = _Array$2._0;
          const _$42$y1_954 = _Array$2._1;
          const _$42$y2_955 = _Array$2._2;
          return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_950, _$42$y0_953) && (moonbitlang$core$builtin$$Eq$equal$127$(_$42$x1_951, _$42$y1_954) && moonbitlang$core$builtin$$Eq$equal$126$(_$42$x2_952, _$42$y2_955));
        } else {
          return false;
        }
      }
      case 6: {
        const _Struct = _x_940$2;
        const _$42$x0_956 = _Struct._0;
        const _$42$x1_957 = _Struct._1;
        const _$42$x2_958 = _Struct._2;
        const _$42$x3_959 = _Struct._3;
        if (_x_941$2.$tag === 6) {
          const _Struct$2 = _x_941$2;
          const _$42$y0_960 = _Struct$2._0;
          const _$42$y1_961 = _Struct$2._1;
          const _$42$y2_962 = _Struct$2._2;
          const _$42$y3_963 = _Struct$2._3;
          return _$42$x0_956 === _$42$y0_960 && (_$42$x1_957 === _$42$y1_961 && (moonbitlang$core$builtin$$Eq$equal$128$(_$42$x2_958, _$42$y2_962) && moonbitlang$core$builtin$$Eq$equal$177$(_$42$x3_959, _$42$y3_963)));
        } else {
          return false;
        }
      }
      case 7: {
        const _Union = _x_940$2;
        const _$42$x0_964 = _Union._0;
        const _$42$x1_965 = _Union._1;
        const _$42$x2_966 = _Union._2;
        const _$42$x3_967 = _Union._3;
        if (_x_941$2.$tag === 7) {
          const _Union$2 = _x_941$2;
          const _$42$y0_968 = _Union$2._0;
          const _$42$y1_969 = _Union$2._1;
          const _$42$y2_970 = _Union$2._2;
          const _$42$y3_971 = _Union$2._3;
          return _$42$x0_964 === _$42$y0_968 && (_$42$x1_965 === _$42$y1_969 && (moonbitlang$core$builtin$$Eq$equal$128$(_$42$x2_966, _$42$y2_970) && moonbitlang$core$builtin$$Eq$equal$177$(_$42$x3_967, _$42$y3_971)));
        } else {
          return false;
        }
      }
      case 8: {
        const _Enum = _x_940$2;
        const _$42$x0_972 = _Enum._0;
        const _$42$x1_973 = _Enum._1;
        const _$42$x2_974 = _Enum._2;
        if (_x_941$2.$tag === 8) {
          const _Enum$2 = _x_941$2;
          const _$42$y0_975 = _Enum$2._0;
          const _$42$y1_976 = _Enum$2._1;
          const _$42$y2_977 = _Enum$2._2;
          return _$42$x0_972 === _$42$y0_975 && (_$42$x1_973 === _$42$y1_976 && moonbitlang$core$builtin$$Eq$equal$130$(_$42$x2_974, _$42$y2_977));
        } else {
          return false;
        }
      }
      case 9: {
        const _TypeofExpr = _x_940$2;
        const _$42$x0_978 = _TypeofExpr._0;
        if (_x_941$2.$tag === 9) {
          const _TypeofExpr$2 = _x_941$2;
          const _$42$y0_979 = _TypeofExpr$2._0;
          return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_978, _$42$y0_979);
        } else {
          return false;
        }
      }
      case 10: {
        const _Function = _x_940$2;
        const _$42$x0_980 = _Function._0;
        const _$42$x1_981 = _Function._1;
        const _$42$x2_982 = _Function._2;
        const _$42$x3_983 = _Function._3;
        const _$42$x4_984 = _Function._4;
        if (_x_941$2.$tag === 10) {
          const _Function$2 = _x_941$2;
          const _$42$y0_985 = _Function$2._0;
          const _$42$y1_986 = _Function$2._1;
          const _$42$y2_987 = _Function$2._2;
          const _$42$y3_988 = _Function$2._3;
          const _$42$y4_989 = _Function$2._4;
          return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_980, _$42$y0_985) && (moonbitlang$core$builtin$$Eq$equal$142$(_$42$x1_981, _$42$y1_986) && (_$42$x2_982 === _$42$y2_987 && (_$42$x3_983 === _$42$y3_988 && moonbitlang$core$builtin$$Eq$equal$87$(_$42$x4_984, _$42$y4_989))));
        } else {
          return false;
        }
      }
      case 11: {
        const _Attributed = _x_940$2;
        const _$42$x0_990 = _Attributed._0;
        const _$42$x1_991 = _Attributed._1;
        if (_x_941$2.$tag === 11) {
          const _Attributed$2 = _x_941$2;
          const _$42$y0_992 = _Attributed$2._0;
          const _$42$y1_993 = _Attributed$2._1;
          if (moonbitlang$core$builtin$$Eq$equal$177$(_$42$x0_990, _$42$y0_992)) {
            _tmp$27 = _$42$x1_991;
            _tmp$28 = _$42$y1_993;
            continue _L;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      default: {
        const _Qualified = _x_940$2;
        const _$42$x0_994 = _Qualified._0;
        const _$42$x1_995 = _Qualified._1;
        if (_x_941$2.$tag === 12) {
          const _Qualified$2 = _x_941$2;
          const _$42$y0_996 = _Qualified$2._0;
          const _$42$y1_997 = _Qualified$2._1;
          if (moonbitlang$core$builtin$$Eq$equal$75$(_$42$x0_994, _$42$y0_996)) {
            _tmp$27 = _$42$x1_995;
            _tmp$28 = _$42$y1_997;
            continue _L;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$49$(_x_583, _x_584) {
  switch (_x_583.$tag) {
    case 0: {
      const _Compound = _x_583;
      const _$42$x0_585 = _Compound._0;
      const _$42$x1_586 = _Compound._1;
      if (_x_584.$tag === 0) {
        const _Compound$2 = _x_584;
        const _$42$y0_587 = _Compound$2._0;
        const _$42$y1_588 = _Compound$2._1;
        return moonbitlang$core$builtin$$Eq$equal$144$(_$42$x0_585, _$42$y0_587) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_586, _$42$y1_588);
      } else {
        return false;
      }
    }
    case 1: {
      const _If = _x_583;
      const _$42$x0_589 = _If._0;
      const _$42$x1_590 = _If._1;
      const _$42$x2_591 = _If._2;
      const _$42$x3_592 = _If._3;
      if (_x_584.$tag === 1) {
        const _If$2 = _x_584;
        const _$42$y0_593 = _If$2._0;
        const _$42$y1_594 = _If$2._1;
        const _$42$y2_595 = _If$2._2;
        const _$42$y3_596 = _If$2._3;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_589, _$42$y0_593) && (moonbitlang$core$builtin$$Eq$equal$49$(_$42$x1_590, _$42$y1_594) && (moonbitlang$core$builtin$$Eq$equal$132$(_$42$x2_591, _$42$y2_595) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_592, _$42$y3_596)));
      } else {
        return false;
      }
    }
    case 2: {
      const _While = _x_583;
      const _$42$x0_597 = _While._0;
      const _$42$x1_598 = _While._1;
      const _$42$x2_599 = _While._2;
      if (_x_584.$tag === 2) {
        const _While$2 = _x_584;
        const _$42$y0_600 = _While$2._0;
        const _$42$y1_601 = _While$2._1;
        const _$42$y2_602 = _While$2._2;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_597, _$42$y0_600) && (moonbitlang$core$builtin$$Eq$equal$49$(_$42$x1_598, _$42$y1_601) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_599, _$42$y2_602));
      } else {
        return false;
      }
    }
    case 3: {
      const _DoWhile = _x_583;
      const _$42$x0_603 = _DoWhile._0;
      const _$42$x1_604 = _DoWhile._1;
      const _$42$x2_605 = _DoWhile._2;
      if (_x_584.$tag === 3) {
        const _DoWhile$2 = _x_584;
        const _$42$y0_606 = _DoWhile$2._0;
        const _$42$y1_607 = _DoWhile$2._1;
        const _$42$y2_608 = _DoWhile$2._2;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_603, _$42$y0_606) && (moonbitlang$core$builtin$$Eq$equal$49$(_$42$x1_604, _$42$y1_607) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_605, _$42$y2_608));
      } else {
        return false;
      }
    }
    case 4: {
      const _For = _x_583;
      const _$42$x0_609 = _For._0;
      const _$42$x1_610 = _For._1;
      const _$42$x2_611 = _For._2;
      const _$42$x3_612 = _For._3;
      const _$42$x4_613 = _For._4;
      if (_x_584.$tag === 4) {
        const _For$2 = _x_584;
        const _$42$y0_614 = _For$2._0;
        const _$42$y1_615 = _For$2._1;
        const _$42$y2_616 = _For$2._2;
        const _$42$y3_617 = _For$2._3;
        const _$42$y4_618 = _For$2._4;
        return moonbitlang$core$builtin$$Eq$equal$132$(_$42$x0_609, _$42$y0_614) && (moonbitlang$core$builtin$$Eq$equal$126$(_$42$x1_610, _$42$y1_615) && (moonbitlang$core$builtin$$Eq$equal$126$(_$42$x2_611, _$42$y2_616) && (moonbitlang$core$builtin$$Eq$equal$49$(_$42$x3_612, _$42$y3_617) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x4_613, _$42$y4_618))));
      } else {
        return false;
      }
    }
    case 5: {
      const _Switch = _x_583;
      const _$42$x0_619 = _Switch._0;
      const _$42$x1_620 = _Switch._1;
      const _$42$x2_621 = _Switch._2;
      if (_x_584.$tag === 5) {
        const _Switch$2 = _x_584;
        const _$42$y0_622 = _Switch$2._0;
        const _$42$y1_623 = _Switch$2._1;
        const _$42$y2_624 = _Switch$2._2;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_619, _$42$y0_622) && (moonbitlang$core$builtin$$Eq$equal$49$(_$42$x1_620, _$42$y1_623) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_621, _$42$y2_624));
      } else {
        return false;
      }
    }
    case 6: {
      const _Case = _x_583;
      const _$42$x0_625 = _Case._0;
      const _$42$x1_626 = _Case._1;
      const _$42$x2_627 = _Case._2;
      const _$42$x3_628 = _Case._3;
      if (_x_584.$tag === 6) {
        const _Case$2 = _x_584;
        const _$42$y0_629 = _Case$2._0;
        const _$42$y1_630 = _Case$2._1;
        const _$42$y2_631 = _Case$2._2;
        const _$42$y3_632 = _Case$2._3;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_625, _$42$y0_629) && (moonbitlang$core$builtin$$Eq$equal$126$(_$42$x1_626, _$42$y1_630) && (moonbitlang$core$builtin$$Eq$equal$49$(_$42$x2_627, _$42$y2_631) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x3_628, _$42$y3_632)));
      } else {
        return false;
      }
    }
    case 7: {
      const _Default = _x_583;
      const _$42$x0_633 = _Default._0;
      const _$42$x1_634 = _Default._1;
      if (_x_584.$tag === 7) {
        const _Default$2 = _x_584;
        const _$42$y0_635 = _Default$2._0;
        const _$42$y1_636 = _Default$2._1;
        return moonbitlang$core$builtin$$Eq$equal$49$(_$42$x0_633, _$42$y0_635) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_634, _$42$y1_636);
      } else {
        return false;
      }
    }
    case 8: {
      const _Label = _x_583;
      const _$42$x0_637 = _Label._0;
      const _$42$x1_638 = _Label._1;
      const _$42$x2_639 = _Label._2;
      if (_x_584.$tag === 8) {
        const _Label$2 = _x_584;
        const _$42$y0_640 = _Label$2._0;
        const _$42$y1_641 = _Label$2._1;
        const _$42$y2_642 = _Label$2._2;
        return _$42$x0_637 === _$42$y0_640 && (moonbitlang$core$builtin$$Eq$equal$49$(_$42$x1_638, _$42$y1_641) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x2_639, _$42$y2_642));
      } else {
        return false;
      }
    }
    case 9: {
      const _Goto = _x_583;
      const _$42$x0_643 = _Goto._0;
      const _$42$x1_644 = _Goto._1;
      if (_x_584.$tag === 9) {
        const _Goto$2 = _x_584;
        const _$42$y0_645 = _Goto$2._0;
        const _$42$y1_646 = _Goto$2._1;
        return _$42$x0_643 === _$42$y0_645 && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_644, _$42$y1_646);
      } else {
        return false;
      }
    }
    case 10: {
      const _GotoExpr = _x_583;
      const _$42$x0_647 = _GotoExpr._0;
      const _$42$x1_648 = _GotoExpr._1;
      if (_x_584.$tag === 10) {
        const _GotoExpr$2 = _x_584;
        const _$42$y0_649 = _GotoExpr$2._0;
        const _$42$y1_650 = _GotoExpr$2._1;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_647, _$42$y0_649) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_648, _$42$y1_650);
      } else {
        return false;
      }
    }
    case 11: {
      const _Break = _x_583;
      const _$42$x0_651 = _Break._0;
      if (_x_584.$tag === 11) {
        const _Break$2 = _x_584;
        const _$42$y0_652 = _Break$2._0;
        return moonbitlang$core$builtin$$Eq$equal$176$(_$42$x0_651, _$42$y0_652);
      } else {
        return false;
      }
    }
    case 12: {
      const _Continue = _x_583;
      const _$42$x0_653 = _Continue._0;
      if (_x_584.$tag === 12) {
        const _Continue$2 = _x_584;
        const _$42$y0_654 = _Continue$2._0;
        return moonbitlang$core$builtin$$Eq$equal$176$(_$42$x0_653, _$42$y0_654);
      } else {
        return false;
      }
    }
    case 13: {
      const _Return = _x_583;
      const _$42$x0_655 = _Return._0;
      const _$42$x1_656 = _Return._1;
      if (_x_584.$tag === 13) {
        const _Return$2 = _x_584;
        const _$42$y0_657 = _Return$2._0;
        const _$42$y1_658 = _Return$2._1;
        return moonbitlang$core$builtin$$Eq$equal$126$(_$42$x0_655, _$42$y0_657) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_656, _$42$y1_658);
      } else {
        return false;
      }
    }
    case 14: {
      const _Asm = _x_583;
      const _$42$x0_659 = _Asm._0;
      if (_x_584.$tag === 14) {
        const _Asm$2 = _x_584;
        const _$42$y0_660 = _Asm$2._0;
        return moonbitlang$core$builtin$$Eq$equal$181$(_$42$x0_659, _$42$y0_660);
      } else {
        return false;
      }
    }
    case 15: {
      const _ExprStmt = _x_583;
      const _$42$x0_661 = _ExprStmt._0;
      const _$42$x1_662 = _ExprStmt._1;
      if (_x_584.$tag === 15) {
        const _ExprStmt$2 = _x_584;
        const _$42$y0_663 = _ExprStmt$2._0;
        const _$42$y1_664 = _ExprStmt$2._1;
        return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_661, _$42$y0_663) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_662, _$42$y1_664);
      } else {
        return false;
      }
    }
    case 16: {
      const _DeclStmt = _x_583;
      const _$42$x0_665 = _DeclStmt._0;
      const _$42$x1_666 = _DeclStmt._1;
      if (_x_584.$tag === 16) {
        const _DeclStmt$2 = _x_584;
        const _$42$y0_667 = _DeclStmt$2._0;
        const _$42$y1_668 = _DeclStmt$2._1;
        return moonbitlang$core$builtin$$Eq$equal$147$(_$42$x0_665, _$42$y0_667) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_666, _$42$y1_668);
      } else {
        return false;
      }
    }
    case 17: {
      const _TagDef = _x_583;
      const _$42$x0_669 = _TagDef._0;
      const _$42$x1_670 = _TagDef._1;
      if (_x_584.$tag === 17) {
        const _TagDef$2 = _x_584;
        const _$42$y0_671 = _TagDef$2._0;
        const _$42$y1_672 = _TagDef$2._1;
        return moonbitlang$core$builtin$$Eq$equal$29$(_$42$x0_669, _$42$y0_671) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_670, _$42$y1_672);
      } else {
        return false;
      }
    }
    case 18: {
      const _StaticAssert = _x_583;
      const _$42$x0_673 = _StaticAssert._0;
      if (_x_584.$tag === 18) {
        const _StaticAssert$2 = _x_584;
        const _$42$y0_674 = _StaticAssert$2._0;
        return moonbitlang$core$builtin$$Eq$equal$182$(_$42$x0_673, _$42$y0_674);
      } else {
        return false;
      }
    }
    default: {
      const _Empty = _x_583;
      const _$42$x0_675 = _Empty._0;
      if (_x_584.$tag === 19) {
        const _Empty$2 = _x_584;
        const _$42$y0_676 = _Empty$2._0;
        return moonbitlang$core$builtin$$Eq$equal$176$(_$42$x0_675, _$42$y0_676);
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$112$(_x_457, _x_458) {
  return moonbitlang$core$builtin$$Eq$equal$124$(_x_457.name, _x_458.name) && _x_457.constraint === _x_458.constraint && moonbitlang$core$builtin$$Eq$equal$55$(_x_457.expr, _x_458.expr) && moonbitlang$core$builtin$$Eq$equal$176$(_x_457.loc, _x_458.loc);
}
function moonbitlang$core$builtin$$Eq$equal$38$(_x_445, _x_446) {
  return moonbitlang$core$builtin$$Eq$equal$148$(_x_445.designators, _x_446.designators) && moonbitlang$core$builtin$$Eq$equal$134$(_x_445.value, _x_446.value) && moonbitlang$core$builtin$$Eq$equal$176$(_x_445.loc, _x_446.loc);
}
function moonbitlang$core$builtin$$Eq$equal$181$(_x_434, _x_435) {
  return _x_434.template === _x_435.template && moonbitlang$core$builtin$$Eq$equal$149$(_x_434.outputs, _x_435.outputs) && moonbitlang$core$builtin$$Eq$equal$149$(_x_434.inputs, _x_435.inputs) && moonbitlang$core$builtin$$Eq$equal$143$(_x_434.clobbers, _x_435.clobbers) && moonbitlang$core$builtin$$Eq$equal$143$(_x_434.labels, _x_435.labels) && _x_434.is_volatile === _x_435.is_volatile && _x_434.is_goto === _x_435.is_goto && moonbitlang$core$builtin$$Eq$equal$176$(_x_434.loc, _x_435.loc);
}
function moonbitlang$core$builtin$$Eq$equal$113$(_x_400, _x_401) {
  if (_x_400.$tag === 0) {
    const _Field = _x_400;
    const _$42$x0_402 = _Field._0;
    if (_x_401.$tag === 0) {
      const _Field$2 = _x_401;
      const _$42$y0_403 = _Field$2._0;
      return moonbitlang$core$builtin$$Eq$equal$39$(_$42$x0_402, _$42$y0_403);
    } else {
      return false;
    }
  } else {
    const _StaticAssert = _x_400;
    const _$42$x0_404 = _StaticAssert._0;
    if (_x_401.$tag === 1) {
      const _StaticAssert$2 = _x_401;
      const _$42$y0_405 = _StaticAssert$2._0;
      return moonbitlang$core$builtin$$Eq$equal$182$(_$42$x0_404, _$42$y0_405);
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$182$(_x_386, _x_387) {
  return moonbitlang$core$builtin$$Eq$equal$55$(_x_386.expr, _x_387.expr) && moonbitlang$core$builtin$$Eq$equal$124$(_x_386.message, _x_387.message) && moonbitlang$core$builtin$$Eq$equal$176$(_x_386.loc, _x_387.loc);
}
function moonbitlang$core$builtin$$Eq$equal$177$(_x_374, _x_375) {
  return moonbitlang$core$builtin$$Eq$equal$120$(_x_374.aligned, _x_375.aligned) && _x_374.packed === _x_375.packed && _x_374.weak === _x_375.weak && moonbitlang$core$builtin$$Eq$equal$122$(_x_374.visibility, _x_375.visibility) && moonbitlang$core$builtin$$Eq$equal$124$(_x_374.section, _x_375.section) && moonbitlang$core$builtin$$Eq$equal$124$(_x_374.alias_name, _x_375.alias_name) && moonbitlang$core$builtin$$Eq$equal$124$(_x_374.asm_label, _x_375.asm_label) && moonbitlang$core$builtin$$Eq$equal$124$(_x_374.cleanup, _x_375.cleanup) && _x_374.noreturn === _x_375.noreturn && _x_374.constructor_attr === _x_375.constructor_attr && _x_374.destructor === _x_375.destructor && _x_374.always_inline === _x_375.always_inline && moonbitlang$core$builtin$$Eq$equal$125$(_x_374.call_conv, _x_375.call_conv) && _x_374.dll_import === _x_375.dll_import && _x_374.dll_export === _x_375.dll_export && _x_374.nodecorate === _x_375.nodecorate && _x_374.nodebug === _x_375.nodebug;
}
function moonbitlang$core$builtin$$Eq$equal$121$(_x_350, _x_351) {
  if (_x_350.$tag === 0) {
    if (_x_351.$tag === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    const _Expr = _x_350;
    const _$42$x0_352 = _Expr._0;
    if (_x_351.$tag === 1) {
      const _Expr$2 = _x_351;
      const _$42$y0_353 = _Expr$2._0;
      return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_352, _$42$y0_353);
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$75$(_x_237, _x_238) {
  return _x_237.is_const === _x_238.is_const && _x_237.is_volatile === _x_238.is_volatile && _x_237.is_restrict === _x_238.is_restrict && _x_237.is_atomic === _x_238.is_atomic;
}
function moonbitlang$core$builtin$$Eq$equal$134$(_x_191, _x_192) {
  if (_x_191.$tag === 0) {
    const _Expr = _x_191;
    const _$42$x0_193 = _Expr._0;
    const _$42$x1_194 = _Expr._1;
    if (_x_192.$tag === 0) {
      const _Expr$2 = _x_192;
      const _$42$y0_195 = _Expr$2._0;
      const _$42$y1_196 = _Expr$2._1;
      return moonbitlang$core$builtin$$Eq$equal$55$(_$42$x0_193, _$42$y0_195) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_194, _$42$y1_196);
    } else {
      return false;
    }
  } else {
    const _List = _x_191;
    const _$42$x0_197 = _List._0;
    const _$42$x1_198 = _List._1;
    if (_x_192.$tag === 1) {
      const _List$2 = _x_192;
      const _$42$y0_199 = _List$2._0;
      const _$42$y1_200 = _List$2._1;
      return moonbitlang$core$builtin$$Eq$equal$146$(_$42$x0_197, _$42$y0_199) && moonbitlang$core$builtin$$Eq$equal$176$(_$42$x1_198, _$42$y1_200);
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$180$(_x_171, _x_172) {
  switch (_x_171) {
    case 0: {
      if (_x_172 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_172 === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_172 === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_172 === 3) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_172 === 4) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$merge_qual(a, b) {
  return { is_const: a.is_const || b.is_const, is_volatile: a.is_volatile || b.is_volatile, is_restrict: a.is_restrict || b.is_restrict, is_atomic: a.is_atomic || b.is_atomic };
}
function hackwaly$tinycc$frontend$ast$ast_core$$qual_is_empty(qual) {
  return !qual.is_const && (!qual.is_volatile && (!qual.is_restrict && !qual.is_atomic));
}
function hackwaly$tinycc$frontend$ast$ast_core$$with_const(qual) {
  return { is_const: true, is_volatile: qual.is_volatile, is_restrict: qual.is_restrict, is_atomic: qual.is_atomic };
}
function hackwaly$tinycc$frontend$ast$ast_core$$with_volatile(qual) {
  return { is_const: qual.is_const, is_volatile: true, is_restrict: qual.is_restrict, is_atomic: qual.is_atomic };
}
function hackwaly$tinycc$frontend$ast$ast_core$$with_restrict(qual) {
  return { is_const: qual.is_const, is_volatile: qual.is_volatile, is_restrict: true, is_atomic: qual.is_atomic };
}
function hackwaly$tinycc$frontend$ast$ast_core$$with_atomic(qual) {
  return { is_const: qual.is_const, is_volatile: qual.is_volatile, is_restrict: qual.is_restrict, is_atomic: true };
}
function hackwaly$tinycc$frontend$ast$ast_core$$apply_qualifiers(ty, qual) {
  if (hackwaly$tinycc$frontend$ast$ast_core$$qual_is_empty(qual)) {
    return ty;
  }
  if (ty.$tag === 12) {
    const _Qualified = ty;
    const _existing = _Qualified._0;
    const _base = _Qualified._1;
    return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(hackwaly$tinycc$frontend$ast$ast_core$$merge_qual(_existing, qual), _base);
  } else {
    return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(qual, ty);
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$expr_is_lvalue_simple(expr) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    switch (expr$2.$tag) {
      case 4: {
        return true;
      }
      case 20: {
        return true;
      }
      case 21: {
        const _Member = expr$2;
        const _base = _Member._0;
        const _is_arrow = _Member._3;
        if (_is_arrow) {
          return true;
        } else {
          _tmp$27 = _base;
          continue _L;
        }
      }
      case 9: {
        const _Unary = expr$2;
        const _x = _Unary._0;
        if (_x === 5) {
          return true;
        } else {
          return false;
        }
      }
      case 11: {
        return true;
      }
      case 12: {
        const _StmtExpr = expr$2;
        const _stmts = _StmtExpr._0;
        const len = _stmts.length;
        if (len === 0) {
          return false;
        } else {
          const _bind = moonbitlang$core$array$$Array$at$49$(_stmts, len - 1 | 0);
          if (_bind.$tag === 15) {
            const _ExprStmt = _bind;
            const _expr = _ExprStmt._0;
            _tmp$27 = _expr;
            continue _L;
          } else {
            return false;
          }
        }
      }
      default: {
        return false;
      }
    }
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$expr_may_call(expr) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    let inner;
    _L$2: {
      switch (expr$2.$tag) {
        case 19: {
          return true;
        }
        case 9: {
          const _Unary = expr$2;
          const _inner = _Unary._1;
          inner = _inner;
          break _L$2;
        }
        case 10: {
          const _Cast = expr$2;
          const _inner$2 = _Cast._1;
          inner = _inner$2;
          break _L$2;
        }
        case 13: {
          return false;
        }
        case 15: {
          return false;
        }
        case 17: {
          const _Binary = expr$2;
          const _left = _Binary._1;
          const _right = _Binary._2;
          if (hackwaly$tinycc$frontend$ast$ast_core$$expr_may_call(_left)) {
            return true;
          } else {
            _tmp$27 = _right;
            continue _L;
          }
        }
        case 18: {
          const _Conditional = expr$2;
          const _cond = _Conditional._0;
          const _then_expr = _Conditional._1;
          const _else_expr = _Conditional._2;
          if (hackwaly$tinycc$frontend$ast$ast_core$$expr_may_call(_cond)) {
            return true;
          } else {
            let _tmp$28;
            if (hackwaly$tinycc$frontend$ast$ast_core$$expr_may_call(_then_expr)) {
              _tmp$28 = true;
            } else {
              _tmp$27 = _else_expr;
              continue _L;
            }
            return _tmp$28;
          }
        }
        case 20: {
          const _Index = expr$2;
          const _base = _Index._0;
          const _index = _Index._1;
          if (hackwaly$tinycc$frontend$ast$ast_core$$expr_may_call(_base)) {
            return true;
          } else {
            _tmp$27 = _index;
            continue _L;
          }
        }
        case 21: {
          const _Member = expr$2;
          const _base$2 = _Member._0;
          _tmp$27 = _base$2;
          continue _L;
        }
        case 8: {
          const _BuiltinVaArg = expr$2;
          const _list = _BuiltinVaArg._0;
          _tmp$27 = _list;
          continue _L;
        }
        case 12: {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    _tmp$27 = inner;
    continue;
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$parse_int64_literal(text) {
  if (text === "") {
    return undefined;
  }
  const len = text.length;
  let base = 10;
  let start = 0;
  let _tmp$27;
  if (len >= 2) {
    $bound_check(text, 0);
    _tmp$27 = text.charCodeAt(0) === 48;
  } else {
    _tmp$27 = false;
  }
  if (_tmp$27) {
    $bound_check(text, 1);
    const second = text.charCodeAt(1);
    if (second === 120 || second === 88) {
      base = 16;
      start = 2;
    } else {
      if (second === 98 || second === 66) {
        base = 2;
        start = 2;
      } else {
        base = 8;
        start = 1;
      }
    }
  }
  if (start >= len) {
    return hackwaly$tinycc$frontend$ast$ast_core$$parse_int64_literal$46$constr$47$5546;
  }
  let acc = $0L;
  const base_u64 = moonbitlang$core$int$$Int$to_uint64(base);
  let any_digit = start === 1;
  let i = start;
  while (true) {
    if (i < len) {
      const _tmp$28 = i;
      $bound_check(text, _tmp$28);
      const ch = text.charCodeAt(_tmp$28);
      i = i + 1 | 0;
      if (ch === 95) {
        continue;
      }
      const base$2 = base;
      const _bind = ch >= 48 && ch <= 57 ? moonbitlang$core$int$$Int$to_uint64(ch - 48 | 0) : base$2 === 16 && (ch >= 97 && ch <= 102) ? moonbitlang$core$int$$Int$to_uint64(10 + (ch - 97 | 0) | 0) : base$2 === 16 && (ch >= 65 && ch <= 70) ? moonbitlang$core$int$$Int$to_uint64(10 + (ch - 65 | 0) | 0) : undefined;
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _d = _Some;
        if (moonbitlang$core$builtin$$Compare$op_ge$80$(_d, base_u64)) {
          return undefined;
        } else {
          any_digit = true;
          acc = moonbitlang$core$builtin$$Add$add$6$(moonbitlang$core$builtin$$Mul$mul$6$(acc, base_u64), _d);
        }
      }
      continue;
    } else {
      break;
    }
  }
  return !any_digit ? undefined : acc;
}
function hackwaly$tinycc$frontend$ast$ast_core$$const_i64_from_expr(expr) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    _L$2: {
      switch (expr$2.$tag) {
        case 0: {
          const _IntLit = expr$2;
          const _value = _IntLit._0;
          return hackwaly$tinycc$frontend$ast$ast_core$$parse_int64_literal(_value);
        }
        case 9: {
          const _Unary = expr$2;
          const _x = _Unary._0;
          switch (_x) {
            case 0: {
              const _inner = _Unary._1;
              _tmp$27 = _inner;
              continue _L;
            }
            case 1: {
              const _inner$2 = _Unary._1;
              const _bind = hackwaly$tinycc$frontend$ast$ast_core$$const_i64_from_expr(_inner$2);
              if (_bind === undefined) {
                return undefined;
              } else {
                const _Some = _bind;
                const _v = _Some;
                return moonbitlang$core$builtin$$Neg$neg$7$(_v);
              }
            }
            default: {
              break _L$2;
            }
          }
        }
        default: {
          break _L$2;
        }
      }
    }
    return undefined;
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$expr_loc(expr) {
  switch (expr.$tag) {
    case 0: {
      const _IntLit = expr;
      return _IntLit._2;
    }
    case 1: {
      const _FloatLit = expr;
      return _FloatLit._2;
    }
    case 2: {
      const _CharLit = expr;
      return _CharLit._2;
    }
    case 3: {
      const _StringLit = expr;
      return _StringLit._3;
    }
    case 4: {
      const _Ident = expr;
      return _Ident._3;
    }
    case 5: {
      const _LabelAddr = expr;
      return _LabelAddr._3;
    }
    case 6: {
      const _BuiltinTypesCompatibleP = expr;
      return _BuiltinTypesCompatibleP._3;
    }
    case 7: {
      const _BuiltinOffsetof = expr;
      return _BuiltinOffsetof._3;
    }
    case 8: {
      const _BuiltinVaArg = expr;
      return _BuiltinVaArg._3;
    }
    case 9: {
      const _Unary = expr;
      return _Unary._3;
    }
    case 10: {
      const _Cast = expr;
      return _Cast._3;
    }
    case 11: {
      const _CompoundLiteral = expr;
      return _CompoundLiteral._3;
    }
    case 12: {
      const _StmtExpr = expr;
      return _StmtExpr._2;
    }
    case 13: {
      const _SizeofExpr = expr;
      return _SizeofExpr._2;
    }
    case 14: {
      const _SizeofType = expr;
      return _SizeofType._2;
    }
    case 15: {
      const _AlignofExpr = expr;
      return _AlignofExpr._2;
    }
    case 16: {
      const _AlignofType = expr;
      return _AlignofType._2;
    }
    case 17: {
      const _Binary = expr;
      return _Binary._4;
    }
    case 18: {
      const _Conditional = expr;
      return _Conditional._4;
    }
    case 19: {
      const _Call = expr;
      return _Call._3;
    }
    case 20: {
      const _Index = expr;
      return _Index._3;
    }
    default: {
      const _Member = expr;
      return _Member._5;
    }
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$expr_node_id(expr) {
  switch (expr.$tag) {
    case 0: {
      const _IntLit = expr;
      return _IntLit._1;
    }
    case 1: {
      const _FloatLit = expr;
      return _FloatLit._1;
    }
    case 2: {
      const _CharLit = expr;
      return _CharLit._1;
    }
    case 3: {
      const _StringLit = expr;
      return _StringLit._2;
    }
    case 4: {
      const _Ident = expr;
      return _Ident._2;
    }
    case 5: {
      const _LabelAddr = expr;
      return _LabelAddr._2;
    }
    case 6: {
      const _BuiltinTypesCompatibleP = expr;
      return _BuiltinTypesCompatibleP._2;
    }
    case 7: {
      const _BuiltinOffsetof = expr;
      return _BuiltinOffsetof._2;
    }
    case 8: {
      const _BuiltinVaArg = expr;
      return _BuiltinVaArg._2;
    }
    case 9: {
      const _Unary = expr;
      return _Unary._2;
    }
    case 10: {
      const _Cast = expr;
      return _Cast._2;
    }
    case 11: {
      const _CompoundLiteral = expr;
      return _CompoundLiteral._2;
    }
    case 12: {
      const _StmtExpr = expr;
      return _StmtExpr._1;
    }
    case 13: {
      const _SizeofExpr = expr;
      return _SizeofExpr._1;
    }
    case 14: {
      const _SizeofType = expr;
      return _SizeofType._1;
    }
    case 15: {
      const _AlignofExpr = expr;
      return _AlignofExpr._1;
    }
    case 16: {
      const _AlignofType = expr;
      return _AlignofType._1;
    }
    case 17: {
      const _Binary = expr;
      return _Binary._3;
    }
    case 18: {
      const _Conditional = expr;
      return _Conditional._3;
    }
    case 19: {
      const _Call = expr;
      return _Call._2;
    }
    case 20: {
      const _Index = expr;
      return _Index._2;
    }
    default: {
      const _Member = expr;
      return _Member._4;
    }
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$normalize_call_conv(call_conv) {
  if (call_conv === undefined) {
    return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default;
  } else {
    const _Some = call_conv;
    const _x = _Some;
    switch (_x.$tag) {
      case 0: {
        return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default;
      }
      case 1: {
        return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default;
      }
      case 5: {
        const _Regparm = _x;
        const _count = _Regparm._0;
        return _count <= 0 ? $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default : new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Regparm(_count);
      }
      default: {
        return _x;
      }
    }
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$merge_call_conv(existing, incoming) {
  return moonbitlang$core$builtin$$Eq$equal$87$(existing, $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default) ? incoming : existing;
}
function hackwaly$tinycc$frontend$ast$ast_core$$empty_attrs() {
  return { aligned: undefined, packed: false, weak: false, visibility: undefined, section: undefined, alias_name: undefined, asm_label: undefined, cleanup: undefined, noreturn: false, constructor_attr: false, destructor: false, always_inline: false, call_conv: undefined, dll_import: false, dll_export: false, nodecorate: false, nodebug: false };
}
function hackwaly$tinycc$frontend$ast$ast_core$$attrs_with$46$inner(aligned, packed, weak, visibility, section, alias_name, asm_label, cleanup, noreturn, constructor_attr, destructor, always_inline, call_conv, dll_import, dll_export, nodecorate, nodebug) {
  return { aligned: aligned, packed: packed, weak: weak, visibility: visibility, section: section, alias_name: alias_name, asm_label: asm_label, cleanup: cleanup, noreturn: noreturn, constructor_attr: constructor_attr, destructor: destructor, always_inline: always_inline, call_conv: call_conv, dll_import: dll_import, dll_export: dll_export, nodecorate: nodecorate, nodebug: nodebug };
}
function hackwaly$tinycc$frontend$ast$ast_core$$attrs_is_empty(attrs) {
  const _bind = attrs.aligned;
  if (_bind === undefined) {
    if (!attrs.packed) {
      let _tmp$27;
      if (!attrs.weak) {
        const _bind$2 = attrs.visibility;
        let _tmp$28;
        if (_bind$2 === undefined) {
          const _bind$3 = attrs.section;
          if (_bind$3 === undefined) {
            const _bind$4 = attrs.alias_name;
            if (_bind$4 === undefined) {
              const _bind$5 = attrs.asm_label;
              if (_bind$5 === undefined) {
                const _bind$6 = attrs.cleanup;
                if (_bind$6 === undefined) {
                  if (!attrs.noreturn) {
                    let _tmp$29;
                    if (!attrs.constructor_attr) {
                      let _tmp$30;
                      if (!attrs.destructor) {
                        let _tmp$31;
                        if (!attrs.always_inline) {
                          const _bind$7 = attrs.call_conv;
                          _tmp$31 = _bind$7 === undefined ? !attrs.dll_import && (!attrs.dll_export && (!attrs.nodecorate && !attrs.nodebug)) : false;
                        } else {
                          _tmp$31 = false;
                        }
                        _tmp$30 = _tmp$31;
                      } else {
                        _tmp$30 = false;
                      }
                      _tmp$29 = _tmp$30;
                    } else {
                      _tmp$29 = false;
                    }
                    _tmp$28 = _tmp$29;
                  } else {
                    _tmp$28 = false;
                  }
                } else {
                  _tmp$28 = false;
                }
              } else {
                _tmp$28 = false;
              }
            } else {
              _tmp$28 = false;
            }
          } else {
            _tmp$28 = false;
          }
        } else {
          _tmp$28 = false;
        }
        _tmp$27 = _tmp$28;
      } else {
        _tmp$27 = false;
      }
      return _tmp$27;
    } else {
      return false;
    }
  } else {
    return false;
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$merge_attrs(base, incoming) {
  if (hackwaly$tinycc$frontend$ast$ast_core$$attrs_is_empty(incoming)) {
    return base;
  }
  if (hackwaly$tinycc$frontend$ast$ast_core$$attrs_is_empty(base)) {
    return incoming;
  }
  const _bind = base.visibility;
  let visibility;
  if (_bind === undefined) {
    visibility = incoming.visibility;
  } else {
    const _Some = _bind;
    const _val = _Some;
    visibility = _val;
  }
  const _bind$2 = incoming.section;
  const section = _bind$2 === undefined ? base.section : incoming.section;
  const _bind$3 = incoming.alias_name;
  const alias_name = _bind$3 === undefined ? base.alias_name : incoming.alias_name;
  const _bind$4 = incoming.asm_label;
  const asm_label = _bind$4 === undefined ? base.asm_label : incoming.asm_label;
  const _bind$5 = incoming.cleanup;
  const cleanup = _bind$5 === undefined ? base.cleanup : incoming.cleanup;
  const _bind$6 = base.call_conv;
  let call_conv;
  if (_bind$6 === undefined) {
    call_conv = incoming.call_conv;
  } else {
    const _Some = _bind$6;
    const _val = _Some;
    call_conv = _val;
  }
  const _bind$7 = base.aligned;
  return { aligned: _bind$7 === undefined ? incoming.aligned : base.aligned, packed: base.packed || incoming.packed, weak: base.weak || incoming.weak, visibility: visibility, section: section, alias_name: alias_name, asm_label: asm_label, cleanup: cleanup, noreturn: base.noreturn || incoming.noreturn, constructor_attr: base.constructor_attr || incoming.constructor_attr, destructor: base.destructor || incoming.destructor, always_inline: base.always_inline || incoming.always_inline, call_conv: call_conv, dll_import: base.dll_import || incoming.dll_import, dll_export: base.dll_export || incoming.dll_export, nodecorate: base.nodecorate || incoming.nodecorate, nodebug: base.nodebug || incoming.nodebug };
}
function hackwaly$tinycc$frontend$ast$ast_core$$type_attrs_from(attrs) {
  return { aligned: attrs.aligned, packed: attrs.packed, weak: false, visibility: undefined, section: undefined, alias_name: undefined, asm_label: undefined, cleanup: undefined, noreturn: false, constructor_attr: false, destructor: false, always_inline: false, call_conv: undefined, dll_import: false, dll_export: false, nodecorate: false, nodebug: false };
}
function hackwaly$tinycc$frontend$ast$ast_core$$apply_type_attrs(ty, attrs) {
  const _p$28 = attrs.aligned;
  if (!(_p$28 === undefined ? attrs.packed : true)) {
    return ty;
  }
  switch (ty.$tag) {
    case 6: {
      const _Struct = ty;
      const _name = _Struct._0;
      const _id = _Struct._1;
      const _fields = _Struct._2;
      const _existing = _Struct._3;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Struct(_name, _id, _fields, hackwaly$tinycc$frontend$ast$ast_core$$merge_attrs(_existing, attrs));
    }
    case 7: {
      const _Union = ty;
      const _name$2 = _Union._0;
      const _id$2 = _Union._1;
      const _fields$2 = _Union._2;
      const _existing$2 = _Union._3;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Union(_name$2, _id$2, _fields$2, hackwaly$tinycc$frontend$ast$ast_core$$merge_attrs(_existing$2, attrs));
    }
    case 11: {
      const _Attributed = ty;
      const _existing$3 = _Attributed._0;
      const _base = _Attributed._1;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(hackwaly$tinycc$frontend$ast$ast_core$$merge_attrs(_existing$3, attrs), _base);
    }
    default: {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(attrs, ty);
    }
  }
}
function hackwaly$tinycc$frontend$ast$ast_core$$apply_call_conv_to_type(ty, call_conv) {
  if (moonbitlang$core$builtin$$Eq$equal$87$(call_conv, $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default)) {
    return ty;
  }
  switch (ty.$tag) {
    case 12: {
      const _Qualified = ty;
      const _qual = _Qualified._0;
      const _base = _Qualified._1;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, hackwaly$tinycc$frontend$ast$ast_core$$apply_call_conv_to_type(_base, call_conv));
    }
    case 11: {
      const _Attributed = ty;
      const _attrs = _Attributed._0;
      const _base$2 = _Attributed._1;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs, hackwaly$tinycc$frontend$ast$ast_core$$apply_call_conv_to_type(_base$2, call_conv));
    }
    case 4: {
      const _Pointer = ty;
      const _inner = _Pointer._0;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$frontend$ast$ast_core$$apply_call_conv_to_type(_inner, call_conv));
    }
    case 5: {
      const _Array = ty;
      const _elem = _Array._0;
      const _size = _Array._1;
      const _size_expr = _Array._2;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$frontend$ast$ast_core$$apply_call_conv_to_type(_elem, call_conv), _size, _size_expr);
    }
    case 10: {
      const _Function = ty;
      const _return_type = _Function._0;
      const _params = _Function._1;
      const _varargs = _Function._2;
      const _is_old_style = _Function._3;
      const _existing = _Function._4;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(_return_type, _params, _varargs, _is_old_style, hackwaly$tinycc$frontend$ast$ast_core$$merge_call_conv(_existing, call_conv));
    }
    default: {
      return ty;
    }
  }
}
function hackwaly$tinycc$frontend$ast$$normalize_call_conv(call_conv) {
  return hackwaly$tinycc$frontend$ast$ast_core$$normalize_call_conv(call_conv);
}
function hackwaly$tinycc$frontend$ast$$empty_attrs() {
  return hackwaly$tinycc$frontend$ast$ast_core$$empty_attrs();
}
function hackwaly$tinycc$frontend$ast$$attrs_with$46$inner(aligned, packed, weak, visibility, section, alias_name, asm_label, cleanup, noreturn, constructor_attr, destructor, always_inline, call_conv, dll_import, dll_export, nodecorate, nodebug) {
  return hackwaly$tinycc$frontend$ast$ast_core$$attrs_with$46$inner(aligned, packed, weak, visibility, section, alias_name, asm_label, cleanup, noreturn, constructor_attr, destructor, always_inline, call_conv, dll_import, dll_export, nodecorate, nodebug);
}
function hackwaly$tinycc$frontend$ast$$attrs_with(aligned$46$opt, packed$46$opt, weak$46$opt, visibility$46$opt, section$46$opt, alias_name$46$opt, asm_label$46$opt, cleanup$46$opt, noreturn$46$opt, constructor_attr$46$opt, destructor$46$opt, always_inline$46$opt, call_conv$46$opt, dll_import$46$opt, dll_export$46$opt, nodecorate$46$opt, nodebug$46$opt) {
  let aligned;
  if (aligned$46$opt.$tag === 1) {
    const _Some = aligned$46$opt;
    aligned = _Some._0;
  } else {
    aligned = undefined;
  }
  const packed = packed$46$opt === -1 ? false : packed$46$opt;
  const weak = weak$46$opt === -1 ? false : weak$46$opt;
  let visibility;
  if (visibility$46$opt.$tag === 1) {
    const _Some = visibility$46$opt;
    visibility = _Some._0;
  } else {
    visibility = undefined;
  }
  let section;
  if (section$46$opt.$tag === 1) {
    const _Some = section$46$opt;
    section = _Some._0;
  } else {
    section = undefined;
  }
  let alias_name;
  if (alias_name$46$opt.$tag === 1) {
    const _Some = alias_name$46$opt;
    alias_name = _Some._0;
  } else {
    alias_name = undefined;
  }
  let asm_label;
  if (asm_label$46$opt.$tag === 1) {
    const _Some = asm_label$46$opt;
    asm_label = _Some._0;
  } else {
    asm_label = undefined;
  }
  let cleanup;
  if (cleanup$46$opt.$tag === 1) {
    const _Some = cleanup$46$opt;
    cleanup = _Some._0;
  } else {
    cleanup = undefined;
  }
  const noreturn = noreturn$46$opt === -1 ? false : noreturn$46$opt;
  const constructor_attr = constructor_attr$46$opt === -1 ? false : constructor_attr$46$opt;
  const destructor = destructor$46$opt === -1 ? false : destructor$46$opt;
  const always_inline = always_inline$46$opt === -1 ? false : always_inline$46$opt;
  let call_conv;
  if (call_conv$46$opt.$tag === 1) {
    const _Some = call_conv$46$opt;
    call_conv = _Some._0;
  } else {
    call_conv = undefined;
  }
  const dll_import = dll_import$46$opt === -1 ? false : dll_import$46$opt;
  const dll_export = dll_export$46$opt === -1 ? false : dll_export$46$opt;
  const nodecorate = nodecorate$46$opt === -1 ? false : nodecorate$46$opt;
  const nodebug = nodebug$46$opt === -1 ? false : nodebug$46$opt;
  return hackwaly$tinycc$frontend$ast$$attrs_with$46$inner(aligned, packed, weak, visibility, section, alias_name, asm_label, cleanup, noreturn, constructor_attr, destructor, always_inline, call_conv, dll_import, dll_export, nodecorate, nodebug);
}
function hackwaly$tinycc$frontend$ast$$merge_attrs(base, incoming) {
  return hackwaly$tinycc$frontend$ast$ast_core$$merge_attrs(base, incoming);
}
function hackwaly$tinycc$frontend$ast$$attrs_is_empty(attrs) {
  return hackwaly$tinycc$frontend$ast$ast_core$$attrs_is_empty(attrs);
}
function hackwaly$tinycc$frontend$ast$$type_attrs_from(attrs) {
  return hackwaly$tinycc$frontend$ast$ast_core$$type_attrs_from(attrs);
}
function hackwaly$tinycc$frontend$ast$$apply_type_attrs(ty, attrs) {
  return hackwaly$tinycc$frontend$ast$ast_core$$apply_type_attrs(ty, attrs);
}
function hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(ty, call_conv) {
  return hackwaly$tinycc$frontend$ast$ast_core$$apply_call_conv_to_type(ty, call_conv);
}
function hackwaly$tinycc$frontend$ast$$default_int_type() {
  return hackwaly$tinycc$frontend$ast$ast_core$$default_int_type_value;
}
function hackwaly$tinycc$frontend$ast$$expr_is_lvalue_simple(expr) {
  return hackwaly$tinycc$frontend$ast$ast_core$$expr_is_lvalue_simple(expr);
}
function hackwaly$tinycc$frontend$ast$$expr_may_call(expr) {
  return hackwaly$tinycc$frontend$ast$ast_core$$expr_may_call(expr);
}
function hackwaly$tinycc$frontend$ast$$parse_int64_literal(text) {
  return hackwaly$tinycc$frontend$ast$ast_core$$parse_int64_literal(text);
}
function hackwaly$tinycc$frontend$ast$$const_i64_from_expr(expr) {
  return hackwaly$tinycc$frontend$ast$ast_core$$const_i64_from_expr(expr);
}
function hackwaly$tinycc$frontend$ast$$expr_loc(expr) {
  return hackwaly$tinycc$frontend$ast$ast_core$$expr_loc(expr);
}
function hackwaly$tinycc$frontend$ast$$expr_node_id(expr) {
  return hackwaly$tinycc$frontend$ast$ast_core$$expr_node_id(expr);
}
function hackwaly$tinycc$frontend$ast$$empty_qual() {
  return hackwaly$tinycc$frontend$ast$ast_core$$empty_qual$46$record$47$5496;
}
function hackwaly$tinycc$frontend$ast$$merge_qual(a, b) {
  return hackwaly$tinycc$frontend$ast$ast_core$$merge_qual(a, b);
}
function hackwaly$tinycc$frontend$ast$$with_const(qual) {
  return hackwaly$tinycc$frontend$ast$ast_core$$with_const(qual);
}
function hackwaly$tinycc$frontend$ast$$with_volatile(qual) {
  return hackwaly$tinycc$frontend$ast$ast_core$$with_volatile(qual);
}
function hackwaly$tinycc$frontend$ast$$with_restrict(qual) {
  return hackwaly$tinycc$frontend$ast$ast_core$$with_restrict(qual);
}
function hackwaly$tinycc$frontend$ast$$with_atomic(qual) {
  return hackwaly$tinycc$frontend$ast$ast_core$$with_atomic(qual);
}
function hackwaly$tinycc$frontend$ast$$apply_qualifiers(ty, qual) {
  return hackwaly$tinycc$frontend$ast$ast_core$$apply_qualifiers(ty, qual);
}
function hackwaly$tinycc$support$diag$diag_core$$new_diag_bag() {
  return { diags: [] };
}
function hackwaly$tinycc$support$diag$diag_core$$add_error(bag, loc, message) {
  moonbitlang$core$array$$Array$push$108$(bag.diags, { loc: loc, message: message });
}
function hackwaly$tinycc$support$diag$diag_core$$has_errors(bag) {
  return bag.diags.length > 0;
}
function hackwaly$tinycc$support$diag$$new_diag_bag() {
  return hackwaly$tinycc$support$diag$diag_core$$new_diag_bag();
}
function hackwaly$tinycc$support$diag$$add_error(bag, loc, message) {
  hackwaly$tinycc$support$diag$diag_core$$add_error(bag, loc, message);
}
function hackwaly$tinycc$support$diag$$has_errors(bag) {
  return hackwaly$tinycc$support$diag$diag_core$$has_errors(bag);
}
function hackwaly$tinycc$support$diag$$format_diag(d) {
  return d.message;
}
function hackwaly$tinycc$sem$sem_core$$default_int_type() {
  return hackwaly$tinycc$frontend$ast$$default_int_type();
}
function hackwaly$tinycc$sem$sem_core$$default_type_aliases() {
  const aliases = hackwaly$tinycc$support$util$$fast_map_new$159$(undefined);
  moonbitlang$core$hashmap$$HashMap$set$159$(aliases, "__builtin_va_list", new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void));
  moonbitlang$core$hashmap$$HashMap$set$159$(aliases, "jmp_buf", new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$sem$sem_core$$default_int_type(), hackwaly$tinycc$sem$sem_core$$default_type_aliases$46$constr$47$5812, undefined));
  moonbitlang$core$hashmap$$HashMap$set$159$(aliases, "FILE", new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void));
  return aliases;
}
function hackwaly$tinycc$sem$sem_core$$new_sem_context(diags) {
  const type_aliases = hackwaly$tinycc$sem$sem_core$$default_type_aliases();
  return { diags: diags, globals: hackwaly$tinycc$support$util$$fast_map_new$159$(undefined), globals_by_id: [], functions: hackwaly$tinycc$support$util$$fast_map_new$160$(undefined), functions_by_id: [], builtin_call_ids: [], builtin_sig_ids: [], atomic_template_ids: [], function_defs: hackwaly$tinycc$support$util$$fast_map_new$161$(undefined), local_scope_ids_by_id: [], local_scope_stack: [], next_local_scope_id: 0, local_values_by_id: [], local_overrides: [], type_aliases: type_aliases, struct_defs: hackwaly$tinycc$support$util$$fast_map_new$162$(undefined), struct_defs_by_id: [], union_defs: hackwaly$tinycc$support$util$$fast_map_new$162$(undefined), union_defs_by_id: [], struct_member_cache: hackwaly$tinycc$support$util$$fast_map_new$163$(undefined), struct_member_cache_by_id: [], union_member_cache: hackwaly$tinycc$support$util$$fast_map_new$163$(undefined), union_member_cache_by_id: [], struct_field_access_cache: hackwaly$tinycc$support$util$$fast_map_new$164$(undefined), struct_field_access_cache_by_id: [], union_field_access_cache: hackwaly$tinycc$support$util$$fast_map_new$164$(undefined), union_field_access_cache_by_id: [], struct_field_index_cache: hackwaly$tinycc$support$util$$fast_map_new$157$(undefined), struct_field_index_cache_by_id: [], union_field_index_cache: hackwaly$tinycc$support$util$$fast_map_new$157$(undefined), union_field_index_cache_by_id: [], struct_size_cache: hackwaly$tinycc$support$util$$fast_map_new$165$(undefined), struct_size_cache_by_id: [], union_size_cache: hackwaly$tinycc$support$util$$fast_map_new$165$(undefined), union_size_cache_by_id: [], func_compound_literals: hackwaly$tinycc$support$util$$fast_map_new$166$(undefined), func_compound_literals_by_id: [], compound_literal_sizes: hackwaly$tinycc$support$util$$fast_map_new$167$(undefined), func_has_compound_literal: hackwaly$tinycc$support$util$$fast_map_new$161$(undefined), func_has_stmt_expr: hackwaly$tinycc$support$util$$fast_map_new$161$(undefined), func_has_stmt_expr_by_id: [], func_has_static_local: hackwaly$tinycc$support$util$$fast_map_new$161$(undefined), func_has_static_local_by_id: [], func_has_local_decl: hackwaly$tinycc$support$util$$fast_map_new$161$(undefined), func_has_local_decl_by_id: [], enum_defs: hackwaly$tinycc$support$util$$fast_map_new$168$(undefined), enum_defs_by_id: [], enum_consts: hackwaly$tinycc$support$util$$fast_map_new$156$(undefined), enum_consts_by_id: [], enum_types: hackwaly$tinycc$support$util$$fast_map_new$159$(undefined), enum_types_by_id: [], compound_literal_types: hackwaly$tinycc$support$util$$fast_map_new$169$(undefined), expr_type_cache: [], func_agg_temps: hackwaly$tinycc$support$util$$fast_map_new$165$(undefined), func_agg_temps_by_id: [], switch_stack: [], labels_defined: hackwaly$tinycc$support$util$$fast_map_new$161$(undefined), labels_used: [], loop_depth: 0, switch_depth: 0, current_func_name: undefined, current_func_id: 0, current_agg_temp_size: 0, current_agg_temp_align: 1, record_agg_temps: true };
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$68$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$58$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$29$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$50$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$183$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$63$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$184$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$64$(arr, Option$None$22$);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$67$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$45$(arr, -1);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$185$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$69$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$186$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$72$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$187$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$73$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$188$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$65$(arr, Option$None$21$);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$189$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$74$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$190$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$71$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$19$(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$77$(arr, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$67$(arr, id) {
  return id <= 0 || id > arr.length ? -1 : moonbitlang$core$array$$Array$at$45$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$50$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$68$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$58$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$63$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$184$(arr, id) {
  return id <= 0 || id > arr.length ? Option$None$22$ : moonbitlang$core$array$$Array$at$64$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$188$(arr, id) {
  return id <= 0 || id > arr.length ? Option$None$21$ : moonbitlang$core$array$$Array$at$65$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$185$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$69$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$190$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$71$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$186$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$72$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$187$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$73$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$189$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$74$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$26$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$17$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$get_opt_by_id$19$(arr, id) {
  return id <= 0 || id > arr.length ? undefined : moonbitlang$core$array$$Array$at$77$(arr, id - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$68$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$68$(arr, id);
  moonbitlang$core$array$$Array$set$58$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$29$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$29$(arr, id);
  moonbitlang$core$array$$Array$set$50$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$183$(arr, id);
  moonbitlang$core$array$$Array$set$63$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$184$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$184$(arr, id);
  moonbitlang$core$array$$Array$set$64$(arr, id - 1 | 0, new Option$Some$22$(value));
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$67$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$67$(arr, id);
  moonbitlang$core$array$$Array$set$45$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$185$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$185$(arr, id);
  moonbitlang$core$array$$Array$set$69$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$186$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$186$(arr, id);
  moonbitlang$core$array$$Array$set$72$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$187$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$187$(arr, id);
  moonbitlang$core$array$$Array$set$73$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$188$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$188$(arr, id);
  moonbitlang$core$array$$Array$set$65$(arr, id - 1 | 0, new Option$Some$21$(value));
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$189$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$189$(arr, id);
  moonbitlang$core$array$$Array$set$74$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$190$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$190$(arr, id);
  moonbitlang$core$array$$Array$set$71$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$set_opt_by_id$19$(arr, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_opt_array_capacity$19$(arr, id);
  moonbitlang$core$array$$Array$set$77$(arr, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$ensure_int_array_capacity(arr, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = arr.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$26$(arr, 0);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$current_local_scope_id(ctx) {
  const len = ctx.local_scope_stack.length;
  return len === 0 ? 0 : moonbitlang$core$array$$Array$at$26$(ctx.local_scope_stack, len - 1 | 0);
}
function hackwaly$tinycc$sem$sem_core$$has_opt_by_id$183$(arr, id) {
  const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(arr, id);
  return !(_bind === undefined);
}
function hackwaly$tinycc$sem$sem_core$$has_opt_by_id$29$(arr, id) {
  const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(arr, id);
  return !(_bind === undefined);
}
function hackwaly$tinycc$sem$sem_core$$ensure_globals_by_id(ctx, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = ctx.globals_by_id.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$50$(ctx.globals_by_id, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$set_global_by_id(ctx, id, ty) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_globals_by_id(ctx, id);
  moonbitlang$core$array$$Array$set$50$(ctx.globals_by_id, id - 1 | 0, ty);
}
function hackwaly$tinycc$sem$sem_core$$get_global_by_id(ctx, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(ctx.globals_by_id, id);
}
function hackwaly$tinycc$sem$sem_core$$has_global_by_id(ctx, id) {
  const _bind = hackwaly$tinycc$sem$sem_core$$get_global_by_id(ctx, id);
  return !(_bind === undefined);
}
function hackwaly$tinycc$sem$sem_core$$ensure_functions_by_id(ctx, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = ctx.functions_by_id.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$71$(ctx.functions_by_id, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$set_function_by_id(ctx, id, sig) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_functions_by_id(ctx, id);
  moonbitlang$core$array$$Array$set$71$(ctx.functions_by_id, id - 1 | 0, sig);
}
function hackwaly$tinycc$sem$sem_core$$get_function_by_id(ctx, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$190$(ctx.functions_by_id, id);
}
function hackwaly$tinycc$sem$sem_core$$has_function_by_id(ctx, id) {
  const _bind = hackwaly$tinycc$sem$sem_core$$get_function_by_id(ctx, id);
  return !(_bind === undefined);
}
function hackwaly$tinycc$sem$sem_core$$ensure_enum_consts_by_id(ctx, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = ctx.enum_consts_by_id.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$17$(ctx.enum_consts_by_id, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$set_enum_const_by_id(ctx, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$ensure_enum_consts_by_id(ctx, id);
  moonbitlang$core$array$$Array$set$17$(ctx.enum_consts_by_id, id - 1 | 0, value);
}
function hackwaly$tinycc$sem$sem_core$$get_enum_const_by_id(ctx, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$26$(ctx.enum_consts_by_id, id);
}
function hackwaly$tinycc$sem$sem_core$$has_enum_const_by_id(ctx, id) {
  const _bind = hackwaly$tinycc$sem$sem_core$$get_enum_const_by_id(ctx, id);
  return !(_bind === undefined);
}
function hackwaly$tinycc$sem$sem_core$$lookup_local_only(ctx, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(ctx.local_values_by_id, id);
}
function hackwaly$tinycc$sem$sem_core$$enum_const_value(ctx, name, id) {
  return id > 0 ? hackwaly$tinycc$sem$sem_core$$get_enum_const_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$get$156$(ctx.enum_consts, name);
}
function hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, name, id) {
  return id > 0 ? hackwaly$tinycc$sem$sem_core$$has_enum_const_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$contains$156$(ctx.enum_consts, name);
}
function hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range(min_value, max_value) {
  return min_value >= 0 ? hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range$46$constr$47$6000 : min_value < -2147483648 || max_value > 2147483647 ? hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range$46$constr$47$6001 : hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range$46$constr$47$6002;
}
function hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, message) {
  hackwaly$tinycc$support$diag$$add_error(ctx.diags, loc, message);
}
function hackwaly$tinycc$sem$sem_core$$has_builtin_prefix(name) {
  return moonbitlang$core$string$$String$has_prefix(name, { str: hackwaly$tinycc$sem$sem_core$$has_builtin_prefix$46$42$bind$124$2102, start: 0, end: hackwaly$tinycc$sem$sem_core$$has_builtin_prefix$46$42$bind$124$2102.length });
}
function hackwaly$tinycc$sem$sem_core$$builtin_call_kind(ctx, name, id) {
  if (id !== 0) {
    const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$186$(ctx.builtin_call_ids, id);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _kind = _Some;
      return _kind;
    }
  }
  let kind;
  if (name === "__sync_synchronize") {
    kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6009;
  } else {
    if (!hackwaly$tinycc$sem$sem_core$$has_builtin_prefix(name)) {
      kind = undefined;
    } else {
      switch (name) {
        case "__builtin_choose_expr": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6010;
          break;
        }
        case "__builtin_expect": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6011;
          break;
        }
        case "__builtin_constant_p": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6012;
          break;
        }
        case "__builtin_unreachable": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6013;
          break;
        }
        case "__builtin_va_start": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6014;
          break;
        }
        case "__builtin_va_copy": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6015;
          break;
        }
        case "__builtin_va_end": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6016;
          break;
        }
        case "__builtin_frame_address": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6017;
          break;
        }
        case "__builtin_return_address": {
          kind = hackwaly$tinycc$sem$sem_core$$builtin_call_kind$46$constr$47$6018;
          break;
        }
        default: {
          kind = undefined;
        }
      }
    }
  }
  if (kind === undefined) {
    return undefined;
  } else {
    const _Some = kind;
    const _value = _Some;
    if (id !== 0) {
      hackwaly$tinycc$sem$sem_core$$set_opt_by_id$186$(ctx.builtin_call_ids, id, _value);
    }
    return _value;
  }
}
function hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty) {
  let current = ty;
  _L: while (true) {
    const _bind = current;
    switch (_bind.$tag) {
      case 12: {
        const _Qualified = _bind;
        const _base = _Qualified._1;
        current = _base;
        break;
      }
      case 11: {
        const _Attributed = _bind;
        const _base$2 = _Attributed._1;
        current = _base$2;
        break;
      }
      default: {
        break _L;
      }
    }
    continue;
  }
  return current;
}
function hackwaly$tinycc$sem$sem_core$$enum_type_for_arith(ctx, ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  if (_bind.$tag === 8) {
    const _Enum = _bind;
    const _name = _Enum._0;
    const _id = _Enum._1;
    if (_id !== 0) {
      const _bind$2 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(ctx.enum_types_by_id, _id);
      if (_bind$2 === undefined) {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind$2;
        return _Some;
      }
    } else {
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$159$(ctx.enum_types, _name);
      if (_bind$2 === undefined) {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind$2;
        return _Some;
      }
    }
  } else {
    return ty;
  }
}
function hackwaly$tinycc$sem$sem_core$$int_size(kind) {
  switch (kind) {
    case 0: {
      return 1;
    }
    case 1: {
      return 2;
    }
    case 2: {
      return 4;
    }
    case 3: {
      return 8;
    }
    default: {
      return 8;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$lookup_value(ctx, name, id) {
  let found = id > 0 ? hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(ctx.local_values_by_id, id) : undefined;
  const _bind = found;
  if (_bind === undefined) {
    found = id > 0 ? hackwaly$tinycc$sem$sem_core$$get_global_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$get$159$(ctx.globals, name);
  }
  const _bind$2 = found;
  if (_bind$2 === undefined) {
    const sig = id > 0 ? hackwaly$tinycc$sem$sem_core$$get_function_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$get$160$(ctx.functions, name);
    if (sig === undefined) {
    } else {
      const _Some = sig;
      const _value = _Some;
      found = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(_value.return_type, _value.params, _value.varargs, _value.is_old_style, _value.call_conv);
    }
  }
  const _bind$3 = found;
  if (_bind$3 === undefined) {
    if (hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, name, id)) {
      found = hackwaly$tinycc$sem$sem_core$$default_int_type();
    } else {
      if (name === "__func__") {
        const elem = hackwaly$tinycc$frontend$ast$$apply_qualifiers(hackwaly$tinycc$sem$sem_core$$char_type_value, hackwaly$tinycc$frontend$ast$$with_const(hackwaly$tinycc$frontend$ast$$empty_qual()));
        const _bind$4 = ctx.current_func_name;
        let len;
        if (_bind$4 === undefined) {
          len = 1;
        } else {
          const _Some = _bind$4;
          const _func = _Some;
          len = _func.length + 1 | 0;
        }
        found = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(elem, len, undefined);
      } else {
        if (name === "__FUNCTION__" || name === "__PRETTY_FUNCTION__") {
          const elem = hackwaly$tinycc$frontend$ast$$apply_qualifiers(hackwaly$tinycc$sem$sem_core$$char_type_value, hackwaly$tinycc$frontend$ast$$with_const(hackwaly$tinycc$frontend$ast$$empty_qual()));
          const _bind$4 = ctx.current_func_name;
          let len;
          if (_bind$4 === undefined) {
            len = 1;
          } else {
            const _Some = _bind$4;
            const _func = _Some;
            len = _func.length + 1 | 0;
          }
          found = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(elem, len, undefined);
        }
      }
    }
  }
  return found;
}
function hackwaly$tinycc$sem$sem_core$$type_eq(a, b) {
  let _tmp$27 = a;
  let _tmp$28 = b;
  _L: while (true) {
    const a$2 = _tmp$27;
    const b$2 = _tmp$28;
    switch (a$2.$tag) {
      case 12: {
        const _Qualified = a$2;
        const _base = _Qualified._1;
        _tmp$27 = _base;
        continue _L;
      }
      case 11: {
        const _Attributed = a$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      default: {
        switch (b$2.$tag) {
          case 12: {
            const _Qualified$2 = b$2;
            const _base$3 = _Qualified$2._1;
            _tmp$28 = _base$3;
            continue _L;
          }
          case 11: {
            const _Attributed$2 = b$2;
            const _base$4 = _Attributed$2._1;
            _tmp$28 = _base$4;
            continue _L;
          }
          default: {
            switch (a$2.$tag) {
              case 0: {
                if (b$2.$tag === 0) {
                  return true;
                } else {
                  return false;
                }
              }
              case 1: {
                if (b$2.$tag === 1) {
                  return true;
                } else {
                  return false;
                }
              }
              case 2: {
                const _Int = a$2;
                const _a_kind = _Int._0;
                const _a_unsigned = _Int._1;
                if (b$2.$tag === 2) {
                  const _Int$2 = b$2;
                  const _b_kind = _Int$2._0;
                  const _b_unsigned = _Int$2._1;
                  return moonbitlang$core$builtin$$Eq$equal$180$(_a_kind, _b_kind) && _a_unsigned === _b_unsigned;
                } else {
                  return false;
                }
              }
              case 3: {
                const _Float = a$2;
                const _a_kind$2 = _Float._0;
                if (b$2.$tag === 3) {
                  const _Float$2 = b$2;
                  const _b_kind = _Float$2._0;
                  return moonbitlang$core$builtin$$Eq$equal$83$(_a_kind$2, _b_kind);
                } else {
                  return false;
                }
              }
              case 4: {
                const _Pointer = a$2;
                const _inner_a = _Pointer._0;
                if (b$2.$tag === 4) {
                  const _Pointer$2 = b$2;
                  const _inner_b = _Pointer$2._0;
                  _tmp$27 = _inner_a;
                  _tmp$28 = _inner_b;
                  continue _L;
                } else {
                  return false;
                }
              }
              case 5: {
                const _Array = a$2;
                const _elem_a = _Array._0;
                const _size_a = _Array._1;
                if (b$2.$tag === 5) {
                  const _Array$2 = b$2;
                  const _elem_b = _Array$2._0;
                  const _size_b = _Array$2._1;
                  _L$2: {
                    if (_size_a === undefined) {
                      break _L$2;
                    } else {
                      const _Some = _size_a;
                      const _sa = _Some;
                      if (_size_b === undefined) {
                        break _L$2;
                      } else {
                        const _Some$2 = _size_b;
                        const _sb = _Some$2;
                        if (_sa === _sb) {
                          _tmp$27 = _elem_a;
                          _tmp$28 = _elem_b;
                          continue _L;
                        } else {
                          return false;
                        }
                      }
                    }
                  }
                  _tmp$27 = _elem_a;
                  _tmp$28 = _elem_b;
                  continue _L;
                } else {
                  return false;
                }
              }
              case 10: {
                const _Function = a$2;
                const _a_ret = _Function._0;
                const _a_params = _Function._1;
                const _a_varargs = _Function._2;
                const _a_old = _Function._3;
                const _a_call = _Function._4;
                if (b$2.$tag === 10) {
                  const _Function$2 = b$2;
                  const _b_ret = _Function$2._0;
                  const _b_params = _Function$2._1;
                  const _b_varargs = _Function$2._2;
                  const _b_old = _Function$2._3;
                  const _b_call = _Function$2._4;
                  if (!hackwaly$tinycc$sem$sem_core$$type_eq(_a_ret, _b_ret)) {
                    return false;
                  }
                  if (moonbitlang$core$builtin$$Eq$not_equal$86$(_a_call, _b_call)) {
                    return false;
                  }
                  if (_a_old || _b_old) {
                    return true;
                  }
                  if (!(_a_varargs === _b_varargs)) {
                    return false;
                  }
                  if (_a_params.length !== _b_params.length) {
                    return false;
                  }
                  let _tmp$29 = 0;
                  while (true) {
                    const i = _tmp$29;
                    if (i < _a_params.length) {
                      if (!hackwaly$tinycc$sem$sem_core$$type_eq(moonbitlang$core$array$$Array$at$29$(_a_params, i), moonbitlang$core$array$$Array$at$29$(_b_params, i))) {
                        return false;
                      }
                      _tmp$29 = i + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                  return true;
                } else {
                  return false;
                }
              }
              case 6: {
                const _Struct = a$2;
                const _a_name = _Struct._0;
                const _a_id = _Struct._1;
                if (b$2.$tag === 6) {
                  const _Struct$2 = b$2;
                  const _b_name = _Struct$2._0;
                  const _b_id = _Struct$2._1;
                  return _a_id !== 0 && _b_id !== 0 ? _a_id === _b_id : _a_name === _b_name;
                } else {
                  return false;
                }
              }
              case 7: {
                const _Union = a$2;
                const _a_name$2 = _Union._0;
                const _a_id$2 = _Union._1;
                if (b$2.$tag === 7) {
                  const _Union$2 = b$2;
                  const _b_name = _Union$2._0;
                  const _b_id = _Union$2._1;
                  return _a_id$2 !== 0 && _b_id !== 0 ? _a_id$2 === _b_id : _a_name$2 === _b_name;
                } else {
                  return false;
                }
              }
              case 8: {
                const _Enum = a$2;
                const _a_name$3 = _Enum._0;
                const _a_id$3 = _Enum._1;
                if (b$2.$tag === 8) {
                  const _Enum$2 = b$2;
                  const _b_name = _Enum$2._0;
                  const _b_id = _Enum$2._1;
                  return _a_id$3 !== 0 && _b_id !== 0 ? _a_id$3 === _b_id : _a_name$3 === _b_name;
                } else {
                  return false;
                }
              }
              default: {
                return false;
              }
            }
          }
        }
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(a, b) {
  let _tmp$27 = a;
  let _tmp$28 = b;
  _L: while (true) {
    const a$2 = _tmp$27;
    const b$2 = _tmp$28;
    _L$2: {
      switch (a$2.$tag) {
        case 12: {
          const _Qualified = a$2;
          const _base = _Qualified._1;
          _tmp$27 = _base;
          continue _L;
        }
        case 11: {
          const _Attributed = a$2;
          const _base$2 = _Attributed._1;
          _tmp$27 = _base$2;
          continue _L;
        }
        default: {
          switch (b$2.$tag) {
            case 12: {
              const _Qualified$2 = b$2;
              const _base$3 = _Qualified$2._1;
              _tmp$28 = _base$3;
              continue _L;
            }
            case 11: {
              const _Attributed$2 = b$2;
              const _base$4 = _Attributed$2._1;
              _tmp$28 = _base$4;
              continue _L;
            }
            default: {
              switch (a$2.$tag) {
                case 5: {
                  const _Array = a$2;
                  const _elem_a = _Array._0;
                  const _size_a = _Array._1;
                  if (b$2.$tag === 5) {
                    const _Array$2 = b$2;
                    const _elem_b = _Array$2._0;
                    const _size_b = _Array$2._1;
                    _L$3: {
                      if (_size_a === undefined) {
                        break _L$3;
                      } else {
                        const _Some = _size_a;
                        const _sa = _Some;
                        if (_size_b === undefined) {
                          break _L$3;
                        } else {
                          const _Some$2 = _size_b;
                          const _sb = _Some$2;
                          if (_sa === _sb) {
                            _tmp$27 = _elem_a;
                            _tmp$28 = _elem_b;
                            continue _L;
                          } else {
                            return false;
                          }
                        }
                      }
                    }
                    _tmp$27 = _elem_a;
                    _tmp$28 = _elem_b;
                    continue _L;
                  } else {
                    break _L$2;
                  }
                }
                case 4: {
                  const _Pointer = a$2;
                  const _inner_a = _Pointer._0;
                  if (b$2.$tag === 4) {
                    const _Pointer$2 = b$2;
                    const _inner_b = _Pointer$2._0;
                    _tmp$27 = _inner_a;
                    _tmp$28 = _inner_b;
                    continue _L;
                  } else {
                    break _L$2;
                  }
                }
                case 10: {
                  const _Function = a$2;
                  const _a_ret = _Function._0;
                  const _a_params = _Function._1;
                  const _a_varargs = _Function._2;
                  const _a_old = _Function._3;
                  const _a_call = _Function._4;
                  if (b$2.$tag === 10) {
                    const _Function$2 = b$2;
                    const _b_ret = _Function$2._0;
                    const _b_params = _Function$2._1;
                    const _b_varargs = _Function$2._2;
                    const _b_old = _Function$2._3;
                    const _b_call = _Function$2._4;
                    if (!hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(_a_ret, _b_ret)) {
                      return false;
                    }
                    if (moonbitlang$core$builtin$$Eq$not_equal$86$(_a_call, _b_call)) {
                      return false;
                    }
                    if (_a_old || _b_old) {
                      return true;
                    }
                    if (!(_a_varargs === _b_varargs)) {
                      return false;
                    }
                    if (_a_params.length !== _b_params.length) {
                      return false;
                    }
                    let _tmp$29 = 0;
                    while (true) {
                      const i = _tmp$29;
                      if (i < _a_params.length) {
                        if (!hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(moonbitlang$core$array$$Array$at$29$(_a_params, i), moonbitlang$core$array$$Array$at$29$(_b_params, i))) {
                          return false;
                        }
                        _tmp$29 = i + 1 | 0;
                        continue;
                      } else {
                        break;
                      }
                    }
                    return true;
                  } else {
                    break _L$2;
                  }
                }
                default: {
                  break _L$2;
                }
              }
            }
          }
        }
      }
    }
    return hackwaly$tinycc$sem$sem_core$$type_eq(a$2, b$2);
  }
}
function hackwaly$tinycc$sem$sem_core$$func_sig_eq(a, b) {
  if (!hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(a.return_type, b.return_type)) {
    return false;
  }
  if (moonbitlang$core$builtin$$Eq$not_equal$86$(a.call_conv, b.call_conv)) {
    return false;
  }
  if (a.is_old_style || b.is_old_style) {
    return true;
  }
  const _p$28 = a.varargs;
  const _p$29 = b.varargs;
  if (!(_p$28 === _p$29)) {
    return false;
  }
  if (a.params.length !== b.params.length) {
    return false;
  }
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < a.params.length) {
      if (!hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(moonbitlang$core$array$$Array$at$29$(a.params, i), moonbitlang$core$array$$Array$at$29$(b.params, i))) {
        return false;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function hackwaly$tinycc$sem$sem_core$$add_function_sig(ctx, name, id, sig, loc, is_def) {
  if (hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, name, id)) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
  }
  let updated = undefined;
  const existing = id > 0 ? hackwaly$tinycc$sem$sem_core$$get_function_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$get$160$(ctx.functions, name);
  if (existing === undefined) {
    moonbitlang$core$hashmap$$HashMap$set$160$(ctx.functions, name, sig);
    updated = sig;
  } else {
    const _Some = existing;
    const _existing = _Some;
    if (!hackwaly$tinycc$sem$sem_core$$func_sig_eq(_existing, sig)) {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `conflicting function declaration for '${name}'`);
    } else {
      if (_existing.is_old_style && !sig.is_old_style) {
        moonbitlang$core$hashmap$$HashMap$set$160$(ctx.functions, name, sig);
        updated = sig;
      } else {
        updated = _existing;
      }
    }
  }
  if (id > 0) {
    const _bind = updated;
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _resolved = _Some;
      hackwaly$tinycc$sem$sem_core$$set_function_by_id(ctx, id, _resolved);
    }
  }
  if (is_def) {
    if (moonbitlang$core$hashmap$$HashMap$contains$161$(ctx.function_defs, name)) {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of function '${name}'`);
      return;
    } else {
      moonbitlang$core$hashmap$$HashMap$set$161$(ctx.function_defs, name, true);
      return;
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$int_bits(kind) {
  switch (kind) {
    case 0: {
      return 8;
    }
    case 1: {
      return 16;
    }
    case 2: {
      return 32;
    }
    case 3: {
      return 64;
    }
    default: {
      return 64;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$int_rank(kind) {
  switch (kind) {
    case 0: {
      return 1;
    }
    case 1: {
      return 2;
    }
    case 2: {
      return 3;
    }
    case 3: {
      return 4;
    }
    default: {
      return 5;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$promote_int_type(ctx, ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty$2);
    switch (_bind.$tag) {
      case 2: {
        const _Int = _bind;
        const _kind = _Int._0;
        const _unsigned = _Int._1;
        return hackwaly$tinycc$sem$sem_core$$int_rank(_kind) < hackwaly$tinycc$sem$sem_core$$int_rank(2) ? hackwaly$tinycc$sem$sem_core$$default_int_type() : new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(_kind, _unsigned);
      }
      case 1: {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      }
      case 8: {
        _tmp$27 = hackwaly$tinycc$sem$sem_core$$enum_type_for_arith(ctx, ty$2);
        continue _L;
      }
      default: {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs, rhs) {
  const left = hackwaly$tinycc$sem$sem_core$$promote_int_type(ctx, lhs);
  const right = hackwaly$tinycc$sem$sem_core$$promote_int_type(ctx, rhs);
  _L: {
    if (left.$tag === 2) {
      const _Int = left;
      const _l_kind = _Int._0;
      const _l_unsigned = _Int._1;
      if (right.$tag === 2) {
        const _Int$2 = right;
        const _r_kind = _Int$2._0;
        const _r_unsigned = _Int$2._1;
        if (_l_unsigned === _r_unsigned) {
          const rank = hackwaly$tinycc$sem$sem_core$$int_rank(_l_kind) >= hackwaly$tinycc$sem$sem_core$$int_rank(_r_kind) ? _l_kind : _r_kind;
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(rank, _l_unsigned);
        }
        let u_kind;
        let u_unsigned;
        let s_kind;
        _L$2: {
          if (_l_unsigned) {
            u_kind = _l_kind;
            u_unsigned = true;
            s_kind = _r_kind;
            break _L$2;
          } else {
            u_kind = _r_kind;
            u_unsigned = true;
            s_kind = _l_kind;
            break _L$2;
          }
        }
        if (hackwaly$tinycc$sem$sem_core$$int_rank(u_kind) >= hackwaly$tinycc$sem$sem_core$$int_rank(s_kind)) {
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(u_kind, u_unsigned);
        }
        const u_bits = hackwaly$tinycc$sem$sem_core$$int_bits(u_kind);
        const s_bits = hackwaly$tinycc$sem$sem_core$$int_bits(s_kind);
        return s_bits > u_bits ? new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(s_kind, false) : new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(s_kind, true);
      } else {
        break _L;
      }
    } else {
      break _L;
    }
  }
  return hackwaly$tinycc$sem$sem_core$$default_int_type();
}
function hackwaly$tinycc$sem$sem_core$$float_rank(kind) {
  switch (kind) {
    case 0: {
      return 1;
    }
    case 1: {
      return 2;
    }
    default: {
      return 3;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs, rhs) {
  const left = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(lhs);
  const right = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(rhs);
  if (left.$tag === 3) {
    const _Float = left;
    const _l_kind = _Float._0;
    if (right.$tag === 3) {
      const _Float$2 = right;
      const _r_kind = _Float$2._0;
      return hackwaly$tinycc$sem$sem_core$$float_rank(_l_kind) >= hackwaly$tinycc$sem$sem_core$$float_rank(_r_kind) ? new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(_l_kind) : new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(_r_kind);
    } else {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(_l_kind);
    }
  } else {
    if (right.$tag === 3) {
      const _Float = right;
      const _kind = _Float._0;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Float(_kind);
    } else {
      return hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs, rhs);
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name(name) {
  switch (name) {
    case "__atomic_store": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6238;
    }
    case "__atomic_load": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6239;
    }
    case "__atomic_exchange": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6240;
    }
    case "__atomic_compare_exchange": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6241;
    }
    case "__atomic_fetch_add": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6242;
    }
    case "__atomic_fetch_sub": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6243;
    }
    case "__atomic_fetch_or": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6244;
    }
    case "__atomic_fetch_xor": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6245;
    }
    case "__atomic_fetch_and": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6246;
    }
    case "__atomic_fetch_nand": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6247;
    }
    case "__atomic_add_fetch": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6248;
    }
    case "__atomic_sub_fetch": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6249;
    }
    case "__atomic_or_fetch": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6250;
    }
    case "__atomic_xor_fetch": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6251;
    }
    case "__atomic_and_fetch": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6252;
    }
    case "__atomic_nand_fetch": {
      return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name$46$constr$47$6253;
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$has_atomic_prefix(name) {
  return moonbitlang$core$string$$String$has_prefix(name, { str: hackwaly$tinycc$sem$sem_core$$has_atomic_prefix$46$42$bind$124$2377, start: 0, end: hackwaly$tinycc$sem$sem_core$$has_atomic_prefix$46$42$bind$124$2377.length });
}
function hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_from_ident(ctx, name, id) {
  if (id !== 0) {
    const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$19$(ctx.atomic_template_ids, id);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _template = _Some;
      return _template;
    }
  }
  if (!hackwaly$tinycc$sem$sem_core$$has_atomic_prefix(name)) {
    return undefined;
  }
  const template = hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_by_name(name);
  if (template === undefined) {
    return undefined;
  } else {
    const _Some = template;
    const _value = _Some;
    if (id !== 0) {
      hackwaly$tinycc$sem$sem_core$$set_opt_by_id$19$(ctx.atomic_template_ids, id, _value);
    }
    return _value;
  }
}
function hackwaly$tinycc$sem$sem_core$$is_float_type(ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  if (_bind.$tag === 3) {
    return true;
  } else {
    return false;
  }
}
function hackwaly$tinycc$sem$sem_core$$is_int_like(ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  switch (_bind.$tag) {
    case 2: {
      return true;
    }
    case 1: {
      return true;
    }
    case 8: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$is_arithmetic(ty) {
  return hackwaly$tinycc$sem$sem_core$$is_int_like(ty) || hackwaly$tinycc$sem$sem_core$$is_float_type(ty);
}
function hackwaly$tinycc$sem$sem_core$$is_void_type(ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  if (_bind.$tag === 0) {
    return true;
  } else {
    return false;
  }
}
function hackwaly$tinycc$sem$sem_core$$pointer_compatible(a, b) {
  if (hackwaly$tinycc$sem$sem_core$$type_eq(a, b) || (hackwaly$tinycc$sem$sem_core$$is_void_type(a) || hackwaly$tinycc$sem$sem_core$$is_void_type(b))) {
    return true;
  }
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(a);
  const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(b);
  if (_bind.$tag === 2) {
    const _Int = _bind;
    const _a_kind = _Int._0;
    const _a_unsigned = _Int._1;
    if (_bind$2.$tag === 2) {
      const _Int$2 = _bind$2;
      const _b_kind = _Int$2._0;
      const _b_unsigned = _Int$2._1;
      return _a_unsigned === _b_unsigned && hackwaly$tinycc$sem$sem_core$$int_size(_a_kind) === hackwaly$tinycc$sem$sem_core$$int_size(_b_kind);
    } else {
      return false;
    }
  } else {
    return false;
  }
}
function hackwaly$tinycc$sem$sem_core$$can_assign(dst, src) {
  const dst_ty = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(dst);
  const src_ty = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(src);
  if (hackwaly$tinycc$sem$sem_core$$is_arithmetic(dst_ty) && hackwaly$tinycc$sem$sem_core$$is_arithmetic(src_ty)) {
    return true;
  }
  _L: {
    if (dst_ty.$tag === 4) {
      const _Pointer = dst_ty;
      const _inner_a = _Pointer._0;
      if (src_ty.$tag === 4) {
        const _Pointer$2 = src_ty;
        const _inner_b = _Pointer$2._0;
        return hackwaly$tinycc$sem$sem_core$$pointer_compatible(_inner_a, _inner_b);
      } else {
        break _L;
      }
    } else {
      break _L;
    }
  }
  return hackwaly$tinycc$sem$sem_core$$type_eq(dst_ty, src_ty);
}
function hackwaly$tinycc$sem$sem_core$$is_pointer_type(ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  if (_bind.$tag === 4) {
    return true;
  } else {
    return false;
  }
}
function hackwaly$tinycc$sem$sem_core$$int_literal_base_from(text, end) {
  let _tmp$27;
  if (end >= 2) {
    $bound_check(text, 0);
    const _p$28 = text.charCodeAt(0);
    const _p$29 = 48;
    _tmp$27 = _p$28 === _p$29;
  } else {
    _tmp$27 = false;
  }
  if (_tmp$27) {
    $bound_check(text, 1);
    const next = text.charCodeAt(1);
    let _tmp$28;
    const _p$28 = 120;
    if (next === _p$28) {
      _tmp$28 = true;
    } else {
      const _p$29 = 88;
      _tmp$28 = next === _p$29;
    }
    if (_tmp$28) {
      return 16;
    }
    let _tmp$29;
    const _p$29 = 98;
    if (next === _p$29) {
      _tmp$29 = true;
    } else {
      const _p$30 = 66;
      _tmp$29 = next === _p$30;
    }
    if (_tmp$29) {
      return 2;
    }
    return 8;
  }
  return 10;
}
function hackwaly$tinycc$sem$sem_core$$is_bin_digit_code(code) {
  const _p$28 = 48;
  if (code === _p$28) {
    return true;
  } else {
    const _p$29 = 49;
    return code === _p$29;
  }
}
function hackwaly$tinycc$sem$sem_core$$is_dec_digit_code(code) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 57);
}
function hackwaly$tinycc$sem$sem_core$$is_hex_digit_code(code) {
  return hackwaly$tinycc$sem$sem_core$$is_dec_digit_code(code) || (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 70) || moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 102));
}
function hackwaly$tinycc$sem$sem_core$$is_oct_digit_code(code) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 55);
}
function hackwaly$tinycc$sem$sem_core$$scan_digits(text, start, accept) {
  let i = start;
  while (true) {
    if (i < text.length) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      if (!accept(text.charCodeAt(_tmp$27))) {
        break;
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return i;
}
function hackwaly$tinycc$sem$sem_core$$int_literal_end(text) {
  const len = text.length;
  if (len === 0) {
    return 0;
  }
  $bound_check(text, 0);
  const first = text.charCodeAt(0);
  const _p$28 = 48;
  if (first === _p$28) {
    if (len >= 2) {
      $bound_check(text, 1);
      const next = text.charCodeAt(1);
      let _tmp$27;
      const _p$29 = 120;
      if (next === _p$29) {
        _tmp$27 = true;
      } else {
        const _p$30 = 88;
        _tmp$27 = next === _p$30;
      }
      if (_tmp$27) {
        return hackwaly$tinycc$sem$sem_core$$scan_digits(text, 2, hackwaly$tinycc$sem$sem_core$$is_hex_digit_code);
      }
      let _tmp$28;
      const _p$30 = 98;
      if (next === _p$30) {
        _tmp$28 = true;
      } else {
        const _p$31 = 66;
        _tmp$28 = next === _p$31;
      }
      if (_tmp$28) {
        return hackwaly$tinycc$sem$sem_core$$scan_digits(text, 2, hackwaly$tinycc$sem$sem_core$$is_bin_digit_code);
      }
      return hackwaly$tinycc$sem$sem_core$$scan_digits(text, 1, hackwaly$tinycc$sem$sem_core$$is_oct_digit_code);
    }
    return 1;
  }
  return hackwaly$tinycc$sem$sem_core$$scan_digits(text, 0, hackwaly$tinycc$sem$sem_core$$is_dec_digit_code);
}
function hackwaly$tinycc$sem$sem_core$$digit_value(code) {
  return hackwaly$tinycc$sem$sem_core$$is_dec_digit_code(code) ? code - 48 | 0 : moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 70) ? (code - 65 | 0) + 10 | 0 : moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 102) ? (code - 97 | 0) + 10 | 0 : undefined;
}
function hackwaly$tinycc$sem$sem_core$$parse_uint64_literal_prefix(text, base, end) {
  let value = $0L;
  let i = 0;
  let _tmp$27;
  if (base === 16) {
    let _tmp$28;
    if (end >= 2) {
      let _tmp$29;
      $bound_check(text, 0);
      const _p$28 = text.charCodeAt(0);
      const _p$29 = 48;
      if (_p$28 === _p$29) {
        let _tmp$30;
        $bound_check(text, 1);
        const _p$30 = text.charCodeAt(1);
        const _p$31 = 120;
        if (_p$30 === _p$31) {
          _tmp$30 = true;
        } else {
          $bound_check(text, 1);
          const _p$32 = text.charCodeAt(1);
          const _p$33 = 88;
          _tmp$30 = _p$32 === _p$33;
        }
        _tmp$29 = _tmp$30;
      } else {
        _tmp$29 = false;
      }
      _tmp$28 = _tmp$29;
    } else {
      _tmp$28 = false;
    }
    _tmp$27 = _tmp$28;
  } else {
    _tmp$27 = false;
  }
  if (_tmp$27) {
    i = 2;
  } else {
    let _tmp$28;
    if (base === 2) {
      let _tmp$29;
      if (end >= 2) {
        let _tmp$30;
        $bound_check(text, 0);
        const _p$28 = text.charCodeAt(0);
        const _p$29 = 48;
        if (_p$28 === _p$29) {
          let _tmp$31;
          $bound_check(text, 1);
          const _p$30 = text.charCodeAt(1);
          const _p$31 = 98;
          if (_p$30 === _p$31) {
            _tmp$31 = true;
          } else {
            $bound_check(text, 1);
            const _p$32 = text.charCodeAt(1);
            const _p$33 = 66;
            _tmp$31 = _p$32 === _p$33;
          }
          _tmp$30 = _tmp$31;
        } else {
          _tmp$30 = false;
        }
        _tmp$29 = _tmp$30;
      } else {
        _tmp$29 = false;
      }
      _tmp$28 = _tmp$29;
    } else {
      _tmp$28 = false;
    }
    if (_tmp$28) {
      i = 2;
    } else {
      let _tmp$29;
      if (base === 8) {
        let _tmp$30;
        if (end > 1) {
          $bound_check(text, 0);
          const _p$28 = text.charCodeAt(0);
          const _p$29 = 48;
          _tmp$30 = _p$28 === _p$29;
        } else {
          _tmp$30 = false;
        }
        _tmp$29 = _tmp$30;
      } else {
        _tmp$29 = false;
      }
      if (_tmp$29) {
        i = 1;
      }
    }
  }
  while (true) {
    if (i < end) {
      const _tmp$28 = i;
      $bound_check(text, _tmp$28);
      const code = text.charCodeAt(_tmp$28);
      const _bind = hackwaly$tinycc$sem$sem_core$$digit_value(code);
      let digit;
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        digit = _Some;
      }
      if (digit >= base) {
        break;
      }
      value = moonbitlang$core$builtin$$Add$add$6$(moonbitlang$core$builtin$$Mul$mul$6$(value, moonbitlang$core$int$$Int$to_uint64(base)), moonbitlang$core$int$$Int$to_uint64(digit));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return value;
}
function hackwaly$tinycc$sem$sem_core$$parse_uint64_value(text) {
  const end = hackwaly$tinycc$sem$sem_core$$int_literal_end(text);
  const base = hackwaly$tinycc$sem$sem_core$$int_literal_base_from(text, end);
  return hackwaly$tinycc$sem$sem_core$$parse_uint64_literal_prefix(text, base, end);
}
function hackwaly$tinycc$sem$sem_core$$parse_int_value(text) {
  return moonbitlang$core$int64$$Int64$to_int(hackwaly$tinycc$sem$sem_core$$parse_uint64_value(text));
}
function hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, expr) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    switch (expr$2.$tag) {
      case 0: {
        const _IntLit = expr$2;
        const _value = _IntLit._0;
        return hackwaly$tinycc$sem$sem_core$$parse_int_value(_value);
      }
      case 2: {
        const _CharLit = expr$2;
        const _value$2 = _CharLit._0;
        return _value$2;
      }
      case 4: {
        const _Ident = expr$2;
        const _name = _Ident._0;
        const _id = _Ident._1;
        return hackwaly$tinycc$sem$sem_core$$enum_const_value(ctx, _name, _id);
      }
      case 9: {
        const _Unary = expr$2;
        const _op = _Unary._0;
        const _expr = _Unary._1;
        switch (_op) {
          case 0: {
            const _bind = hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, _expr);
            if (_bind === undefined) {
              return undefined;
            } else {
              const _Some = _bind;
              const _v = _Some;
              return _v;
            }
          }
          case 1: {
            const _bind$2 = hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, _expr);
            if (_bind$2 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$2;
              const _v = _Some;
              return 0 - _v | 0;
            }
          }
          default: {
            return undefined;
          }
        }
      }
      case 10: {
        const _Cast = expr$2;
        const _ty = _Cast._0;
        const _expr$2 = _Cast._1;
        if (hackwaly$tinycc$sem$sem_core$$is_pointer_type(_ty) || hackwaly$tinycc$sem$sem_core$$is_int_like(_ty)) {
          _tmp$27 = _expr$2;
          continue _L;
        } else {
          return undefined;
        }
      }
      default: {
        return undefined;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, expr) {
  const _bind = hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, expr);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _v = _Some;
    return _v === 0;
  }
}
function hackwaly$tinycc$sem$sem_core$$is_scalar(ty) {
  if (hackwaly$tinycc$sem$sem_core$$is_int_like(ty) || hackwaly$tinycc$sem$sem_core$$is_float_type(ty)) {
    return true;
  }
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  if (_bind.$tag === 4) {
    return true;
  } else {
    return false;
  }
}
function hackwaly$tinycc$sem$sem_core$$ensure_expr_type_cache(ctx, id) {
  if (id <= 0) {
    return undefined;
  }
  const cache_len = ctx.expr_type_cache.length;
  if (cache_len >= id) {
    return undefined;
  }
  let i = cache_len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$50$(ctx.expr_type_cache, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$lookup_struct_def(ctx, name, id, is_union) {
  if (id !== 0) {
    const def = is_union ? hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(ctx.union_defs_by_id, id) : hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(ctx.struct_defs_by_id, id);
    if (def === undefined) {
      return undefined;
    } else {
      const _Some = def;
      const _def = _Some;
      return _def.fields.length === 0 ? undefined : _def;
    }
  } else {
    const defs = is_union ? ctx.union_defs : ctx.struct_defs;
    const _bind = moonbitlang$core$hashmap$$HashMap$get$162$(defs, name);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _def = _Some;
      return _def.fields.length === 0 ? undefined : _def;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$record_items_to_fields(items) {
  const fields = [];
  const _len = items.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const item = items[_i];
      if (item.$tag === 0) {
        const _Field = item;
        const _field = _Field._0;
        moonbitlang$core$array$$Array$push$39$(fields, _field);
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return fields;
}
function hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, tag, tag_id, fields, is_union, loc) {
  if (fields.$tag === 1) {
    const _Some = fields;
    const _list = _Some._0;
    const _p$28 = "";
    if (!(tag === _p$28)) {
      const _bind = hackwaly$tinycc$sem$sem_core$$lookup_struct_def(ctx, tag, tag_id, is_union);
      if (_bind === undefined) {
        return { fields: hackwaly$tinycc$sem$sem_core$$record_items_to_fields(_list), attrs: hackwaly$tinycc$frontend$ast$$empty_attrs() };
      } else {
        const _Some$2 = _bind;
        const _def = _Some$2;
        return _def;
      }
    } else {
      return { fields: hackwaly$tinycc$sem$sem_core$$record_items_to_fields(_list), attrs: hackwaly$tinycc$frontend$ast$$empty_attrs() };
    }
  } else {
    if (is_union) {
      if (tag_id !== 0) {
        _L: {
          const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(ctx.union_defs_by_id, tag_id);
          if (_bind === undefined) {
            break _L;
          } else {
            const _Some = _bind;
            const _def = _Some;
            if (_def.fields.length > 0) {
              return _def;
            } else {
              break _L;
            }
          }
        }
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete union '${tag}'`);
        return undefined;
      } else {
        _L: {
          const _bind = moonbitlang$core$hashmap$$HashMap$get$162$(ctx.union_defs, tag);
          if (_bind === undefined) {
            break _L;
          } else {
            const _Some = _bind;
            const _def = _Some;
            if (_def.fields.length > 0) {
              return _def;
            } else {
              break _L;
            }
          }
        }
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete union '${tag}'`);
        return undefined;
      }
    } else {
      if (tag_id !== 0) {
        _L: {
          const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(ctx.struct_defs_by_id, tag_id);
          if (_bind === undefined) {
            break _L;
          } else {
            const _Some = _bind;
            const _def = _Some;
            if (_def.fields.length > 0) {
              return _def;
            } else {
              break _L;
            }
          }
        }
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete struct '${tag}'`);
        return undefined;
      } else {
        _L: {
          const _bind = moonbitlang$core$hashmap$$HashMap$get$162$(ctx.struct_defs, tag);
          if (_bind === undefined) {
            break _L;
          } else {
            const _Some = _bind;
            const _def = _Some;
            if (_def.fields.length > 0) {
              return _def;
            } else {
              break _L;
            }
          }
        }
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete struct '${tag}'`);
        return undefined;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$float_size(kind) {
  switch (kind) {
    case 0: {
      return 4;
    }
    case 1: {
      return 8;
    }
    default: {
      return 8;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(ty) {
  let current = ty;
  while (true) {
    const _bind = current;
    if (_bind.$tag === 12) {
      const _Qualified = _bind;
      const _base = _Qualified._1;
      current = _base;
    } else {
      break;
    }
    continue;
  }
  return current;
}
function hackwaly$tinycc$sem$sem_core$$align_to(value, align) {
  if (align <= 1) {
    return value;
  }
  return Math.imul(((value + align | 0) - 1 | 0) / align | 0, align) | 0;
}
function hackwaly$tinycc$sem$sem_core$$builtin_func_sig_by_name(name) {
  const voidp = hackwaly$tinycc$sem$sem_core$$void_pointer_type_value;
  const charp = hackwaly$tinycc$sem$sem_core$$char_pointer_type_value;
  const size_t = hackwaly$tinycc$sem$sem_core$$size_t_type_value;
  const int_ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
  _L: {
    _L$2: {
      _L$3: {
        switch (name) {
          case "__builtin_abort": {
            return { return_type: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void, params: [], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_free": {
            return { return_type: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void, params: [voidp], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_malloc": {
            return { return_type: voidp, params: [size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_calloc": {
            return { return_type: voidp, params: [size_t, size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_realloc": {
            return { return_type: voidp, params: [voidp, size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_alloca": {
            return { return_type: voidp, params: [size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_memcpy": {
            break _L$3;
          }
          case "__builtin_memmove": {
            break _L$3;
          }
          case "__builtin_memset": {
            return { return_type: voidp, params: [voidp, int_ty, size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_memcmp": {
            return { return_type: int_ty, params: [voidp, voidp, size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_va_start": {
            return { return_type: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void, params: [voidp, int_ty], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_va_copy": {
            return { return_type: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void, params: [voidp, voidp], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_va_end": {
            return { return_type: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void, params: [voidp], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_strlen": {
            return { return_type: size_t, params: [charp], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_strcpy": {
            break _L$2;
          }
          case "__builtin_strncpy": {
            break _L$2;
          }
          case "__builtin_strcat": {
            break _L$2;
          }
          case "__builtin_strncat": {
            break _L$2;
          }
          case "__builtin_strcmp": {
            return { return_type: int_ty, params: [charp, charp], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_strncmp": {
            return { return_type: int_ty, params: [charp, charp, size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          case "__builtin_strchr": {
            break _L;
          }
          case "__builtin_strrchr": {
            break _L;
          }
          case "__builtin_strdup": {
            return { return_type: charp, params: [charp], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
          }
          default: {
            return undefined;
          }
        }
      }
      return { return_type: voidp, params: [voidp, voidp, size_t], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
    }
    return { return_type: charp, params: name === "__builtin_strncpy" || name === "__builtin_strncat" ? [charp, charp, size_t] : [charp, charp], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
  }
  return { return_type: charp, params: [charp, int_ty], varargs: false, is_old_style: false, call_conv: $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default };
}
function hackwaly$tinycc$sem$sem_core$$builtin_func_sig_from_ident(ctx, name, id) {
  if (id !== 0) {
    const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$190$(ctx.builtin_sig_ids, id);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _sig = _Some;
      return _sig;
    }
  }
  if (!hackwaly$tinycc$sem$sem_core$$has_builtin_prefix(name)) {
    return undefined;
  }
  const sig = hackwaly$tinycc$sem$sem_core$$builtin_func_sig_by_name(name);
  if (sig === undefined) {
    return undefined;
  } else {
    const _Some = sig;
    const _value = _Some;
    if (id !== 0) {
      hackwaly$tinycc$sem$sem_core$$set_opt_by_id$190$(ctx.builtin_sig_ids, id, _value);
    }
    return _value;
  }
}
function hackwaly$tinycc$sem$sem_core$$apply_inferred_array_size(ty, size) {
  switch (ty.$tag) {
    case 12: {
      const _Qualified = ty;
      const _qual = _Qualified._0;
      const _base = _Qualified._1;
      const updated = hackwaly$tinycc$sem$sem_core$$apply_inferred_array_size(_base, size);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, updated);
    }
    case 5: {
      const _Array = ty;
      const _elem = _Array._0;
      const _arr_size = _Array._1;
      const _size_expr = _Array._2;
      _L: {
        if (_arr_size === undefined) {
          if (_size_expr === undefined) {
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(_elem, size, undefined);
          } else {
            break _L;
          }
        } else {
          break _L;
        }
      }
      return ty;
    }
    default: {
      return ty;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$collect_elided_array_items(items, start, max_count) {
  const collected = [];
  let idx = start;
  let limit;
  if (max_count === undefined) {
    limit = items.length;
  } else {
    const _Some = max_count;
    const _n = _Some;
    limit = _n < 0 ? 0 : start + _n | 0;
  }
  while (true) {
    if (idx < items.length && idx < limit) {
      const item = moonbitlang$core$array$$Array$at$38$(items, idx);
      if (item.designators.length > 0) {
        break;
      }
      moonbitlang$core$array$$Array$push$38$(collected, { designators: [], value: item.value, loc: item.loc });
      idx = idx + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: collected, _1: idx - start | 0 };
}
function hackwaly$tinycc$sem$sem_core$$collect_field_index_cache_from_field(ctx, field, top_index, loc, cache_by_name, cache_by_id) {
  const _p$28 = field.name;
  const _p$29 = "";
  if (!(_p$28 === _p$29)) {
    if (!moonbitlang$core$hashmap$$HashMap$contains$156$(cache_by_name, field.name)) {
      moonbitlang$core$hashmap$$HashMap$set$156$(cache_by_name, field.name, top_index);
    }
    if (field.id > 0 && !moonbitlang$core$hashmap$$HashMap$contains$173$(cache_by_id, field.id)) {
      moonbitlang$core$hashmap$$HashMap$set$173$(cache_by_id, field.id, top_index);
    }
    return undefined;
  }
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(field.ty);
  switch (_bind.$tag) {
    case 6: {
      const _Struct = _bind;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const nested = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
      if (nested === undefined) {
        return;
      } else {
        const _Some = nested;
        const _def = _Some;
        const _arr = _def.fields;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const nested_field = _arr[_i];
            hackwaly$tinycc$sem$sem_core$$collect_field_index_cache_from_field(ctx, nested_field, top_index, loc, cache_by_name, cache_by_id);
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
    }
    case 7: {
      const _Union = _bind;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const nested$2 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
      if (nested$2 === undefined) {
        return;
      } else {
        const _Some = nested$2;
        const _def = _Some;
        const _arr = _def.fields;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const nested_field = _arr[_i];
            hackwaly$tinycc$sem$sem_core$$collect_field_index_cache_from_field(ctx, nested_field, top_index, loc, cache_by_name, cache_by_id);
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
    }
    default: {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$build_field_index_caches(ctx, fields, loc) {
  const cache_by_name = hackwaly$tinycc$support$util$$fast_map_new$156$(undefined);
  const cache_by_id = hackwaly$tinycc$support$util$$fast_map_new$173$(undefined);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < fields.length) {
      hackwaly$tinycc$sem$sem_core$$collect_field_index_cache_from_field(ctx, moonbitlang$core$array$$Array$at$39$(fields, i), i, loc, cache_by_name, cache_by_id);
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: cache_by_name, _1: cache_by_id };
}
function hackwaly$tinycc$sem$sem_core$$lookup_struct_fields(ctx, name, id, is_union) {
  const _bind = hackwaly$tinycc$sem$sem_core$$lookup_struct_def(ctx, name, id, is_union);
  if (_bind === undefined) {
    return Option$None$27$;
  } else {
    const _Some = _bind;
    const _def = _Some;
    return new Option$Some$27$(_def.fields);
  }
}
function hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, tag, tag_id, fields, is_union) {
  const _p$28 = "";
  if (!(tag === _p$28)) {
    const _bind = hackwaly$tinycc$sem$sem_core$$lookup_struct_fields(ctx, tag, tag_id, is_union);
    if (_bind.$tag === 1) {
      const _Some = _bind;
      const _list = _Some._0;
      return new Option$Some$27$(_list);
    }
  }
  if (fields.$tag === 1) {
    const _Some = fields;
    const _list = _Some._0;
    return new Option$Some$27$(hackwaly$tinycc$sem$sem_core$$record_items_to_fields(_list));
  } else {
    return Option$None$27$;
  }
}
function hackwaly$tinycc$sem$sem_core$$find_field(ctx, fields, name, id) {
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const field = fields[_i];
      if (id > 0 && field.id === id || field.name === name) {
        return field;
      }
      if (field.name === "") {
        const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(field.ty);
        switch (_bind.$tag) {
          case 6: {
            const _Struct = _bind;
            const _tag = _Struct._0;
            const _tag_id = _Struct._1;
            const _field_list = _Struct._2;
            const nested = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag, _tag_id, _field_list, false);
            if (nested.$tag === 1) {
              const _Some = nested;
              const _list = _Some._0;
              const _bind$2 = hackwaly$tinycc$sem$sem_core$$find_field(ctx, _list, name, id);
              if (_bind$2 === undefined) {
              } else {
                const _Some$2 = _bind$2;
                const _found = _Some$2;
                return _found;
              }
            }
            break;
          }
          case 7: {
            const _Union = _bind;
            const _tag$2 = _Union._0;
            const _tag_id$2 = _Union._1;
            const _field_list$2 = _Union._2;
            const nested$2 = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true);
            if (nested$2.$tag === 1) {
              const _Some = nested$2;
              const _list = _Some._0;
              const _bind$2 = hackwaly$tinycc$sem$sem_core$$find_field(ctx, _list, name, id);
              if (_bind$2 === undefined) {
              } else {
                const _Some$2 = _bind$2;
                const _found = _Some$2;
                return _found;
              }
            }
            break;
          }
        }
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$sem$sem_core$$find_field_index(ctx, fields, name, id) {
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < fields.length) {
      if (id > 0 && moonbitlang$core$array$$Array$at$39$(fields, i).id === id || moonbitlang$core$array$$Array$at$39$(fields, i).name === name) {
        return i;
      }
      if (moonbitlang$core$array$$Array$at$39$(fields, i).name === "") {
        const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(moonbitlang$core$array$$Array$at$39$(fields, i).ty);
        switch (_bind.$tag) {
          case 6: {
            const _Struct = _bind;
            const _tag = _Struct._0;
            const _tag_id = _Struct._1;
            const _field_list = _Struct._2;
            const nested = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag, _tag_id, _field_list, false);
            if (nested.$tag === 1) {
              const _Some = nested;
              const _list = _Some._0;
              const _bind$2 = hackwaly$tinycc$sem$sem_core$$find_field(ctx, _list, name, id);
              if (_bind$2 === undefined) {
              } else {
                return i;
              }
            }
            break;
          }
          case 7: {
            const _Union = _bind;
            const _tag$2 = _Union._0;
            const _tag_id$2 = _Union._1;
            const _field_list$2 = _Union._2;
            const nested$2 = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true);
            if (nested$2.$tag === 1) {
              const _Some = nested$2;
              const _list = _Some._0;
              const _bind$2 = hackwaly$tinycc$sem$sem_core$$find_field(ctx, _list, name, id);
              if (_bind$2 === undefined) {
              } else {
                return i;
              }
            }
            break;
          }
        }
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$sem$sem_core$$next_init_field(fields, start) {
  let i = start;
  while (true) {
    if (i < fields.length) {
      const field = moonbitlang$core$array$$Array$at$39$(fields, i);
      if (field.name === "") {
        const _bind = field.bit_width;
        if (_bind === undefined) {
        } else {
          i = i + 1 | 0;
          continue;
        }
      }
      return { _0: field, _1: i + 1 | 0 };
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$sem$sem_core$$has_single_init_field(ctx, ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  switch (_bind.$tag) {
    case 6: {
      const _Struct = _bind;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const fields = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag, _tag_id, _field_list, false);
      if (fields.$tag === 0) {
        return false;
      } else {
        const _Some = fields;
        const _list = _Some._0;
        const _bind$2 = hackwaly$tinycc$sem$sem_core$$next_init_field(_list, 0);
        if (_bind$2 === undefined) {
          return false;
        } else {
          const _Some$2 = _bind$2;
          const _x = _Some$2;
          const _next_idx = _x._1;
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$next_init_field(_list, _next_idx);
          return _bind$3 === undefined;
        }
      }
    }
    case 7: {
      const _Union = _bind;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const fields$2 = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true);
      if (fields$2.$tag === 0) {
        return false;
      } else {
        const _Some = fields$2;
        const _list = _Some._0;
        const _bind$2 = hackwaly$tinycc$sem$sem_core$$next_init_field(_list, 0);
        if (_bind$2 === undefined) {
          return false;
        } else {
          const _Some$2 = _bind$2;
          const _x = _Some$2;
          const _next_idx = _x._1;
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$next_init_field(_list, _next_idx);
          return _bind$3 === undefined;
        }
      }
    }
    default: {
      return false;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$is_zero_aggregate_init(ctx, ty, expr) {
  const _bind = hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, expr);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _v = _Some;
    if (_v === 0) {
      const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
      switch (_bind$2.$tag) {
        case 6: {
          return true;
        }
        case 7: {
          return true;
        }
        case 5: {
          return true;
        }
        default: {
          return false;
        }
      }
    } else {
      return false;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$float_kind_to_string(kind) {
  switch (kind) {
    case 0: {
      return "float";
    }
    case 1: {
      return "double";
    }
    default: {
      return "long double";
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$int_kind_to_string(kind) {
  switch (kind) {
    case 0: {
      return "char";
    }
    case 1: {
      return "short";
    }
    case 2: {
      return "int";
    }
    case 3: {
      return "long";
    }
    default: {
      return "long long";
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$qual_to_string(qual) {
  const parts = [];
  if (qual.is_const) {
    moonbitlang$core$array$$Array$push$19$(parts, "const");
  }
  if (qual.is_volatile) {
    moonbitlang$core$array$$Array$push$19$(parts, "volatile");
  }
  if (qual.is_restrict) {
    moonbitlang$core$array$$Array$push$19$(parts, "restrict");
  }
  if (qual.is_atomic) {
    moonbitlang$core$array$$Array$push$19$(parts, "_Atomic");
  }
  return parts.length === 0 ? "" : `${moonbitlang$core$array$$Array$join$19$(parts, { str: hackwaly$tinycc$sem$sem_core$$qual_to_string$46$42$bind$124$2747, start: 0, end: hackwaly$tinycc$sem$sem_core$$qual_to_string$46$42$bind$124$2747.length })} `;
}
function hackwaly$tinycc$sem$sem_core$$type_to_string(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _qual = _Qualified._0;
        const _base = _Qualified._1;
        return `${hackwaly$tinycc$sem$sem_core$$qual_to_string(_qual)}${hackwaly$tinycc$sem$sem_core$$type_to_string(_base)}`;
      }
      case 11: {
        const _Attributed = ty$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      case 0: {
        return "void";
      }
      case 1: {
        return "_Bool";
      }
      case 2: {
        const _Int = ty$2;
        const _kind = _Int._0;
        const _unsigned = _Int._1;
        const base = hackwaly$tinycc$sem$sem_core$$int_kind_to_string(_kind);
        return _unsigned ? `unsigned ${base}` : base;
      }
      case 3: {
        const _Float = ty$2;
        const _kind$2 = _Float._0;
        return hackwaly$tinycc$sem$sem_core$$float_kind_to_string(_kind$2);
      }
      case 4: {
        const _Pointer = ty$2;
        const _inner = _Pointer._0;
        return `${hackwaly$tinycc$sem$sem_core$$type_to_string(_inner)}*`;
      }
      case 5: {
        const _Array = ty$2;
        const _elem = _Array._0;
        const _size = _Array._1;
        if (_size === undefined) {
          return `${hackwaly$tinycc$sem$sem_core$$type_to_string(_elem)}[]`;
        } else {
          const _Some = _size;
          const _n = _Some;
          return `${hackwaly$tinycc$sem$sem_core$$type_to_string(_elem)}[${moonbitlang$core$builtin$$Show$to_string$90$(_n)}]`;
        }
      }
      case 6: {
        const _Struct = ty$2;
        const _name = _Struct._0;
        return `struct ${_name}`;
      }
      case 7: {
        const _Union = ty$2;
        const _name$2 = _Union._0;
        return `union ${_name$2}`;
      }
      case 8: {
        const _Enum = ty$2;
        const _name$3 = _Enum._0;
        return `enum ${_name$3}`;
      }
      case 9: {
        return "typeof";
      }
      default: {
        const _Function = ty$2;
        const _return_type = _Function._0;
        const _params = _Function._1;
        const _varargs = _Function._2;
        const _is_old_style = _Function._3;
        const _p$28 = new Array(_params.length);
        const _p$29 = _params.length;
        let _tmp$28 = 0;
        while (true) {
          const _p$30 = _tmp$28;
          if (_p$30 < _p$29) {
            const _p$31 = _params[_p$30];
            _p$28[_p$30] = hackwaly$tinycc$sem$sem_core$$type_to_string(_p$31);
            _tmp$28 = _p$30 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const args = moonbitlang$core$array$$Array$join$19$(_p$28, { str: hackwaly$tinycc$sem$sem_core$$type_to_string$46$42$bind$124$2752, start: 0, end: hackwaly$tinycc$sem$sem_core$$type_to_string$46$42$bind$124$2752.length });
        const rendered = _is_old_style ? "" : _varargs ? (args === "" ? "..." : `${args}, ...`) : args;
        return `fn(${rendered}) -> ${hackwaly$tinycc$sem$sem_core$$type_to_string(_return_type)}`;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$define_enum_const(ctx, name, id, loc, value) {
  let conflict = hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, name, id);
  if (!conflict) {
    conflict = id > 0 ? hackwaly$tinycc$sem$sem_core$$has_global_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$contains$159$(ctx.globals, name);
  }
  if (!conflict) {
    conflict = id > 0 ? hackwaly$tinycc$sem$sem_core$$has_function_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$contains$160$(ctx.functions, name);
  }
  if (conflict) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
    return undefined;
  }
  moonbitlang$core$hashmap$$HashMap$set$156$(ctx.enum_consts, name, value);
  if (id > 0) {
    hackwaly$tinycc$sem$sem_core$$set_enum_const_by_id(ctx, id, value);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$decay_type(ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  switch (_bind.$tag) {
    case 5: {
      const _Array = _bind;
      const _elem = _Array._0;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_elem);
    }
    case 10: {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(ty);
    }
    default: {
      return ty;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$float_type_from_literal(lit) {
  const len = lit.length;
  if (len === 0) {
    return hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6652;
  }
  const _tmp$27 = len - 1 | 0;
  $bound_check(lit, _tmp$27);
  const last = lit.charCodeAt(_tmp$27);
  let _tmp$28;
  const _p$28 = 102;
  if (last === _p$28) {
    _tmp$28 = true;
  } else {
    const _p$29 = 70;
    _tmp$28 = last === _p$29;
  }
  if (_tmp$28) {
    return hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6653;
  } else {
    let _tmp$29;
    const _p$29 = 108;
    if (last === _p$29) {
      _tmp$29 = true;
    } else {
      const _p$30 = 76;
      _tmp$29 = last === _p$30;
    }
    if (_tmp$29) {
      return hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6654;
    } else {
      return hackwaly$tinycc$sem$sem_core$$float_type_from_literal$46$constr$47$6655;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$index_access_type(ctx, base_ty, index_ty, loc) {
  if (hackwaly$tinycc$sem$sem_core$$is_int_like(index_ty)) {
    const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(base_ty);
    switch (_bind.$tag) {
      case 4: {
        const _Pointer = _bind;
        const _elem = _Pointer._0;
        return _elem;
      }
      case 5: {
        const _Array = _bind;
        const _elem$2 = _Array._0;
        return _elem$2;
      }
      default: {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "subscripted value is not an array");
        return undefined;
      }
    }
  } else {
    if (hackwaly$tinycc$sem$sem_core$$is_int_like(base_ty)) {
      const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(index_ty);
      switch (_bind.$tag) {
        case 4: {
          const _Pointer = _bind;
          const _elem = _Pointer._0;
          return _elem;
        }
        case 5: {
          const _Array = _bind;
          const _elem$2 = _Array._0;
          return _elem$2;
        }
        default: {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "array index must be int");
          return undefined;
        }
      }
    } else {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "array index must be int");
      return undefined;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$adjust_int_literal_kind(value, base, long_count, unsigned) {
  let lcount = long_count;
  let ucount = unsigned;
  if (!ucount && base === 10) {
    if (lcount <= 0) {
      if (moonbitlang$core$builtin$$Compare$op_ge$80$(value, $2147483648L)) {
        lcount = 1;
      }
    }
    if (moonbitlang$core$builtin$$Compare$op_ge$80$(value, $_9223372036854775808L)) {
      ucount = true;
    }
  } else {
    if (lcount <= 0) {
      if (moonbitlang$core$builtin$$Compare$op_ge$80$(value, $4294967296L)) {
        lcount = 1;
      } else {
        if (moonbitlang$core$builtin$$Compare$op_ge$80$(value, $2147483648L)) {
          ucount = true;
        }
      }
    }
    if (moonbitlang$core$builtin$$Compare$op_ge$80$(value, $_9223372036854775808L)) {
      ucount = true;
    }
  }
  return { _0: lcount, _1: ucount };
}
function hackwaly$tinycc$sem$sem_core$$parse_int_suffix_range(text, start) {
  let long_count = 0;
  let unsigned = false;
  const len = text.length;
  let i = start;
  while (true) {
    if (i < len) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      let _tmp$28;
      const _p$28 = 108;
      if (code === _p$28) {
        _tmp$28 = true;
      } else {
        const _p$29 = 76;
        _tmp$28 = code === _p$29;
      }
      if (_tmp$28) {
        long_count = long_count + 1 | 0;
      } else {
        let _tmp$29;
        const _p$29 = 117;
        if (code === _p$29) {
          _tmp$29 = true;
        } else {
          const _p$30 = 85;
          _tmp$29 = code === _p$30;
        }
        if (_tmp$29) {
          unsigned = true;
        }
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (long_count > 2) {
    long_count = 2;
  }
  return { _0: long_count, _1: unsigned };
}
function hackwaly$tinycc$sem$sem_core$$int_literal_type(text) {
  const end = hackwaly$tinycc$sem$sem_core$$int_literal_end(text);
  const _bind = hackwaly$tinycc$sem$sem_core$$parse_int_suffix_range(text, end);
  const _long_count = _bind._0;
  const _unsigned = _bind._1;
  const base = hackwaly$tinycc$sem$sem_core$$int_literal_base_from(text, end);
  if (base === 10 && (end <= 9 && (_long_count === 0 && !_unsigned))) {
    return hackwaly$tinycc$sem$sem_core$$int_literal_type$46$constr$47$6687;
  }
  const value = hackwaly$tinycc$sem$sem_core$$parse_uint64_literal_prefix(text, base, end);
  const _bind$2 = hackwaly$tinycc$sem$sem_core$$adjust_int_literal_kind(value, base, _long_count, _unsigned);
  const _adj_long_count = _bind$2._0;
  const _adj_unsigned = _bind$2._1;
  const kind = _adj_long_count >= 2 ? 4 : _adj_long_count === 1 ? 3 : 2;
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(kind, _adj_unsigned);
}
function hackwaly$tinycc$sem$sem_core$$is_const_qualified(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _qual = _Qualified._0;
        return _qual.is_const;
      }
      case 11: {
        const _Attributed = ty$2;
        const _base = _Attributed._1;
        _tmp$27 = _base;
        continue _L;
      }
      default: {
        return false;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$is_void_pointer_type(ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  if (_bind.$tag === 4) {
    const _Pointer = _bind;
    const _inner = _Pointer._0;
    return hackwaly$tinycc$sem$sem_core$$is_void_type(_inner);
  } else {
    return false;
  }
}
function hackwaly$tinycc$sem$sem_core$$split_top_qual(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _qual = _Qualified._0;
        const _base = _Qualified._1;
        return { _0: _qual, _1: _base };
      }
      case 11: {
        const _Attributed = ty$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      default: {
        return { _0: hackwaly$tinycc$frontend$ast$$empty_qual(), _1: ty$2 };
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$collect_member_cache_from_fields(ctx, fields, qual, loc, cache_by_name, cache_by_id) {
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      _L: {
        const field = fields[_i];
        const _bind = hackwaly$tinycc$sem$sem_core$$split_top_qual(field.ty);
        const _field_qual = _bind._0;
        const combined = hackwaly$tinycc$frontend$ast$$merge_qual(qual, _field_qual);
        const _p$28 = field.name;
        const _p$29 = "";
        if (!(_p$28 === _p$29)) {
          if (!moonbitlang$core$hashmap$$HashMap$contains$159$(cache_by_name, field.name)) {
            moonbitlang$core$hashmap$$HashMap$set$159$(cache_by_name, field.name, hackwaly$tinycc$frontend$ast$$apply_qualifiers(field.ty, qual));
          }
          if (field.id > 0 && !moonbitlang$core$hashmap$$HashMap$contains$169$(cache_by_id, field.id)) {
            moonbitlang$core$hashmap$$HashMap$set$169$(cache_by_id, field.id, hackwaly$tinycc$frontend$ast$$apply_qualifiers(field.ty, qual));
          }
          break _L;
        }
        const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(field.ty);
        switch (_bind$2.$tag) {
          case 6: {
            const _Struct = _bind$2;
            const _tag = _Struct._0;
            const _tag_id = _Struct._1;
            const _field_list = _Struct._2;
            const def = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
            if (def === undefined) {
            } else {
              const _Some = def;
              const _def_val = _Some;
              hackwaly$tinycc$sem$sem_core$$collect_member_cache_from_fields(ctx, _def_val.fields, combined, loc, cache_by_name, cache_by_id);
            }
            break;
          }
          case 7: {
            const _Union = _bind$2;
            const _tag$2 = _Union._0;
            const _tag_id$2 = _Union._1;
            const _field_list$2 = _Union._2;
            const def$2 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
            if (def$2 === undefined) {
            } else {
              const _Some = def$2;
              const _def_val = _Some;
              hackwaly$tinycc$sem$sem_core$$collect_member_cache_from_fields(ctx, _def_val.fields, combined, loc, cache_by_name, cache_by_id);
            }
            break;
          }
        }
        break _L;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$build_member_caches(ctx, fields, loc) {
  const cache_by_name = hackwaly$tinycc$support$util$$fast_map_new$159$(undefined);
  const cache_by_id = hackwaly$tinycc$support$util$$fast_map_new$169$(undefined);
  hackwaly$tinycc$sem$sem_core$$collect_member_cache_from_fields(ctx, fields, hackwaly$tinycc$frontend$ast$$empty_qual(), loc, cache_by_name, cache_by_id);
  return { _0: cache_by_name, _1: cache_by_id };
}
function hackwaly$tinycc$sem$sem_core$$member_access_search(ctx, ty, qual, name, id, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  switch (_bind.$tag) {
    case 6: {
      const _Struct = _bind;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const def = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
      if (def === undefined) {
        return undefined;
      } else {
        const _Some = def;
        const _def_val = _Some;
        const _arr = _def_val.fields;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const field = _arr[_i];
            const _bind$2 = hackwaly$tinycc$sem$sem_core$$split_top_qual(field.ty);
            const _field_qual = _bind$2._0;
            const combined = hackwaly$tinycc$frontend$ast$$merge_qual(qual, _field_qual);
            if (id > 0 && field.id === id || field.name === name) {
              return hackwaly$tinycc$frontend$ast$$apply_qualifiers(field.ty, qual);
            }
            if (field.name === "") {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$member_access_search(ctx, field.ty, combined, name, id, loc);
              if (_bind$3 === undefined) {
              } else {
                const _Some$2 = _bind$3;
                const _found = _Some$2;
                return _found;
              }
            }
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return undefined;
      }
    }
    case 7: {
      const _Union = _bind;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const def$2 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
      if (def$2 === undefined) {
        return undefined;
      } else {
        const _Some = def$2;
        const _def_val = _Some;
        const _arr = _def_val.fields;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const field = _arr[_i];
            const _bind$2 = hackwaly$tinycc$sem$sem_core$$split_top_qual(field.ty);
            const _field_qual = _bind$2._0;
            const combined = hackwaly$tinycc$frontend$ast$$merge_qual(qual, _field_qual);
            if (id > 0 && field.id === id || field.name === name) {
              return hackwaly$tinycc$frontend$ast$$apply_qualifiers(field.ty, qual);
            }
            if (field.name === "") {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$member_access_search(ctx, field.ty, combined, name, id, loc);
              if (_bind$3 === undefined) {
              } else {
                const _Some$2 = _bind$3;
                const _found = _Some$2;
                return _found;
              }
            }
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return undefined;
      }
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$member_access_type(ctx, base_ty, name, id, is_arrow, loc) {
  let obj_ty;
  if (is_arrow) {
    const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(base_ty);
    if (_bind.$tag === 4) {
      const _Pointer = _bind;
      obj_ty = _Pointer._0;
    } else {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "arrow operator requires pointer");
      return undefined;
    }
  } else {
    obj_ty = base_ty;
  }
  const _bind = hackwaly$tinycc$sem$sem_core$$split_top_qual(obj_ty);
  const _obj_qual = _bind._0;
  const _obj_base = _bind._1;
  const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_obj_base);
  switch (_bind$2.$tag) {
    case 6: {
      const _Struct = _bind$2;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const def = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
      if (def === undefined) {
        return undefined;
      } else {
        const _Some = def;
        const _def_val = _Some;
        const _p$28 = "";
        if (!(_tag === _p$28)) {
          if (id > 0 && _tag_id !== 0) {
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$187$(ctx.struct_member_cache_by_id, _tag_id);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$build_member_caches(ctx, _def_val.fields, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              hackwaly$tinycc$sem$sem_core$$set_opt_by_id$187$(ctx.struct_member_cache_by_id, _tag_id, _built_id);
              moonbitlang$core$hashmap$$HashMap$set$163$(ctx.struct_member_cache, _tag, _built_name);
              cache = _built_id;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$169$(cache, id);
            if (_bind$4 === undefined) {
              const msg = `unknown field '${name}' in ${hackwaly$tinycc$sem$sem_core$$type_to_string(_obj_base)}`;
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, msg);
              return undefined;
            } else {
              const _Some$2 = _bind$4;
              const _ty = _Some$2;
              return hackwaly$tinycc$frontend$ast$$apply_qualifiers(_ty, _obj_qual);
            }
          } else {
            const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$163$(ctx.struct_member_cache, _tag);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$build_member_caches(ctx, _def_val.fields, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              moonbitlang$core$hashmap$$HashMap$set$163$(ctx.struct_member_cache, _tag, _built_name);
              if (_tag_id !== 0) {
                hackwaly$tinycc$sem$sem_core$$set_opt_by_id$187$(ctx.struct_member_cache_by_id, _tag_id, _built_id);
              }
              cache = _built_name;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$159$(cache, name);
            if (_bind$4 === undefined) {
              const msg = `unknown field '${name}' in ${hackwaly$tinycc$sem$sem_core$$type_to_string(_obj_base)}`;
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, msg);
              return undefined;
            } else {
              const _Some$2 = _bind$4;
              const _ty = _Some$2;
              return hackwaly$tinycc$frontend$ast$$apply_qualifiers(_ty, _obj_qual);
            }
          }
        } else {
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$member_access_search(ctx, _obj_base, _obj_qual, name, id, loc);
          if (_bind$3 === undefined) {
            const msg = `unknown field '${name}' in ${hackwaly$tinycc$sem$sem_core$$type_to_string(_obj_base)}`;
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, msg);
            return undefined;
          } else {
            const _Some$2 = _bind$3;
            const _ty = _Some$2;
            return _ty;
          }
        }
      }
    }
    case 7: {
      const _Union = _bind$2;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const def$2 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
      if (def$2 === undefined) {
        return undefined;
      } else {
        const _Some = def$2;
        const _def_val = _Some;
        const _p$28 = "";
        if (!(_tag$2 === _p$28)) {
          if (id > 0 && _tag_id$2 !== 0) {
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$187$(ctx.union_member_cache_by_id, _tag_id$2);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$build_member_caches(ctx, _def_val.fields, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              hackwaly$tinycc$sem$sem_core$$set_opt_by_id$187$(ctx.union_member_cache_by_id, _tag_id$2, _built_id);
              moonbitlang$core$hashmap$$HashMap$set$163$(ctx.union_member_cache, _tag$2, _built_name);
              cache = _built_id;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$169$(cache, id);
            if (_bind$4 === undefined) {
              const msg = `unknown field '${name}' in ${hackwaly$tinycc$sem$sem_core$$type_to_string(_obj_base)}`;
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, msg);
              return undefined;
            } else {
              const _Some$2 = _bind$4;
              const _ty = _Some$2;
              return hackwaly$tinycc$frontend$ast$$apply_qualifiers(_ty, _obj_qual);
            }
          } else {
            const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$163$(ctx.union_member_cache, _tag$2);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$build_member_caches(ctx, _def_val.fields, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              moonbitlang$core$hashmap$$HashMap$set$163$(ctx.union_member_cache, _tag$2, _built_name);
              if (_tag_id$2 !== 0) {
                hackwaly$tinycc$sem$sem_core$$set_opt_by_id$187$(ctx.union_member_cache_by_id, _tag_id$2, _built_id);
              }
              cache = _built_name;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$159$(cache, name);
            if (_bind$4 === undefined) {
              const msg = `unknown field '${name}' in ${hackwaly$tinycc$sem$sem_core$$type_to_string(_obj_base)}`;
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, msg);
              return undefined;
            } else {
              const _Some$2 = _bind$4;
              const _ty = _Some$2;
              return hackwaly$tinycc$frontend$ast$$apply_qualifiers(_ty, _obj_qual);
            }
          }
        } else {
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$member_access_search(ctx, _obj_base, _obj_qual, name, id, loc);
          if (_bind$3 === undefined) {
            const msg = `unknown field '${name}' in ${hackwaly$tinycc$sem$sem_core$$type_to_string(_obj_base)}`;
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, msg);
            return undefined;
          } else {
            const _Some$2 = _bind$3;
            const _ty = _Some$2;
            return _ty;
          }
        }
      }
    }
    default: {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "member access on non-aggregate");
      return undefined;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$current_return_type(ctx) {
  const _bind = ctx.current_func_name;
  if (_bind === undefined) {
    return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
  } else {
    const _Some = _bind;
    const _name = _Some;
    const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$160$(ctx.functions, _name);
    if (_bind$2 === undefined) {
      return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
    } else {
      const _Some$2 = _bind$2;
      const _sig = _Some$2;
      return _sig.return_type;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$pop_scope(ctx) {
  const _bind = moonbitlang$core$array$$Array$pop$56$(ctx.local_overrides);
  if (_bind.$tag === 1) {
    const _Some = _bind;
    const _overrides = _Some._0;
    let i = _overrides.length;
    while (true) {
      if (i > 0) {
        i = i - 1 | 0;
        const entry = moonbitlang$core$array$$Array$at$54$(_overrides, i);
        const id = entry.id;
        if (id <= 0) {
          continue;
        }
        const _bind$2 = entry.prev_ty;
        if (_bind$2 === undefined) {
          if (id <= ctx.local_values_by_id.length) {
            moonbitlang$core$array$$Array$set$50$(ctx.local_values_by_id, id - 1 | 0, undefined);
          }
        } else {
          const _Some$2 = _bind$2;
          const _ty = _Some$2;
          hackwaly$tinycc$sem$sem_core$$set_opt_by_id$29$(ctx.local_values_by_id, id, _ty);
        }
        hackwaly$tinycc$sem$sem_core$$ensure_int_array_capacity(ctx.local_scope_ids_by_id, id);
        moonbitlang$core$array$$Array$set$26$(ctx.local_scope_ids_by_id, id - 1 | 0, entry.prev_scope);
        continue;
      } else {
        break;
      }
    }
  }
  moonbitlang$core$array$$Array$pop$26$(ctx.local_scope_stack);
}
function hackwaly$tinycc$sem$sem_core$$push_scope(ctx) {
  ctx.next_local_scope_id = ctx.next_local_scope_id + 1 | 0;
  moonbitlang$core$array$$Array$push$26$(ctx.local_scope_stack, ctx.next_local_scope_id);
  moonbitlang$core$array$$Array$push$56$(ctx.local_overrides, []);
}
function hackwaly$tinycc$sem$sem_core$$record_stmt_expr(ctx) {
  const id = ctx.current_func_id;
  if (id > 0) {
    hackwaly$tinycc$sem$sem_core$$set_opt_by_id$67$(ctx.func_has_stmt_expr_by_id, id, true);
    return undefined;
  }
  const _bind = ctx.current_func_name;
  if (_bind === undefined) {
    return;
  } else {
    const _Some = _bind;
    const _name = _Some;
    moonbitlang$core$hashmap$$HashMap$set$161$(ctx.func_has_stmt_expr, _name, true);
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$check_storage_class(ctx, storage, loc, is_local, is_function) {
  if (is_function) {
    _L: {
      switch (storage) {
        case 3: {
          break _L;
        }
        case 4: {
          break _L;
        }
        case 2: {
          if (is_local) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "function without file scope cannot be static");
            return;
          } else {
            return;
          }
        }
        default: {
          return;
        }
      }
    }
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid storage class for function");
    return;
  } else {
    if (!is_local) {
      _L: {
        switch (storage) {
          case 3: {
            break _L;
          }
          case 4: {
            break _L;
          }
          default: {
            return;
          }
        }
      }
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid storage class for global");
      return;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(existing, incoming) {
  _L: {
    if (existing.$tag === 12) {
      const _Qualified = existing;
      const _qual = _Qualified._0;
      const _base = _Qualified._1;
      const merged = hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(_base, incoming);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, merged);
    } else {
      if (incoming.$tag === 12) {
        const _Qualified = incoming;
        const _qual = _Qualified._0;
        const _base = _Qualified._1;
        const merged = hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(existing, _base);
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, merged);
      } else {
        if (existing.$tag === 11) {
          const _Attributed = existing;
          const _attrs_a = _Attributed._0;
          const _base_a = _Attributed._1;
          if (incoming.$tag === 11) {
            const _Attributed$2 = incoming;
            const _attrs_b = _Attributed$2._0;
            const _base_b = _Attributed$2._1;
            const merged_base = hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(_base_a, _base_b);
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(hackwaly$tinycc$frontend$ast$$merge_attrs(_attrs_a, _attrs_b), merged_base);
          } else {
            const merged = hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(_base_a, incoming);
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs_a, merged);
          }
        } else {
          if (incoming.$tag === 11) {
            const _Attributed = incoming;
            const _attrs_b = _Attributed._0;
            const _base_b = _Attributed._1;
            const merged = hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(existing, _base_b);
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs_b, merged);
          } else {
            switch (existing.$tag) {
              case 5: {
                const _Array = existing;
                const _elem_a = _Array._0;
                const _size_a = _Array._1;
                const _size_expr_a = _Array._2;
                if (incoming.$tag === 5) {
                  const _Array$2 = incoming;
                  const _elem_b = _Array$2._0;
                  const _size_b = _Array$2._1;
                  const _size_expr_b = _Array$2._2;
                  const merged_elem = hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(_elem_a, _elem_b);
                  const merged_size = _size_a === undefined ? _size_b : _size_a;
                  const merged_size_expr = _size_expr_a === undefined ? _size_expr_b : _size_expr_a;
                  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(merged_elem, merged_size, merged_size_expr);
                } else {
                  break _L;
                }
              }
              case 4: {
                const _Pointer = existing;
                const _inner_a = _Pointer._0;
                if (incoming.$tag === 4) {
                  const _Pointer$2 = incoming;
                  const _inner_b = _Pointer$2._0;
                  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(_inner_a, _inner_b));
                } else {
                  break _L;
                }
              }
              default: {
                break _L;
              }
            }
          }
        }
      }
    }
  }
  return existing;
}
function hackwaly$tinycc$sem$sem_core$$declare_global(ctx, name, id, ty, loc) {
  if (hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, name, id)) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of global '${name}'`);
    return undefined;
  }
  let updated = undefined;
  const existing = id > 0 ? hackwaly$tinycc$sem$sem_core$$get_global_by_id(ctx, id) : moonbitlang$core$hashmap$$HashMap$get$159$(ctx.globals, name);
  if (existing === undefined) {
    moonbitlang$core$hashmap$$HashMap$set$159$(ctx.globals, name, ty);
    updated = ty;
  } else {
    const _Some = existing;
    const _existing = _Some;
    if (!hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(_existing, ty)) {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of global '${name}'`);
    } else {
      const merged = hackwaly$tinycc$sem$sem_core$$merge_global_decl_type(_existing, ty);
      moonbitlang$core$hashmap$$HashMap$set$159$(ctx.globals, name, merged);
      updated = merged;
    }
  }
  if (id > 0) {
    const _bind = updated;
    if (_bind === undefined) {
      return;
    } else {
      const _Some = _bind;
      const _resolved = _Some;
      hackwaly$tinycc$sem$sem_core$$set_global_by_id(ctx, id, _resolved);
      return;
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$record_local_binding(ctx, id, ty) {
  const scope_id = hackwaly$tinycc$sem$sem_core$$current_local_scope_id(ctx);
  if (scope_id === 0 || id <= 0) {
    return undefined;
  }
  const idx = ctx.local_overrides.length - 1 | 0;
  const overrides = moonbitlang$core$array$$Array$at$56$(ctx.local_overrides, idx);
  const prev_scope = id <= ctx.local_scope_ids_by_id.length ? moonbitlang$core$array$$Array$at$26$(ctx.local_scope_ids_by_id, id - 1 | 0) : 0;
  moonbitlang$core$array$$Array$push$54$(overrides, { id: id, prev_ty: hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(ctx.local_values_by_id, id), prev_scope: prev_scope });
  moonbitlang$core$array$$Array$set$56$(ctx.local_overrides, idx, overrides);
  hackwaly$tinycc$sem$sem_core$$set_opt_by_id$29$(ctx.local_values_by_id, id, ty);
  hackwaly$tinycc$sem$sem_core$$ensure_int_array_capacity(ctx.local_scope_ids_by_id, id);
  moonbitlang$core$array$$Array$set$26$(ctx.local_scope_ids_by_id, id - 1 | 0, scope_id);
}
function hackwaly$tinycc$sem$sem_core$$declare_local(ctx, name, id, ty, loc) {
  const scope_id = hackwaly$tinycc$sem$sem_core$$current_local_scope_id(ctx);
  if (scope_id === 0 || id <= 0) {
    return undefined;
  }
  const prev_scope = id <= ctx.local_scope_ids_by_id.length ? moonbitlang$core$array$$Array$at$26$(ctx.local_scope_ids_by_id, id - 1 | 0) : 0;
  if (prev_scope === scope_id) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
    return;
  } else {
    hackwaly$tinycc$sem$sem_core$$record_local_binding(ctx, id, ty);
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$record_local_decl(ctx) {
  const id = ctx.current_func_id;
  if (id > 0) {
    hackwaly$tinycc$sem$sem_core$$set_opt_by_id$67$(ctx.func_has_local_decl_by_id, id, true);
    return undefined;
  }
  const _bind = ctx.current_func_name;
  if (_bind === undefined) {
    return;
  } else {
    const _Some = _bind;
    const _name = _Some;
    moonbitlang$core$hashmap$$HashMap$set$161$(ctx.func_has_local_decl, _name, true);
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$record_static_local(ctx) {
  const id = ctx.current_func_id;
  if (id > 0) {
    hackwaly$tinycc$sem$sem_core$$set_opt_by_id$67$(ctx.func_has_static_local_by_id, id, true);
    return undefined;
  }
  const _bind = ctx.current_func_name;
  if (_bind === undefined) {
    return;
  } else {
    const _Some = _bind;
    const _name = _Some;
    moonbitlang$core$hashmap$$HashMap$set$161$(ctx.func_has_static_local, _name, true);
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$decl_allows_vla(is_local, storage) {
  if (!is_local) {
    return false;
  }
  switch (storage) {
    case 0: {
      return true;
    }
    case 3: {
      return true;
    }
    case 4: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$type_has_vla_object_size(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    let elem;
    _L$2: {
      const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty$2);
      switch (_bind.$tag) {
        case 5: {
          const _Array = _bind;
          const _x = _Array._1;
          if (_x === undefined) {
            const _x$2 = _Array._2;
            if (_x$2 === undefined) {
              const _elem = _Array._0;
              elem = _elem;
              break _L$2;
            } else {
              return true;
            }
          } else {
            const _elem = _Array._0;
            elem = _elem;
            break _L$2;
          }
        }
        case 12: {
          const _Qualified = _bind;
          const _base = _Qualified._1;
          _tmp$27 = _base;
          continue _L;
        }
        case 11: {
          const _Attributed = _bind;
          const _base$2 = _Attributed._1;
          _tmp$27 = _base$2;
          continue _L;
        }
        default: {
          return false;
        }
      }
    }
    _tmp$27 = elem;
    continue;
  }
}
function hackwaly$tinycc$sem$sem_core$$update_decl_type(ctx, name, id, ty, is_local) {
  if (is_local) {
    const scope_id = hackwaly$tinycc$sem$sem_core$$current_local_scope_id(ctx);
    if (scope_id === 0 || id <= 0) {
      return undefined;
    }
    if (id <= ctx.local_scope_ids_by_id.length && moonbitlang$core$array$$Array$at$26$(ctx.local_scope_ids_by_id, id - 1 | 0) === scope_id) {
      hackwaly$tinycc$sem$sem_core$$set_opt_by_id$29$(ctx.local_values_by_id, id, ty);
      return;
    } else {
      return;
    }
  } else {
    if (id > 0) {
      if (hackwaly$tinycc$sem$sem_core$$has_global_by_id(ctx, id)) {
        moonbitlang$core$hashmap$$HashMap$set$159$(ctx.globals, name, ty);
        hackwaly$tinycc$sem$sem_core$$set_global_by_id(ctx, id, ty);
        return;
      } else {
        if (moonbitlang$core$hashmap$$HashMap$contains$159$(ctx.globals, name)) {
          moonbitlang$core$hashmap$$HashMap$set$159$(ctx.globals, name, ty);
          return;
        } else {
          return;
        }
      }
    } else {
      if (moonbitlang$core$hashmap$$HashMap$contains$159$(ctx.globals, name)) {
        moonbitlang$core$hashmap$$HashMap$set$159$(ctx.globals, name, ty);
        return;
      } else {
        return;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$register_case_range(ctx, start, end, loc) {
  if (ctx.switch_stack.length === 0) {
    return undefined;
  }
  if (start > end) {
    return undefined;
  }
  const idx = ctx.switch_stack.length - 1 | 0;
  const info = moonbitlang$core$array$$Array$at$53$(ctx.switch_stack, idx);
  moonbitlang$core$array$$Array$push$18$(info.cases, { _0: start, _1: end, _2: loc });
  moonbitlang$core$array$$Array$set$53$(ctx.switch_stack, idx, info);
}
function hackwaly$tinycc$sem$sem_core$$with_loop(ctx, f) {
  ctx.loop_depth = ctx.loop_depth + 1 | 0;
  f();
  ctx.loop_depth = ctx.loop_depth - 1 | 0;
}
function hackwaly$tinycc$sem$sem_core$$check_switch_cases(ctx, info) {
  const cases = info.cases;
  if (cases.length < 2) {
    return undefined;
  }
  moonbitlang$core$array$$Array$sort_by$18$(cases, (a, b) => {
    const _a_start = a._0;
    const _a_end = a._1;
    const _b_start = b._0;
    const _b_end = b._1;
    return _a_start < _b_start ? -1 : _a_start > _b_start ? 1 : _a_end < _b_end ? -1 : _a_end > _b_end ? 1 : 0;
  });
  const _bind = moonbitlang$core$array$$Array$at$18$(cases, 0);
  const _first_end = _bind._1;
  let prev_end = _first_end;
  let i = 1;
  while (true) {
    if (i < cases.length) {
      const _bind$2 = moonbitlang$core$array$$Array$at$18$(cases, i);
      const _start = _bind$2._0;
      const _end = _bind$2._1;
      const _loc = _bind$2._2;
      if (prev_end >= _start) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, "duplicate case value");
      }
      if (_end > prev_end) {
        prev_end = _end;
      }
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$with_switch(ctx, f) {
  ctx.switch_depth = ctx.switch_depth + 1 | 0;
  moonbitlang$core$array$$Array$push$53$(ctx.switch_stack, { cases: [], has_default: false });
  f();
  const _bind = moonbitlang$core$array$$Array$pop$53$(ctx.switch_stack);
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _info = _Some;
    hackwaly$tinycc$sem$sem_core$$check_switch_cases(ctx, _info);
  }
  ctx.switch_depth = ctx.switch_depth - 1 | 0;
}
function hackwaly$tinycc$sem$sem_core$$enum_type_from_items(ctx, items) {
  let value = 0;
  let min_value = 0;
  let max_value = 0;
  let has_value = false;
  const _len = items.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const item = items[_i];
      const _bind = item.value;
      let current;
      if (_bind === undefined) {
        current = value;
      } else {
        const _Some = _bind;
        const _expr = _Some;
        current = hackwaly$tinycc$sem$sem_core$$eval_const_expr(ctx, _expr, item.loc);
      }
      if (!has_value) {
        min_value = current;
        max_value = current;
        has_value = true;
      } else {
        if (current < min_value) {
          min_value = current;
        }
        if (current > max_value) {
          max_value = current;
        }
      }
      value = current + 1 | 0;
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return has_value ? hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range(min_value, max_value) : hackwaly$tinycc$sem$sem_core$$default_int_type();
}
function hackwaly$tinycc$sem$sem_core$$eval_const_expr(ctx, expr, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, expr, loc);
  return _bind._0;
}
function hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, expr, loc) {
  let _tmp$27 = expr;
  let _tmp$28 = loc;
  _L: while (true) {
    const expr$2 = _tmp$27;
    const loc$2 = _tmp$28;
    _L$2: {
      switch (expr$2.$tag) {
        case 0: {
          const _IntLit = expr$2;
          const _value = _IntLit._0;
          return { _0: hackwaly$tinycc$sem$sem_core$$parse_int_value(_value), _1: true };
        }
        case 2: {
          const _CharLit = expr$2;
          const _value$2 = _CharLit._0;
          return { _0: _value$2, _1: true };
        }
        case 1: {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
          return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7049;
        }
        case 3: {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
          return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7050;
        }
        case 4: {
          const _Ident = expr$2;
          const _name = _Ident._0;
          const _id = _Ident._1;
          const _bind = hackwaly$tinycc$sem$sem_core$$enum_const_value(ctx, _name, _id);
          if (_bind === undefined) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7051;
          } else {
            const _Some = _bind;
            const _v = _Some;
            return { _0: _v, _1: true };
          }
        }
        case 6: {
          const _BuiltinTypesCompatibleP = expr$2;
          const _a = _BuiltinTypesCompatibleP._0;
          const _b = _BuiltinTypesCompatibleP._1;
          const _type_loc = _BuiltinTypesCompatibleP._3;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _a, _type_loc);
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _b, _type_loc);
          const lhs = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _a, _type_loc);
          const rhs = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _b, _type_loc);
          return { _0: hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(lhs, rhs) ? 1 : 0, _1: true };
        }
        case 7: {
          const _BuiltinOffsetof = expr$2;
          const _ty = _BuiltinOffsetof._0;
          const _path = _BuiltinOffsetof._1;
          const _type_loc$2 = _BuiltinOffsetof._3;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty, _type_loc$2);
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof(ctx, _ty, _path, _type_loc$2);
          if (_bind$2 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7052;
          } else {
            const _Some = _bind$2;
            const _v = _Some;
            return { _0: _v, _1: true };
          }
        }
        case 8: {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
          return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7053;
        }
        case 9: {
          const _Unary = expr$2;
          const _op = _Unary._0;
          const _expr = _Unary._1;
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, _expr, loc$2);
          const _v = _bind$3._0;
          const _ok = _bind$3._1;
          if (!_ok) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7054;
          }
          switch (_op) {
            case 0: {
              return { _0: _v, _1: true };
            }
            case 1: {
              return { _0: 0 - _v | 0, _1: true };
            }
            case 3: {
              return { _0: _v ^ -1, _1: true };
            }
            case 2: {
              return { _0: _v === 0 ? 1 : 0, _1: true };
            }
            default: {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
              return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7055;
            }
          }
        }
        case 17: {
          const _Binary = expr$2;
          const _op$2 = _Binary._0;
          const _left = _Binary._1;
          const _right = _Binary._2;
          const _bind$4 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, _left, loc$2);
          const _lhs = _bind$4._0;
          const _ok_lhs = _bind$4._1;
          const _bind$5 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, _right, loc$2);
          const _rhs = _bind$5._0;
          const _ok_rhs = _bind$5._1;
          if (!_ok_lhs || !_ok_rhs) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7056;
          }
          switch (_op$2) {
            case 12: {
              return { _0: _lhs + _rhs | 0, _1: true };
            }
            case 13: {
              return { _0: _lhs - _rhs | 0, _1: true };
            }
            case 14: {
              return { _0: Math.imul(_lhs, _rhs) | 0, _1: true };
            }
            case 15: {
              if (_rhs === 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "division by zero in constant expression");
                return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7057;
              } else {
                return { _0: _lhs / _rhs | 0, _1: true };
              }
            }
            case 16: {
              if (_rhs === 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "division by zero in constant expression");
                return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7058;
              } else {
                return { _0: _lhs % _rhs | 0, _1: true };
              }
            }
            case 17: {
              return { _0: _lhs << _rhs, _1: true };
            }
            case 18: {
              return { _0: _lhs >> _rhs, _1: true };
            }
            case 25: {
              return { _0: _lhs & _rhs, _1: true };
            }
            case 27: {
              return { _0: _lhs | _rhs, _1: true };
            }
            case 26: {
              return { _0: _lhs ^ _rhs, _1: true };
            }
            case 19: {
              return { _0: _lhs === _rhs ? 1 : 0, _1: true };
            }
            case 20: {
              return { _0: _lhs !== _rhs ? 1 : 0, _1: true };
            }
            case 21: {
              return { _0: _lhs < _rhs ? 1 : 0, _1: true };
            }
            case 22: {
              return { _0: _lhs <= _rhs ? 1 : 0, _1: true };
            }
            case 23: {
              return { _0: _lhs > _rhs ? 1 : 0, _1: true };
            }
            case 24: {
              return { _0: _lhs >= _rhs ? 1 : 0, _1: true };
            }
            case 28: {
              return { _0: _lhs !== 0 && _rhs !== 0 ? 1 : 0, _1: true };
            }
            case 29: {
              return { _0: _lhs !== 0 || _rhs !== 0 ? 1 : 0, _1: true };
            }
            case 11: {
              return { _0: _rhs, _1: true };
            }
            default: {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
              return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7059;
            }
          }
        }
        case 18: {
          const _Conditional = expr$2;
          const _cond = _Conditional._0;
          const _then_expr = _Conditional._1;
          const _else_expr = _Conditional._2;
          const _bind$6 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, _cond, loc$2);
          const _cond_val = _bind$6._0;
          const _ok$2 = _bind$6._1;
          if (!_ok$2) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7060;
          }
          if (_cond_val !== 0) {
            _tmp$27 = _then_expr;
            continue _L;
          } else {
            _tmp$27 = _else_expr;
            continue _L;
          }
        }
        case 10: {
          const _Cast = expr$2;
          const _ty$2 = _Cast._0;
          const _expr$2 = _Cast._1;
          const _bind$7 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, _expr$2, loc$2);
          const _v$2 = _bind$7._0;
          const _ok$3 = _bind$7._1;
          if (!_ok$3) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7061;
          }
          const _bind$8 = hackwaly$tinycc$sem$sem_core$$cast_const_int64_value(ctx, moonbitlang$core$int$$Int$to_int64(_v$2), _ty$2, loc$2);
          const _casted = _bind$8._0;
          const _ok_cast = _bind$8._1;
          return { _0: moonbitlang$core$int64$$Int64$to_int(_casted), _1: _ok_cast };
        }
        case 13: {
          const _SizeofExpr = expr$2;
          const _expr$3 = _SizeofExpr._0;
          const _loc = _SizeofExpr._2;
          const ty = hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _expr$3);
          _L$3: {
            const _bind$9 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
            if (_bind$9.$tag === 5) {
              const _Array = _bind$9;
              const _x = _Array._1;
              if (_x === undefined) {
                const _x$2 = _Array._2;
                if (_x$2 === undefined) {
                  break _L$3;
                } else {
                  return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7063;
                }
              } else {
                break _L$3;
              }
            } else {
              break _L$3;
            }
          }
          const _bind$9 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty, _loc);
          if (_bind$9 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7062;
          } else {
            const _Some = _bind$9;
            const _x = _Some;
            const _size = _x._0;
            return { _0: _size, _1: true };
          }
        }
        case 14: {
          const _SizeofType = expr$2;
          const _ty$3 = _SizeofType._0;
          const _loc$2 = _SizeofType._2;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$3, _loc$2);
          _L$4: {
            const _bind$10 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty$3, _loc$2));
            if (_bind$10.$tag === 5) {
              const _Array = _bind$10;
              const _x = _Array._1;
              if (_x === undefined) {
                const _x$2 = _Array._2;
                if (_x$2 === undefined) {
                  break _L$4;
                } else {
                  return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7065;
                }
              } else {
                break _L$4;
              }
            } else {
              break _L$4;
            }
          }
          const _bind$10 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _ty$3, _loc$2);
          if (_bind$10 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7064;
          } else {
            const _Some = _bind$10;
            const _x = _Some;
            const _size = _x._0;
            return { _0: _size, _1: true };
          }
        }
        case 15: {
          const _AlignofExpr = expr$2;
          const _expr$4 = _AlignofExpr._0;
          const _loc$3 = _AlignofExpr._2;
          const ty$2 = hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _expr$4);
          const _bind$11 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty$2, _loc$3);
          if (_bind$11 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7066;
          } else {
            const _Some = _bind$11;
            const _x = _Some;
            const _align = _x._1;
            return { _0: _align, _1: true };
          }
        }
        case 16: {
          const _AlignofType = expr$2;
          const _ty$4 = _AlignofType._0;
          const _loc$4 = _AlignofType._2;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$4, _loc$4);
          const _bind$12 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _ty$4, _loc$4);
          if (_bind$12 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7067;
          } else {
            const _Some = _bind$12;
            const _x = _Some;
            const _align = _x._1;
            return { _0: _align, _1: true };
          }
        }
        case 19: {
          const _Call = expr$2;
          const _x = _Call._0;
          if (_x.$tag === 4) {
            const _Ident$2 = _x;
            const _name$2 = _Ident$2._0;
            const _id$2 = _Ident$2._1;
            const _args = _Call._1;
            const _call_loc = _Call._3;
            _L$5: {
              const _bind$13 = hackwaly$tinycc$sem$sem_core$$builtin_call_kind(ctx, _name$2, _id$2);
              if (_bind$13 === undefined) {
                break _L$5;
              } else {
                const _Some = _bind$13;
                const _x$2 = _Some;
                switch (_x$2) {
                  case 0: {
                    if (_args.length === 3) {
                      const _bind$14 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0), _call_loc);
                      const _cond_val$2 = _bind$14._0;
                      const _ok$4 = _bind$14._1;
                      if (!_ok$4) {
                        return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7069;
                      }
                      if (_cond_val$2 !== 0) {
                        _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 1);
                        _tmp$28 = _call_loc;
                        continue _L;
                      } else {
                        _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 2);
                        _tmp$28 = _call_loc;
                        continue _L;
                      }
                    } else {
                      break _L$5;
                    }
                  }
                  case 1: {
                    if (_args.length === 2) {
                      _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 0);
                      _tmp$28 = _call_loc;
                      continue _L;
                    } else {
                      break _L$5;
                    }
                  }
                  case 2: {
                    if (_args.length === 1) {
                      return { _0: hackwaly$tinycc$sem$sem_core$$is_constant_expr_for_builtin(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0)) ? 1 : 0, _1: true };
                    } else {
                      break _L$5;
                    }
                  }
                  default: {
                    break _L$5;
                  }
                }
              }
            }
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7068;
          } else {
            break _L$2;
          }
        }
        default: {
          break _L$2;
        }
      }
    }
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
    return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value$46$tuple$47$7048;
  }
}
function hackwaly$tinycc$sem$sem_core$$cast_const_int64_value(ctx, value, ty, loc) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    const resolved = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, ty$2, loc);
    const base = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(resolved);
    switch (base.$tag) {
      case 1: {
        return { _0: moonbitlang$core$builtin$$Eq$equal$7$(value, $0L) ? $0L : $1L, _1: true };
      }
      case 8: {
        _tmp$27 = hackwaly$tinycc$sem$sem_core$$enum_type_for_arith(ctx, base);
        continue _L;
      }
      case 4: {
        return { _0: value, _1: true };
      }
      case 2: {
        const _Int = base;
        const _kind = _Int._0;
        const _unsigned = _Int._1;
        const bits = Math.imul(hackwaly$tinycc$sem$sem_core$$int_size(_kind), 8) | 0;
        const mask = bits >= 64 ? moonbitlang$core$uint64$$UInt64$lnot($0L) : moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, bits), $1L);
        const u = moonbitlang$core$builtin$$BitAnd$land$6$(value, mask);
        if (_unsigned || bits >= 64) {
          return { _0: u, _1: true };
        } else {
          const sign_bit = moonbitlang$core$builtin$$Shl$shl$6$($1L, bits - 1 | 0);
          const signed_u = moonbitlang$core$builtin$$Eq$not_equal$80$(moonbitlang$core$builtin$$BitAnd$land$6$(u, sign_bit), $0L) ? moonbitlang$core$builtin$$BitOr$lor$6$(u, moonbitlang$core$uint64$$UInt64$lnot(mask)) : u;
          return { _0: signed_u, _1: true };
        }
      }
      default: {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid constant expression");
        return hackwaly$tinycc$sem$sem_core$$cast_const_int64_value$46$tuple$47$7186;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, ty, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, ty, loc);
  return _bind._0;
}
function hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, ty, loc) {
  switch (ty.$tag) {
    case 12: {
      const _Qualified = ty;
      const _qual = _Qualified._0;
      const _base = _Qualified._1;
      const _bind = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, _base, loc);
      const _resolved_base = _bind._0;
      const _changed = _bind._1;
      return _changed ? { _0: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, _resolved_base), _1: true } : { _0: ty, _1: false };
    }
    case 11: {
      const _Attributed = ty;
      const _attrs = _Attributed._0;
      const _base$2 = _Attributed._1;
      const _bind$2 = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, _base$2, loc);
      const _resolved_base$2 = _bind$2._0;
      const _changed$2 = _bind$2._1;
      return _changed$2 ? { _0: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs, _resolved_base$2), _1: true } : { _0: ty, _1: false };
    }
    case 4: {
      const _Pointer = ty;
      const _inner = _Pointer._0;
      const _bind$3 = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, _inner, loc);
      const _resolved_inner = _bind$3._0;
      const _changed$3 = _bind$3._1;
      return _changed$3 ? { _0: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_resolved_inner), _1: true } : { _0: ty, _1: false };
    }
    case 5: {
      const _Array = ty;
      const _elem = _Array._0;
      const _size = _Array._1;
      const _size_expr = _Array._2;
      const _bind$4 = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, _elem, loc);
      const _resolved_elem = _bind$4._0;
      const _changed$4 = _bind$4._1;
      return _changed$4 ? { _0: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(_resolved_elem, _size, _size_expr), _1: true } : { _0: ty, _1: false };
    }
    case 10: {
      const _Function = ty;
      const _return_type = _Function._0;
      const _params = _Function._1;
      const _varargs = _Function._2;
      const _is_old_style = _Function._3;
      const _call_conv = _Function._4;
      const _bind$5 = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, _return_type, loc);
      const _resolved_ret = _bind$5._0;
      const _ret_changed = _bind$5._1;
      let any_changed = _ret_changed;
      let out_params = Option$None$28$;
      const len = _params.length;
      let _tmp$27 = 0;
      while (true) {
        const i = _tmp$27;
        if (i < len) {
          const param = moonbitlang$core$array$$Array$at$29$(_params, i);
          const _bind$6 = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, param, loc);
          const _resolved_param = _bind$6._0;
          const _param_changed = _bind$6._1;
          if (_param_changed) {
            any_changed = true;
            const _bind$7 = out_params;
            if (_bind$7.$tag === 0) {
              const arr = moonbitlang$core$array$$Array$new$46$inner$29$(len);
              let _tmp$28 = 0;
              while (true) {
                const j = _tmp$28;
                if (j < i) {
                  moonbitlang$core$array$$Array$push$29$(arr, moonbitlang$core$array$$Array$at$29$(_params, j));
                  _tmp$28 = j + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              out_params = new Option$Some$28$(arr);
            }
          }
          const _bind$7 = out_params;
          if (_bind$7.$tag === 1) {
            const _Some = _bind$7;
            const _arr = _Some._0;
            if (_param_changed) {
              moonbitlang$core$array$$Array$push$29$(_arr, _resolved_param);
            } else {
              moonbitlang$core$array$$Array$push$29$(_arr, param);
            }
          }
          _tmp$27 = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!any_changed) {
        return { _0: ty, _1: false };
      } else {
        const _bind$6 = out_params;
        let resolved_params;
        if (_bind$6.$tag === 1) {
          const _Some = _bind$6;
          resolved_params = _Some._0;
        } else {
          resolved_params = _params;
        }
        return { _0: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(_resolved_ret, resolved_params, _varargs, _is_old_style, _call_conv), _1: true };
      }
    }
    case 9: {
      const _TypeofExpr = ty;
      const _expr = _TypeofExpr._0;
      const resolved = hackwaly$tinycc$sem$sem_core$$type_for_typeof(ctx, _expr);
      const _bind$6 = hackwaly$tinycc$sem$sem_core$$resolve_type_inner(ctx, resolved, hackwaly$tinycc$frontend$ast$$expr_loc(_expr));
      const _final_ty = _bind$6._0;
      return { _0: _final_ty, _1: true };
    }
    default: {
      return { _0: ty, _1: false };
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$type_for_typeof(ctx, expr) {
  const prev = ctx.record_agg_temps;
  ctx.record_agg_temps = false;
  let ty;
  switch (expr.$tag) {
    case 4: {
      const _Ident = expr;
      const _name = _Ident._0;
      const _id = _Ident._1;
      const _loc = _Ident._3;
      const _bind = hackwaly$tinycc$sem$sem_core$$lookup_value(ctx, _name, _id);
      if (_bind === undefined) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, `use of undeclared identifier '${_name}'`);
        ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind;
        ty = _Some;
      }
      break;
    }
    case 3: {
      const _StringLit = expr;
      const _length = _StringLit._1;
      ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$sem$sem_core$$char_type_value, _length, undefined);
      break;
    }
    default: {
      ty = hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, expr);
    }
  }
  ctx.record_agg_temps = prev;
  return ty;
}
function hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, expr) {
  switch (expr.$tag) {
    case 0: {
      const _IntLit = expr;
      const _value = _IntLit._0;
      return hackwaly$tinycc$sem$sem_core$$int_literal_type(_value);
    }
    case 1: {
      const _FloatLit = expr;
      const _value$2 = _FloatLit._0;
      return hackwaly$tinycc$sem$sem_core$$float_type_from_literal(_value$2);
    }
    case 2: {
      return hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
    case 3: {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$sem$sem_core$$char_type_value);
    }
    case 4: {
      const _Ident = expr;
      const _name = _Ident._0;
      const _id = _Ident._1;
      const _loc = _Ident._3;
      const _bind = hackwaly$tinycc$sem$sem_core$$lookup_value(ctx, _name, _id);
      if (_bind === undefined) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, `use of undeclared identifier '${_name}'`);
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind;
        const _ty = _Some;
        return hackwaly$tinycc$sem$sem_core$$decay_type(_ty);
      }
    }
    case 5: {
      const _LabelAddr = expr;
      const _name$2 = _LabelAddr._0;
      const _loc$2 = _LabelAddr._3;
      const _bind$2 = ctx.current_func_name;
      if (_bind$2 === undefined) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$2, "label address used outside of function");
      }
      moonbitlang$core$array$$Array$push$111$(ctx.labels_used, { _0: _name$2, _1: _loc$2 });
      return hackwaly$tinycc$sem$sem_core$$void_pointer_type_value;
    }
    case 6: {
      const _BuiltinTypesCompatibleP = expr;
      const _a = _BuiltinTypesCompatibleP._0;
      const _b = _BuiltinTypesCompatibleP._1;
      const _loc$3 = _BuiltinTypesCompatibleP._3;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _a, _loc$3);
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _b, _loc$3);
      return hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
    case 7: {
      const _BuiltinOffsetof = expr;
      const _ty = _BuiltinOffsetof._0;
      const _path = _BuiltinOffsetof._1;
      const _loc$4 = _BuiltinOffsetof._3;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty, _loc$4);
      hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof(ctx, _ty, _path, _loc$4);
      return hackwaly$tinycc$sem$sem_core$$size_t_type_value;
    }
    case 8: {
      const _BuiltinVaArg = expr;
      const _list = _BuiltinVaArg._0;
      const _ty$2 = _BuiltinVaArg._1;
      const _loc$5 = _BuiltinVaArg._3;
      hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _list);
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$2, _loc$5);
      return hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty$2, _loc$5);
    }
    case 11: {
      const _CompoundLiteral = expr;
      const _ty$3 = _CompoundLiteral._0;
      const _init = _CompoundLiteral._1;
      const _node_id = _CompoundLiteral._2;
      const _loc$6 = _CompoundLiteral._3;
      const resolved = hackwaly$tinycc$sem$sem_core$$compound_literal_type(ctx, _ty$3, _init, _loc$6, _node_id);
      hackwaly$tinycc$sem$sem_core$$record_compound_literal(ctx, _loc$6, _node_id, resolved);
      return hackwaly$tinycc$sem$sem_core$$decay_type(resolved);
    }
    case 12: {
      const _StmtExpr = expr;
      const _stmts = _StmtExpr._0;
      const _loc$7 = _StmtExpr._2;
      return hackwaly$tinycc$sem$sem_core$$stmt_expr_result_type(ctx, _stmts, _loc$7);
    }
    case 9: {
      const _Unary = expr;
      const _op = _Unary._0;
      const _expr = _Unary._1;
      const _loc$8 = _Unary._3;
      _L: {
        _L$2: {
          switch (_op) {
            case 4: {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, _expr);
              if (_bind$3 === undefined) {
                return hackwaly$tinycc$sem$sem_core$$default_int_type();
              } else {
                const _Some = _bind$3;
                const _ty$4 = _Some;
                return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_ty$4);
              }
            }
            case 5: {
              const inner = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(inner);
              if (_bind$4.$tag === 4) {
                const _Pointer = _bind$4;
                return _Pointer._0;
              } else {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "cannot dereference non-pointer");
                return hackwaly$tinycc$sem$sem_core$$default_int_type();
              }
            }
            case 2: {
              const inner$2 = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
              if (!hackwaly$tinycc$sem$sem_core$$is_scalar(inner$2)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "unary operator expects scalar");
              }
              return hackwaly$tinycc$sem$sem_core$$default_int_type();
            }
            case 0: {
              break _L$2;
            }
            case 1: {
              break _L$2;
            }
            case 3: {
              const inner$3 = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
              if (!hackwaly$tinycc$sem$sem_core$$is_int_like(inner$3)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "unary operator expects int");
              }
              return hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, inner$3, inner$3);
            }
            case 6: {
              break _L;
            }
            case 7: {
              break _L;
            }
            case 8: {
              break _L;
            }
            default: {
              break _L;
            }
          }
        }
        const inner = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
        if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(inner)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "unary operator expects arithmetic");
        }
        return hackwaly$tinycc$sem$sem_core$$is_float_type(inner) ? hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(inner) : hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, inner, inner);
      }
      const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, _expr);
      if (_bind$3 === undefined) {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind$3;
        const _ty$4 = _Some;
        if (hackwaly$tinycc$sem$sem_core$$is_const_qualified(_ty$4)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "increment of read-only location");
          return hackwaly$tinycc$sem$sem_core$$default_int_type();
        }
        _L$2: {
          _L$3: {
            const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_ty$4);
            switch (_bind$4.$tag) {
              case 5: {
                break _L$3;
              }
              case 10: {
                break _L$3;
              }
            }
            break _L$2;
          }
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "invalid operand to increment");
          return hackwaly$tinycc$sem$sem_core$$default_int_type();
        }
        if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(_ty$4)) {
          const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_ty$4);
          if (_bind$4.$tag === 4) {
          } else {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "invalid operand to increment");
          }
        }
        return _ty$4;
      }
    }
    case 10: {
      const _Cast = expr;
      const _ty$4 = _Cast._0;
      const _expr$2 = _Cast._1;
      const _loc$9 = _Cast._3;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$4, _loc$9);
      const resolved$2 = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty$4, _loc$9);
      hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr$2);
      return resolved$2;
    }
    case 13: {
      const _SizeofExpr = expr;
      const _expr$3 = _SizeofExpr._0;
      const ty = hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _expr$3);
      _L$2: {
        _L$3: {
          const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
          if (_bind$4.$tag === 5) {
            const _Array = _bind$4;
            const _x = _Array._1;
            if (_x === undefined) {
              const _x$2 = _Array._2;
              if (_x$2 === undefined) {
                break _L$3;
              }
            } else {
              break _L$3;
            }
          } else {
            break _L$3;
          }
          break _L$2;
        }
        hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty, hackwaly$tinycc$frontend$ast$$expr_loc(_expr$3));
      }
      return hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
    case 14: {
      const _SizeofType = expr;
      const _ty$5 = _SizeofType._0;
      const _loc$10 = _SizeofType._2;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$5, _loc$10);
      const resolved$3 = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty$5, _loc$10);
      _L$3: {
        _L$4: {
          const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(resolved$3);
          if (_bind$4.$tag === 5) {
            const _Array = _bind$4;
            const _x = _Array._1;
            if (_x === undefined) {
              const _x$2 = _Array._2;
              if (_x$2 === undefined) {
                break _L$4;
              }
            } else {
              break _L$4;
            }
          } else {
            break _L$4;
          }
          break _L$3;
        }
        hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, resolved$3, _loc$10);
      }
      return hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
    case 15: {
      const _AlignofExpr = expr;
      const _expr$4 = _AlignofExpr._0;
      const _loc$11 = _AlignofExpr._2;
      const ty$2 = hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _expr$4);
      hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty$2, _loc$11);
      return hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
    case 16: {
      const _AlignofType = expr;
      const _ty$6 = _AlignofType._0;
      const _loc$12 = _AlignofType._2;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$6, _loc$12);
      const resolved$4 = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty$6, _loc$12);
      hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, resolved$4, _loc$12);
      return hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
    case 17: {
      const _Binary = expr;
      const _op$2 = _Binary._0;
      const _left = _Binary._1;
      const _right = _Binary._2;
      const _loc$13 = _Binary._4;
      _L$4: {
        _L$5: {
          _L$6: {
            _L$7: {
              _L$8: {
                _L$9: {
                  switch (_op$2) {
                    case 0: {
                      const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, _left);
                      if (_bind$4 === undefined) {
                        return hackwaly$tinycc$sem$sem_core$$default_int_type();
                      } else {
                        const _Some = _bind$4;
                        const _lhs_ty = _Some;
                        if (hackwaly$tinycc$sem$sem_core$$is_const_qualified(_lhs_ty)) {
                          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "assignment to read-only location");
                          return hackwaly$tinycc$sem$sem_core$$default_int_type();
                        }
                        _L$10: {
                          _L$11: {
                            const _bind$5 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_lhs_ty);
                            switch (_bind$5.$tag) {
                              case 5: {
                                break _L$11;
                              }
                              case 10: {
                                break _L$11;
                              }
                            }
                            break _L$10;
                          }
                          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "assignment to non-modifiable lvalue");
                          return hackwaly$tinycc$sem$sem_core$$default_int_type();
                        }
                        const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
                        if (!hackwaly$tinycc$sem$sem_core$$can_assign(_lhs_ty, rhs_ty) && !(hackwaly$tinycc$sem$sem_core$$is_pointer_type(_lhs_ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _right))) {
                          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, `cannot assign '${hackwaly$tinycc$sem$sem_core$$type_to_string(rhs_ty)}' to '${hackwaly$tinycc$sem$sem_core$$type_to_string(_lhs_ty)}'`);
                        }
                        return _lhs_ty;
                      }
                    }
                    case 1: {
                      break _L$9;
                    }
                    case 2: {
                      break _L$9;
                    }
                    case 3: {
                      break _L$9;
                    }
                    case 4: {
                      break _L$9;
                    }
                    case 5: {
                      break _L$9;
                    }
                    case 6: {
                      break _L$9;
                    }
                    case 7: {
                      break _L$9;
                    }
                    case 8: {
                      break _L$9;
                    }
                    case 9: {
                      break _L$9;
                    }
                    case 10: {
                      break _L$9;
                    }
                    case 11: {
                      hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
                      return hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
                    }
                    case 12: {
                      const lhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
                      const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
                      const _bind$5 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(lhs_ty);
                      if (_bind$5.$tag === 4) {
                        const _Pointer = _bind$5;
                        const _pointee = _Pointer._0;
                        if (hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
                          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_pointee);
                        } else {
                          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "invalid operands to '+'");
                          return hackwaly$tinycc$sem$sem_core$$default_int_type();
                        }
                      }
                      const _bind$6 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(rhs_ty);
                      if (_bind$6.$tag === 4) {
                        const _Pointer = _bind$6;
                        const _pointee = _Pointer._0;
                        if (hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty)) {
                          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_pointee);
                        } else {
                          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "invalid operands to '+'");
                          return hackwaly$tinycc$sem$sem_core$$default_int_type();
                        }
                      }
                      if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty)) {
                        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "binary operator expects arithmetic operands");
                      }
                      return hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs_ty, rhs_ty);
                    }
                    case 13: {
                      const lhs_ty$2 = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
                      const rhs_ty$2 = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
                      const _bind$7 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(lhs_ty$2);
                      if (_bind$7.$tag === 4) {
                        const _Pointer = _bind$7;
                        const _pointee = _Pointer._0;
                        const _bind$8 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(rhs_ty$2);
                        if (_bind$8.$tag === 4) {
                          const _Pointer$2 = _bind$8;
                          const _other = _Pointer$2._0;
                          if (!hackwaly$tinycc$sem$sem_core$$pointer_compatible(_pointee, _other)) {
                            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "pointer subtraction type mismatch");
                          }
                          return hackwaly$tinycc$sem$sem_core$$default_int_type();
                        } else {
                          if (hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty$2)) {
                            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_pointee);
                          } else {
                            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "invalid operands to '-'");
                            return hackwaly$tinycc$sem$sem_core$$default_int_type();
                          }
                        }
                      }
                      if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty$2) || !hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty$2)) {
                        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "binary operator expects arithmetic operands");
                      }
                      return hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs_ty$2, rhs_ty$2);
                    }
                    case 19: {
                      break _L$8;
                    }
                    case 20: {
                      break _L$8;
                    }
                    case 21: {
                      break _L$8;
                    }
                    case 22: {
                      break _L$8;
                    }
                    case 23: {
                      break _L$8;
                    }
                    case 24: {
                      break _L$8;
                    }
                    case 28: {
                      break _L$7;
                    }
                    case 29: {
                      break _L$7;
                    }
                    case 14: {
                      break _L$6;
                    }
                    case 15: {
                      break _L$6;
                    }
                    case 17: {
                      break _L$5;
                    }
                    case 18: {
                      break _L$5;
                    }
                    case 16: {
                      break _L$4;
                    }
                    case 25: {
                      break _L$4;
                    }
                    case 26: {
                      break _L$4;
                    }
                    default: {
                      break _L$4;
                    }
                  }
                }
                return hackwaly$tinycc$sem$sem_core$$type_of_compound_assign(ctx, _op$2, _left, _right, _loc$13);
              }
              const lhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
              const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(lhs_ty);
              if (_bind$4.$tag === 4) {
                const _Pointer = _bind$4;
                const _pointee = _Pointer._0;
                const _bind$5 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(rhs_ty);
                if (_bind$5.$tag === 4) {
                  const _Pointer$2 = _bind$5;
                  const _other = _Pointer$2._0;
                  if (!hackwaly$tinycc$sem$sem_core$$pointer_compatible(_pointee, _other)) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "pointer comparison type mismatch");
                  }
                  return hackwaly$tinycc$sem$sem_core$$default_int_type();
                } else {
                  if (hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _right)) {
                    return hackwaly$tinycc$sem$sem_core$$default_int_type();
                  }
                }
              }
              const _bind$5 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(rhs_ty);
              if (_bind$5.$tag === 4) {
                if (hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _left)) {
                  return hackwaly$tinycc$sem$sem_core$$default_int_type();
                }
              }
              if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "binary operator expects arithmetic operands");
              }
              return hackwaly$tinycc$sem$sem_core$$default_int_type();
            }
            const lhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
            const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
            if (!hackwaly$tinycc$sem$sem_core$$is_scalar(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_scalar(rhs_ty)) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "binary operator expects scalar operands");
            }
            return hackwaly$tinycc$sem$sem_core$$default_int_type();
          }
          const lhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
          const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
          if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty)) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "binary operator expects arithmetic operands");
          }
          return hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs_ty, rhs_ty);
        }
        const lhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
        const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
        if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "binary operator expects int operands");
        }
        return hackwaly$tinycc$sem$sem_core$$promote_int_type(ctx, lhs_ty);
      }
      const lhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _left);
      const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _right);
      if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$13, "binary operator expects int operands");
      }
      return hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs_ty, rhs_ty);
    }
    case 18: {
      const _Conditional = expr;
      const _cond = _Conditional._0;
      const _then_expr = _Conditional._1;
      const _else_expr = _Conditional._2;
      const _loc$14 = _Conditional._4;
      hackwaly$tinycc$sem$sem_core$$check_cond_expr(ctx, _cond);
      const then_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _then_expr);
      const else_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _else_expr);
      const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(then_ty);
      const _bind$5 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(else_ty);
      if (_bind$4.$tag === 4) {
        const _Pointer = _bind$4;
        const _a$2 = _Pointer._0;
        if (_bind$5.$tag === 4) {
          const _Pointer$2 = _bind$5;
          const _b$2 = _Pointer$2._0;
          if (!hackwaly$tinycc$sem$sem_core$$pointer_compatible(_a$2, _b$2)) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$14, "conditional operator type mismatch");
          }
          if (hackwaly$tinycc$sem$sem_core$$is_void_pointer_type(then_ty)) {
            return then_ty;
          }
          if (hackwaly$tinycc$sem$sem_core$$is_void_pointer_type(else_ty)) {
            return else_ty;
          }
          return then_ty;
        } else {
          if (hackwaly$tinycc$sem$sem_core$$is_int_like(else_ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _else_expr)) {
            return then_ty;
          }
        }
      } else {
        if (_bind$5.$tag === 4) {
          if (hackwaly$tinycc$sem$sem_core$$is_int_like(then_ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _then_expr)) {
            return else_ty;
          }
        }
      }
      if (hackwaly$tinycc$sem$sem_core$$is_arithmetic(then_ty) && hackwaly$tinycc$sem$sem_core$$is_arithmetic(else_ty)) {
        return hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, then_ty, else_ty);
      }
      if (!hackwaly$tinycc$sem$sem_core$$type_eq(then_ty, else_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$14, "conditional operator type mismatch");
      }
      return then_ty;
    }
    case 20: {
      const _Index = expr;
      const _base = _Index._0;
      const _index = _Index._1;
      const _loc$15 = _Index._3;
      const _bind$6 = hackwaly$tinycc$sem$sem_core$$index_access_type(ctx, hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _base), hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _index), _loc$15);
      if (_bind$6 === undefined) {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind$6;
        const _ty$7 = _Some;
        return hackwaly$tinycc$sem$sem_core$$decay_type(_ty$7);
      }
    }
    case 21: {
      const _Member = expr;
      const _base$2 = _Member._0;
      const _name$3 = _Member._1;
      const _id$2 = _Member._2;
      const _is_arrow = _Member._3;
      const _loc$16 = _Member._5;
      const base_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _base$2);
      if (!_is_arrow && !hackwaly$tinycc$frontend$ast$$expr_is_lvalue_simple(_base$2)) {
        hackwaly$tinycc$sem$sem_core$$record_agg_temp_for_type(ctx, base_ty, _loc$16);
      }
      const _bind$7 = hackwaly$tinycc$sem$sem_core$$member_access_type(ctx, base_ty, _name$3, _id$2, _is_arrow, _loc$16);
      if (_bind$7 === undefined) {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind$7;
        const _ty$7 = _Some;
        return hackwaly$tinycc$sem$sem_core$$decay_type(_ty$7);
      }
    }
    default: {
      const _Call = expr;
      const _callee = _Call._0;
      const _args = _Call._1;
      const _loc$17 = _Call._3;
      if (_callee.$tag === 4) {
        const _Ident$2 = _callee;
        const _name$4 = _Ident$2._0;
        const _id$3 = _Ident$2._1;
        _L$5: {
          _L$6: {
            const _bind$8 = hackwaly$tinycc$sem$sem_core$$builtin_call_kind(ctx, _name$4, _id$3);
            if (_bind$8 === undefined) {
            } else {
              const _Some = _bind$8;
              const _x = _Some;
              switch (_x) {
                case 0: {
                  if (_args.length !== 3) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "__builtin_choose_expr expects 3 arguments");
                    return hackwaly$tinycc$sem$sem_core$$default_int_type();
                  }
                  const cond = hackwaly$tinycc$sem$sem_core$$eval_const_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0), _loc$17);
                  if (cond !== 0) {
                    return hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, 1));
                  }
                  return hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, 2));
                }
                case 1: {
                  if (_args.length !== 2) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "__builtin_expect expects 2 arguments");
                    return hackwaly$tinycc$sem$sem_core$$default_int_type();
                  }
                  hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, 1));
                  return hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0));
                }
                case 2: {
                  if (_args.length !== 1) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "__builtin_constant_p expects 1 argument");
                    return hackwaly$tinycc$sem$sem_core$$default_int_type();
                  }
                  hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0));
                  return hackwaly$tinycc$sem$sem_core$$default_int_type();
                }
                case 3: {
                  if (_args.length !== 0) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "__builtin_unreachable expects no args");
                  }
                  return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
                }
                case 4: {
                  if (_args.length !== 0) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "__sync_synchronize expects no args");
                  }
                  return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
                }
                case 5: {
                  if (_args.length !== 2) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "__builtin_va_start expects 2 arguments");
                  }
                  if (_args.length >= 1) {
                    const _bind$9 = moonbitlang$core$array$$Array$at$55$(_args, 0);
                    if (_bind$9.$tag === 4) {
                      const _Ident$3 = _bind$9;
                      const _ap_id = _Ident$3._1;
                      const _ap_loc = _Ident$3._3;
                      const _bind$10 = hackwaly$tinycc$sem$sem_core$$lookup_local_only(ctx, _ap_id);
                      if (_bind$10 === undefined) {
                        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _ap_loc, "__builtin_va_start expects a local variable");
                      }
                    } else {
                      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(moonbitlang$core$array$$Array$at$55$(_args, 0)), "__builtin_va_start expects a local variable");
                    }
                  }
                  const _len = _args.length;
                  let _tmp$27 = 0;
                  while (true) {
                    const _i = _tmp$27;
                    if (_i < _len) {
                      const arg = _args[_i];
                      hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, arg);
                      _tmp$27 = _i + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                  return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
                }
                case 8: {
                  break _L$6;
                }
                case 9: {
                  break _L$6;
                }
              }
            }
            break _L$5;
          }
          if (_args.length !== 1) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, `${_name$4} expects 1 argument`);
          } else {
            const level = hackwaly$tinycc$sem$sem_core$$eval_const_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0), _loc$17);
            if (level < 0) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, `${_name$4} only takes non-negative integers`);
            }
          }
          return hackwaly$tinycc$sem$sem_core$$void_pointer_type_value;
        }
        const _bind$8 = hackwaly$tinycc$sem$sem_core$$atomic_builtin_return_type(ctx, _name$4, _id$3, _args, _loc$17);
        if (_bind$8 === undefined) {
        } else {
          const _Some = _bind$8;
          const _ret = _Some;
          return _ret;
        }
      }
      let callee_ty;
      if (_callee.$tag === 4) {
        const _Ident$2 = _callee;
        const _name$4 = _Ident$2._0;
        const _id$3 = _Ident$2._1;
        const _ident_loc = _Ident$2._3;
        const _bind$8 = hackwaly$tinycc$sem$sem_core$$lookup_value(ctx, _name$4, _id$3);
        if (_bind$8 === undefined) {
          const _bind$9 = hackwaly$tinycc$sem$sem_core$$builtin_func_sig_from_ident(ctx, _name$4, _id$3);
          if (_bind$9 === undefined) {
            const _bind$10 = hackwaly$tinycc$sem$sem_core$$default_int_type();
            const _bind$11 = [];
            const _bind$12 = $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default;
            const sig = { return_type: _bind$10, params: _bind$11, varargs: false, is_old_style: true, call_conv: _bind$12 };
            hackwaly$tinycc$sem$sem_core$$add_function_sig(ctx, _name$4, _id$3, sig, _ident_loc, false);
            callee_ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(_bind$10, _bind$11, false, true, _bind$12);
          } else {
            const _Some = _bind$9;
            const _sig = _Some;
            hackwaly$tinycc$sem$sem_core$$add_function_sig(ctx, _name$4, _id$3, _sig, _ident_loc, false);
            callee_ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(_sig.return_type, _sig.params, _sig.varargs, _sig.is_old_style, _sig.call_conv);
          }
        } else {
          const _Some = _bind$8;
          callee_ty = _Some;
        }
      } else {
        callee_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _callee);
      }
      const callee_unqual = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(callee_ty);
      let fn_ty;
      switch (callee_unqual.$tag) {
        case 10: {
          fn_ty = callee_unqual;
          break;
        }
        case 4: {
          const _Pointer = callee_unqual;
          const _inner = _Pointer._0;
          const _bind$8 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_inner);
          if (_bind$8.$tag === 10) {
            fn_ty = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_inner);
          } else {
            fn_ty = undefined;
          }
          break;
        }
        default: {
          fn_ty = undefined;
        }
      }
      _L$5: {
        if (fn_ty === undefined) {
          break _L$5;
        } else {
          const _Some = fn_ty;
          const _x = _Some;
          if (_x.$tag === 10) {
            const _Function = _x;
            const _return_type = _Function._0;
            const _params = _Function._1;
            const _varargs = _Function._2;
            const _is_old_style = _Function._3;
            if (!_is_old_style) {
              if (_varargs) {
                if (_args.length < _params.length) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "argument count mismatch in call");
                }
              } else {
                if (_params.length !== _args.length) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "argument count mismatch in call");
                }
              }
            }
            let _tmp$27 = 0;
            while (true) {
              const i = _tmp$27;
              if (i < _args.length) {
                const arg_ty = hackwaly$tinycc$sem$sem_core$$decay_type(hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, i)));
                if (!_is_old_style && i < _params.length) {
                  if (!hackwaly$tinycc$sem$sem_core$$can_assign(moonbitlang$core$array$$Array$at$29$(_params, i), arg_ty) && !(hackwaly$tinycc$sem$sem_core$$is_pointer_type(moonbitlang$core$array$$Array$at$29$(_params, i)) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, moonbitlang$core$array$$Array$at$55$(_args, i)))) {
                    let call_name;
                    if (_callee.$tag === 4) {
                      const _Ident$2 = _callee;
                      call_name = _Ident$2._0;
                    } else {
                      call_name = "<call>";
                    }
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, `argument type mismatch in call to ${call_name}: expected '${hackwaly$tinycc$sem$sem_core$$type_to_string(moonbitlang$core$array$$Array$at$29$(_params, i))}', got '${hackwaly$tinycc$sem$sem_core$$type_to_string(arg_ty)}'`);
                    break;
                  }
                }
                _tmp$27 = i + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            return _return_type;
          } else {
            break _L$5;
          }
        }
      }
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$17, "call target is not a function");
      return hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$atomic_builtin_return_type(ctx, name, id, args, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_from_ident(ctx, name, id);
  let template;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    template = _Some;
  }
  let dot_index = 0;
  while (true) {
    let _tmp$27;
    if (dot_index < template.length) {
      const _tmp$28 = dot_index;
      $bound_check(template, _tmp$28);
      const _p$28 = template.charCodeAt(_tmp$28);
      const _p$29 = 46;
      _tmp$27 = _p$28 !== _p$29;
    } else {
      _tmp$27 = false;
    }
    if (_tmp$27) {
      dot_index = dot_index + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (dot_index >= (template.length - 1 | 0)) {
    return undefined;
  }
  const arg_spec_len = dot_index;
  if (args.length !== arg_spec_len) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects ${moonbitlang$core$builtin$$Show$to_string$90$(arg_spec_len)} arguments`);
  }
  let atom_type = undefined;
  let atom_size = 0;
  const allow_pointer_target = name === "__atomic_store" || (name === "__atomic_load" || (name === "__atomic_exchange" || name === "__atomic_compare_exchange"));
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < arg_spec_len && i < args.length) {
      $bound_check(template, i);
      const spec = template.charCodeAt(i);
      _L: {
        _L$2: {
          _L$3: {
            _L$4: {
              switch (spec) {
                case 97: {
                  break _L$4;
                }
                case 65: {
                  break _L$4;
                }
                case 112: {
                  break _L$2;
                }
                case 108: {
                  break _L$2;
                }
                case 115: {
                  break _L$2;
                }
                case 118: {
                  const v_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(args, i));
                  const _bind$2 = atom_type;
                  if (_bind$2 === undefined) {
                  } else {
                    const _Some = _bind$2;
                    const _at = _Some;
                    if (!hackwaly$tinycc$sem$sem_core$$can_assign(_at, v_ty) && !(hackwaly$tinycc$sem$sem_core$$is_pointer_type(_at) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, moonbitlang$core$array$$Array$at$55$(args, i)))) {
                      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} type mismatch in argument ${moonbitlang$core$builtin$$Show$to_string$90$(i + 1 | 0)}`);
                    }
                  }
                  break;
                }
                case 109: {
                  const m_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(args, i));
                  if (!hackwaly$tinycc$sem$sem_core$$is_int_like(m_ty)) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects int memory model`);
                  }
                  break;
                }
                case 98: {
                  const b_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(args, i));
                  if (!hackwaly$tinycc$sem$sem_core$$is_scalar(b_ty)) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects scalar boolean argument`);
                  }
                  break;
                }
              }
              break _L$3;
            }
            const ptr_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(args, i));
            const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ptr_ty);
            if (_bind$2.$tag === 4) {
              const _Pointer = _bind$2;
              const _pointee = _Pointer._0;
              atom_type = _pointee;
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _pointee, loc);
              if (_bind$3 === undefined) {
                atom_size = 0;
              } else {
                const _Some = _bind$3;
                const _x = _Some;
                const _size = _x._0;
                atom_size = _size;
                if (_size > 8 || !(_size > 0 && (_size & (_size - 1 | 0)) === 0)) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects 1/2/4/8-byte atomic type`);
                }
              }
              if (!allow_pointer_target) {
                const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_pointee);
                if (_bind$4.$tag === 4) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects integral atomic target type`);
                } else {
                  if (!hackwaly$tinycc$sem$sem_core$$is_int_like(_pointee)) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects integral atomic target type`);
                  }
                }
              }
            } else {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects pointer argument`);
            }
          }
          break _L;
        }
        const ptr_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, moonbitlang$core$array$$Array$at$55$(args, i));
        const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ptr_ty);
        if (_bind$2.$tag === 4) {
          const _Pointer = _bind$2;
          const _pointee = _Pointer._0;
          if (atom_size > 0) {
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _pointee, loc);
            if (_bind$3 === undefined) {
            } else {
              const _Some = _bind$3;
              const _x = _Some;
              const _size = _x._0;
              if (_size !== atom_size) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} pointer target type mismatch in argument ${moonbitlang$core$builtin$$Show$to_string$90$(i + 1 | 0)}`);
              }
            }
          }
          const _p$28 = 108;
          if (spec === _p$28) {
            const _bind$3 = atom_type;
            if (_bind$3 === undefined) {
            } else {
              const _Some = _bind$3;
              const _at = _Some;
              if (!hackwaly$tinycc$sem$sem_core$$can_assign(_at, _pointee)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} type mismatch in argument ${moonbitlang$core$builtin$$Show$to_string$90$(i + 1 | 0)}`);
              }
            }
          }
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `${name} expects pointer argument`);
        }
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _tmp$28 = dot_index + 1 | 0;
  $bound_check(template, _tmp$28);
  const ret = template.charCodeAt(_tmp$28);
  switch (ret) {
    case 63: {
      return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
    }
    case 98: {
      return $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Bool;
    }
    case 118: {
      const _bind$2 = atom_type;
      if (_bind$2 === undefined) {
        return hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind$2;
        const _at = _Some;
        return _at;
      }
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, expr) {
  const id = hackwaly$tinycc$frontend$ast$$expr_node_id(expr);
  let ty;
  if (id > 0) {
    const idx = id - 1 | 0;
    const cache_len = ctx.expr_type_cache.length;
    if (idx < cache_len) {
      const _bind = moonbitlang$core$array$$Array$at$50$(ctx.expr_type_cache, idx);
      if (_bind === undefined) {
        const computed = hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, expr);
        moonbitlang$core$array$$Array$set$50$(ctx.expr_type_cache, idx, computed);
        ty = computed;
      } else {
        const _Some = _bind;
        ty = _Some;
      }
    } else {
      const computed = hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, expr);
      hackwaly$tinycc$sem$sem_core$$ensure_expr_type_cache(ctx, id);
      moonbitlang$core$array$$Array$set$50$(ctx.expr_type_cache, idx, computed);
      ty = computed;
    }
  } else {
    ty = hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, expr);
  }
  if (ctx.record_agg_temps) {
    const _bind = ctx.current_func_name;
    if (_bind === undefined) {
    } else {
      hackwaly$tinycc$sem$sem_core$$maybe_record_agg_temp_for_expr(ctx, expr, ty);
    }
  }
  return ty;
}
function hackwaly$tinycc$sem$sem_core$$maybe_record_agg_temp_for_expr(ctx, expr, ty) {
  const _bind = ctx.current_func_name;
  if (_bind === undefined) {
    return undefined;
  }
  if (!ctx.record_agg_temps) {
    return undefined;
  }
  _L: {
    const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
    switch (_bind$2.$tag) {
      case 6: {
        break _L;
      }
      case 7: {
        break _L;
      }
      default: {
        return;
      }
    }
  }
  if (!hackwaly$tinycc$frontend$ast$$expr_is_lvalue_simple(expr)) {
    hackwaly$tinycc$sem$sem_core$$record_agg_temp_for_type(ctx, ty, hackwaly$tinycc$frontend$ast$$expr_loc(expr));
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$record_agg_temp_for_type(ctx, ty, loc) {
  const _bind = ctx.current_func_name;
  if (_bind === undefined) {
    return undefined;
  }
  if (!ctx.record_agg_temps) {
    return undefined;
  }
  _L: {
    const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
    switch (_bind$2.$tag) {
      case 6: {
        break _L;
      }
      case 7: {
        break _L;
      }
      default: {
        return;
      }
    }
  }
  const _bind$2 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty, loc);
  if (_bind$2 === undefined) {
    return;
  } else {
    const _Some = _bind$2;
    const _x = _Some;
    const _size = _x._0;
    const _align = _x._1;
    if (_size > 0) {
      if (_size > ctx.current_agg_temp_size) {
        ctx.current_agg_temp_size = _size;
      }
      if (_align > ctx.current_agg_temp_align) {
        ctx.current_agg_temp_align = _align;
        return;
      } else {
        return;
      }
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty, loc) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(ty$2);
    switch (_bind.$tag) {
      case 9: {
        const _TypeofExpr = _bind;
        const _expr = _TypeofExpr._0;
        _tmp$27 = hackwaly$tinycc$sem$sem_core$$type_for_typeof(ctx, _expr);
        continue _L;
      }
      case 11: {
        const _Attributed = _bind;
        const _attrs = _Attributed._0;
        const _base = _Attributed._1;
        const _bind$2 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _base, loc);
        if (_bind$2 === undefined) {
          return undefined;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _size = _x._0;
          const _align = _x._1;
          let final_align = _attrs.packed ? 1 : _align;
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, _attrs, loc);
          if (_bind$3 === undefined) {
          } else {
            const _Some$2 = _bind$3;
            const _value = _Some$2;
            if (_value > final_align) {
              final_align = _value;
            }
          }
          return { _0: _size, _1: final_align };
        }
      }
      case 0: {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid application of sizeof to void");
        return undefined;
      }
      case 1: {
        return hackwaly$tinycc$sem$sem_core$$type_size_align$46$constr$47$7583;
      }
      case 2: {
        const _Int = _bind;
        const _kind = _Int._0;
        const size = hackwaly$tinycc$sem$sem_core$$int_size(_kind);
        return { _0: size, _1: size };
      }
      case 3: {
        const _Float = _bind;
        const _kind$2 = _Float._0;
        const size$2 = hackwaly$tinycc$sem$sem_core$$float_size(_kind$2);
        return { _0: size$2, _1: size$2 };
      }
      case 4: {
        return hackwaly$tinycc$sem$sem_core$$type_size_align$46$constr$47$7585;
      }
      case 8: {
        const _Enum = _bind;
        const _name = _Enum._0;
        const _id = _Enum._1;
        const _items = _Enum._2;
        let enum_ty;
        if (_id !== 0) {
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$29$(ctx.enum_types_by_id, _id);
          if (_bind$3 === undefined) {
            if (_items.$tag === 0) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete enum '${_name}'`);
              enum_ty = undefined;
            } else {
              const _Some = _items;
              const _list = _Some._0;
              if (_list.length === 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete enum '${_name}'`);
                enum_ty = undefined;
              } else {
                const base = hackwaly$tinycc$sem$sem_core$$enum_type_from_items(ctx, _list);
                const _p$28 = "";
                if (!(_name === _p$28)) {
                  hackwaly$tinycc$sem$sem_core$$set_opt_by_id$29$(ctx.enum_types_by_id, _id, base);
                  moonbitlang$core$hashmap$$HashMap$set$159$(ctx.enum_types, _name, base);
                }
                enum_ty = base;
              }
            }
          } else {
            const _Some = _bind$3;
            const _base$2 = _Some;
            enum_ty = _base$2;
          }
        } else {
          const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$159$(ctx.enum_types, _name);
          if (_bind$3 === undefined) {
            if (_items.$tag === 0) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete enum '${_name}'`);
              enum_ty = undefined;
            } else {
              const _Some = _items;
              const _list = _Some._0;
              if (_list.length === 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete enum '${_name}'`);
                enum_ty = undefined;
              } else {
                const base = hackwaly$tinycc$sem$sem_core$$enum_type_from_items(ctx, _list);
                const _p$28 = "";
                if (!(_name === _p$28)) {
                  moonbitlang$core$hashmap$$HashMap$set$159$(ctx.enum_types, _name, base);
                }
                enum_ty = base;
              }
            }
          } else {
            const _Some = _bind$3;
            const _base$2 = _Some;
            enum_ty = _base$2;
          }
        }
        if (enum_ty === undefined) {
          return undefined;
        } else {
          const _Some = enum_ty;
          const _base$2 = _Some;
          _tmp$27 = _base$2;
          continue _L;
        }
      }
      case 10: {
        return hackwaly$tinycc$sem$sem_core$$type_size_align$46$constr$47$7587;
      }
      case 5: {
        const _Array = _bind;
        const _elem = _Array._0;
        const _size = _Array._1;
        const _size_expr = _Array._2;
        const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _elem, loc);
        let _bind$4;
        if (_bind$3 === undefined) {
          return undefined;
        } else {
          const _Some = _bind$3;
          _bind$4 = _Some;
        }
        const _elem_size = _bind$4._0;
        const _elem_align = _bind$4._1;
        if (_size === undefined) {
          if (_size_expr === undefined) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "sizeof incomplete array");
            return undefined;
          } else {
            const _Some = _size_expr;
            const _expr$2 = _Some;
            const _bind$5 = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr$2, hackwaly$tinycc$frontend$ast$$expr_loc(_expr$2));
            if (_bind$5 === undefined) {
              return undefined;
            } else {
              const _Some$2 = _bind$5;
              const _n = _Some$2;
              if (_n < 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(_expr$2), "invalid array size");
                return undefined;
              } else {
                return { _0: Math.imul(_elem_size, _n) | 0, _1: _elem_align };
              }
            }
          }
        } else {
          const _Some = _size;
          const _n = _Some;
          return { _0: Math.imul(_elem_size, _n) | 0, _1: _elem_align };
        }
      }
      case 6: {
        const _Struct = _bind;
        const _tag = _Struct._0;
        const _tag_id = _Struct._1;
        const _field_list = _Struct._2;
        const _struct_attrs = _Struct._3;
        const _bind$5 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
        if (_bind$5 === undefined) {
          return undefined;
        } else {
          const _Some = _bind$5;
          const _def = _Some;
          const merged = hackwaly$tinycc$frontend$ast$$merge_attrs(_def.attrs, _struct_attrs);
          let _tmp$28;
          const _p$28 = "";
          if (!(_tag === _p$28)) {
            _tmp$28 = hackwaly$tinycc$frontend$ast$$attrs_is_empty(_struct_attrs);
          } else {
            _tmp$28 = false;
          }
          if (_tmp$28) {
            if (_tag_id !== 0) {
              const _bind$6 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$68$(ctx.struct_size_cache_by_id, _tag_id);
              if (_bind$6 === undefined) {
                const value = hackwaly$tinycc$sem$sem_core$$struct_size_align(ctx, _def.fields, merged, loc);
                hackwaly$tinycc$sem$sem_core$$set_opt_by_id$68$(ctx.struct_size_cache_by_id, _tag_id, value);
                return value;
              } else {
                const _Some$2 = _bind$6;
                const _value = _Some$2;
                return _value;
              }
            } else {
              const _bind$6 = moonbitlang$core$hashmap$$HashMap$get$165$(ctx.struct_size_cache, _tag);
              if (_bind$6 === undefined) {
                const value = hackwaly$tinycc$sem$sem_core$$struct_size_align(ctx, _def.fields, merged, loc);
                moonbitlang$core$hashmap$$HashMap$set$165$(ctx.struct_size_cache, _tag, value);
                return value;
              } else {
                const _Some$2 = _bind$6;
                const _value = _Some$2;
                return _value;
              }
            }
          } else {
            return hackwaly$tinycc$sem$sem_core$$struct_size_align(ctx, _def.fields, merged, loc);
          }
        }
      }
      case 7: {
        const _Union = _bind;
        const _tag$2 = _Union._0;
        const _tag_id$2 = _Union._1;
        const _field_list$2 = _Union._2;
        const _struct_attrs$2 = _Union._3;
        const _bind$6 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
        if (_bind$6 === undefined) {
          return undefined;
        } else {
          const _Some = _bind$6;
          const _def = _Some;
          const merged = hackwaly$tinycc$frontend$ast$$merge_attrs(_def.attrs, _struct_attrs$2);
          let _tmp$28;
          const _p$28 = "";
          if (!(_tag$2 === _p$28)) {
            _tmp$28 = hackwaly$tinycc$frontend$ast$$attrs_is_empty(_struct_attrs$2);
          } else {
            _tmp$28 = false;
          }
          if (_tmp$28) {
            if (_tag_id$2 !== 0) {
              const _bind$7 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$68$(ctx.union_size_cache_by_id, _tag_id$2);
              if (_bind$7 === undefined) {
                const value = hackwaly$tinycc$sem$sem_core$$union_size_align(ctx, _def.fields, merged, loc);
                hackwaly$tinycc$sem$sem_core$$set_opt_by_id$68$(ctx.union_size_cache_by_id, _tag_id$2, value);
                return value;
              } else {
                const _Some$2 = _bind$7;
                const _value = _Some$2;
                return _value;
              }
            } else {
              const _bind$7 = moonbitlang$core$hashmap$$HashMap$get$165$(ctx.union_size_cache, _tag$2);
              if (_bind$7 === undefined) {
                const value = hackwaly$tinycc$sem$sem_core$$union_size_align(ctx, _def.fields, merged, loc);
                moonbitlang$core$hashmap$$HashMap$set$165$(ctx.union_size_cache, _tag$2, value);
                return value;
              } else {
                const _Some$2 = _bind$7;
                const _value = _Some$2;
                return _value;
              }
            }
          } else {
            return hackwaly$tinycc$sem$sem_core$$union_size_align(ctx, _def.fields, merged, loc);
          }
        }
      }
      default: {
        const _Qualified = _bind;
        const _base$2 = _Qualified._1;
        _tmp$27 = _base$2;
        continue _L;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, attrs, loc) {
  const _bind = attrs.aligned;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _spec = _Some;
    return hackwaly$tinycc$sem$sem_core$$resolve_align_spec(ctx, _spec, loc);
  }
}
function hackwaly$tinycc$sem$sem_core$$resolve_align_spec(ctx, spec, loc) {
  if (spec.$tag === 0) {
    return hackwaly$tinycc$sem$sem_core$$resolve_align_spec$46$constr$47$7691;
  } else {
    const _Expr = spec;
    const _expr = _Expr._0;
    const _bind = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, loc);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _value = _Some;
      if (!(_value > 0 && (_value & (_value - 1 | 0)) === 0)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "alignment must be a positive power of two");
        return undefined;
      } else {
        return _value;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, expr, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, expr, loc);
  const _value = _bind._0;
  const _ok = _bind._1;
  return _ok ? _value : undefined;
}
function hackwaly$tinycc$sem$sem_core$$struct_size_align(ctx, fields, attrs, loc) {
  let size = 0;
  let align = 1;
  let bit_pos = 0;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < fields.length) {
      _L: {
        const field = moonbitlang$core$array$$Array$at$39$(fields, i);
        const packed = attrs.packed || field.attrs.packed;
        const field_align_override = hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, field.attrs, field.loc);
        const _bind = field.bit_width;
        if (_bind === undefined) {
          if (bit_pos !== 0) {
            size = size + ((bit_pos + 7 | 0) / 8 | 0) | 0;
            bit_pos = 0;
          }
          let _bind$2;
          _L$2: {
            _L$3: {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(field.ty);
              if (_bind$3.$tag === 5) {
                const _Array = _bind$3;
                const _elem = _Array._0;
                const _x = _Array._1;
                if (_x === undefined) {
                  const _size_expr = _Array._2;
                  if (_size_expr === undefined) {
                    if (i !== (fields.length - 1 | 0)) {
                      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, `flexible array member '${field.name}' not at the end of struct`);
                    }
                    const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _elem, field.loc);
                    let _bind$5;
                    if (_bind$4 === undefined) {
                      _bind$5 = hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7708;
                    } else {
                      const _Some = _bind$4;
                      _bind$5 = _Some;
                    }
                    const _elem_align = _bind$5._1;
                    _bind$2 = { _0: 0, _1: _elem_align };
                  } else {
                    const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, field.loc);
                    if (_bind$4 === undefined) {
                      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, "variable length array not allowed in struct");
                      _bind$2 = hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7709;
                    } else {
                      const _Some = _bind$4;
                      _bind$2 = _Some;
                    }
                  }
                } else {
                  break _L$3;
                }
              } else {
                break _L$3;
              }
              break _L$2;
            }
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, loc);
            if (_bind$3 === undefined) {
              _bind$2 = hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7707;
            } else {
              const _Some = _bind$3;
              _bind$2 = _Some;
            }
          }
          const _field_size = _bind$2._0;
          const _field_align = _bind$2._1;
          let adjusted_align = packed ? 1 : _field_align;
          if (field_align_override === undefined) {
          } else {
            const _Some = field_align_override;
            const _value = _Some;
            adjusted_align = _value;
          }
          size = hackwaly$tinycc$sem$sem_core$$align_to(size, adjusted_align);
          size = size + _field_size | 0;
          align = adjusted_align > align ? adjusted_align : align;
        } else {
          const _Some = _bind;
          const _expr = _Some;
          const _p$28 = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, field.loc);
          const _p$29 = 0;
          let width;
          if (_p$28 === undefined) {
            width = _p$29;
          } else {
            const _p$30 = _p$28;
            width = _p$30;
          }
          const base = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(field.ty);
          const _p$30 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, base, loc);
          let _bind$2;
          if (_p$30 === undefined) {
            _bind$2 = hackwaly$tinycc$sem$sem_core$$struct_size_align$46$tuple$47$7706;
          } else {
            const _p$31 = _p$30;
            _bind$2 = _p$31;
          }
          const _base_size = _bind$2._0;
          const _base_align = _bind$2._1;
          let field_align = _base_align;
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          if (width === 0) {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$sem_core$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
            break _L;
          }
          if (packed && width !== 0) {
            field_align = 1;
          }
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          align = field_align > align ? field_align : align;
          if (field_align_override === undefined) {
            if (!packed) {
              const a8 = Math.imul(field_align, 8) | 0;
              const max_units = field_align > 0 ? _base_size / field_align | 0 : 0;
              if (a8 > 0) {
                const ofs = ((((((Math.imul(size, 8) | 0) + bit_pos | 0) % a8 | 0) + width | 0) + a8 | 0) - 1 | 0) / a8 | 0;
                if (ofs > max_units) {
                  const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
                  size = hackwaly$tinycc$sem$sem_core$$align_to(size + used_bytes | 0, field_align);
                  bit_pos = 0;
                }
              }
            }
          } else {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$sem_core$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
          }
          while (true) {
            if (bit_pos >= (Math.imul(field_align, 8) | 0)) {
              size = size + field_align | 0;
              bit_pos = bit_pos - (Math.imul(field_align, 8) | 0) | 0;
              continue;
            } else {
              break;
            }
          }
          bit_pos = bit_pos + width | 0;
        }
        break _L;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (bit_pos !== 0) {
    size = size + ((bit_pos + 7 | 0) / 8 | 0) | 0;
  }
  let final_align = align;
  const _bind = hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, attrs, loc);
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _value = _Some;
    if (_value > final_align) {
      final_align = _value;
    }
  }
  size = hackwaly$tinycc$sem$sem_core$$align_to(size, final_align);
  return { _0: size, _1: final_align };
}
function hackwaly$tinycc$sem$sem_core$$union_size_align(ctx, fields, attrs, loc) {
  let size = 0;
  let align = 1;
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const field = fields[_i];
      const packed = attrs.packed || field.attrs.packed;
      const field_align_override = hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, field.attrs, field.loc);
      const base = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(field.ty);
      const _bind = field.bit_width;
      let _bind$2;
      if (_bind === undefined) {
        _L: {
          _L$2: {
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(field.ty);
            if (_bind$3.$tag === 5) {
              const _Array = _bind$3;
              const _x = _Array._1;
              if (_x === undefined) {
                const _size_expr = _Array._2;
                if (_size_expr === undefined) {
                  const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, loc);
                  if (_bind$4 === undefined) {
                    _bind$2 = hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7769;
                  } else {
                    const _Some = _bind$4;
                    _bind$2 = _Some;
                  }
                } else {
                  const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, field.loc);
                  if (_bind$4 === undefined) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, "variable length array not allowed in union");
                    _bind$2 = hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7770;
                  } else {
                    const _Some = _bind$4;
                    _bind$2 = _Some;
                  }
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
            break _L;
          }
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, loc);
          if (_bind$3 === undefined) {
            _bind$2 = hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7768;
          } else {
            const _Some = _bind$3;
            _bind$2 = _Some;
          }
        }
      } else {
        const _Some = _bind;
        const _expr = _Some;
        const _p$28 = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, field.loc);
        const _p$29 = 0;
        let width;
        if (_p$28 === undefined) {
          width = _p$29;
        } else {
          const _p$30 = _p$28;
          width = _p$30;
        }
        const size_bits = width > 0 ? width : 0;
        const size_bytes = (size_bits + 7 | 0) / 8 | 0;
        const _p$30 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, base, loc);
        let _bind$3;
        if (_p$30 === undefined) {
          _bind$3 = hackwaly$tinycc$sem$sem_core$$union_size_align$46$tuple$47$7767;
        } else {
          const _p$31 = _p$30;
          _bind$3 = _p$31;
        }
        const _base_align = _bind$3._1;
        _bind$2 = { _0: size_bytes, _1: _base_align };
      }
      const _field_size = _bind$2._0;
      const _field_align = _bind$2._1;
      let adjusted_align = packed ? 1 : _field_align;
      if (field_align_override === undefined) {
      } else {
        const _Some = field_align_override;
        const _value = _Some;
        adjusted_align = _value;
      }
      if (_field_size > size) {
        size = _field_size;
      }
      if (adjusted_align > align) {
        align = adjusted_align;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let final_align = align;
  const _bind = hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, attrs, loc);
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _value = _Some;
    if (_value > final_align) {
      final_align = _value;
    }
  }
  size = hackwaly$tinycc$sem$sem_core$$align_to(size, final_align);
  return { _0: size, _1: final_align };
}
function hackwaly$tinycc$sem$sem_core$$check_cond_expr(ctx, expr) {
  const ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, expr);
  if (!hackwaly$tinycc$sem$sem_core$$is_scalar(ty)) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(expr), "condition expression must be scalar");
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$compound_literal_type(ctx, ty, init, loc, node_id) {
  const key = node_id;
  const _bind = moonbitlang$core$hashmap$$HashMap$get$169$(ctx.compound_literal_types, key);
  if (_bind === undefined) {
    hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, ty, loc);
    const resolved = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, ty, loc);
    let final_ty = resolved;
    const _bind$2 = hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, resolved, init, loc);
    if (_bind$2 === undefined) {
    } else {
      const _Some = _bind$2;
      const _size = _Some;
      final_ty = hackwaly$tinycc$sem$sem_core$$apply_inferred_array_size(final_ty, _size);
    }
    hackwaly$tinycc$sem$sem_core$$require_complete_object_type$46$inner(ctx, final_ty, loc, false);
    moonbitlang$core$hashmap$$HashMap$set$169$(ctx.compound_literal_types, key, final_ty);
    return final_ty;
  } else {
    const _Some = _bind;
    return _Some;
  }
}
function hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, ty, init, loc) {
  if (init.$tag === 0) {
    const _Expr = init;
    const _expr = _Expr._0;
    if (hackwaly$tinycc$sem$sem_core$$is_zero_aggregate_init(ctx, ty, _expr)) {
      return undefined;
    } else {
      if (_expr.$tag === 3) {
        const _StringLit = _expr;
        const _length = _StringLit._1;
        const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
        if (_bind.$tag === 5) {
          const _Array = _bind;
          const _elem = _Array._0;
          const _size = _Array._1;
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _elem, loc);
          let elem_sz;
          if (_bind$2 === undefined) {
            elem_sz = -1;
          } else {
            const _Some = _bind$2;
            const _x = _Some;
            elem_sz = _x._0;
          }
          if (elem_sz === 1) {
            if (_size === undefined) {
              return _length;
            } else {
              const _Some = _size;
              const _n = _Some;
              if (_length > (_n + 1 | 0)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "string literal too long for array");
              }
              return undefined;
            }
          } else {
            const init_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
            if (!hackwaly$tinycc$sem$sem_core$$can_assign(ty, init_ty) && !(hackwaly$tinycc$sem$sem_core$$is_pointer_type(ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _expr))) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `cannot assign '${hackwaly$tinycc$sem$sem_core$$type_to_string(init_ty)}' to '${hackwaly$tinycc$sem$sem_core$$type_to_string(ty)}'`);
            }
            return undefined;
          }
        } else {
          const init_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
          if (!hackwaly$tinycc$sem$sem_core$$can_assign(ty, init_ty) && !(hackwaly$tinycc$sem$sem_core$$is_pointer_type(ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _expr))) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `cannot assign '${hackwaly$tinycc$sem$sem_core$$type_to_string(init_ty)}' to '${hackwaly$tinycc$sem$sem_core$$type_to_string(ty)}'`);
          }
          return undefined;
        }
      } else {
        const init_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
        if (!hackwaly$tinycc$sem$sem_core$$can_assign(ty, init_ty) && !(hackwaly$tinycc$sem$sem_core$$is_pointer_type(ty) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _expr))) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `cannot assign '${hackwaly$tinycc$sem$sem_core$$type_to_string(init_ty)}' to '${hackwaly$tinycc$sem$sem_core$$type_to_string(ty)}'`);
        }
        return undefined;
      }
    }
  } else {
    const _List = init;
    const _items = _List._0;
    return hackwaly$tinycc$sem$sem_core$$check_initializer_list(ctx, ty, _items, loc);
  }
}
function hackwaly$tinycc$sem$sem_core$$check_initializer_list(ctx, ty, items, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  switch (_bind.$tag) {
    case 5: {
      const _Array = _bind;
      const _elem = _Array._0;
      const _size = _Array._1;
      let next_index = 0;
      let max_index = -1;
      const _len = items.length;
      let _tmp$27 = 0;
      while (true) {
        const _i = _tmp$27;
        if (_i < _len) {
          const item = items[_i];
          let index = next_index;
          let has_index = false;
          let range_end = undefined;
          let target;
          if (item.designators.length > 0) {
            const _bind$2 = moonbitlang$core$array$$Array$at$37$(item.designators, 0);
            switch (_bind$2.$tag) {
              case 0: {
                const _Index = _bind$2;
                const _expr = _Index._0;
                const _des_loc = _Index._1;
                const _bind$3 = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, _des_loc);
                if (_bind$3 === undefined) {
                } else {
                  const _Some = _bind$3;
                  const _v = _Some;
                  index = _v;
                  has_index = true;
                }
                break;
              }
              case 1: {
                const _IndexRange = _bind$2;
                const _start = _IndexRange._0;
                const _end = _IndexRange._1;
                const _des_loc$2 = _IndexRange._2;
                const start_val = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _start, _des_loc$2);
                const end_val = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _end, _des_loc$2);
                if (start_val === undefined) {
                } else {
                  const _Some = start_val;
                  const _start_idx = _Some;
                  if (end_val === undefined) {
                  } else {
                    const _Some$2 = end_val;
                    const _end_idx = _Some$2;
                    index = _start_idx;
                    has_index = true;
                    range_end = _end_idx;
                    if (_end_idx < _start_idx) {
                      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _des_loc$2, "array designator range is empty");
                    }
                  }
                }
                break;
              }
            }
            target = hackwaly$tinycc$sem$sem_core$$resolve_designator_type(ctx, ty, item.designators, item.loc);
          } else {
            target = _elem;
          }
          if (target === undefined) {
          } else {
            const _Some = target;
            const _target_ty = _Some;
            hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, _target_ty, item.value, item.loc);
          }
          if (has_index) {
            _L: {
              _L$2: {
                if (_size === undefined) {
                  if (index < 0) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, item.loc, "array designator out of bounds");
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
                break _L;
              }
              if (_size === undefined) {
              } else {
                const _Some = _size;
                const _n = _Some;
                const _p$28 = range_end;
                const _p$29 = index;
                let end_idx;
                if (_p$28 === undefined) {
                  end_idx = _p$29;
                } else {
                  const _p$30 = _p$28;
                  end_idx = _p$30;
                }
                if (index < 0 || (end_idx < 0 || (index >= _n || end_idx >= _n))) {
                }
              }
            }
          } else {
            if (_size === undefined) {
            } else {
              const _Some = _size;
              const _n = _Some;
              if (index >= _n) {
              }
            }
          }
          const _p$28 = range_end;
          const _p$29 = index;
          let range_last;
          if (_p$28 === undefined) {
            range_last = _p$29;
          } else {
            const _p$30 = _p$28;
            range_last = _p$30;
          }
          if (range_last >= 0 && range_last > max_index) {
            max_index = range_last;
          }
          if (has_index) {
            if (range_last >= 0) {
              next_index = range_last + 1 | 0;
            }
          } else {
            next_index = next_index + 1 | 0;
          }
          _tmp$27 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return _size === undefined ? (max_index < 0 ? hackwaly$tinycc$sem$sem_core$$check_initializer_list$46$constr$47$7852 : max_index + 1 | 0) : undefined;
    }
    case 6: {
      const _Struct = _bind;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const fields = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag, _tag_id, _field_list, false);
      if (fields.$tag === 0) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete struct '${_tag}'`);
      } else {
        const _Some = fields;
        const _list = _Some._0;
        hackwaly$tinycc$sem$sem_core$$check_struct_initializer(ctx, ty, _list, items, false, loc);
      }
      return undefined;
    }
    case 7: {
      const _Union = _bind;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const fields$2 = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true);
      if (fields$2.$tag === 0) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete union '${_tag$2}'`);
      } else {
        const _Some = fields$2;
        const _list = _Some._0;
        hackwaly$tinycc$sem$sem_core$$check_struct_initializer(ctx, ty, _list, items, true, loc);
      }
      return undefined;
    }
    default: {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "initializer list for non-aggregate");
      return undefined;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$check_struct_initializer(ctx, ty, fields, items, is_union, loc) {
  let index = 0;
  let saw = 0;
  let item_index = 0;
  while (true) {
    if (item_index < items.length) {
      const item = moonbitlang$core$array$$Array$at$38$(items, item_index);
      if (item.designators.length > 0) {
        const _bind = moonbitlang$core$array$$Array$at$37$(item.designators, 0);
        if (_bind.$tag === 2) {
          const _Field = _bind;
          const _name = _Field._0;
          const _id = _Field._1;
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$find_field_index_cached(ctx, ty, _name, _id, item.loc);
          if (_bind$2 === undefined) {
          } else {
            const _Some = _bind$2;
            const _idx = _Some;
            index = _idx + 1 | 0;
          }
        }
        const _bind$2 = hackwaly$tinycc$sem$sem_core$$resolve_designator_type(ctx, ty, item.designators, item.loc);
        if (_bind$2 === undefined) {
        } else {
          const _Some = _bind$2;
          const _target_ty = _Some;
          hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, _target_ty, item.value, item.loc);
        }
        if (is_union) {
          saw = saw + 1 | 0;
          if (saw > 1) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, item.loc, "too many initializers for union");
          }
        }
        item_index = item_index + 1 | 0;
      } else {
        const _bind = hackwaly$tinycc$sem$sem_core$$next_init_field(fields, index);
        if (_bind === undefined) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, item.loc, "too many initializers for aggregate");
          item_index = item_index + 1 | 0;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _field = _x._0;
          const _next_index = _x._1;
          let consumed = 1;
          let used_elision = false;
          _L: {
            _L$2: {
              const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(_field.ty);
              const _bind$3 = item.value;
              switch (_bind$2.$tag) {
                case 5: {
                  const _Array = _bind$2;
                  const _size = _Array._1;
                  if (_bind$3.$tag === 0) {
                    const _Expr = _bind$3;
                    const _expr = _Expr._0;
                    if (_expr.$tag === 3) {
                    } else {
                      const _bind$4 = hackwaly$tinycc$sem$sem_core$$collect_elided_array_items(items, item_index, _size);
                      const _elided_items = _bind$4._0;
                      const _count = _bind$4._1;
                      const init = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List(_elided_items, item.loc);
                      hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, _field.ty, init, item.loc);
                      consumed = _count;
                      used_elision = true;
                    }
                  }
                  break;
                }
                case 6: {
                  if (_bind$3.$tag === 0) {
                    break _L$2;
                  }
                  break;
                }
                case 7: {
                  if (_bind$3.$tag === 0) {
                    break _L$2;
                  }
                  break;
                }
              }
              break _L;
            }
            if (hackwaly$tinycc$sem$sem_core$$has_single_init_field(ctx, _field.ty)) {
              const init = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List([{ designators: [], value: item.value, loc: item.loc }], item.loc);
              hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, _field.ty, init, item.loc);
              used_elision = true;
            }
          }
          if (!used_elision) {
            hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, _field.ty, item.value, item.loc);
          }
          index = _next_index;
          if (is_union) {
            saw = saw + 1 | 0;
            if (saw > 1) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, item.loc, "too many initializers for union");
            }
          }
          item_index = item_index + consumed | 0;
        }
      }
      continue;
    } else {
      break;
    }
  }
  if (is_union && (items.length === 0 && fields.length === 0)) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "incomplete union");
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$find_field_index_cached(ctx, record_ty, name, id, loc) {
  const resolved = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, record_ty, loc));
  switch (resolved.$tag) {
    case 6: {
      const _Struct = resolved;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const _bind = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _def = _Some;
        let _tmp$27;
        const _p$28 = "";
        if (!(_tag === _p$28)) {
          _tmp$27 = _tag_id !== 0 ? hackwaly$tinycc$sem$sem_core$$has_opt_by_id$183$(ctx.struct_defs_by_id, _tag_id) : moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.struct_defs, _tag);
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          if (id > 0 && _tag_id !== 0) {
            const _bind$2 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$185$(ctx.struct_field_index_cache_by_id, _tag_id);
            let cache;
            if (_bind$2 === undefined) {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$build_field_index_caches(ctx, _def.fields, loc);
              const _built_name = _bind$3._0;
              const _built_id = _bind$3._1;
              hackwaly$tinycc$sem$sem_core$$set_opt_by_id$185$(ctx.struct_field_index_cache_by_id, _tag_id, _built_id);
              moonbitlang$core$hashmap$$HashMap$set$157$(ctx.struct_field_index_cache, _tag, _built_name);
              cache = _built_id;
            } else {
              const _Some$2 = _bind$2;
              cache = _Some$2;
            }
            const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$173$(cache, id);
            if (_bind$3 === undefined) {
              if (name === "") {
                return undefined;
              } else {
                const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$157$(ctx.struct_field_index_cache, _tag);
                if (_bind$4 === undefined) {
                  return undefined;
                } else {
                  const _Some$2 = _bind$4;
                  const _by_name = _Some$2;
                  return moonbitlang$core$hashmap$$HashMap$get$156$(_by_name, name);
                }
              }
            } else {
              const _Some$2 = _bind$3;
              const _idx = _Some$2;
              return _idx;
            }
          } else {
            const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$157$(ctx.struct_field_index_cache, _tag);
            let cache;
            if (_bind$2 === undefined) {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$build_field_index_caches(ctx, _def.fields, loc);
              const _built_name = _bind$3._0;
              const _built_id = _bind$3._1;
              moonbitlang$core$hashmap$$HashMap$set$157$(ctx.struct_field_index_cache, _tag, _built_name);
              if (_tag_id !== 0) {
                hackwaly$tinycc$sem$sem_core$$set_opt_by_id$185$(ctx.struct_field_index_cache_by_id, _tag_id, _built_id);
              }
              cache = _built_name;
            } else {
              const _Some$2 = _bind$2;
              cache = _Some$2;
            }
            return moonbitlang$core$hashmap$$HashMap$get$156$(cache, name);
          }
        } else {
          return hackwaly$tinycc$sem$sem_core$$find_field_index(ctx, _def.fields, name, id);
        }
      }
    }
    case 7: {
      const _Union = resolved;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const _bind$2 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$2;
        const _def = _Some;
        let _tmp$27;
        const _p$28 = "";
        if (!(_tag$2 === _p$28)) {
          _tmp$27 = _tag_id$2 !== 0 ? hackwaly$tinycc$sem$sem_core$$has_opt_by_id$183$(ctx.union_defs_by_id, _tag_id$2) : moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.union_defs, _tag$2);
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          if (id > 0 && _tag_id$2 !== 0) {
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$185$(ctx.union_field_index_cache_by_id, _tag_id$2);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$build_field_index_caches(ctx, _def.fields, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              hackwaly$tinycc$sem$sem_core$$set_opt_by_id$185$(ctx.union_field_index_cache_by_id, _tag_id$2, _built_id);
              moonbitlang$core$hashmap$$HashMap$set$157$(ctx.union_field_index_cache, _tag$2, _built_name);
              cache = _built_id;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$173$(cache, id);
            if (_bind$4 === undefined) {
              if (name === "") {
                return undefined;
              } else {
                const _bind$5 = moonbitlang$core$hashmap$$HashMap$get$157$(ctx.union_field_index_cache, _tag$2);
                if (_bind$5 === undefined) {
                  return undefined;
                } else {
                  const _Some$2 = _bind$5;
                  const _by_name = _Some$2;
                  return moonbitlang$core$hashmap$$HashMap$get$156$(_by_name, name);
                }
              }
            } else {
              const _Some$2 = _bind$4;
              const _idx = _Some$2;
              return _idx;
            }
          } else {
            const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$157$(ctx.union_field_index_cache, _tag$2);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$sem$sem_core$$build_field_index_caches(ctx, _def.fields, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              moonbitlang$core$hashmap$$HashMap$set$157$(ctx.union_field_index_cache, _tag$2, _built_name);
              if (_tag_id$2 !== 0) {
                hackwaly$tinycc$sem$sem_core$$set_opt_by_id$185$(ctx.union_field_index_cache_by_id, _tag_id$2, _built_id);
              }
              cache = _built_name;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            return moonbitlang$core$hashmap$$HashMap$get$156$(cache, name);
          }
        } else {
          return hackwaly$tinycc$sem$sem_core$$find_field_index(ctx, _def.fields, name, id);
        }
      }
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$resolve_designator_type(ctx, ty, designators, loc) {
  let current = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  const _len = designators.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const des = designators[_i];
      switch (des.$tag) {
        case 0: {
          const _Index = des;
          const _expr = _Index._0;
          const _des_loc = _Index._1;
          const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(current);
          if (_bind.$tag === 5) {
            const _Array = _bind;
            const _elem = _Array._0;
            const _size = _Array._1;
            if (_size === undefined) {
            } else {
              const _Some = _size;
              const _n = _Some;
              const _bind$2 = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, _des_loc);
              if (_bind$2 === undefined) {
              } else {
                const _Some$2 = _bind$2;
                const _v = _Some$2;
                if (_v < 0 || _v >= _n) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "array designator out of bounds");
                }
              }
            }
            current = _elem;
          } else {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "array designator on non-array type");
            return undefined;
          }
          break;
        }
        case 1: {
          const _IndexRange = des;
          const _start = _IndexRange._0;
          const _end = _IndexRange._1;
          const _des_loc$2 = _IndexRange._2;
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(current);
          if (_bind$2.$tag === 5) {
            const _Array = _bind$2;
            const _elem = _Array._0;
            const _size = _Array._1;
            const start_val = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _start, _des_loc$2);
            const end_val = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _end, _des_loc$2);
            if (start_val === undefined) {
            } else {
              const _Some = start_val;
              const _start_idx = _Some;
              if (end_val === undefined) {
              } else {
                const _Some$2 = end_val;
                const _end_idx = _Some$2;
                if (_end_idx < _start_idx) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "array designator range is empty");
                }
              }
            }
            if (_size === undefined) {
            } else {
              const _Some = _size;
              const _n = _Some;
              if (start_val === undefined) {
              } else {
                const _Some$2 = start_val;
                const _start_idx = _Some$2;
                if (end_val === undefined) {
                } else {
                  const _Some$3 = end_val;
                  const _end_idx = _Some$3;
                  if (_start_idx < 0 || (_end_idx < 0 || (_start_idx >= _n || _end_idx >= _n))) {
                    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "array designator out of bounds");
                  }
                }
              }
            }
            current = _elem;
          } else {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "array designator on non-array type");
            return undefined;
          }
          break;
        }
        default: {
          const _Field = des;
          const _name = _Field._0;
          const _id = _Field._1;
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(current);
          switch (_bind$3.$tag) {
            case 6: {
              const _Struct = _bind$3;
              const _tag = _Struct._0;
              const _tag_id = _Struct._1;
              const _field_list = _Struct._2;
              const fields = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag, _tag_id, _field_list, false);
              if (fields.$tag === 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete struct '${_tag}'`);
                return undefined;
              } else {
                const _Some = fields;
                const _list = _Some._0;
                const _bind$4 = hackwaly$tinycc$sem$sem_core$$find_field(ctx, _list, _name, _id);
                if (_bind$4 === undefined) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `unknown field '${_name}'`);
                  return undefined;
                } else {
                  const _Some$2 = _bind$4;
                  const _field = _Some$2;
                  current = _field.ty;
                }
              }
              break;
            }
            case 7: {
              const _Union = _bind$3;
              const _tag$2 = _Union._0;
              const _tag_id$2 = _Union._1;
              const _field_list$2 = _Union._2;
              const fields$2 = hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true);
              if (fields$2.$tag === 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete union '${_tag$2}'`);
                return undefined;
              } else {
                const _Some = fields$2;
                const _list = _Some._0;
                const _bind$4 = hackwaly$tinycc$sem$sem_core$$find_field(ctx, _list, _name, _id);
                if (_bind$4 === undefined) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `unknown field '${_name}'`);
                  return undefined;
                } else {
                  const _Some$2 = _bind$4;
                  const _field = _Some$2;
                  current = _field.ty;
                }
              }
              break;
            }
            default: {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "field designator on non-aggregate");
              return undefined;
            }
          }
        }
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return current;
}
function hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, ty, loc) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _base = _Qualified._1;
        _tmp$27 = _base;
        continue _L;
      }
      case 11: {
        const _Attributed = ty$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      case 6: {
        const _Struct = ty$2;
        const _name = _Struct._0;
        const _id = _Struct._1;
        const _fields = _Struct._2;
        const _attrs = _Struct._3;
        hackwaly$tinycc$sem$sem_core$$register_struct_def(ctx, _name, _id, _fields, _attrs, false, loc);
        return;
      }
      case 7: {
        const _Union = ty$2;
        const _name$2 = _Union._0;
        const _id$2 = _Union._1;
        const _fields$2 = _Union._2;
        const _attrs$2 = _Union._3;
        hackwaly$tinycc$sem$sem_core$$register_struct_def(ctx, _name$2, _id$2, _fields$2, _attrs$2, true, loc);
        return;
      }
      case 8: {
        const _Enum = ty$2;
        const _name$3 = _Enum._0;
        const _id$3 = _Enum._1;
        const _items = _Enum._2;
        hackwaly$tinycc$sem$sem_core$$register_enum_def(ctx, _name$3, _id$3, _items, loc);
        return;
      }
      case 4: {
        const _Pointer = ty$2;
        const _inner = _Pointer._0;
        _tmp$27 = _inner;
        continue _L;
      }
      case 5: {
        const _Array = ty$2;
        const _elem = _Array._0;
        _tmp$27 = _elem;
        continue _L;
      }
      case 10: {
        const _Function = ty$2;
        const _return_type = _Function._0;
        const _params = _Function._1;
        hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _return_type, loc);
        const _len = _params.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len) {
            const param_ty = _params[_i];
            hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, param_ty, loc);
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      default: {
        return;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$register_enum_def(ctx, name, id, items, loc) {
  if (name === "") {
    return undefined;
  }
  let incoming;
  if (items.$tag === 0) {
    incoming = [];
  } else {
    const _Some = items;
    incoming = _Some._0;
  }
  const existing = id !== 0 ? hackwaly$tinycc$sem$sem_core$$get_opt_by_id$184$(ctx.enum_defs_by_id, id) : moonbitlang$core$hashmap$$HashMap$get$168$(ctx.enum_defs, name);
  if (existing.$tag === 0) {
    moonbitlang$core$hashmap$$HashMap$set$168$(ctx.enum_defs, name, incoming);
    if (id !== 0) {
      hackwaly$tinycc$sem$sem_core$$set_opt_by_id$184$(ctx.enum_defs_by_id, id, incoming);
    }
  } else {
    const _Some = existing;
    const _existing = _Some._0;
    if (_existing.length > 0 && incoming.length > 0) {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
    } else {
      if (_existing.length === 0 && incoming.length > 0) {
        moonbitlang$core$hashmap$$HashMap$set$168$(ctx.enum_defs, name, incoming);
        if (id !== 0) {
          hackwaly$tinycc$sem$sem_core$$set_opt_by_id$184$(ctx.enum_defs_by_id, id, incoming);
        }
      }
    }
  }
  if (incoming.length > 0) {
    let value = 0;
    let min_value = 0;
    let max_value = 0;
    let has_value = false;
    const _len = incoming.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const item = incoming[_i];
        const _bind = item.value;
        let current;
        if (_bind === undefined) {
          current = value;
        } else {
          const _Some = _bind;
          const _expr = _Some;
          current = hackwaly$tinycc$sem$sem_core$$eval_const_expr(ctx, _expr, item.loc);
        }
        hackwaly$tinycc$sem$sem_core$$define_enum_const(ctx, item.name, item.id, item.loc, current);
        if (!has_value) {
          min_value = current;
          max_value = current;
          has_value = true;
        } else {
          if (current < min_value) {
            min_value = current;
          }
          if (current > max_value) {
            max_value = current;
          }
        }
        value = current + 1 | 0;
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    if (has_value) {
      const base = hackwaly$tinycc$sem$sem_core$$enum_int_type_from_range(min_value, max_value);
      moonbitlang$core$hashmap$$HashMap$set$159$(ctx.enum_types, name, base);
      if (id !== 0) {
        hackwaly$tinycc$sem$sem_core$$set_opt_by_id$29$(ctx.enum_types_by_id, id, base);
        return;
      } else {
        return;
      }
    } else {
      return;
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$register_struct_def$46$validate_fields$124$1496(_env, def) {
  const is_union = _env._2;
  const ctx = _env._1;
  const loc = _env._0;
  if (def.fields.length === 0) {
    return undefined;
  }
  if (is_union) {
    hackwaly$tinycc$sem$sem_core$$union_size_align(ctx, def.fields, def.attrs, loc);
    return;
  } else {
    hackwaly$tinycc$sem$sem_core$$struct_size_align(ctx, def.fields, def.attrs, loc);
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$register_struct_def(ctx, name, id, fields, attrs, is_union, loc) {
  if (name === "") {
    return undefined;
  }
  if (is_union) {
    if (id !== 0) {
      if (hackwaly$tinycc$sem$sem_core$$has_opt_by_id$183$(ctx.struct_defs_by_id, id)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
        return undefined;
      }
    } else {
      if (moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.struct_defs, name)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
        return undefined;
      }
    }
  } else {
    if (id !== 0) {
      if (hackwaly$tinycc$sem$sem_core$$has_opt_by_id$183$(ctx.union_defs_by_id, id)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
        return undefined;
      }
    } else {
      if (moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.union_defs, name)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
        return undefined;
      }
    }
  }
  let incoming_fields;
  if (fields.$tag === 0) {
    incoming_fields = [];
  } else {
    const _Some = fields;
    const _val = _Some._0;
    incoming_fields = hackwaly$tinycc$sem$sem_core$$record_items_to_fields_checked(ctx, _val);
  }
  const incoming = { fields: incoming_fields, attrs: attrs };
  const _env = { _0: loc, _1: ctx, _2: is_union };
  if (is_union) {
    const existing = id !== 0 ? hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(ctx.union_defs_by_id, id) : moonbitlang$core$hashmap$$HashMap$get$162$(ctx.union_defs, name);
    if (existing === undefined) {
      moonbitlang$core$hashmap$$HashMap$set$162$(ctx.union_defs, name, incoming);
      if (id !== 0) {
        hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.union_defs_by_id, id, incoming);
      }
      hackwaly$tinycc$sem$sem_core$$register_struct_def$46$validate_fields$124$1496(_env, incoming);
    } else {
      const _Some = existing;
      const _existing = _Some;
      if (_existing.fields.length > 0 && incoming_fields.length > 0) {
        if (moonbitlang$core$builtin$$Eq$equal$141$(_existing.fields, incoming_fields) && moonbitlang$core$builtin$$Eq$equal$177$(_existing.attrs, attrs)) {
          const merged = { fields: _existing.fields, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(_existing.attrs, attrs) };
          moonbitlang$core$hashmap$$HashMap$set$162$(ctx.union_defs, name, merged);
          if (id !== 0) {
            hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.union_defs_by_id, id, merged);
          }
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
        }
      } else {
        if (_existing.fields.length === 0 && incoming_fields.length > 0) {
          const merged = { fields: incoming_fields, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(_existing.attrs, attrs) };
          moonbitlang$core$hashmap$$HashMap$set$162$(ctx.union_defs, name, merged);
          if (id !== 0) {
            hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.union_defs_by_id, id, merged);
          }
          hackwaly$tinycc$sem$sem_core$$register_struct_def$46$validate_fields$124$1496(_env, merged);
        } else {
          const merged = { fields: _existing.fields, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(_existing.attrs, attrs) };
          moonbitlang$core$hashmap$$HashMap$set$162$(ctx.union_defs, name, merged);
          if (id !== 0) {
            hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.union_defs_by_id, id, merged);
          }
        }
      }
    }
  } else {
    const existing = id !== 0 ? hackwaly$tinycc$sem$sem_core$$get_opt_by_id$183$(ctx.struct_defs_by_id, id) : moonbitlang$core$hashmap$$HashMap$get$162$(ctx.struct_defs, name);
    if (existing === undefined) {
      moonbitlang$core$hashmap$$HashMap$set$162$(ctx.struct_defs, name, incoming);
      if (id !== 0) {
        hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.struct_defs_by_id, id, incoming);
      }
      hackwaly$tinycc$sem$sem_core$$register_struct_def$46$validate_fields$124$1496(_env, incoming);
    } else {
      const _Some = existing;
      const _existing = _Some;
      if (_existing.fields.length > 0 && incoming_fields.length > 0) {
        if (moonbitlang$core$builtin$$Eq$equal$141$(_existing.fields, incoming_fields) && moonbitlang$core$builtin$$Eq$equal$177$(_existing.attrs, attrs)) {
          const merged = { fields: _existing.fields, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(_existing.attrs, attrs) };
          moonbitlang$core$hashmap$$HashMap$set$162$(ctx.struct_defs, name, merged);
          if (id !== 0) {
            hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.struct_defs_by_id, id, merged);
          }
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `redefinition of '${name}'`);
        }
      } else {
        if (_existing.fields.length === 0 && incoming_fields.length > 0) {
          const merged = { fields: incoming_fields, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(_existing.attrs, attrs) };
          moonbitlang$core$hashmap$$HashMap$set$162$(ctx.struct_defs, name, merged);
          if (id !== 0) {
            hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.struct_defs_by_id, id, merged);
          }
          hackwaly$tinycc$sem$sem_core$$register_struct_def$46$validate_fields$124$1496(_env, merged);
        } else {
          const merged = { fields: _existing.fields, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(_existing.attrs, attrs) };
          moonbitlang$core$hashmap$$HashMap$set$162$(ctx.struct_defs, name, merged);
          if (id !== 0) {
            hackwaly$tinycc$sem$sem_core$$set_opt_by_id$183$(ctx.struct_defs_by_id, id, merged);
          }
        }
      }
    }
  }
  if (incoming_fields.length > 0) {
    const _len = incoming_fields.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const field = incoming_fields[_i];
        hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, field.ty, field.loc);
        const _bind = field.bit_width;
        if (_bind === undefined) {
        } else {
          const _Some = _bind;
          const _expr = _Some;
          if (!hackwaly$tinycc$sem$sem_core$$is_int_like(field.ty)) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, "bitfields must have integer type");
          }
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, field.loc);
          if (_bind$2 === undefined) {
          } else {
            const _Some$2 = _bind$2;
            const _width = _Some$2;
            if (_width < 0) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, "negative width in bit-field");
            }
            let _tmp$28;
            if (_width === 0) {
              const _p$28 = field.name;
              const _p$29 = "";
              _tmp$28 = !(_p$28 === _p$29);
            } else {
              _tmp$28 = false;
            }
            if (_tmp$28) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, "zero width for bit-field");
            }
            if (_width > 0) {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, field.loc);
              if (_bind$3 === undefined) {
              } else {
                const _Some$3 = _bind$3;
                const _x = _Some$3;
                const _size = _x._0;
                if (_width > (Math.imul(_size, 8) | 0)) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, `width of '${field.name}' exceeds its type`);
                }
              }
            }
          }
        }
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$record_items_to_fields_checked(ctx, items) {
  const fields = [];
  const _len = items.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const item = items[_i];
      if (item.$tag === 0) {
        const _Field = item;
        const _field = _Field._0;
        moonbitlang$core$array$$Array$push$39$(fields, _field);
      } else {
        const _StaticAssert = item;
        const _static_assert = _StaticAssert._0;
        hackwaly$tinycc$sem$sem_core$$check_static_assert(ctx, _static_assert);
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return fields;
}
function hackwaly$tinycc$sem$sem_core$$check_static_assert(ctx, item) {
  const _bind = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, item.expr, item.loc);
  const _value = _bind._0;
  const _ok = _bind._1;
  if (_ok && _value === 0) {
    const _tmp$27 = item.loc;
    const _p$28 = item.message;
    let _tmp$28;
    if (_p$28 === undefined) {
      _tmp$28 = "_Static_assert fail";
    } else {
      const _p$29 = _p$28;
      _tmp$28 = _p$29;
    }
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _tmp$27, _tmp$28);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$require_complete_object_type$46$inner(ctx, ty, loc, allow_incomplete_array) {
  let _tmp$27 = ty;
  let _tmp$28 = allow_incomplete_array;
  _L: while (true) {
    const ty$2 = _tmp$27;
    const allow_incomplete_array$2 = _tmp$28;
    const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty$2);
    switch (_bind.$tag) {
      case 5: {
        const _Array = _bind;
        const _elem = _Array._0;
        const _size = _Array._1;
        const _size_expr = _Array._2;
        if (_size === undefined) {
          if (_size_expr === undefined) {
            if (!allow_incomplete_array$2) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "incomplete array type");
            }
          }
        }
        _tmp$27 = _elem;
        _tmp$28 = false;
        continue _L;
      }
      case 6: {
        const _Struct = _bind;
        const _tag = _Struct._0;
        const _tag_id = _Struct._1;
        const _field_list = _Struct._2;
        hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
        return;
      }
      case 7: {
        const _Union = _bind;
        const _tag$2 = _Union._0;
        const _tag_id$2 = _Union._1;
        const _field_list$2 = _Union._2;
        hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
        return;
      }
      case 8: {
        const _Enum = _bind;
        const _tag$3 = _Enum._0;
        const _tag_id$3 = _Enum._1;
        const _items = _Enum._2;
        if (_items.$tag === 1) {
          const _Some = _items;
          const _list = _Some._0;
          if (_list.length === 0) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete enum '${_tag$3}'`);
            return;
          } else {
            const base = hackwaly$tinycc$sem$sem_core$$enum_type_from_items(ctx, _list);
            const _p$28 = "";
            if (!(_tag$3 === _p$28)) {
              if (_tag_id$3 !== 0) {
                hackwaly$tinycc$sem$sem_core$$set_opt_by_id$29$(ctx.enum_types_by_id, _tag_id$3, base);
                return;
              } else {
                moonbitlang$core$hashmap$$HashMap$set$159$(ctx.enum_types, _tag$3, base);
                return;
              }
            } else {
              return;
            }
          }
        } else {
          if (_tag_id$3 !== 0) {
            if (!hackwaly$tinycc$sem$sem_core$$has_opt_by_id$29$(ctx.enum_types_by_id, _tag_id$3)) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete enum '${_tag$3}'`);
              return;
            } else {
              return;
            }
          } else {
            if (!moonbitlang$core$hashmap$$HashMap$contains$159$(ctx.enum_types, _tag$3)) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `incomplete enum '${_tag$3}'`);
              return;
            } else {
              return;
            }
          }
        }
      }
      default: {
        return;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof(ctx, ty, path, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof_and_type(ctx, ty, path, loc, false);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _off = _x._0;
    return _off;
  }
}
function hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof_and_type(ctx, ty, path, loc, suppress_error) {
  if (path.length === 0) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "__builtin_offsetof expects member designator");
    return undefined;
  }
  let current = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, ty, loc));
  let offset = 0;
  const _len = path.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const name = path[_i];
      const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(current);
      switch (_bind.$tag) {
        case 6: {
          const _Struct = _bind;
          const _tag = _Struct._0;
          const _tag_id = _Struct._1;
          const _field_list = _Struct._2;
          const _attrs = _Struct._3;
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
          if (_bind$2 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$2;
            const _def = _Some;
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type(ctx, _def, _attrs, name, loc);
            if (_bind$3 === undefined) {
              if (suppress_error) {
                return undefined;
              } else {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `unknown field '${name}' in __builtin_offsetof`);
                return undefined;
              }
            } else {
              const _Some$2 = _bind$3;
              const _x = _Some$2;
              const _field_off = _x._0;
              const _field_ty = _x._1;
              const _is_bitfield = _x._2;
              if (_is_bitfield) {
                if (!suppress_error) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "__builtin_offsetof does not allow bitfields");
                }
                return undefined;
              }
              offset = offset + _field_off | 0;
              current = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _field_ty, loc));
            }
          }
          break;
        }
        case 7: {
          const _Union = _bind;
          const _tag$2 = _Union._0;
          const _tag_id$2 = _Union._1;
          const _field_list$2 = _Union._2;
          const _attrs$2 = _Union._3;
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
          if (_bind$3 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$3;
            const _def = _Some;
            const _bind$4 = hackwaly$tinycc$sem$sem_core$$union_field_offset_and_type(ctx, _def, _attrs$2, name, loc);
            if (_bind$4 === undefined) {
              if (suppress_error) {
                return undefined;
              } else {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `unknown field '${name}' in __builtin_offsetof`);
                return undefined;
              }
            } else {
              const _Some$2 = _bind$4;
              const _x = _Some$2;
              const _field_off = _x._0;
              const _field_ty = _x._1;
              const _is_bitfield = _x._2;
              if (_is_bitfield) {
                if (!suppress_error) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "__builtin_offsetof does not allow bitfields");
                }
                return undefined;
              }
              offset = offset + _field_off | 0;
              current = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _field_ty, loc));
            }
          }
          break;
        }
        default: {
          if (!suppress_error) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "__builtin_offsetof expects struct/union type");
          }
          return undefined;
        }
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: offset, _1: current, _2: false };
}
function hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type(ctx, def, struct_attrs, name, loc) {
  const fields = def.fields;
  const attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(def.attrs, struct_attrs);
  let size = 0;
  let bit_pos = 0;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < fields.length) {
      _L: {
        const field = moonbitlang$core$array$$Array$at$39$(fields, i);
        const packed = attrs.packed || field.attrs.packed;
        const field_align_override = hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, field.attrs, field.loc);
        const _bind = field.bit_width;
        if (_bind === undefined) {
          if (bit_pos !== 0) {
            size = size + ((bit_pos + 7 | 0) / 8 | 0) | 0;
            bit_pos = 0;
          }
          let _bind$2;
          _L$2: {
            _L$3: {
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(field.ty);
              if (_bind$3.$tag === 5) {
                const _Array = _bind$3;
                const _elem = _Array._0;
                const _x = _Array._1;
                if (_x === undefined) {
                  const _size_expr = _Array._2;
                  if (_size_expr === undefined) {
                    const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _elem, field.loc);
                    let _bind$5;
                    if (_bind$4 === undefined) {
                      _bind$5 = hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8265;
                    } else {
                      const _Some = _bind$4;
                      _bind$5 = _Some;
                    }
                    const _elem_align = _bind$5._1;
                    _bind$2 = { _0: 0, _1: _elem_align };
                  } else {
                    const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, field.loc);
                    if (_bind$4 === undefined) {
                      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, field.loc, "variable length array not allowed in struct");
                      _bind$2 = hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8266;
                    } else {
                      const _Some = _bind$4;
                      _bind$2 = _Some;
                    }
                  }
                } else {
                  break _L$3;
                }
              } else {
                break _L$3;
              }
              break _L$2;
            }
            const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, field.ty, loc);
            if (_bind$3 === undefined) {
              _bind$2 = hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8264;
            } else {
              const _Some = _bind$3;
              _bind$2 = _Some;
            }
          }
          const _field_size = _bind$2._0;
          const _field_align = _bind$2._1;
          let adjusted_align = packed ? 1 : _field_align;
          if (field_align_override === undefined) {
          } else {
            const _Some = field_align_override;
            const _value = _Some;
            adjusted_align = _value;
          }
          size = hackwaly$tinycc$sem$sem_core$$align_to(size, adjusted_align);
          if (field.name === name) {
            return { _0: size, _1: field.ty, _2: false };
          }
          if (field.name === "") {
            _L$3: {
              _L$4: {
                const _bind$3 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(field.ty);
                switch (_bind$3.$tag) {
                  case 6: {
                    break _L$4;
                  }
                  case 7: {
                    break _L$4;
                  }
                }
                break _L$3;
              }
              const _bind$3 = hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof_and_type(ctx, field.ty, [name], loc, true);
              if (_bind$3 === undefined) {
              } else {
                const _Some = _bind$3;
                const _x = _Some;
                const _inner_off = _x._0;
                const _inner_ty = _x._1;
                return { _0: size + _inner_off | 0, _1: _inner_ty, _2: false };
              }
            }
          }
          size = size + _field_size | 0;
        } else {
          const _Some = _bind;
          const _expr = _Some;
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, field.loc);
          let width;
          if (_bind$2 === undefined) {
            width = 0;
          } else {
            const _Some$2 = _bind$2;
            width = _Some$2;
          }
          const base = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(field.ty);
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, base, loc);
          let _bind$4;
          if (_bind$3 === undefined) {
            _bind$4 = hackwaly$tinycc$sem$sem_core$$struct_field_offset_and_type$46$tuple$47$8263;
          } else {
            const _Some$2 = _bind$3;
            _bind$4 = _Some$2;
          }
          const _base_size = _bind$4._0;
          const _base_align = _bind$4._1;
          let field_align = _base_align;
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          if (width === 0) {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$sem_core$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
            break _L;
          }
          if (packed && width !== 0) {
            field_align = 1;
          }
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          if (field_align_override === undefined) {
            if (!packed) {
              const a8 = Math.imul(field_align, 8) | 0;
              const max_units = field_align > 0 ? _base_size / field_align | 0 : 0;
              if (a8 > 0) {
                const ofs = ((((((Math.imul(size, 8) | 0) + bit_pos | 0) % a8 | 0) + width | 0) + a8 | 0) - 1 | 0) / a8 | 0;
                if (ofs > max_units) {
                  const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
                  size = hackwaly$tinycc$sem$sem_core$$align_to(size + used_bytes | 0, field_align);
                  bit_pos = 0;
                }
              }
            }
          } else {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$sem_core$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
          }
          while (true) {
            if (bit_pos >= (Math.imul(field_align, 8) | 0)) {
              size = size + field_align | 0;
              bit_pos = bit_pos - (Math.imul(field_align, 8) | 0) | 0;
              continue;
            } else {
              break;
            }
          }
          if (field.name === name) {
            return { _0: size, _1: field.ty, _2: true };
          }
          bit_pos = bit_pos + width | 0;
        }
        break _L;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$sem$sem_core$$union_field_offset_and_type(ctx, def, union_attrs, name, loc) {
  const fields = def.fields;
  hackwaly$tinycc$frontend$ast$$merge_attrs(def.attrs, union_attrs);
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const field = fields[_i];
      if (field.name === name) {
        const _bind = field.bit_width;
        if (_bind === undefined) {
        } else {
          return { _0: 0, _1: field.ty, _2: true };
        }
        return { _0: 0, _1: field.ty, _2: false };
      }
      if (field.name === "") {
        _L: {
          _L$2: {
            const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(field.ty);
            switch (_bind.$tag) {
              case 6: {
                break _L$2;
              }
              case 7: {
                break _L$2;
              }
            }
            break _L;
          }
          const _bind = hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof_and_type(ctx, field.ty, [name], loc, true);
          if (_bind === undefined) {
          } else {
            const _Some = _bind;
            const _x = _Some;
            const _inner_off = _x._0;
            const _inner_ty = _x._1;
            return { _0: _inner_off, _1: _inner_ty, _2: false };
          }
        }
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$sem$sem_core$$record_compound_literal(ctx, loc, node_id, ty) {
  if (!ctx.record_agg_temps) {
    return undefined;
  }
  const key = node_id;
  const id = ctx.current_func_id;
  if (id > 0) {
    const _bind = hackwaly$tinycc$sem$sem_core$$get_opt_by_id$188$(ctx.func_compound_literals_by_id, id);
    let keys;
    if (_bind.$tag === 0) {
      keys = [];
    } else {
      const _Some = _bind;
      keys = _Some._0;
    }
    let has_key = false;
    const _len = keys.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const existing = keys[_i];
        if (existing === key) {
          has_key = true;
        }
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    if (!has_key) {
      moonbitlang$core$array$$Array$push$26$(keys, key);
      hackwaly$tinycc$sem$sem_core$$set_opt_by_id$188$(ctx.func_compound_literals_by_id, id, keys);
    }
  } else {
    const _bind = ctx.current_func_name;
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _name = _Some;
      moonbitlang$core$hashmap$$HashMap$set$161$(ctx.func_has_compound_literal, _name, true);
      const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$166$(ctx.func_compound_literals, _name);
      let keys;
      if (_bind$2.$tag === 0) {
        keys = [];
      } else {
        const _Some$2 = _bind$2;
        keys = _Some$2._0;
      }
      let has_key = false;
      const _len = keys.length;
      let _tmp$27 = 0;
      while (true) {
        const _i = _tmp$27;
        if (_i < _len) {
          const existing = keys[_i];
          if (existing === key) {
            has_key = true;
          }
          _tmp$27 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!has_key) {
        moonbitlang$core$array$$Array$push$26$(keys, key);
        moonbitlang$core$hashmap$$HashMap$set$166$(ctx.func_compound_literals, _name, keys);
      }
    }
  }
  if (!moonbitlang$core$hashmap$$HashMap$contains$167$(ctx.compound_literal_sizes, key)) {
    const _bind = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty, loc);
    if (_bind === undefined) {
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _size = _x._0;
      const _align = _x._1;
      if (_size > 0) {
        moonbitlang$core$hashmap$$HashMap$set$167$(ctx.compound_literal_sizes, key, { _0: _size, _1: _align });
        return;
      } else {
        return;
      }
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$sem$sem_core$$stmt_expr_result_type(ctx, stmts, _loc) {
  hackwaly$tinycc$sem$sem_core$$record_stmt_expr(ctx);
  const return_type = hackwaly$tinycc$sem$sem_core$$current_return_type(ctx);
  hackwaly$tinycc$sem$sem_core$$push_scope(ctx);
  let result = $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
  const len = stmts.length;
  if (len === 0) {
    hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
    return result;
  }
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      const stmt = moonbitlang$core$array$$Array$at$49$(stmts, i);
      if ((i + 1 | 0) === len) {
        if (stmt.$tag === 15) {
          const _ExprStmt = stmt;
          const _expr = _ExprStmt._0;
          result = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
        } else {
          hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, stmt, return_type);
          result = $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
        }
      } else {
        hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, stmt, return_type);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
  return result;
}
function hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, stmt, return_type) {
  let _tmp$27 = stmt;
  _L: while (true) {
    const stmt$2 = _tmp$27;
    switch (stmt$2.$tag) {
      case 0: {
        const _Compound = stmt$2;
        const _stmts = _Compound._0;
        let scope_open = false;
        const _len = _stmts.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len) {
            const item = _stmts[_i];
            if (!scope_open) {
              if (item.$tag === 16) {
                hackwaly$tinycc$sem$sem_core$$push_scope(ctx);
                scope_open = true;
              }
            }
            hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, item, return_type);
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (scope_open) {
          hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
          return;
        } else {
          return;
        }
      }
      case 1: {
        const _If = stmt$2;
        const _cond = _If._0;
        const _then_branch = _If._1;
        const _else_branch = _If._2;
        hackwaly$tinycc$sem$sem_core$$check_cond_expr(ctx, _cond);
        hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, _then_branch, return_type);
        if (_else_branch === undefined) {
          return;
        } else {
          const _Some = _else_branch;
          const _stmt = _Some;
          _tmp$27 = _stmt;
          continue _L;
        }
      }
      case 2: {
        const _While = stmt$2;
        const _cond$2 = _While._0;
        const _body = _While._1;
        hackwaly$tinycc$sem$sem_core$$check_cond_expr(ctx, _cond$2);
        hackwaly$tinycc$sem$sem_core$$with_loop(ctx, () => {
          hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, _body, return_type);
        });
        return;
      }
      case 3: {
        const _DoWhile = stmt$2;
        const _cond$3 = _DoWhile._0;
        const _body$2 = _DoWhile._1;
        hackwaly$tinycc$sem$sem_core$$with_loop(ctx, () => {
          hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, _body$2, return_type);
        });
        hackwaly$tinycc$sem$sem_core$$check_cond_expr(ctx, _cond$3);
        return;
      }
      case 4: {
        const _For = stmt$2;
        const _init = _For._0;
        const _cond$4 = _For._1;
        const _step = _For._2;
        const _body$3 = _For._3;
        let needs_scope;
        if (_init === undefined) {
          needs_scope = false;
        } else {
          const _Some = _init;
          const _x = _Some;
          if (_x.$tag === 16) {
            needs_scope = true;
          } else {
            needs_scope = false;
          }
        }
        if (needs_scope) {
          hackwaly$tinycc$sem$sem_core$$push_scope(ctx);
        }
        if (_init === undefined) {
        } else {
          const _Some = _init;
          const _stmt = _Some;
          hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, _stmt, return_type);
        }
        if (_cond$4 === undefined) {
        } else {
          const _Some = _cond$4;
          const _expr = _Some;
          hackwaly$tinycc$sem$sem_core$$check_cond_expr(ctx, _expr);
        }
        if (_step === undefined) {
        } else {
          const _Some = _step;
          const _expr = _Some;
          hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
        }
        hackwaly$tinycc$sem$sem_core$$with_loop(ctx, () => {
          hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, _body$3, return_type);
        });
        if (needs_scope) {
          hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
          return;
        } else {
          return;
        }
      }
      case 5: {
        const _Switch = stmt$2;
        const _cond$5 = _Switch._0;
        const _body$4 = _Switch._1;
        const _loc = _Switch._2;
        const cond_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _cond$5);
        if (!hackwaly$tinycc$sem$sem_core$$is_int_like(cond_ty)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, "switch expression must have integer type");
        }
        hackwaly$tinycc$sem$sem_core$$with_switch(ctx, () => {
          hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, _body$4, return_type);
        });
        return;
      }
      case 6: {
        const _Case = stmt$2;
        const _expr = _Case._0;
        const _end_expr = _Case._1;
        const _body$5 = _Case._2;
        if (ctx.switch_depth === 0) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(_expr), "case outside of switch");
        }
        const start = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, hackwaly$tinycc$frontend$ast$$expr_loc(_expr));
        if (start === undefined) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(_expr), "case label is not constant");
        }
        let end;
        if (_end_expr === undefined) {
          end = start;
        } else {
          const _Some = _end_expr;
          const _end_value = _Some;
          const end_val = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _end_value, hackwaly$tinycc$frontend$ast$$expr_loc(_end_value));
          if (end_val === undefined) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(_end_value), "case label is not constant");
          }
          end = end_val;
        }
        if (start === undefined) {
        } else {
          const _Some = start;
          const _v1 = _Some;
          if (end === undefined) {
          } else {
            const _Some$2 = end;
            const _v2 = _Some$2;
            hackwaly$tinycc$sem$sem_core$$register_case_range(ctx, _v1, _v2, hackwaly$tinycc$frontend$ast$$expr_loc(_expr));
          }
        }
        _tmp$27 = _body$5;
        continue _L;
      }
      case 7: {
        const _Default = stmt$2;
        const _body$6 = _Default._0;
        const _loc$2 = _Default._1;
        if (ctx.switch_depth === 0) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$2, "default outside of switch");
        }
        if (ctx.switch_stack.length > 0) {
          const idx = ctx.switch_stack.length - 1 | 0;
          const info = moonbitlang$core$array$$Array$at$53$(ctx.switch_stack, idx);
          if (info.has_default) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$2, "too many 'default'");
          } else {
            info.has_default = true;
            moonbitlang$core$array$$Array$set$53$(ctx.switch_stack, idx, info);
          }
        }
        _tmp$27 = _body$6;
        continue _L;
      }
      case 8: {
        const _Label = stmt$2;
        const _name = _Label._0;
        const _body$7 = _Label._1;
        const _loc$3 = _Label._2;
        if (moonbitlang$core$hashmap$$HashMap$contains$161$(ctx.labels_defined, _name)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$3, `duplicate label '${_name}'`);
        } else {
          moonbitlang$core$hashmap$$HashMap$set$161$(ctx.labels_defined, _name, true);
        }
        _tmp$27 = _body$7;
        continue _L;
      }
      case 9: {
        const _Goto = stmt$2;
        const _name$2 = _Goto._0;
        const _loc$4 = _Goto._1;
        moonbitlang$core$array$$Array$push$111$(ctx.labels_used, { _0: _name$2, _1: _loc$4 });
        return;
      }
      case 10: {
        const _GotoExpr = stmt$2;
        const _expr$2 = _GotoExpr._0;
        const _loc$5 = _GotoExpr._1;
        const expr_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr$2);
        if (!hackwaly$tinycc$sem$sem_core$$is_pointer_type(expr_ty)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$5, "computed goto expects pointer");
          return;
        } else {
          return;
        }
      }
      case 11: {
        const _Break = stmt$2;
        const _loc$6 = _Break._0;
        if (ctx.loop_depth === 0 && ctx.switch_depth === 0) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$6, "cannot break outside of loop or switch");
          return;
        } else {
          return;
        }
      }
      case 12: {
        const _Continue = stmt$2;
        const _loc$7 = _Continue._0;
        if (ctx.loop_depth === 0) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$7, "cannot continue outside of loop");
          return;
        } else {
          return;
        }
      }
      case 13: {
        const _Return = stmt$2;
        const _value = _Return._0;
        const _loc$8 = _Return._1;
        if (_value === undefined) {
          if (!hackwaly$tinycc$sem$sem_core$$is_void_type(return_type)) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "non-void function must return a value");
            return;
          } else {
            return;
          }
        } else {
          const _Some = _value;
          const _expr$3 = _Some;
          const expr_ty$2 = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr$3);
          if (hackwaly$tinycc$sem$sem_core$$is_void_type(return_type)) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, "void function should not return a value");
            return;
          } else {
            if (!hackwaly$tinycc$sem$sem_core$$can_assign(return_type, expr_ty$2) && !(hackwaly$tinycc$sem$sem_core$$is_pointer_type(return_type) && hackwaly$tinycc$sem$sem_core$$is_null_pointer_expr(ctx, _expr$3))) {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$8, `return type '${hackwaly$tinycc$sem$sem_core$$type_to_string(expr_ty$2)}' does not match '${hackwaly$tinycc$sem$sem_core$$type_to_string(return_type)}'`);
              return;
            } else {
              return;
            }
          }
        }
      }
      case 14: {
        const _Asm = stmt$2;
        const _asm_stmt = _Asm._0;
        hackwaly$tinycc$sem$sem_core$$check_asm_stmt(ctx, _asm_stmt);
        return;
      }
      case 15: {
        const _ExprStmt = stmt$2;
        const _expr$3 = _ExprStmt._0;
        hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr$3);
        return;
      }
      case 16: {
        const _DeclStmt = stmt$2;
        const _decls = _DeclStmt._0;
        const _len$2 = _decls.length;
        let _tmp$29 = 0;
        while (true) {
          const _i = _tmp$29;
          if (_i < _len$2) {
            const decl = _decls[_i];
            hackwaly$tinycc$sem$sem_core$$check_var_decl(ctx, decl, true);
            _tmp$29 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 17: {
        const _TagDef = stmt$2;
        const _ty = _TagDef._0;
        const _loc$9 = _TagDef._1;
        hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty, _loc$9);
        return;
      }
      case 18: {
        const _StaticAssert = stmt$2;
        const _static_assert = _StaticAssert._0;
        hackwaly$tinycc$sem$sem_core$$check_static_assert(ctx, _static_assert);
        return;
      }
      default: {
        return;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$check_asm_stmt(ctx, asm_stmt) {
  const _arr = asm_stmt.outputs;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const op = _arr[_i];
      hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, op.expr);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$2 = asm_stmt.inputs;
  const _len$2 = _arr$2.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len$2) {
      const op = _arr$2[_i];
      hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, op.expr);
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$3 = asm_stmt.labels;
  const _len$3 = _arr$3.length;
  let _tmp$29 = 0;
  while (true) {
    const _i = _tmp$29;
    if (_i < _len$3) {
      const label = _arr$3[_i];
      moonbitlang$core$array$$Array$push$111$(ctx.labels_used, { _0: label, _1: asm_stmt.loc });
      _tmp$29 = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, expr) {
  _L: {
    switch (expr.$tag) {
      case 4: {
        const _Ident = expr;
        const _name = _Ident._0;
        const _id = _Ident._1;
        const _loc = _Ident._3;
        if (hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, _name, _id)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, "expression is not assignable");
          return undefined;
        } else {
          const _bind = hackwaly$tinycc$sem$sem_core$$lookup_value(ctx, _name, _id);
          if (_bind === undefined) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, `use of undeclared identifier '${_name}'`);
            return undefined;
          } else {
            const _Some = _bind;
            const _ty = _Some;
            return _ty;
          }
        }
      }
      case 20: {
        const _Index = expr;
        const _base = _Index._0;
        const _index = _Index._1;
        const _loc$2 = _Index._3;
        const _bind = hackwaly$tinycc$sem$sem_core$$index_access_type(ctx, hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _base), hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _index), _loc$2);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _ty = _Some;
          return _ty;
        }
      }
      case 21: {
        const _Member = expr;
        const _base$2 = _Member._0;
        const _name$2 = _Member._1;
        const _id$2 = _Member._2;
        const _is_arrow = _Member._3;
        const _loc$3 = _Member._5;
        return hackwaly$tinycc$sem$sem_core$$member_access_type(ctx, hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _base$2), _name$2, _id$2, _is_arrow, _loc$3);
      }
      case 9: {
        const _Unary = expr;
        const _x = _Unary._0;
        if (_x === 5) {
          const _inner = _Unary._1;
          const _loc$4 = _Unary._3;
          const inner_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _inner);
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(inner_ty);
          if (_bind$2.$tag === 4) {
            const _Pointer = _bind$2;
            const _pointee = _Pointer._0;
            return _pointee;
          } else {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$4, "cannot dereference non-pointer");
            return undefined;
          }
        } else {
          break _L;
        }
      }
      case 11: {
        const _CompoundLiteral = expr;
        const _ty = _CompoundLiteral._0;
        const _init = _CompoundLiteral._1;
        const _node_id = _CompoundLiteral._2;
        const _loc$4 = _CompoundLiteral._3;
        const resolved = hackwaly$tinycc$sem$sem_core$$compound_literal_type(ctx, _ty, _init, _loc$4, _node_id);
        hackwaly$tinycc$sem$sem_core$$record_compound_literal(ctx, _loc$4, _node_id, resolved);
        return resolved;
      }
      case 12: {
        const _StmtExpr = expr;
        const _stmts = _StmtExpr._0;
        const _loc$5 = _StmtExpr._2;
        return hackwaly$tinycc$sem$sem_core$$stmt_expr_lvalue_type(ctx, _stmts, _loc$5);
      }
      default: {
        break _L;
      }
    }
  }
  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(expr), "expression is not assignable");
  return undefined;
}
function hackwaly$tinycc$sem$sem_core$$stmt_expr_lvalue_type(ctx, stmts, loc) {
  hackwaly$tinycc$sem$sem_core$$record_stmt_expr(ctx);
  const return_type = hackwaly$tinycc$sem$sem_core$$current_return_type(ctx);
  hackwaly$tinycc$sem$sem_core$$push_scope(ctx);
  let result = undefined;
  const len = stmts.length;
  if (len === 0) {
    hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "statement expression is not assignable");
    return undefined;
  }
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      const stmt = moonbitlang$core$array$$Array$at$49$(stmts, i);
      if ((i + 1 | 0) === len) {
        if (stmt.$tag === 15) {
          const _ExprStmt = stmt;
          const _expr = _ExprStmt._0;
          result = hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, _expr);
        } else {
          hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, stmt, return_type);
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "statement expression is not assignable");
          result = undefined;
        }
      } else {
        hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, stmt, return_type);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
  return result;
}
function hackwaly$tinycc$sem$sem_core$$check_var_decl(ctx, decl, is_local) {
  hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, decl.ty, decl.loc);
  const resolved = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, decl.ty, decl.loc);
  const is_local$2 = is_local && moonbitlang$core$builtin$$Eq$not_equal$78$(decl.storage, 1);
  if (is_local$2) {
    hackwaly$tinycc$sem$sem_core$$record_local_decl(ctx);
    if (moonbitlang$core$builtin$$Eq$equal$79$(decl.storage, 2)) {
      hackwaly$tinycc$sem$sem_core$$record_static_local(ctx);
    }
  }
  const resolved_with_attrs = hackwaly$tinycc$frontend$ast$$apply_type_attrs(resolved, hackwaly$tinycc$frontend$ast$$type_attrs_from(decl.attrs));
  const resolved_with_sizes = hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, resolved_with_attrs, is_local$2, decl.storage, decl.loc);
  let final_ty = resolved_with_sizes;
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(resolved);
  if (_bind.$tag === 10) {
    const _Function = _bind;
    const _return_type = _Function._0;
    const _params = _Function._1;
    const _varargs = _Function._2;
    const _is_old_style = _Function._3;
    const _call_conv = _Function._4;
    hackwaly$tinycc$sem$sem_core$$check_storage_class(ctx, decl.storage, decl.loc, is_local$2, true);
    const _bind$2 = decl.init;
    if (_bind$2 === undefined) {
    } else {
      hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, decl.loc, "function declaration cannot have initializer");
    }
    const sig = { return_type: _return_type, params: _params, varargs: _varargs, is_old_style: _is_old_style, call_conv: _call_conv };
    hackwaly$tinycc$sem$sem_core$$add_function_sig(ctx, decl.name, decl.id, sig, decl.loc, false);
    return undefined;
  }
  hackwaly$tinycc$sem$sem_core$$check_storage_class(ctx, decl.storage, decl.loc, is_local$2, false);
  if (hackwaly$tinycc$sem$sem_core$$is_void_type(final_ty)) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, decl.loc, `variable '${decl.name}' has void type`);
  }
  if (is_local$2) {
    hackwaly$tinycc$sem$sem_core$$declare_local(ctx, decl.name, decl.id, final_ty, decl.loc);
  } else {
    hackwaly$tinycc$sem$sem_core$$declare_global(ctx, decl.name, decl.id, final_ty, decl.loc);
  }
  _L: {
    _L$2: {
      if (hackwaly$tinycc$sem$sem_core$$type_has_vla_object_size(final_ty)) {
        const _bind$2 = decl.init;
        if (_bind$2 === undefined) {
          break _L$2;
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, decl.loc, "variable length array cannot be initialized");
        }
      } else {
        break _L$2;
      }
      break _L;
    }
    const _bind$2 = decl.init;
    if (_bind$2 === undefined) {
    } else {
      const _Some = _bind$2;
      const _init = _Some;
      const _bind$3 = hackwaly$tinycc$sem$sem_core$$check_initializer(ctx, final_ty, _init, decl.loc);
      if (_bind$3 === undefined) {
      } else {
        const _Some$2 = _bind$3;
        const _size = _Some$2;
        const updated = hackwaly$tinycc$sem$sem_core$$apply_inferred_array_size(final_ty, _size);
        final_ty = updated;
        hackwaly$tinycc$sem$sem_core$$update_decl_type(ctx, decl.name, decl.id, updated, is_local$2);
      }
    }
  }
  _L$2: {
    if (moonbitlang$core$builtin$$Eq$not_equal$78$(decl.storage, 1)) {
      break _L$2;
    } else {
      const _bind$2 = decl.init;
      if (_bind$2 === undefined) {
        return;
      } else {
        break _L$2;
      }
    }
  }
  let allow_incomplete_array;
  if (!is_local$2) {
    const _bind$2 = decl.init;
    allow_incomplete_array = _bind$2 === undefined;
  } else {
    allow_incomplete_array = false;
  }
  hackwaly$tinycc$sem$sem_core$$require_complete_object_type$46$inner(ctx, final_ty, decl.loc, allow_incomplete_array);
}
function hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, ty, is_local, storage, loc) {
  switch (ty.$tag) {
    case 12: {
      const _Qualified = ty;
      const _qual = _Qualified._0;
      const _base = _Qualified._1;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, _base, is_local, storage, loc));
    }
    case 11: {
      const _Attributed = ty;
      const _attrs = _Attributed._0;
      const _base$2 = _Attributed._1;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs, hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, _base$2, is_local, storage, loc));
    }
    case 4: {
      const _Pointer = ty;
      const _inner = _Pointer._0;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, _inner, is_local, storage, loc));
    }
    case 10: {
      const _Function = ty;
      const _return_type = _Function._0;
      const _params = _Function._1;
      const _varargs = _Function._2;
      const _is_old_style = _Function._3;
      const _call_conv = _Function._4;
      const _p$28 = new Array(_params.length);
      const _p$29 = _params.length;
      let _tmp$27 = 0;
      while (true) {
        const _p$30 = _tmp$27;
        if (_p$30 < _p$29) {
          const _p$31 = _params[_p$30];
          _p$28[_p$30] = hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, _p$31, is_local, storage, loc);
          _tmp$27 = _p$30 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, _return_type, is_local, storage, loc), _p$28, _varargs, _is_old_style, _call_conv);
    }
    case 5: {
      const _Array = ty;
      const _elem = _Array._0;
      const _size = _Array._1;
      const _size_expr = _Array._2;
      const resolved_elem = hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, _elem, is_local, storage, loc);
      if (_size === undefined) {
        if (_size_expr === undefined) {
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, undefined, undefined);
        } else {
          const _Some = _size_expr;
          const _expr = _Some;
          if (hackwaly$tinycc$sem$sem_core$$decl_allows_vla(is_local, storage)) {
            if (hackwaly$tinycc$sem$sem_core$$is_constant_expr_for_builtin(ctx, _expr)) {
              const _bind = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value(ctx, _expr, hackwaly$tinycc$frontend$ast$$expr_loc(_expr));
              const _value = _bind._0;
              const _ok = _bind._1;
              if (!_ok) {
                return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, undefined, _size_expr);
              } else {
                if (_value < 0) {
                  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(_expr), "invalid array size");
                  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, undefined, _size_expr);
                } else {
                  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, _value, _size_expr);
                }
              }
            } else {
              const expr_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, _expr);
              if (!hackwaly$tinycc$sem$sem_core$$is_int_like(expr_ty)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(_expr), "size of variable length array should be an integer");
              }
              return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, undefined, _size_expr);
            }
          } else {
            const _bind = hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, _expr, hackwaly$tinycc$frontend$ast$$expr_loc(_expr));
            if (_bind === undefined) {
              return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, undefined, _size_expr);
            } else {
              const _Some$2 = _bind;
              const _value = _Some$2;
              if (_value < 0) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, hackwaly$tinycc$frontend$ast$$expr_loc(_expr), "invalid array size");
                return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, undefined, _size_expr);
              } else {
                return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, _value, _size_expr);
              }
            }
          }
        }
      } else {
        const _Some = _size;
        const _n = _Some;
        if (_n < 0) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid array size");
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, undefined, _size_expr);
        } else {
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(resolved_elem, _n, _size_expr);
        }
      }
    }
    default: {
      return ty;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$is_constant_expr_for_builtin(ctx, expr) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    switch (expr$2.$tag) {
      case 0: {
        return true;
      }
      case 2: {
        return true;
      }
      case 4: {
        const _Ident = expr$2;
        const _name = _Ident._0;
        const _id = _Ident._1;
        return hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, _name, _id);
      }
      case 9: {
        const _Unary = expr$2;
        const _op = _Unary._0;
        const _inner = _Unary._1;
        _L$2: {
          switch (_op) {
            case 0: {
              break _L$2;
            }
            case 1: {
              break _L$2;
            }
            case 3: {
              break _L$2;
            }
            case 2: {
              break _L$2;
            }
            default: {
              return false;
            }
          }
        }
        _tmp$27 = _inner;
        continue _L;
      }
      case 17: {
        const _Binary = expr$2;
        const _op$2 = _Binary._0;
        const _left = _Binary._1;
        const _right = _Binary._2;
        if (!hackwaly$tinycc$sem$sem_core$$is_constant_expr_for_builtin(ctx, _left) || !hackwaly$tinycc$sem$sem_core$$is_constant_expr_for_builtin(ctx, _right)) {
          return false;
        }
        _L$3: {
          switch (_op$2) {
            case 15: {
              break _L$3;
            }
            case 16: {
              break _L$3;
            }
            default: {
              return true;
            }
          }
        }
        const _bind = hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, _right);
        if (_bind === undefined) {
          return false;
        } else {
          const _Some = _bind;
          const _v = _Some;
          return _v !== 0;
        }
      }
      case 18: {
        const _Conditional = expr$2;
        const _cond = _Conditional._0;
        const _then_expr = _Conditional._1;
        const _else_expr = _Conditional._2;
        const _bind$2 = hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, _cond);
        if (_bind$2 === undefined) {
          return false;
        } else {
          const _Some = _bind$2;
          const _v = _Some;
          if (_v !== 0) {
            _tmp$27 = _then_expr;
            continue _L;
          } else {
            _tmp$27 = _else_expr;
            continue _L;
          }
        }
      }
      case 10: {
        const _Cast = expr$2;
        const _inner$2 = _Cast._1;
        _tmp$27 = _inner$2;
        continue _L;
      }
      case 13: {
        const _SizeofExpr = expr$2;
        const _inner$3 = _SizeofExpr._0;
        const _loc = _SizeofExpr._2;
        _L$4: {
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _inner$3));
          if (_bind$3.$tag === 5) {
            const _Array = _bind$3;
            const _x = _Array._1;
            if (_x === undefined) {
              const _x$2 = _Array._2;
              if (_x$2 === undefined) {
                break _L$4;
              } else {
                return false;
              }
            } else {
              break _L$4;
            }
          } else {
            break _L$4;
          }
        }
        const _bind$3 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _inner$3), _loc);
        return !(_bind$3 === undefined);
      }
      case 14: {
        const _SizeofType = expr$2;
        const _ty = _SizeofType._0;
        const _loc$2 = _SizeofType._2;
        _L$5: {
          const _bind$4 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty, _loc$2));
          if (_bind$4.$tag === 5) {
            const _Array = _bind$4;
            const _x = _Array._1;
            if (_x === undefined) {
              const _x$2 = _Array._2;
              if (_x$2 === undefined) {
                break _L$5;
              } else {
                return false;
              }
            } else {
              break _L$5;
            }
          } else {
            break _L$5;
          }
        }
        const _bind$4 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _ty, _loc$2);
        return !(_bind$4 === undefined);
      }
      case 15: {
        const _AlignofExpr = expr$2;
        const _inner$4 = _AlignofExpr._0;
        const _loc$3 = _AlignofExpr._2;
        const _bind$5 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _inner$4), _loc$3);
        return !(_bind$5 === undefined);
      }
      case 16: {
        const _AlignofType = expr$2;
        const _ty$2 = _AlignofType._0;
        const _loc$4 = _AlignofType._2;
        const _bind$6 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _ty$2, _loc$4);
        return !(_bind$6 === undefined);
      }
      case 6: {
        return true;
      }
      case 7: {
        return true;
      }
      case 19: {
        const _Call = expr$2;
        const _x = _Call._0;
        if (_x.$tag === 4) {
          const _Ident$2 = _x;
          const _name$2 = _Ident$2._0;
          const _id$2 = _Ident$2._1;
          const _args = _Call._1;
          const _bind$7 = hackwaly$tinycc$sem$sem_core$$builtin_call_kind(ctx, _name$2, _id$2);
          if (_bind$7 === undefined) {
            return false;
          } else {
            const _Some = _bind$7;
            const _x$2 = _Some;
            switch (_x$2) {
              case 0: {
                if (_args.length === 3) {
                  const _bind$8 = hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0));
                  if (_bind$8 === undefined) {
                    return false;
                  } else {
                    const _Some$2 = _bind$8;
                    const _v = _Some$2;
                    if (_v !== 0) {
                      _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 1);
                      continue _L;
                    } else {
                      _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 2);
                      continue _L;
                    }
                  }
                } else {
                  return false;
                }
              }
              case 1: {
                if (_args.length === 2) {
                  _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 0);
                  continue _L;
                } else {
                  return false;
                }
              }
              case 2: {
                return _args.length === 1;
              }
              default: {
                return false;
              }
            }
          }
        } else {
          return false;
        }
      }
      default: {
        return false;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, expr) {
  const prev = ctx.record_agg_temps;
  ctx.record_agg_temps = false;
  let ty;
  switch (expr.$tag) {
    case 4: {
      const _Ident = expr;
      const _name = _Ident._0;
      const _id = _Ident._1;
      const _loc = _Ident._3;
      const _bind = hackwaly$tinycc$sem$sem_core$$lookup_value(ctx, _name, _id);
      if (_bind === undefined) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, `use of undeclared identifier '${_name}'`);
        ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
      } else {
        const _Some = _bind;
        ty = _Some;
      }
      break;
    }
    case 3: {
      const _StringLit = expr;
      const _length = _StringLit._1;
      ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$sem$sem_core$$char_type_value, _length, undefined);
      break;
    }
    default: {
      const _bind$2 = hackwaly$tinycc$sem$sem_core$$type_of_lvalue_optional(ctx, expr);
      if (_bind$2 === undefined) {
        ty = hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, expr);
      } else {
        const _Some = _bind$2;
        ty = _Some;
      }
    }
  }
  ctx.record_agg_temps = prev;
  return ty;
}
function hackwaly$tinycc$sem$sem_core$$type_of_lvalue_optional(ctx, expr) {
  _L: {
    switch (expr.$tag) {
      case 4: {
        const _Ident = expr;
        const _name = _Ident._0;
        const _id = _Ident._1;
        if (hackwaly$tinycc$sem$sem_core$$enum_const_exists(ctx, _name, _id)) {
          return undefined;
        } else {
          const _bind = hackwaly$tinycc$sem$sem_core$$lookup_value(ctx, _name, _id);
          if (_bind === undefined) {
            return undefined;
          } else {
            const _Some = _bind;
            const _ty = _Some;
            return _ty;
          }
        }
      }
      case 20: {
        const _Index = expr;
        const _base = _Index._0;
        const _index = _Index._1;
        const _loc = _Index._3;
        const _bind = hackwaly$tinycc$sem$sem_core$$index_access_type(ctx, hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, _base), hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, _index), _loc);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _ty = _Some;
          return _ty;
        }
      }
      case 21: {
        const _Member = expr;
        const _base$2 = _Member._0;
        const _name$2 = _Member._1;
        const _id$2 = _Member._2;
        const _is_arrow = _Member._3;
        const _loc$2 = _Member._5;
        return hackwaly$tinycc$sem$sem_core$$member_access_type(ctx, hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, _base$2), _name$2, _id$2, _is_arrow, _loc$2);
      }
      case 9: {
        const _Unary = expr;
        const _x = _Unary._0;
        if (_x === 5) {
          const _inner = _Unary._1;
          const _loc$3 = _Unary._3;
          const inner_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr_impl(ctx, _inner);
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(inner_ty);
          if (_bind$2.$tag === 4) {
            const _Pointer = _bind$2;
            const _pointee = _Pointer._0;
            return _pointee;
          } else {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc$3, "cannot dereference non-pointer");
            return undefined;
          }
        } else {
          break _L;
        }
      }
      case 11: {
        const _CompoundLiteral = expr;
        const _ty = _CompoundLiteral._0;
        const _init = _CompoundLiteral._1;
        const _node_id = _CompoundLiteral._2;
        const _loc$3 = _CompoundLiteral._3;
        const resolved = hackwaly$tinycc$sem$sem_core$$compound_literal_type(ctx, _ty, _init, _loc$3, _node_id);
        hackwaly$tinycc$sem$sem_core$$record_compound_literal(ctx, _loc$3, _node_id, resolved);
        return resolved;
      }
      case 12: {
        const _StmtExpr = expr;
        const _stmts = _StmtExpr._0;
        const _loc$4 = _StmtExpr._2;
        return hackwaly$tinycc$sem$sem_core$$stmt_expr_lvalue_type(ctx, _stmts, _loc$4);
      }
      default: {
        break _L;
      }
    }
  }
  return undefined;
}
function hackwaly$tinycc$sem$sem_core$$type_of_compound_assign(ctx, op, left, right, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, left);
  let lhs_ty;
  if (_bind === undefined) {
    return hackwaly$tinycc$sem$sem_core$$default_int_type();
  } else {
    const _Some = _bind;
    lhs_ty = _Some;
  }
  _L: {
    _L$2: {
      const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(lhs_ty);
      switch (_bind$2.$tag) {
        case 5: {
          break _L$2;
        }
        case 10: {
          break _L$2;
        }
      }
      break _L;
    }
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "assignment to non-modifiable lvalue");
    return hackwaly$tinycc$sem$sem_core$$default_int_type();
  }
  const rhs_ty = hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, right);
  let result_ty;
  switch (op) {
    case 1: {
      const _bind$2 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(lhs_ty);
      if (_bind$2.$tag === 4) {
        const _Pointer = _bind$2;
        const _pointee = _Pointer._0;
        if (hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
          result_ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_pointee);
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '+='");
          result_ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
        }
      } else {
        if (hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty) && hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty)) {
          result_ty = hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs_ty, rhs_ty);
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '+='");
          result_ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
        }
      }
      break;
    }
    case 2: {
      const _bind$3 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(lhs_ty);
      if (_bind$3.$tag === 4) {
        const _Pointer = _bind$3;
        const _pointee = _Pointer._0;
        if (hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
          result_ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_pointee);
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '-='");
          result_ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
        }
      } else {
        if (hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty) && hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty)) {
          result_ty = hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs_ty, rhs_ty);
        } else {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '-='");
          result_ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
        }
      }
      break;
    }
    case 3: {
      if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '*='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    case 4: {
      if (!hackwaly$tinycc$sem$sem_core$$is_arithmetic(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_arithmetic(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '/='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$arithmetic_result_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    case 5: {
      if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '%='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    case 6: {
      if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '<<='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    case 7: {
      if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '>>='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    case 8: {
      if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '&='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    case 9: {
      if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '^='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    case 10: {
      if (!hackwaly$tinycc$sem$sem_core$$is_int_like(lhs_ty) || !hackwaly$tinycc$sem$sem_core$$is_int_like(rhs_ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "invalid operands to '|='");
      }
      result_ty = hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs_ty, rhs_ty);
      break;
    }
    default: {
      result_ty = hackwaly$tinycc$sem$sem_core$$default_int_type();
    }
  }
  if (hackwaly$tinycc$sem$sem_core$$is_const_qualified(lhs_ty)) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, "assignment to read-only location");
  }
  if (!hackwaly$tinycc$sem$sem_core$$can_assign(lhs_ty, result_ty)) {
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, `cannot assign '${hackwaly$tinycc$sem$sem_core$$type_to_string(result_ty)}' to '${hackwaly$tinycc$sem$sem_core$$type_to_string(lhs_ty)}'`);
  }
  return lhs_ty;
}
function hackwaly$tinycc$sem$sem_core$$strip_qualifiers(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _base = _Qualified._1;
        _tmp$27 = _base;
        continue _L;
      }
      case 11: {
        const _Attributed = ty$2;
        const _attrs = _Attributed._0;
        const _base$2 = _Attributed._1;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs, hackwaly$tinycc$sem$sem_core$$strip_qualifiers(_base$2));
      }
      case 4: {
        const _Pointer = ty$2;
        const _inner = _Pointer._0;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$sem$sem_core$$strip_qualifiers(_inner));
      }
      case 5: {
        const _Array = ty$2;
        const _elem = _Array._0;
        const _size = _Array._1;
        const _size_expr = _Array._2;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$sem$sem_core$$strip_qualifiers(_elem), _size, _size_expr);
      }
      case 10: {
        const _Function = ty$2;
        const _return_type = _Function._0;
        const _params = _Function._1;
        const _varargs = _Function._2;
        const _is_old_style = _Function._3;
        const _call_conv = _Function._4;
        const _p$28 = new Array(_params.length);
        const _p$29 = _params.length;
        let _tmp$28 = 0;
        while (true) {
          const _p$30 = _tmp$28;
          if (_p$30 < _p$29) {
            const _p$31 = _params[_p$30];
            _p$28[_p$30] = hackwaly$tinycc$sem$sem_core$$strip_qualifiers(_p$31);
            _tmp$28 = _p$30 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(hackwaly$tinycc$sem$sem_core$$strip_qualifiers(_return_type), _p$28, _varargs, _is_old_style, _call_conv);
      }
      default: {
        return ty$2;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$strip_qual_attrs(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _base = _Qualified._1;
        _tmp$27 = _base;
        continue _L;
      }
      case 11: {
        const _Attributed = ty$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      case 4: {
        const _Pointer = ty$2;
        const _inner = _Pointer._0;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$sem$sem_core$$strip_qual_attrs(_inner));
      }
      case 5: {
        const _Array = ty$2;
        const _elem = _Array._0;
        const _size = _Array._1;
        const _size_expr = _Array._2;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$sem$sem_core$$strip_qual_attrs(_elem), _size, _size_expr);
      }
      case 10: {
        const _Function = ty$2;
        const _return_type = _Function._0;
        const _params = _Function._1;
        const _varargs = _Function._2;
        const _is_old_style = _Function._3;
        const _call_conv = _Function._4;
        const _p$28 = new Array(_params.length);
        const _p$29 = _params.length;
        let _tmp$28 = 0;
        while (true) {
          const _p$30 = _tmp$28;
          if (_p$30 < _p$29) {
            const _p$31 = _params[_p$30];
            _p$28[_p$30] = hackwaly$tinycc$sem$sem_core$$strip_qual_attrs(_p$31);
            _tmp$28 = _p$30 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(hackwaly$tinycc$sem$sem_core$$strip_qual_attrs(_return_type), _p$28, _varargs, _is_old_style, _call_conv);
      }
      default: {
        return ty$2;
      }
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$type_contains_vla(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    let elem;
    _L$2: {
      const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty$2);
      switch (_bind.$tag) {
        case 5: {
          const _Array = _bind;
          const _x = _Array._1;
          if (_x === undefined) {
            const _x$2 = _Array._2;
            if (_x$2 === undefined) {
              const _elem = _Array._0;
              elem = _elem;
              break _L$2;
            } else {
              return true;
            }
          } else {
            const _elem = _Array._0;
            elem = _elem;
            break _L$2;
          }
        }
        case 4: {
          const _Pointer = _bind;
          const _inner = _Pointer._0;
          _tmp$27 = _inner;
          continue _L;
        }
        case 10: {
          const _Function = _bind;
          const _return_type = _Function._0;
          const _params = _Function._1;
          return hackwaly$tinycc$sem$sem_core$$type_contains_vla(_return_type) || moonbitlang$core$array$$Array$any$119$(_params, hackwaly$tinycc$sem$sem_core$$type_contains_vla);
        }
        case 12: {
          const _Qualified = _bind;
          const _base = _Qualified._1;
          _tmp$27 = _base;
          continue _L;
        }
        case 11: {
          const _Attributed = _bind;
          const _base$2 = _Attributed._1;
          _tmp$27 = _base$2;
          continue _L;
        }
        default: {
          return false;
        }
      }
    }
    _tmp$27 = elem;
    continue;
  }
}
function hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_local(ty) {
  switch (ty.$tag) {
    case 12: {
      const _Qualified = ty;
      const _qual = _Qualified._0;
      const _base = _Qualified._1;
      const adjusted = hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_local(_base);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, adjusted);
    }
    case 11: {
      const _Attributed = ty;
      const _attrs = _Attributed._0;
      const _base$2 = _Attributed._1;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs, hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_local(_base$2));
    }
    case 5: {
      const _Array = ty;
      const _elem = _Array._0;
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(_elem);
    }
    case 10: {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(ty);
    }
    default: {
      return ty;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_sig(ty) {
  const adjusted = hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_local(ty);
  return hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(adjusted);
}
function hackwaly$tinycc$sem$sem_core$$func_sig_from_params(return_type, params, varargs, is_old_style, call_conv) {
  const _p$28 = new Array(params.length);
  const _p$29 = params.length;
  let _tmp$27 = 0;
  while (true) {
    const _p$30 = _tmp$27;
    if (_p$30 < _p$29) {
      const _p$31 = params[_p$30];
      _p$28[_p$30] = hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_sig(_p$31.ty);
      _tmp$27 = _p$30 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const param_types = _p$28;
  return { return_type: return_type, params: param_types, varargs: varargs, is_old_style: is_old_style, call_conv: call_conv };
}
function hackwaly$tinycc$sem$sem_core$$check_func_decl(ctx, func_decl) {
  hackwaly$tinycc$sem$sem_core$$check_storage_class(ctx, func_decl.storage, func_decl.loc, false, true);
  const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(func_decl.attrs.call_conv);
  const resolved_return = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, func_decl.return_type, func_decl.loc);
  const _p$28 = func_decl.params;
  const _p$29 = new Array(_p$28.length);
  const _p$30 = _p$28.length;
  let _tmp$27 = 0;
  while (true) {
    const _p$31 = _tmp$27;
    if (_p$31 < _p$30) {
      const _p$32 = _p$28[_p$31];
      _p$29[_p$31] = { name: _p$32.name, id: _p$32.id, ty: hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _p$32.ty, _p$32.loc), loc: _p$32.loc };
      _tmp$27 = _p$31 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const params = _p$29;
  const _len = params.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len) {
      const param = params[_i];
      if (hackwaly$tinycc$sem$sem_core$$is_void_type(param.ty)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, param.loc, "parameter declared as void");
      }
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const sig = hackwaly$tinycc$sem$sem_core$$func_sig_from_params(resolved_return, params, func_decl.varargs, func_decl.is_old_style, call_conv);
  hackwaly$tinycc$sem$sem_core$$add_function_sig(ctx, func_decl.name, func_decl.id, sig, func_decl.loc, false);
}
function hackwaly$tinycc$sem$sem_core$$check_label_uses(ctx) {
  const _arr = ctx.labels_used;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const item = _arr[_i];
      const _name = item._0;
      const _loc = item._1;
      if (!moonbitlang$core$hashmap$$HashMap$contains$161$(ctx.labels_defined, _name)) {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, _loc, `undefined label '${_name}'`);
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$promote_old_style_param_type(ty) {
  _L: {
    switch (ty.$tag) {
      case 12: {
        const _Qualified = ty;
        const _qual = _Qualified._0;
        const _base = _Qualified._1;
        const updated = hackwaly$tinycc$sem$sem_core$$promote_old_style_param_type(_base);
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, updated);
      }
      case 11: {
        const _Attributed = ty;
        const _attrs = _Attributed._0;
        const _base$2 = _Attributed._1;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs, hackwaly$tinycc$sem$sem_core$$promote_old_style_param_type(_base$2));
      }
      case 3: {
        const _Float = ty;
        const _x = _Float._0;
        if (_x === 0) {
          return hackwaly$tinycc$sem$sem_core$$promote_old_style_param_type$46$constr$47$8858;
        } else {
          break _L;
        }
      }
      default: {
        break _L;
      }
    }
  }
  return ty;
}
function hackwaly$tinycc$sem$sem_core$$promote_old_style_params(params) {
  const _p$28 = new Array(params.length);
  const _p$29 = params.length;
  let _tmp$27 = 0;
  while (true) {
    const _p$30 = _tmp$27;
    if (_p$30 < _p$29) {
      const _p$31 = params[_p$30];
      _p$28[_p$30] = { name: _p$31.name, id: _p$31.id, ty: hackwaly$tinycc$sem$sem_core$$promote_old_style_param_type(_p$31.ty), loc: _p$31.loc };
      _tmp$27 = _p$30 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return _p$28;
}
function hackwaly$tinycc$sem$sem_core$$check_func_def(ctx, func_def) {
  hackwaly$tinycc$sem$sem_core$$check_storage_class(ctx, func_def.storage, func_def.loc, false, true);
  const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(func_def.attrs.call_conv);
  const resolved_return = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, func_def.return_type, func_def.loc);
  const _p$28 = func_def.params;
  const _p$29 = new Array(_p$28.length);
  const _p$30 = _p$28.length;
  let _tmp$27 = 0;
  while (true) {
    const _p$31 = _tmp$27;
    if (_p$31 < _p$30) {
      const _p$32 = _p$28[_p$31];
      _p$29[_p$31] = { name: _p$32.name, id: _p$32.id, ty: hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _p$32.ty, _p$32.loc), loc: _p$32.loc };
      _tmp$27 = _p$31 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const resolved_params = _p$29;
  const params = func_def.is_old_style ? hackwaly$tinycc$sem$sem_core$$promote_old_style_params(resolved_params) : resolved_params;
  const sig = hackwaly$tinycc$sem$sem_core$$func_sig_from_params(resolved_return, params, func_def.varargs, func_def.is_old_style, call_conv);
  hackwaly$tinycc$sem$sem_core$$add_function_sig(ctx, func_def.name, func_def.id, sig, func_def.loc, true);
  const prev_func = ctx.current_func_name;
  const prev_func_id = ctx.current_func_id;
  const prev_agg_size = ctx.current_agg_temp_size;
  const prev_agg_align = ctx.current_agg_temp_align;
  ctx.current_func_name = func_def.name;
  ctx.current_func_id = func_def.id;
  ctx.current_agg_temp_size = 0;
  ctx.current_agg_temp_align = 1;
  ctx.labels_defined = hackwaly$tinycc$support$util$$fast_map_new$161$(undefined);
  ctx.labels_used = [];
  ctx.loop_depth = 0;
  ctx.switch_depth = 0;
  hackwaly$tinycc$sem$sem_core$$push_scope(ctx);
  const func_name_ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$frontend$ast$$apply_qualifiers(hackwaly$tinycc$sem$sem_core$$char_type_value, hackwaly$tinycc$frontend$ast$$with_const(hackwaly$tinycc$frontend$ast$$empty_qual())), func_def.name.length + 1 | 0, undefined);
  hackwaly$tinycc$sem$sem_core$$declare_local(ctx, "__func__", 0, func_name_ty, func_def.loc);
  hackwaly$tinycc$sem$sem_core$$declare_local(ctx, "__FUNCTION__", 0, func_name_ty, func_def.loc);
  hackwaly$tinycc$sem$sem_core$$declare_local(ctx, "__PRETTY_FUNCTION__", 0, func_name_ty, func_def.loc);
  const _len = params.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len) {
      const param = params[_i];
      if (param.name === "") {
        hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, param.loc, "parameter name missing in definition");
      } else {
        if (hackwaly$tinycc$sem$sem_core$$is_void_type(param.ty)) {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, param.loc, "parameter declared as void");
        } else {
          const param_ty = hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_local(param.ty);
          hackwaly$tinycc$sem$sem_core$$declare_local(ctx, param.name, param.id, param_ty, param.loc);
        }
      }
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$sem$sem_core$$check_stmt(ctx, func_def.body, resolved_return);
  hackwaly$tinycc$sem$sem_core$$check_label_uses(ctx);
  if (func_def.id > 0) {
    hackwaly$tinycc$sem$sem_core$$set_opt_by_id$68$(ctx.func_agg_temps_by_id, func_def.id, { _0: ctx.current_agg_temp_size, _1: ctx.current_agg_temp_align });
  } else {
    moonbitlang$core$hashmap$$HashMap$set$165$(ctx.func_agg_temps, func_def.name, { _0: ctx.current_agg_temp_size, _1: ctx.current_agg_temp_align });
  }
  ctx.current_agg_temp_size = prev_agg_size;
  ctx.current_agg_temp_align = prev_agg_align;
  ctx.current_func_name = prev_func;
  ctx.current_func_id = prev_func_id;
  hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
}
function hackwaly$tinycc$sem$sem_core$$check_decl(ctx, decl) {
  switch (decl.$tag) {
    case 2: {
      const _Var = decl;
      const _var_decl = _Var._0;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _var_decl.ty, _var_decl.loc);
      hackwaly$tinycc$sem$sem_core$$check_var_decl(ctx, _var_decl, false);
      return;
    }
    case 1: {
      const _FuncDecl = decl;
      const _func_decl = _FuncDecl._0;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _func_decl.return_type, _func_decl.loc);
      const _arr = _func_decl.params;
      const _len = _arr.length;
      let _tmp$27 = 0;
      while (true) {
        const _i = _tmp$27;
        if (_i < _len) {
          const param = _arr[_i];
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, param.ty, param.loc);
          _tmp$27 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      hackwaly$tinycc$sem$sem_core$$check_func_decl(ctx, _func_decl);
      return;
    }
    case 0: {
      const _FuncDef = decl;
      const _func_def = _FuncDef._0;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _func_def.return_type, _func_def.loc);
      const _arr$2 = _func_def.params;
      const _len$2 = _arr$2.length;
      let _tmp$28 = 0;
      while (true) {
        const _i = _tmp$28;
        if (_i < _len$2) {
          const param = _arr$2[_i];
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, param.ty, param.loc);
          _tmp$28 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      hackwaly$tinycc$sem$sem_core$$check_func_def(ctx, _func_def);
      return;
    }
    case 3: {
      const _Typedef = decl;
      const _name = _Typedef._0;
      const _ty = _Typedef._1;
      const _attrs = _Typedef._2;
      const _loc = _Typedef._3;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty, _loc);
      const resolved = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty, _loc);
      const resolved_with_attrs = hackwaly$tinycc$frontend$ast$$apply_type_attrs(resolved, hackwaly$tinycc$frontend$ast$$type_attrs_from(_attrs));
      const final_ty = hackwaly$tinycc$sem$sem_core$$resolve_array_sizes_for_decl(ctx, resolved_with_attrs, false, 0, _loc);
      moonbitlang$core$hashmap$$HashMap$set$159$(ctx.type_aliases, _name, final_ty);
      return;
    }
    case 4: {
      const _TagDef = decl;
      const _ty$2 = _TagDef._0;
      const _loc$2 = _TagDef._1;
      hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$2, _loc$2);
      return;
    }
    case 5: {
      const _StaticAssert = decl;
      const _static_assert = _StaticAssert._0;
      hackwaly$tinycc$sem$sem_core$$check_static_assert(ctx, _static_assert);
      return;
    }
    default: {
      const _Asm = decl;
      const _asm_stmt = _Asm._0;
      hackwaly$tinycc$sem$sem_core$$check_asm_stmt(ctx, _asm_stmt);
      return;
    }
  }
}
function hackwaly$tinycc$sem$sem_core$$check_translation_unit(unit, diags) {
  const ctx = hackwaly$tinycc$sem$sem_core$$new_sem_context(diags);
  hackwaly$tinycc$sem$sem_core$$ensure_expr_type_cache(ctx, unit.expr_id_max);
  const _arr = unit.decls;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const decl = _arr[_i];
      hackwaly$tinycc$sem$sem_core$$check_decl(ctx, decl);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return ctx;
}
function hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, expr, loc) {
  let _tmp$27 = expr;
  let _tmp$28 = loc;
  _L: while (true) {
    const expr$2 = _tmp$27;
    const loc$2 = _tmp$28;
    _L$2: {
      switch (expr$2.$tag) {
        case 0: {
          const _IntLit = expr$2;
          const _value = _IntLit._0;
          return { _0: hackwaly$tinycc$sem$sem_core$$parse_uint64_value(_value), _1: true };
        }
        case 2: {
          const _CharLit = expr$2;
          const _value$2 = _CharLit._0;
          return { _0: moonbitlang$core$int$$Int$to_int64(_value$2), _1: true };
        }
        case 1: {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
          return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8932;
        }
        case 3: {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
          return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8933;
        }
        case 4: {
          const _Ident = expr$2;
          const _name = _Ident._0;
          const _id = _Ident._1;
          const _bind = hackwaly$tinycc$sem$sem_core$$enum_const_value(ctx, _name, _id);
          if (_bind === undefined) {
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8934;
          } else {
            const _Some = _bind;
            const _v = _Some;
            return { _0: moonbitlang$core$int$$Int$to_int64(_v), _1: true };
          }
        }
        case 6: {
          const _BuiltinTypesCompatibleP = expr$2;
          const _a = _BuiltinTypesCompatibleP._0;
          const _b = _BuiltinTypesCompatibleP._1;
          const _type_loc = _BuiltinTypesCompatibleP._3;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _a, _type_loc);
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _b, _type_loc);
          const lhs = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _a, _type_loc);
          const rhs = hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _b, _type_loc);
          return { _0: hackwaly$tinycc$sem$sem_core$$types_compatible_for_decl(lhs, rhs) ? $1L : $0L, _1: true };
        }
        case 7: {
          const _BuiltinOffsetof = expr$2;
          const _ty = _BuiltinOffsetof._0;
          const _path = _BuiltinOffsetof._1;
          const _type_loc$2 = _BuiltinOffsetof._3;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty, _type_loc$2);
          const _bind$2 = hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof(ctx, _ty, _path, _type_loc$2);
          if (_bind$2 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8935;
          } else {
            const _Some = _bind$2;
            const _v = _Some;
            return { _0: moonbitlang$core$int$$Int$to_int64(_v), _1: true };
          }
        }
        case 8: {
          hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
          return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8936;
        }
        case 9: {
          const _Unary = expr$2;
          const _op = _Unary._0;
          const _expr = _Unary._1;
          const _bind$3 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, _expr, loc$2);
          const _v = _bind$3._0;
          const _ok = _bind$3._1;
          if (!_ok) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8937;
          }
          switch (_op) {
            case 0: {
              return { _0: _v, _1: true };
            }
            case 1: {
              return { _0: moonbitlang$core$builtin$$Sub$sub$7$($0L, _v), _1: true };
            }
            case 3: {
              return { _0: moonbitlang$core$builtin$$BitXOr$lxor$7$(_v, $_1L), _1: true };
            }
            case 2: {
              return { _0: moonbitlang$core$builtin$$Eq$equal$7$(_v, $0L) ? $1L : $0L, _1: true };
            }
            default: {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
              return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8938;
            }
          }
        }
        case 17: {
          const _Binary = expr$2;
          const _op$2 = _Binary._0;
          const _left = _Binary._1;
          const _right = _Binary._2;
          const _bind$4 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, _left, loc$2);
          const _lhs = _bind$4._0;
          const _ok_lhs = _bind$4._1;
          const _bind$5 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, _right, loc$2);
          const _rhs = _bind$5._0;
          const _ok_rhs = _bind$5._1;
          if (!_ok_lhs || !_ok_rhs) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8939;
          }
          switch (_op$2) {
            case 12: {
              return { _0: moonbitlang$core$builtin$$Add$add$7$(_lhs, _rhs), _1: true };
            }
            case 13: {
              return { _0: moonbitlang$core$builtin$$Sub$sub$7$(_lhs, _rhs), _1: true };
            }
            case 14: {
              return { _0: moonbitlang$core$builtin$$Mul$mul$7$(_lhs, _rhs), _1: true };
            }
            case 15: {
              if (moonbitlang$core$builtin$$Eq$equal$7$(_rhs, $0L)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "division by zero in constant expression");
                return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8940;
              } else {
                return { _0: moonbitlang$core$builtin$$Div$div$7$(_lhs, _rhs), _1: true };
              }
            }
            case 16: {
              if (moonbitlang$core$builtin$$Eq$equal$7$(_rhs, $0L)) {
                hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "division by zero in constant expression");
                return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8941;
              } else {
                return { _0: moonbitlang$core$builtin$$Mod$mod$7$(_lhs, _rhs), _1: true };
              }
            }
            case 17: {
              return { _0: moonbitlang$core$builtin$$Shl$shl$7$(_lhs, moonbitlang$core$int64$$Int64$to_int(_rhs)), _1: true };
            }
            case 18: {
              return { _0: moonbitlang$core$builtin$$Shr$shr$7$(_lhs, moonbitlang$core$int64$$Int64$to_int(_rhs)), _1: true };
            }
            case 25: {
              return { _0: moonbitlang$core$builtin$$BitAnd$land$7$(_lhs, _rhs), _1: true };
            }
            case 27: {
              return { _0: moonbitlang$core$builtin$$BitOr$lor$7$(_lhs, _rhs), _1: true };
            }
            case 26: {
              return { _0: moonbitlang$core$builtin$$BitXOr$lxor$7$(_lhs, _rhs), _1: true };
            }
            case 19: {
              return { _0: moonbitlang$core$builtin$$Eq$equal$7$(_lhs, _rhs) ? $1L : $0L, _1: true };
            }
            case 20: {
              return { _0: moonbitlang$core$builtin$$Eq$not_equal$81$(_lhs, _rhs) ? $1L : $0L, _1: true };
            }
            case 21: {
              return { _0: moonbitlang$core$builtin$$Compare$op_lt$81$(_lhs, _rhs) ? $1L : $0L, _1: true };
            }
            case 22: {
              return { _0: moonbitlang$core$builtin$$Compare$op_le$81$(_lhs, _rhs) ? $1L : $0L, _1: true };
            }
            case 23: {
              return { _0: moonbitlang$core$builtin$$Compare$op_gt$81$(_lhs, _rhs) ? $1L : $0L, _1: true };
            }
            case 24: {
              return { _0: moonbitlang$core$builtin$$Compare$op_ge$81$(_lhs, _rhs) ? $1L : $0L, _1: true };
            }
            case 28: {
              return { _0: moonbitlang$core$builtin$$Eq$not_equal$81$(_lhs, $0L) && moonbitlang$core$builtin$$Eq$not_equal$81$(_rhs, $0L) ? $1L : $0L, _1: true };
            }
            case 29: {
              return { _0: moonbitlang$core$builtin$$Eq$not_equal$81$(_lhs, $0L) || moonbitlang$core$builtin$$Eq$not_equal$81$(_rhs, $0L) ? $1L : $0L, _1: true };
            }
            case 11: {
              return { _0: _rhs, _1: true };
            }
            default: {
              hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
              return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8942;
            }
          }
        }
        case 18: {
          const _Conditional = expr$2;
          const _cond = _Conditional._0;
          const _then_expr = _Conditional._1;
          const _else_expr = _Conditional._2;
          const _bind$6 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, _cond, loc$2);
          const _cond_val = _bind$6._0;
          const _ok$2 = _bind$6._1;
          if (!_ok$2) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8943;
          }
          if (moonbitlang$core$builtin$$Eq$not_equal$81$(_cond_val, $0L)) {
            _tmp$27 = _then_expr;
            continue _L;
          } else {
            _tmp$27 = _else_expr;
            continue _L;
          }
        }
        case 10: {
          const _Cast = expr$2;
          const _ty$2 = _Cast._0;
          const _expr$2 = _Cast._1;
          const _bind$7 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, _expr$2, loc$2);
          const _v$2 = _bind$7._0;
          const _ok$3 = _bind$7._1;
          if (!_ok$3) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8944;
          }
          return hackwaly$tinycc$sem$sem_core$$cast_const_int64_value(ctx, _v$2, _ty$2, loc$2);
        }
        case 13: {
          const _SizeofExpr = expr$2;
          const _expr$3 = _SizeofExpr._0;
          const _loc = _SizeofExpr._2;
          const ty = hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _expr$3);
          _L$3: {
            const _bind$8 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
            if (_bind$8.$tag === 5) {
              const _Array = _bind$8;
              const _x = _Array._1;
              if (_x === undefined) {
                const _x$2 = _Array._2;
                if (_x$2 === undefined) {
                  break _L$3;
                } else {
                  return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8946;
                }
              } else {
                break _L$3;
              }
            } else {
              break _L$3;
            }
          }
          const _bind$8 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty, _loc);
          if (_bind$8 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8945;
          } else {
            const _Some = _bind$8;
            const _x = _Some;
            const _size = _x._0;
            return { _0: moonbitlang$core$int$$Int$to_int64(_size), _1: true };
          }
        }
        case 14: {
          const _SizeofType = expr$2;
          const _ty$3 = _SizeofType._0;
          const _loc$2 = _SizeofType._2;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$3, _loc$2);
          _L$4: {
            const _bind$9 = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, _ty$3, _loc$2));
            if (_bind$9.$tag === 5) {
              const _Array = _bind$9;
              const _x = _Array._1;
              if (_x === undefined) {
                const _x$2 = _Array._2;
                if (_x$2 === undefined) {
                  break _L$4;
                } else {
                  return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8948;
                }
              } else {
                break _L$4;
              }
            } else {
              break _L$4;
            }
          }
          const _bind$9 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _ty$3, _loc$2);
          if (_bind$9 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8947;
          } else {
            const _Some = _bind$9;
            const _x = _Some;
            const _size = _x._0;
            return { _0: moonbitlang$core$int$$Int$to_int64(_size), _1: true };
          }
        }
        case 15: {
          const _AlignofExpr = expr$2;
          const _expr$4 = _AlignofExpr._0;
          const _loc$3 = _AlignofExpr._2;
          const ty$2 = hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, _expr$4);
          const _bind$10 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty$2, _loc$3);
          if (_bind$10 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8949;
          } else {
            const _Some = _bind$10;
            const _x = _Some;
            const _align = _x._1;
            return { _0: moonbitlang$core$int$$Int$to_int64(_align), _1: true };
          }
        }
        case 16: {
          const _AlignofType = expr$2;
          const _ty$4 = _AlignofType._0;
          const _loc$4 = _AlignofType._2;
          hackwaly$tinycc$sem$sem_core$$register_type_defs(ctx, _ty$4, _loc$4);
          const _bind$11 = hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, _ty$4, _loc$4);
          if (_bind$11 === undefined) {
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8950;
          } else {
            const _Some = _bind$11;
            const _x = _Some;
            const _align = _x._1;
            return { _0: moonbitlang$core$int$$Int$to_int64(_align), _1: true };
          }
        }
        case 19: {
          const _Call = expr$2;
          const _x = _Call._0;
          if (_x.$tag === 4) {
            const _Ident$2 = _x;
            const _name$2 = _Ident$2._0;
            const _id$2 = _Ident$2._1;
            const _args = _Call._1;
            const _call_loc = _Call._3;
            _L$5: {
              const _bind$12 = hackwaly$tinycc$sem$sem_core$$builtin_call_kind(ctx, _name$2, _id$2);
              if (_bind$12 === undefined) {
                break _L$5;
              } else {
                const _Some = _bind$12;
                const _x$2 = _Some;
                switch (_x$2) {
                  case 0: {
                    if (_args.length === 3) {
                      const _bind$13 = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0), _call_loc);
                      const _cond_val$2 = _bind$13._0;
                      const _ok$4 = _bind$13._1;
                      if (!_ok$4) {
                        return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8952;
                      }
                      if (moonbitlang$core$builtin$$Eq$not_equal$81$(_cond_val$2, $0L)) {
                        _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 1);
                        _tmp$28 = _call_loc;
                        continue _L;
                      } else {
                        _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 2);
                        _tmp$28 = _call_loc;
                        continue _L;
                      }
                    } else {
                      break _L$5;
                    }
                  }
                  case 1: {
                    if (_args.length === 2) {
                      _tmp$27 = moonbitlang$core$array$$Array$at$55$(_args, 0);
                      _tmp$28 = _call_loc;
                      continue _L;
                    } else {
                      break _L$5;
                    }
                  }
                  case 2: {
                    if (_args.length === 1) {
                      return { _0: hackwaly$tinycc$sem$sem_core$$is_constant_expr_for_builtin(ctx, moonbitlang$core$array$$Array$at$55$(_args, 0)) ? $1L : $0L, _1: true };
                    } else {
                      break _L$5;
                    }
                  }
                  default: {
                    break _L$5;
                  }
                }
              }
            }
            hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
            return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8951;
          } else {
            break _L$2;
          }
        }
        default: {
          break _L$2;
        }
      }
    }
    hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc$2, "invalid constant expression");
    return hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64$46$tuple$47$8931;
  }
}
function hackwaly$tinycc$sem$sem_core$$const_int64_from_expr(ctx, expr, loc) {
  const _bind = hackwaly$tinycc$sem$sem_core$$eval_const_expr_value_i64(ctx, expr, loc);
  const _value = _bind._0;
  const _ok = _bind._1;
  return _ok ? _value : undefined;
}
function hackwaly$tinycc$sem$sem_core$$is_char_type(ty) {
  const _bind = hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
  if (_bind.$tag === 2) {
    const _Int = _bind;
    const _x = _Int._0;
    if (_x === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}
function hackwaly$tinycc$sem$$add_sem_error(ctx, loc, msg) {
  hackwaly$tinycc$sem$sem_core$$add_sem_error(ctx, loc, msg);
}
function hackwaly$tinycc$sem$$adjust_param_type_for_local(ty) {
  return hackwaly$tinycc$sem$sem_core$$adjust_param_type_for_local(ty);
}
function hackwaly$tinycc$sem$$align_to(value, align) {
  return hackwaly$tinycc$sem$sem_core$$align_to(value, align);
}
function hackwaly$tinycc$sem$$apply_inferred_array_size(ty, size) {
  return hackwaly$tinycc$sem$sem_core$$apply_inferred_array_size(ty, size);
}
function hackwaly$tinycc$sem$$atomic_builtin_return_type(ctx, name, id, args, loc) {
  return hackwaly$tinycc$sem$sem_core$$atomic_builtin_return_type(ctx, name, id, args, loc);
}
function hackwaly$tinycc$sem$$atomic_builtin_template_from_ident(ctx, name, id) {
  return hackwaly$tinycc$sem$sem_core$$atomic_builtin_template_from_ident(ctx, name, id);
}
function hackwaly$tinycc$sem$$attr_align_value(ctx, attrs, loc) {
  return hackwaly$tinycc$sem$sem_core$$attr_align_value(ctx, attrs, loc);
}
function hackwaly$tinycc$sem$$attrs_layout_empty(attrs) {
  const _p$28 = attrs.aligned;
  return _p$28 === undefined ? !attrs.packed : false;
}
function hackwaly$tinycc$sem$$builtin_call_kind(ctx, name, id) {
  return hackwaly$tinycc$sem$sem_core$$builtin_call_kind(ctx, name, id);
}
function hackwaly$tinycc$sem$$check_translation_unit(unit, bag) {
  return hackwaly$tinycc$sem$sem_core$$check_translation_unit(unit, bag);
}
function hackwaly$tinycc$sem$$common_int_type(ctx, lhs, rhs) {
  return hackwaly$tinycc$sem$sem_core$$common_int_type(ctx, lhs, rhs);
}
function hackwaly$tinycc$sem$$compound_literal_key(id) {
  return id;
}
function hackwaly$tinycc$sem$$compound_literal_type(ctx, ty, init, loc, node_id) {
  return hackwaly$tinycc$sem$sem_core$$compound_literal_type(ctx, ty, init, loc, node_id);
}
function hackwaly$tinycc$sem$$const_int64_from_expr(ctx, expr, loc) {
  return hackwaly$tinycc$sem$sem_core$$const_int64_from_expr(ctx, expr, loc);
}
function hackwaly$tinycc$sem$$const_int_from_expr(ctx, expr, loc) {
  return hackwaly$tinycc$sem$sem_core$$const_int_from_expr(ctx, expr, loc);
}
function hackwaly$tinycc$sem$$current_local_scope_id(ctx) {
  return hackwaly$tinycc$sem$sem_core$$current_local_scope_id(ctx);
}
function hackwaly$tinycc$sem$$decay_type(ty) {
  return hackwaly$tinycc$sem$sem_core$$decay_type(ty);
}
function hackwaly$tinycc$sem$$default_int_type() {
  return hackwaly$tinycc$sem$sem_core$$default_int_type();
}
function hackwaly$tinycc$sem$$ensure_struct_fields(ctx, name, id, items, is_union, loc) {
  return hackwaly$tinycc$sem$sem_core$$ensure_struct_fields(ctx, name, id, items, is_union, loc);
}
function hackwaly$tinycc$sem$$enum_const_value(ctx, name, id) {
  return hackwaly$tinycc$sem$sem_core$$enum_const_value(ctx, name, id);
}
function hackwaly$tinycc$sem$$eval_builtin_offsetof(ctx, ty, path, loc) {
  return hackwaly$tinycc$sem$sem_core$$eval_builtin_offsetof(ctx, ty, path, loc);
}
function hackwaly$tinycc$sem$$find_field_index_cached(ctx, ty, name, id, loc) {
  return hackwaly$tinycc$sem$sem_core$$find_field_index_cached(ctx, ty, name, id, loc);
}
function hackwaly$tinycc$sem$$float_size(kind) {
  return hackwaly$tinycc$sem$sem_core$$float_size(kind);
}
function hackwaly$tinycc$sem$$get_function_by_id(ctx, id) {
  return hackwaly$tinycc$sem$sem_core$$get_function_by_id(ctx, id);
}
function hackwaly$tinycc$sem$$get_global_by_id(ctx, id) {
  return hackwaly$tinycc$sem$sem_core$$get_global_by_id(ctx, id);
}
function hackwaly$tinycc$sem$$get_opt_by_id$67$(arr, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$67$(arr, id);
}
function hackwaly$tinycc$sem$$get_opt_by_id$188$(arr, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$188$(arr, id);
}
function hackwaly$tinycc$sem$$get_opt_by_id$68$(arr, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$68$(arr, id);
}
function hackwaly$tinycc$sem$$get_opt_by_id$189$(arr, id) {
  return hackwaly$tinycc$sem$sem_core$$get_opt_by_id$189$(arr, id);
}
function hackwaly$tinycc$sem$$has_function_by_id(ctx, id) {
  return hackwaly$tinycc$sem$sem_core$$has_function_by_id(ctx, id);
}
function hackwaly$tinycc$sem$$has_opt_by_id$183$(arr, id) {
  return hackwaly$tinycc$sem$sem_core$$has_opt_by_id$183$(arr, id);
}
function hackwaly$tinycc$sem$$int_size(kind) {
  return hackwaly$tinycc$sem$sem_core$$int_size(kind);
}
function hackwaly$tinycc$sem$$is_char_type(ty) {
  return hackwaly$tinycc$sem$sem_core$$is_char_type(ty);
}
function hackwaly$tinycc$sem$$is_int_like(ty) {
  return hackwaly$tinycc$sem$sem_core$$is_int_like(ty);
}
function hackwaly$tinycc$sem$$next_init_field(fields, index) {
  return hackwaly$tinycc$sem$sem_core$$next_init_field(fields, index);
}
function hackwaly$tinycc$sem$$pop_scope(ctx) {
  hackwaly$tinycc$sem$sem_core$$pop_scope(ctx);
}
function hackwaly$tinycc$sem$$push_scope(ctx) {
  hackwaly$tinycc$sem$sem_core$$push_scope(ctx);
}
function hackwaly$tinycc$sem$$record_local_binding(ctx, id, ty) {
  hackwaly$tinycc$sem$sem_core$$record_local_binding(ctx, id, ty);
}
function hackwaly$tinycc$sem$$resolve_struct_fields(ctx, name, id, items, is_union) {
  return hackwaly$tinycc$sem$sem_core$$resolve_struct_fields(ctx, name, id, items, is_union);
}
function hackwaly$tinycc$sem$$resolve_type(ctx, ty, loc) {
  return hackwaly$tinycc$sem$sem_core$$resolve_type(ctx, ty, loc);
}
function hackwaly$tinycc$sem$$set_opt_by_id$189$(arr, id, value) {
  hackwaly$tinycc$sem$sem_core$$set_opt_by_id$189$(arr, id, value);
}
function hackwaly$tinycc$sem$$strip_qual_attrs(ty) {
  return hackwaly$tinycc$sem$sem_core$$strip_qual_attrs(ty);
}
function hackwaly$tinycc$sem$$strip_qualifiers(ty) {
  return hackwaly$tinycc$sem$sem_core$$strip_qualifiers(ty);
}
function hackwaly$tinycc$sem$$strip_top_qualifiers(ty) {
  return hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers(ty);
}
function hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(ty) {
  return hackwaly$tinycc$sem$sem_core$$strip_top_qualifiers_keep_attrs(ty);
}
function hackwaly$tinycc$sem$$struct_size_align(ctx, fields, attrs, loc) {
  return hackwaly$tinycc$sem$sem_core$$struct_size_align(ctx, fields, attrs, loc);
}
function hackwaly$tinycc$sem$$try_eval_int_const(ctx, expr) {
  return hackwaly$tinycc$sem$sem_core$$try_eval_int_const(ctx, expr);
}
function hackwaly$tinycc$sem$$type_contains_vla(ty) {
  return hackwaly$tinycc$sem$sem_core$$type_contains_vla(ty);
}
function hackwaly$tinycc$sem$$type_for_sizeof(ctx, expr) {
  return hackwaly$tinycc$sem$sem_core$$type_for_sizeof(ctx, expr);
}
function hackwaly$tinycc$sem$$type_of_expr(ctx, expr) {
  return hackwaly$tinycc$sem$sem_core$$type_of_expr(ctx, expr);
}
function hackwaly$tinycc$sem$$type_of_lvalue(ctx, expr) {
  return hackwaly$tinycc$sem$sem_core$$type_of_lvalue(ctx, expr);
}
function hackwaly$tinycc$sem$$type_size_align(ctx, ty, loc) {
  return hackwaly$tinycc$sem$sem_core$$type_size_align(ctx, ty, loc);
}
function hackwaly$tinycc$sem$$union_size_align(ctx, fields, attrs, loc) {
  return hackwaly$tinycc$sem$sem_core$$union_size_align(ctx, fields, attrs, loc);
}
function hackwaly$tinycc$backend$codegen$$align_up(value, align) {
  if (align <= 0) {
    return value;
  } else {
    const mask = align - 1 | 0;
    return value + mask & ~mask;
  }
}
function hackwaly$tinycc$backend$codegen$$ensure_bytes_len(buf, size) {
  if (buf.length < size) {
    moonbitlang$core$array$$Array$resize$26$(buf, size, 0);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(sem, ty, loc) {
  _L: {
    const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
    if (_bind.$tag === 5) {
      const _Array = _bind;
      const _x = _Array._1;
      if (_x === undefined) {
        const _x$2 = _Array._2;
        if (_x$2 === undefined) {
          break _L;
        } else {
          const _Some = _x$2;
          const _expr = _Some;
          _L$2: {
            const _bind$2 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, loc);
            if (_bind$2 === undefined) {
              break _L$2;
            } else {
              const _Some$2 = _bind$2;
              const _v = _Some$2;
              if (_v >= 0) {
                return _v;
              } else {
                break _L$2;
              }
            }
          }
          return undefined;
        }
      } else {
        const _Some = _x;
        const _n = _Some;
        return _n;
      }
    } else {
      break _L;
    }
  }
  return undefined;
}
function hackwaly$tinycc$backend$codegen$$collect_elided_array_items_codegen(items, start, max_count) {
  let limit;
  if (max_count === undefined) {
    limit = items.length;
  } else {
    const _Some = max_count;
    const _n = _Some;
    limit = _n < 0 ? 0 : start + _n | 0;
  }
  const max_items = limit <= start ? 0 : limit - start | 0;
  const collected = moonbitlang$core$array$$Array$new$46$inner$38$(max_items);
  let idx = start;
  while (true) {
    if (idx < items.length && idx < limit) {
      const item = moonbitlang$core$array$$Array$at$38$(items, idx);
      if (item.designators.length > 0) {
        break;
      }
      moonbitlang$core$array$$Array$push$38$(collected, { designators: [], value: item.value, loc: item.loc });
      idx = idx + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: collected, _1: idx - start | 0 };
}
function hackwaly$tinycc$backend$codegen$$cast_float_value(kind, value) {
  return moonbitlang$core$builtin$$Eq$equal$83$(kind, 0) ? Math.fround(value) : value;
}
function hackwaly$tinycc$backend$codegen$$float_kind_of_type(ty) {
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  if (_bind.$tag === 3) {
    const _Float = _bind;
    const _kind = _Float._0;
    return _kind;
  } else {
    return undefined;
  }
}
function hackwaly$tinycc$backend$codegen$$normalize_float_kind(kind) {
  if (kind === 2) {
    return 1;
  } else {
    return kind;
  }
}
function hackwaly$tinycc$backend$codegen$$parse_hex_float_literal_value(text) {
  const len = text.length;
  if (len === 0) {
    return Option$None$20$;
  }
  let sign = 1;
  let idx = 0;
  $bound_check(text, 0);
  const first = text.charCodeAt(0);
  const _p$28 = 43;
  if (first === _p$28) {
    idx = 1;
  } else {
    const _p$29 = 45;
    if (first === _p$29) {
      sign = -1;
      idx = 1;
    }
  }
  if ((idx + 2 | 0) > len) {
    return Option$None$20$;
  }
  const _tmp$27 = idx;
  $bound_check(text, _tmp$27);
  const _p$29 = text.charCodeAt(_tmp$27);
  const _p$30 = 48;
  if (_p$29 !== _p$30) {
    return Option$None$20$;
  }
  const _tmp$28 = idx + 1 | 0;
  $bound_check(text, _tmp$28);
  const prefix = text.charCodeAt(_tmp$28);
  let _tmp$29;
  const _p$31 = 120;
  if (prefix !== _p$31) {
    const _p$32 = 88;
    _tmp$29 = prefix !== _p$32;
  } else {
    _tmp$29 = false;
  }
  if (_tmp$29) {
    return Option$None$20$;
  }
  idx = idx + 2 | 0;
  let p_index = -1;
  let i = idx;
  while (true) {
    if (i < len) {
      const _tmp$30 = i;
      $bound_check(text, _tmp$30);
      const code = text.charCodeAt(_tmp$30);
      let _tmp$31;
      const _p$32 = 112;
      if (code === _p$32) {
        _tmp$31 = true;
      } else {
        const _p$33 = 80;
        _tmp$31 = code === _p$33;
      }
      if (_tmp$31) {
        p_index = i;
        break;
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (p_index < 0) {
    return Option$None$20$;
  }
  const mantissa = hackwaly$tinycc$support$util$$slice_string(text, idx, p_index);
  const exp_str = hackwaly$tinycc$support$util$$slice_string(text, p_index + 1 | 0, len);
  if (exp_str.length === 0) {
    return Option$None$20$;
  }
  let exp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$core$strconv$$parse_int$46$inner({ str: exp_str, start: 0, end: exp_str.length }, 10);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        exp = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$30 = _err._0;
        _try_err = _tmp$30;
        break _L$2;
      }
      break _L;
    }
    return Option$None$20$;
  }
  let int_value = 0;
  let frac_value = 0;
  let frac_scale = 1;
  let seen_dot = false;
  let seen_digit = false;
  let j = 0;
  while (true) {
    if (j < mantissa.length) {
      const _tmp$30 = j;
      $bound_check(mantissa, _tmp$30);
      const code = mantissa.charCodeAt(_tmp$30);
      const _p$32 = 46;
      if (code === _p$32) {
        if (seen_dot) {
          return Option$None$20$;
        }
        seen_dot = true;
        j = j + 1 | 0;
        continue;
      }
      const _bind = hackwaly$tinycc$support$util$$hex_digit_value(code);
      let digit;
      if (_bind === undefined) {
        return Option$None$20$;
      } else {
        const _Some = _bind;
        digit = _Some;
      }
      seen_digit = true;
      if (seen_dot) {
        frac_scale = frac_scale / 16;
        frac_value = frac_value + (digit + 0) * frac_scale;
      } else {
        int_value = int_value * 16 + (digit + 0);
      }
      j = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (!seen_digit) {
    return Option$None$20$;
  }
  const mant = int_value + frac_value;
  const scaled = moonbitlang$core$math$$scalbn(mant, exp);
  return new Option$Some$20$(scaled * sign);
}
function hackwaly$tinycc$backend$codegen$$strip_float_literal_suffix(text) {
  const len = text.length;
  if (len === 0) {
    return text;
  }
  const _tmp$27 = len - 1 | 0;
  $bound_check(text, _tmp$27);
  const last = text.charCodeAt(_tmp$27);
  let _tmp$28;
  const _p$28 = 102;
  if (last === _p$28) {
    _tmp$28 = true;
  } else {
    let _tmp$29;
    const _p$29 = 70;
    if (last === _p$29) {
      _tmp$29 = true;
    } else {
      let _tmp$30;
      const _p$30 = 108;
      if (last === _p$30) {
        _tmp$30 = true;
      } else {
        const _p$31 = 76;
        _tmp$30 = last === _p$31;
      }
      _tmp$29 = _tmp$30;
    }
    _tmp$28 = _tmp$29;
  }
  if (_tmp$28) {
    return hackwaly$tinycc$support$util$$slice_string(text, 0, len - 1 | 0);
  } else {
    return text;
  }
}
function hackwaly$tinycc$backend$codegen$$parse_float_literal_value(text) {
  const trimmed = hackwaly$tinycc$backend$codegen$$strip_float_literal_suffix(text);
  let parsed;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$core$strconv$$parse_double({ str: trimmed, start: 0, end: trimmed.length });
      let _bind$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _bind$2 = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      parsed = new Option$Some$20$(_bind$2);
      break _L;
    }
    parsed = Option$None$20$;
  }
  if (parsed.$tag === 1) {
    const _Some = parsed;
    const _v = _Some._0;
    return new Option$Some$20$(_v);
  } else {
    return hackwaly$tinycc$backend$codegen$$parse_hex_float_literal_value(trimmed);
  }
}
function hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, expr, loc) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    _L$2: {
      switch (expr$2.$tag) {
        case 1: {
          const _FloatLit = expr$2;
          const _value = _FloatLit._0;
          return hackwaly$tinycc$backend$codegen$$parse_float_literal_value(_value);
        }
        case 9: {
          const _Unary = expr$2;
          const _x = _Unary._0;
          switch (_x) {
            case 0: {
              const _inner = _Unary._1;
              _tmp$27 = _inner;
              continue _L;
            }
            case 1: {
              const _inner$2 = _Unary._1;
              const _bind = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _inner$2, loc);
              if (_bind.$tag === 0) {
                return Option$None$20$;
              } else {
                const _Some = _bind;
                const _v = _Some._0;
                return new Option$Some$20$(0 - _v);
              }
            }
            default: {
              break _L$2;
            }
          }
        }
        case 17: {
          const _Binary = expr$2;
          const _x$2 = _Binary._0;
          switch (_x$2) {
            case 11: {
              const _right = _Binary._2;
              _tmp$27 = _right;
              continue _L;
            }
            case 12: {
              const _left = _Binary._1;
              const _right$2 = _Binary._2;
              _L$3: {
                const _bind$2 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _left, loc);
                const _bind$3 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _right$2, loc);
                if (_bind$2.$tag === 1) {
                  const _Some = _bind$2;
                  const _lv = _Some._0;
                  if (_bind$3.$tag === 1) {
                    const _Some$2 = _bind$3;
                    const _rv = _Some$2._0;
                    return new Option$Some$20$(_lv + _rv);
                  } else {
                    break _L$3;
                  }
                } else {
                  break _L$3;
                }
              }
              return Option$None$20$;
            }
            case 13: {
              const _left$2 = _Binary._1;
              const _right$3 = _Binary._2;
              _L$4: {
                const _bind$2 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _left$2, loc);
                const _bind$3 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _right$3, loc);
                if (_bind$2.$tag === 1) {
                  const _Some = _bind$2;
                  const _lv = _Some._0;
                  if (_bind$3.$tag === 1) {
                    const _Some$2 = _bind$3;
                    const _rv = _Some$2._0;
                    return new Option$Some$20$(_lv - _rv);
                  } else {
                    break _L$4;
                  }
                } else {
                  break _L$4;
                }
              }
              return Option$None$20$;
            }
            case 14: {
              const _left$3 = _Binary._1;
              const _right$4 = _Binary._2;
              _L$5: {
                const _bind$2 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _left$3, loc);
                const _bind$3 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _right$4, loc);
                if (_bind$2.$tag === 1) {
                  const _Some = _bind$2;
                  const _lv = _Some._0;
                  if (_bind$3.$tag === 1) {
                    const _Some$2 = _bind$3;
                    const _rv = _Some$2._0;
                    return new Option$Some$20$(_lv * _rv);
                  } else {
                    break _L$5;
                  }
                } else {
                  break _L$5;
                }
              }
              return Option$None$20$;
            }
            case 15: {
              const _left$4 = _Binary._1;
              const _right$5 = _Binary._2;
              _L$6: {
                const _bind$2 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _left$4, loc);
                const _bind$3 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _right$5, loc);
                if (_bind$2.$tag === 1) {
                  const _Some = _bind$2;
                  const _lv = _Some._0;
                  if (_bind$3.$tag === 1) {
                    const _Some$2 = _bind$3;
                    const _rv = _Some$2._0;
                    return new Option$Some$20$(_lv / _rv);
                  } else {
                    break _L$6;
                  }
                } else {
                  break _L$6;
                }
              }
              return Option$None$20$;
            }
            default: {
              break _L$2;
            }
          }
        }
        case 10: {
          const _Cast = expr$2;
          const _ty = _Cast._0;
          const _inner$3 = _Cast._1;
          const cast_ty = hackwaly$tinycc$sem$$strip_top_qualifiers(_ty);
          const _bind$2 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(cast_ty);
          if (_bind$2 === undefined) {
            if (hackwaly$tinycc$sem$$is_int_like(cast_ty)) {
              const _bind$3 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _inner$3, loc);
              if (_bind$3.$tag === 0) {
                return Option$None$20$;
              } else {
                const _Some = _bind$3;
                const _v = _Some._0;
                const _p$28 = moonbitlang$core$double$$Double$to_int(_v);
                return new Option$Some$20$(_p$28 + 0);
              }
            } else {
              _tmp$27 = _inner$3;
              continue _L;
            }
          } else {
            const _Some = _bind$2;
            const _k_raw = _Some;
            const k = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_k_raw);
            const _bind$3 = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, _inner$3, loc);
            if (_bind$3.$tag === 0) {
              return Option$None$20$;
            } else {
              const _Some$2 = _bind$3;
              const _v = _Some$2._0;
              return new Option$Some$20$(hackwaly$tinycc$backend$codegen$$cast_float_value(k, _v));
            }
          }
        }
        default: {
          break _L$2;
        }
      }
    }
    const _bind = hackwaly$tinycc$sem$$const_int_from_expr(sem, expr$2, loc);
    if (_bind === undefined) {
      return Option$None$20$;
    } else {
      const _Some = _bind;
      const _v = _Some;
      return new Option$Some$20$(_v + 0);
    }
  }
}
function hackwaly$tinycc$backend$codegen$$float_kind_supported(kind) {
  return moonbitlang$core$builtin$$Eq$equal$83$(kind, 0) || (moonbitlang$core$builtin$$Eq$equal$83$(kind, 1) || moonbitlang$core$builtin$$Eq$equal$83$(kind, 2));
}
function hackwaly$tinycc$backend$codegen$$float_bits_from_double(kind, value) {
  if (!hackwaly$tinycc$backend$codegen$$float_kind_supported(kind)) {
    return undefined;
  }
  if (moonbitlang$core$builtin$$Eq$equal$83$(kind, 0)) {
    const f = Math.fround(value);
    return moonbitlang$core$uint$$UInt$to_uint64($i32_reinterpret_f32(f));
  } else {
    return moonbitlang$core$double$$Double$reinterpret_as_uint64(value);
  }
}
function hackwaly$tinycc$backend$codegen$$const_float_bits_from_expr(sem, expr, kind, loc) {
  const _bind = hackwaly$tinycc$backend$codegen$$eval_float_const_value(sem, expr, loc);
  if (_bind.$tag === 0) {
    return undefined;
  } else {
    const _Some = _bind;
    const _v = _Some._0;
    return hackwaly$tinycc$backend$codegen$$float_bits_from_double(kind, _v);
  }
}
function hackwaly$tinycc$backend$codegen$$sym_for_name(tab, name) {
  const _bind = moonbitlang$core$hashmap$$HashMap$get$156$(tab.name_to_id, name);
  if (_bind === undefined) {
    const id = tab.names.length + 1 | 0;
    moonbitlang$core$array$$Array$push$19$(tab.names, name);
    moonbitlang$core$hashmap$$HashMap$set$156$(tab.name_to_id, name, id);
    moonbitlang$core$hashmap$$HashMap$set$170$(tab.externals, id, true);
    return { id: id };
  } else {
    const _Some = _bind;
    const _id = _Some;
    return { id: _id };
  }
}
function hackwaly$tinycc$backend$codegen$$cstring_sym_or_add(pool, syms, value) {
  const _bind = moonbitlang$core$hashmap$$HashMap$get$172$(pool.syms, value);
  if (_bind === undefined) {
    const index = pool.order.length;
    const sym_name = `_L_.str.${moonbitlang$core$builtin$$Show$to_string$90$(index)}`;
    const sym = hackwaly$tinycc$backend$codegen$$sym_for_name(syms, sym_name);
    moonbitlang$core$hashmap$$HashMap$set$172$(pool.syms, value, sym);
    moonbitlang$core$array$$Array$push$19$(pool.order, value);
    return sym;
  } else {
    const _Some = _bind;
    return _Some;
  }
}
function hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(ty) {
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(ty);
  switch (_bind.$tag) {
    case 4: {
      const _Pointer = _bind;
      const _inner = _Pointer._0;
      return _inner;
    }
    case 5: {
      const _Array = _bind;
      const _elem = _Array._0;
      return _elem;
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$add_field_access_entry(cache, name, info) {
  if (name === "" || moonbitlang$core$hashmap$$HashMap$contains$136$(cache, name)) {
    return undefined;
  }
  moonbitlang$core$hashmap$$HashMap$set$136$(cache, name, info);
}
function hackwaly$tinycc$backend$codegen$$add_field_access_entry_by_id(cache, id, info) {
  if (id <= 0 || moonbitlang$core$hashmap$$HashMap$contains$137$(cache, id)) {
    return undefined;
  }
  moonbitlang$core$hashmap$$HashMap$set$137$(cache, id, info);
}
function hackwaly$tinycc$backend$codegen$$bitfield_access_size_for_bytes(bytes) {
  return bytes <= 1 ? 1 : bytes <= 2 ? 2 : bytes <= 4 ? 4 : 8;
}
function hackwaly$tinycc$backend$codegen$$adjust_bitfield_access_info(ctx, struct_size, info, loc) {
  const _bind = info.bit_width;
  if (_bind === undefined) {
    return info;
  } else {
    const _Some = _bind;
    const _width = _Some;
    const _bind$2 = info.bit_offset;
    let bit_off;
    if (_bind$2 === undefined) {
      bit_off = 0;
    } else {
      const _Some$2 = _bind$2;
      bit_off = _Some$2;
    }
    const _bind$3 = hackwaly$tinycc$sem$$type_size_align(ctx, info.ty, loc);
    let _bind$4;
    if (_bind$3 === undefined) {
      return info;
    } else {
      const _Some$2 = _bind$3;
      _bind$4 = _Some$2;
    }
    const _base_size = _bind$4._0;
    if (_base_size > 0) {
      const unit_bits = Math.imul(_base_size, 8) | 0;
      if ((bit_off + _width | 0) <= unit_bits && (info.offset + _base_size | 0) <= struct_size) {
        return { offset: info.offset, ty: info.ty, bit_offset: bit_off, bit_width: _width, bit_unit_size: _base_size };
      }
    }
    const overall = (Math.imul(info.offset, 8) | 0) + bit_off | 0;
    let last_cx = -1;
    let size = 1;
    let align = 1;
    let bit_pos = 0;
    let cx = 0;
    while (true) {
      const candidate_cx = overall >> 3 & (-align | 0);
      bit_pos = overall - (Math.imul(candidate_cx, 8) | 0) | 0;
      if (candidate_cx === last_cx) {
        cx = candidate_cx;
        break;
      }
      const bytes_needed = ((bit_pos + _width | 0) + 7 | 0) / 8 | 0;
      size = hackwaly$tinycc$backend$codegen$$bitfield_access_size_for_bytes(bytes_needed);
      align = size;
      last_cx = candidate_cx;
      continue;
    }
    if ((bit_pos + _width | 0) <= (Math.imul(size, 8) | 0) && (cx + size | 0) <= struct_size) {
      return { offset: cx, ty: info.ty, bit_offset: bit_pos, bit_width: _width, bit_unit_size: size };
    }
    return { offset: info.offset, ty: info.ty, bit_offset: bit_off, bit_width: _width, bit_unit_size: undefined };
  }
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$154$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$154$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$155$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$155$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$156$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$156$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$157$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$157$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$158$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$158$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$170$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$170$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$171$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$171$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$172$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$172$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$174$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$174$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$175$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$175$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$173$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$173$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$166$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$166$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$136$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$136$(capacity);
}
function hackwaly$tinycc$backend$codegen$$fast_map_new$137$(capacity) {
  return hackwaly$tinycc$support$util$$fast_map_new$137$(capacity);
}
function hackwaly$tinycc$backend$codegen$$ensure_struct_fields(ctx, tag, tag_id, fields, is_union, loc) {
  return hackwaly$tinycc$sem$$ensure_struct_fields(ctx, tag, tag_id, fields, is_union, loc);
}
function hackwaly$tinycc$backend$codegen$$get_opt_by_id$67$(arr, id) {
  return hackwaly$tinycc$sem$$get_opt_by_id$67$(arr, id);
}
function hackwaly$tinycc$backend$codegen$$get_opt_by_id$188$(arr, id) {
  return hackwaly$tinycc$sem$$get_opt_by_id$188$(arr, id);
}
function hackwaly$tinycc$backend$codegen$$get_opt_by_id$68$(arr, id) {
  return hackwaly$tinycc$sem$$get_opt_by_id$68$(arr, id);
}
function hackwaly$tinycc$backend$codegen$$get_opt_by_id$189$(arr, id) {
  return hackwaly$tinycc$sem$$get_opt_by_id$189$(arr, id);
}
function hackwaly$tinycc$backend$codegen$$has_opt_by_id$183$(arr, id) {
  return hackwaly$tinycc$sem$$has_opt_by_id$183$(arr, id);
}
function hackwaly$tinycc$backend$codegen$$set_opt_by_id$189$(arr, id, value) {
  hackwaly$tinycc$sem$$set_opt_by_id$189$(arr, id, value);
}
function hackwaly$tinycc$backend$codegen$$build_struct_field_access_caches(ctx, def, struct_attrs, loc) {
  const cache_by_name = hackwaly$tinycc$backend$codegen$$fast_map_new$136$(undefined);
  const cache_by_id = hackwaly$tinycc$backend$codegen$$fast_map_new$137$(undefined);
  const attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(def.attrs, struct_attrs);
  hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache(ctx, def.fields, attrs, loc, cache_by_name, cache_by_id);
  return { _0: cache_by_name, _1: cache_by_id };
}
function hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache(ctx, fields, attrs, loc, cache, cache_by_id) {
  const _bind = hackwaly$tinycc$sem$$struct_size_align(ctx, fields, attrs, loc);
  const _struct_size = _bind._0;
  let size = 0;
  let bit_pos = 0;
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      _L: {
        const field = fields[_i];
        const packed = attrs.packed || field.attrs.packed;
        const field_align_override = hackwaly$tinycc$sem$$attr_align_value(ctx, field.attrs, field.loc);
        const _bind$2 = field.bit_width;
        if (_bind$2 === undefined) {
          if (bit_pos !== 0) {
            size = size + ((bit_pos + 7 | 0) / 8 | 0) | 0;
            bit_pos = 0;
          }
          let _bind$3;
          _L$2: {
            _L$3: {
              const _bind$4 = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(field.ty);
              if (_bind$4.$tag === 5) {
                const _Array = _bind$4;
                const _elem = _Array._0;
                const _x = _Array._1;
                if (_x === undefined) {
                  const _size_expr = _Array._2;
                  if (_size_expr === undefined) {
                    const _bind$5 = hackwaly$tinycc$sem$$type_size_align(ctx, _elem, field.loc);
                    let _bind$6;
                    if (_bind$5 === undefined) {
                      _bind$6 = hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9451;
                    } else {
                      const _Some = _bind$5;
                      _bind$6 = _Some;
                    }
                    const _elem_align = _bind$6._1;
                    _bind$3 = { _0: 0, _1: _elem_align };
                  } else {
                    const _bind$5 = hackwaly$tinycc$sem$$type_size_align(ctx, field.ty, field.loc);
                    if (_bind$5 === undefined) {
                      hackwaly$tinycc$sem$$add_sem_error(ctx, field.loc, "variable length array not allowed in struct");
                      _bind$3 = hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9452;
                    } else {
                      const _Some = _bind$5;
                      _bind$3 = _Some;
                    }
                  }
                } else {
                  break _L$3;
                }
              } else {
                break _L$3;
              }
              break _L$2;
            }
            const _bind$4 = hackwaly$tinycc$sem$$type_size_align(ctx, field.ty, loc);
            if (_bind$4 === undefined) {
              _bind$3 = hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9450;
            } else {
              const _Some = _bind$4;
              _bind$3 = _Some;
            }
          }
          const _field_size = _bind$3._0;
          const _field_align = _bind$3._1;
          let adjusted_align = packed ? 1 : _field_align;
          if (field_align_override === undefined) {
          } else {
            const _Some = field_align_override;
            const _value = _Some;
            adjusted_align = _value;
          }
          size = hackwaly$tinycc$sem$$align_to(size, adjusted_align);
          const info = { offset: size, ty: field.ty, bit_offset: undefined, bit_width: undefined, bit_unit_size: undefined };
          hackwaly$tinycc$backend$codegen$$add_field_access_entry(cache, field.name, info);
          hackwaly$tinycc$backend$codegen$$add_field_access_entry_by_id(cache_by_id, field.id, info);
          if (field.name === "") {
            _L$3: {
              _L$4: {
                const _bind$4 = hackwaly$tinycc$sem$$strip_top_qualifiers(field.ty);
                switch (_bind$4.$tag) {
                  case 6: {
                    break _L$4;
                  }
                  case 7: {
                    break _L$4;
                  }
                }
                break _L$3;
              }
              const _bind$4 = hackwaly$tinycc$backend$codegen$$build_record_field_access_caches(ctx, field.ty, loc);
              const _nested_by_name = _bind$4._0;
              const _nested_by_id = _bind$4._1;
              const _it = moonbitlang$core$hashmap$$HashMap$iter2$136$(_nested_by_name);
              while (true) {
                const _bind$5 = moonbitlang$core$builtin$$Iter2$next$136$(_it);
                if (_bind$5 === undefined) {
                  break;
                } else {
                  const _Some = _bind$5;
                  const _x = _Some;
                  const _nested_name = _x._0;
                  const _nested_info = _x._1;
                  hackwaly$tinycc$backend$codegen$$add_field_access_entry(cache, _nested_name, { offset: size + _nested_info.offset | 0, ty: _nested_info.ty, bit_offset: _nested_info.bit_offset, bit_width: _nested_info.bit_width, bit_unit_size: _nested_info.bit_unit_size });
                  continue;
                }
              }
              const _it$2 = moonbitlang$core$hashmap$$HashMap$iter2$137$(_nested_by_id);
              while (true) {
                const _bind$5 = moonbitlang$core$builtin$$Iter2$next$137$(_it$2);
                if (_bind$5 === undefined) {
                  break;
                } else {
                  const _Some = _bind$5;
                  const _x = _Some;
                  const _nested_id = _x._0;
                  const _nested_info = _x._1;
                  hackwaly$tinycc$backend$codegen$$add_field_access_entry_by_id(cache_by_id, _nested_id, { offset: size + _nested_info.offset | 0, ty: _nested_info.ty, bit_offset: _nested_info.bit_offset, bit_width: _nested_info.bit_width, bit_unit_size: _nested_info.bit_unit_size });
                  continue;
                }
              }
            }
          }
          size = size + _field_size | 0;
        } else {
          const _Some = _bind$2;
          const _expr = _Some;
          const _bind$3 = hackwaly$tinycc$sem$$const_int_from_expr(ctx, _expr, field.loc);
          let width;
          if (_bind$3 === undefined) {
            width = 0;
          } else {
            const _Some$2 = _bind$3;
            width = _Some$2;
          }
          const base = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(field.ty);
          const _bind$4 = hackwaly$tinycc$sem$$type_size_align(ctx, base, loc);
          let _bind$5;
          if (_bind$4 === undefined) {
            _bind$5 = hackwaly$tinycc$backend$codegen$$collect_struct_field_access_cache$46$tuple$47$9449;
          } else {
            const _Some$2 = _bind$4;
            _bind$5 = _Some$2;
          }
          const _base_size = _bind$5._0;
          const _base_align = _bind$5._1;
          let field_align = _base_align;
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          if (width === 0) {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
            break _L;
          }
          if (packed && width !== 0) {
            field_align = 1;
          }
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          if (field_align_override === undefined) {
            if (!packed) {
              const a8 = Math.imul(field_align, 8) | 0;
              const max_units = field_align > 0 ? _base_size / field_align | 0 : 0;
              if (a8 > 0) {
                const ofs = ((((((Math.imul(size, 8) | 0) + bit_pos | 0) % a8 | 0) + width | 0) + a8 | 0) - 1 | 0) / a8 | 0;
                if (ofs > max_units) {
                  const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
                  size = hackwaly$tinycc$sem$$align_to(size + used_bytes | 0, field_align);
                  bit_pos = 0;
                }
              }
            }
          } else {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
          }
          while (true) {
            if (bit_pos >= (Math.imul(field_align, 8) | 0)) {
              size = size + field_align | 0;
              bit_pos = bit_pos - (Math.imul(field_align, 8) | 0) | 0;
              continue;
            } else {
              break;
            }
          }
          const info = hackwaly$tinycc$backend$codegen$$adjust_bitfield_access_info(ctx, _struct_size, { offset: size, ty: field.ty, bit_offset: bit_pos, bit_width: width, bit_unit_size: undefined }, loc);
          hackwaly$tinycc$backend$codegen$$add_field_access_entry(cache, field.name, info);
          hackwaly$tinycc$backend$codegen$$add_field_access_entry_by_id(cache_by_id, field.id, info);
          bit_pos = bit_pos + width | 0;
        }
        break _L;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$build_record_field_access_caches(ctx, record_ty, loc) {
  const resolved = hackwaly$tinycc$sem$$strip_top_qualifiers(hackwaly$tinycc$sem$$resolve_type(ctx, record_ty, loc));
  switch (resolved.$tag) {
    case 6: {
      const _Struct = resolved;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const _struct_attrs = _Struct._3;
      const _bind = hackwaly$tinycc$backend$codegen$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
      if (_bind === undefined) {
        return { _0: hackwaly$tinycc$backend$codegen$$fast_map_new$136$(undefined), _1: hackwaly$tinycc$backend$codegen$$fast_map_new$137$(undefined) };
      } else {
        const _Some = _bind;
        const _def = _Some;
        let _tmp$27;
        const _p$28 = "";
        if (!(_tag === _p$28)) {
          _tmp$27 = hackwaly$tinycc$sem$$attrs_layout_empty(_struct_attrs) && (_tag_id !== 0 ? hackwaly$tinycc$backend$codegen$$has_opt_by_id$183$(ctx.struct_defs_by_id, _tag_id) : moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.struct_defs, _tag));
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          const by_name = moonbitlang$core$hashmap$$HashMap$get$164$(ctx.struct_field_access_cache, _tag);
          const by_id = _tag_id !== 0 ? hackwaly$tinycc$backend$codegen$$get_opt_by_id$189$(ctx.struct_field_access_cache_by_id, _tag_id) : undefined;
          _L: {
            if (by_name === undefined) {
              break _L;
            } else {
              const _Some$2 = by_name;
              const _name_cache = _Some$2;
              if (by_id === undefined) {
                break _L;
              } else {
                const _Some$3 = by_id;
                const _id_cache = _Some$3;
                return { _0: _name_cache, _1: _id_cache };
              }
            }
          }
          const _bind$2 = hackwaly$tinycc$backend$codegen$$build_struct_field_access_caches(ctx, _def, _struct_attrs, loc);
          const _built_name = _bind$2._0;
          const _built_id = _bind$2._1;
          moonbitlang$core$hashmap$$HashMap$set$164$(ctx.struct_field_access_cache, _tag, _built_name);
          if (_tag_id !== 0) {
            hackwaly$tinycc$backend$codegen$$set_opt_by_id$189$(ctx.struct_field_access_cache_by_id, _tag_id, _built_id);
          }
          return { _0: _built_name, _1: _built_id };
        } else {
          return hackwaly$tinycc$backend$codegen$$build_struct_field_access_caches(ctx, _def, _struct_attrs, loc);
        }
      }
    }
    case 7: {
      const _Union = resolved;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const _union_attrs = _Union._3;
      const _bind$2 = hackwaly$tinycc$backend$codegen$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
      if (_bind$2 === undefined) {
        return { _0: hackwaly$tinycc$backend$codegen$$fast_map_new$136$(undefined), _1: hackwaly$tinycc$backend$codegen$$fast_map_new$137$(undefined) };
      } else {
        const _Some = _bind$2;
        const _def = _Some;
        let _tmp$27;
        const _p$28 = "";
        if (!(_tag$2 === _p$28)) {
          _tmp$27 = hackwaly$tinycc$sem$$attrs_layout_empty(_union_attrs) && (_tag_id$2 !== 0 ? hackwaly$tinycc$backend$codegen$$has_opt_by_id$183$(ctx.union_defs_by_id, _tag_id$2) : moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.union_defs, _tag$2));
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          const by_name = moonbitlang$core$hashmap$$HashMap$get$164$(ctx.union_field_access_cache, _tag$2);
          const by_id = _tag_id$2 !== 0 ? hackwaly$tinycc$backend$codegen$$get_opt_by_id$189$(ctx.union_field_access_cache_by_id, _tag_id$2) : undefined;
          _L: {
            if (by_name === undefined) {
              break _L;
            } else {
              const _Some$2 = by_name;
              const _name_cache = _Some$2;
              if (by_id === undefined) {
                break _L;
              } else {
                const _Some$3 = by_id;
                const _id_cache = _Some$3;
                return { _0: _name_cache, _1: _id_cache };
              }
            }
          }
          const _bind$3 = hackwaly$tinycc$backend$codegen$$build_union_field_access_caches(ctx, _def, _union_attrs, loc);
          const _built_name = _bind$3._0;
          const _built_id = _bind$3._1;
          moonbitlang$core$hashmap$$HashMap$set$164$(ctx.union_field_access_cache, _tag$2, _built_name);
          if (_tag_id$2 !== 0) {
            hackwaly$tinycc$backend$codegen$$set_opt_by_id$189$(ctx.union_field_access_cache_by_id, _tag_id$2, _built_id);
          }
          return { _0: _built_name, _1: _built_id };
        } else {
          return hackwaly$tinycc$backend$codegen$$build_union_field_access_caches(ctx, _def, _union_attrs, loc);
        }
      }
    }
    default: {
      return { _0: hackwaly$tinycc$backend$codegen$$fast_map_new$136$(undefined), _1: hackwaly$tinycc$backend$codegen$$fast_map_new$137$(undefined) };
    }
  }
}
function hackwaly$tinycc$backend$codegen$$build_union_field_access_caches(ctx, def, union_attrs, loc) {
  const cache_by_name = hackwaly$tinycc$backend$codegen$$fast_map_new$136$(undefined);
  const cache_by_id = hackwaly$tinycc$backend$codegen$$fast_map_new$137$(undefined);
  const attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(def.attrs, union_attrs);
  hackwaly$tinycc$backend$codegen$$collect_union_field_access_cache(ctx, def.fields, attrs, loc, cache_by_name, cache_by_id);
  return { _0: cache_by_name, _1: cache_by_id };
}
function hackwaly$tinycc$backend$codegen$$collect_union_field_access_cache(ctx, fields, attrs, loc, cache, cache_by_id) {
  const _bind = hackwaly$tinycc$sem$$union_size_align(ctx, fields, attrs, loc);
  const _union_size = _bind._0;
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      _L: {
        const field = fields[_i];
        const _bind$2 = field.bit_width;
        if (_bind$2 === undefined) {
        } else {
          const _Some = _bind$2;
          const _expr = _Some;
          const _bind$3 = hackwaly$tinycc$sem$$const_int_from_expr(ctx, _expr, field.loc);
          let width;
          if (_bind$3 === undefined) {
            width = 0;
          } else {
            const _Some$2 = _bind$3;
            width = _Some$2;
          }
          if (width > 0) {
            const info = hackwaly$tinycc$backend$codegen$$adjust_bitfield_access_info(ctx, _union_size, { offset: 0, ty: field.ty, bit_offset: hackwaly$tinycc$backend$codegen$$collect_union_field_access_cache$46$constr$47$9582, bit_width: width, bit_unit_size: undefined }, loc);
            hackwaly$tinycc$backend$codegen$$add_field_access_entry(cache, field.name, info);
            hackwaly$tinycc$backend$codegen$$add_field_access_entry_by_id(cache_by_id, field.id, info);
          }
          break _L;
        }
        const info = { offset: 0, ty: field.ty, bit_offset: undefined, bit_width: undefined, bit_unit_size: undefined };
        hackwaly$tinycc$backend$codegen$$add_field_access_entry(cache, field.name, info);
        hackwaly$tinycc$backend$codegen$$add_field_access_entry_by_id(cache_by_id, field.id, info);
        if (field.name === "") {
          _L$2: {
            _L$3: {
              const _bind$3 = hackwaly$tinycc$sem$$strip_top_qualifiers(field.ty);
              switch (_bind$3.$tag) {
                case 6: {
                  break _L$3;
                }
                case 7: {
                  break _L$3;
                }
              }
              break _L$2;
            }
            const _bind$3 = hackwaly$tinycc$backend$codegen$$build_record_field_access_caches(ctx, field.ty, loc);
            const _nested_by_name = _bind$3._0;
            const _nested_by_id = _bind$3._1;
            const _it = moonbitlang$core$hashmap$$HashMap$iter2$136$(_nested_by_name);
            while (true) {
              const _bind$4 = moonbitlang$core$builtin$$Iter2$next$136$(_it);
              if (_bind$4 === undefined) {
                break;
              } else {
                const _Some = _bind$4;
                const _x = _Some;
                const _nested_name = _x._0;
                const _nested_info = _x._1;
                hackwaly$tinycc$backend$codegen$$add_field_access_entry(cache, _nested_name, { offset: _nested_info.offset, ty: _nested_info.ty, bit_offset: _nested_info.bit_offset, bit_width: _nested_info.bit_width, bit_unit_size: _nested_info.bit_unit_size });
                continue;
              }
            }
            const _it$2 = moonbitlang$core$hashmap$$HashMap$iter2$137$(_nested_by_id);
            while (true) {
              const _bind$4 = moonbitlang$core$builtin$$Iter2$next$137$(_it$2);
              if (_bind$4 === undefined) {
                break;
              } else {
                const _Some = _bind$4;
                const _x = _Some;
                const _nested_id = _x._0;
                const _nested_info = _x._1;
                hackwaly$tinycc$backend$codegen$$add_field_access_entry_by_id(cache_by_id, _nested_id, { offset: _nested_info.offset, ty: _nested_info.ty, bit_offset: _nested_info.bit_offset, bit_width: _nested_info.bit_width, bit_unit_size: _nested_info.bit_unit_size });
                continue;
              }
            }
          }
        }
        break _L;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$record_field_access_info(ctx, record_ty, name, id, loc) {
  const resolved = hackwaly$tinycc$sem$$strip_top_qualifiers(hackwaly$tinycc$sem$$resolve_type(ctx, record_ty, loc));
  switch (resolved.$tag) {
    case 6: {
      const _Struct = resolved;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const _struct_attrs = _Struct._3;
      const _bind = hackwaly$tinycc$backend$codegen$$ensure_struct_fields(ctx, _tag, _tag_id, _field_list, false, loc);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _def = _Some;
        let _tmp$27;
        const _p$28 = "";
        if (!(_tag === _p$28)) {
          _tmp$27 = hackwaly$tinycc$sem$$attrs_layout_empty(_struct_attrs) && (_tag_id !== 0 ? hackwaly$tinycc$backend$codegen$$has_opt_by_id$183$(ctx.struct_defs_by_id, _tag_id) : moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.struct_defs, _tag));
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          if (id > 0 && _tag_id !== 0) {
            const _bind$2 = hackwaly$tinycc$backend$codegen$$get_opt_by_id$189$(ctx.struct_field_access_cache_by_id, _tag_id);
            let cache;
            if (_bind$2 === undefined) {
              const _bind$3 = hackwaly$tinycc$backend$codegen$$build_struct_field_access_caches(ctx, _def, _struct_attrs, loc);
              const _built_name = _bind$3._0;
              const _built_id = _bind$3._1;
              hackwaly$tinycc$backend$codegen$$set_opt_by_id$189$(ctx.struct_field_access_cache_by_id, _tag_id, _built_id);
              moonbitlang$core$hashmap$$HashMap$set$164$(ctx.struct_field_access_cache, _tag, _built_name);
              cache = _built_id;
            } else {
              const _Some$2 = _bind$2;
              cache = _Some$2;
            }
            const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$137$(cache, id);
            if (_bind$3 === undefined) {
              if (name === "") {
                return undefined;
              } else {
                const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$164$(ctx.struct_field_access_cache, _tag);
                if (_bind$4 === undefined) {
                  return undefined;
                } else {
                  const _Some$2 = _bind$4;
                  const _by_name = _Some$2;
                  return moonbitlang$core$hashmap$$HashMap$get$136$(_by_name, name);
                }
              }
            } else {
              const _Some$2 = _bind$3;
              const _info = _Some$2;
              return _info;
            }
          } else {
            const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$164$(ctx.struct_field_access_cache, _tag);
            let cache;
            if (_bind$2 === undefined) {
              const _bind$3 = hackwaly$tinycc$backend$codegen$$build_struct_field_access_caches(ctx, _def, _struct_attrs, loc);
              const _built_name = _bind$3._0;
              const _built_id = _bind$3._1;
              moonbitlang$core$hashmap$$HashMap$set$164$(ctx.struct_field_access_cache, _tag, _built_name);
              if (_tag_id !== 0) {
                hackwaly$tinycc$backend$codegen$$set_opt_by_id$189$(ctx.struct_field_access_cache_by_id, _tag_id, _built_id);
              }
              cache = _built_name;
            } else {
              const _Some$2 = _bind$2;
              cache = _Some$2;
            }
            return moonbitlang$core$hashmap$$HashMap$get$136$(cache, name);
          }
        } else {
          return hackwaly$tinycc$backend$codegen$$struct_field_access_info(ctx, _def, _struct_attrs, name, id, loc);
        }
      }
    }
    case 7: {
      const _Union = resolved;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const _union_attrs = _Union._3;
      const _bind$2 = hackwaly$tinycc$backend$codegen$$ensure_struct_fields(ctx, _tag$2, _tag_id$2, _field_list$2, true, loc);
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$2;
        const _def = _Some;
        let _tmp$27;
        const _p$28 = "";
        if (!(_tag$2 === _p$28)) {
          _tmp$27 = hackwaly$tinycc$sem$$attrs_layout_empty(_union_attrs) && (_tag_id$2 !== 0 ? hackwaly$tinycc$backend$codegen$$has_opt_by_id$183$(ctx.union_defs_by_id, _tag_id$2) : moonbitlang$core$hashmap$$HashMap$contains$162$(ctx.union_defs, _tag$2));
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          if (id > 0 && _tag_id$2 !== 0) {
            const _bind$3 = hackwaly$tinycc$backend$codegen$$get_opt_by_id$189$(ctx.union_field_access_cache_by_id, _tag_id$2);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$backend$codegen$$build_union_field_access_caches(ctx, _def, _union_attrs, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              hackwaly$tinycc$backend$codegen$$set_opt_by_id$189$(ctx.union_field_access_cache_by_id, _tag_id$2, _built_id);
              moonbitlang$core$hashmap$$HashMap$set$164$(ctx.union_field_access_cache, _tag$2, _built_name);
              cache = _built_id;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$137$(cache, id);
            if (_bind$4 === undefined) {
              if (name === "") {
                return undefined;
              } else {
                const _bind$5 = moonbitlang$core$hashmap$$HashMap$get$164$(ctx.union_field_access_cache, _tag$2);
                if (_bind$5 === undefined) {
                  return undefined;
                } else {
                  const _Some$2 = _bind$5;
                  const _by_name = _Some$2;
                  return moonbitlang$core$hashmap$$HashMap$get$136$(_by_name, name);
                }
              }
            } else {
              const _Some$2 = _bind$4;
              const _info = _Some$2;
              return _info;
            }
          } else {
            const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$164$(ctx.union_field_access_cache, _tag$2);
            let cache;
            if (_bind$3 === undefined) {
              const _bind$4 = hackwaly$tinycc$backend$codegen$$build_union_field_access_caches(ctx, _def, _union_attrs, loc);
              const _built_name = _bind$4._0;
              const _built_id = _bind$4._1;
              moonbitlang$core$hashmap$$HashMap$set$164$(ctx.union_field_access_cache, _tag$2, _built_name);
              if (_tag_id$2 !== 0) {
                hackwaly$tinycc$backend$codegen$$set_opt_by_id$189$(ctx.union_field_access_cache_by_id, _tag_id$2, _built_id);
              }
              cache = _built_name;
            } else {
              const _Some$2 = _bind$3;
              cache = _Some$2;
            }
            return moonbitlang$core$hashmap$$HashMap$get$136$(cache, name);
          }
        } else {
          return hackwaly$tinycc$backend$codegen$$union_field_access_info(ctx, _def, _union_attrs, name, id, loc);
        }
      }
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$struct_field_access_info(ctx, def, struct_attrs, name, id, loc) {
  const fields = def.fields;
  const attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(def.attrs, struct_attrs);
  const _bind = hackwaly$tinycc$sem$$struct_size_align(ctx, fields, attrs, loc);
  const _struct_size = _bind._0;
  let size = 0;
  let bit_pos = 0;
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      _L: {
        const field = fields[_i];
        const packed = attrs.packed || field.attrs.packed;
        const field_align_override = hackwaly$tinycc$sem$$attr_align_value(ctx, field.attrs, field.loc);
        const _bind$2 = field.bit_width;
        if (_bind$2 === undefined) {
          if (bit_pos !== 0) {
            size = size + ((bit_pos + 7 | 0) / 8 | 0) | 0;
            bit_pos = 0;
          }
          let _bind$3;
          _L$2: {
            _L$3: {
              const _bind$4 = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(field.ty);
              if (_bind$4.$tag === 5) {
                const _Array = _bind$4;
                const _elem = _Array._0;
                const _x = _Array._1;
                if (_x === undefined) {
                  const _size_expr = _Array._2;
                  if (_size_expr === undefined) {
                    const _bind$5 = hackwaly$tinycc$sem$$type_size_align(ctx, _elem, field.loc);
                    let _bind$6;
                    if (_bind$5 === undefined) {
                      _bind$6 = hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9683;
                    } else {
                      const _Some = _bind$5;
                      _bind$6 = _Some;
                    }
                    const _elem_align = _bind$6._1;
                    _bind$3 = { _0: 0, _1: _elem_align };
                  } else {
                    const _bind$5 = hackwaly$tinycc$sem$$type_size_align(ctx, field.ty, field.loc);
                    if (_bind$5 === undefined) {
                      hackwaly$tinycc$sem$$add_sem_error(ctx, field.loc, "variable length array not allowed in struct");
                      _bind$3 = hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9684;
                    } else {
                      const _Some = _bind$5;
                      _bind$3 = _Some;
                    }
                  }
                } else {
                  break _L$3;
                }
              } else {
                break _L$3;
              }
              break _L$2;
            }
            const _bind$4 = hackwaly$tinycc$sem$$type_size_align(ctx, field.ty, loc);
            if (_bind$4 === undefined) {
              _bind$3 = hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9682;
            } else {
              const _Some = _bind$4;
              _bind$3 = _Some;
            }
          }
          const _field_size = _bind$3._0;
          const _field_align = _bind$3._1;
          let adjusted_align = packed ? 1 : _field_align;
          if (field_align_override === undefined) {
          } else {
            const _Some = field_align_override;
            const _value = _Some;
            adjusted_align = _value;
          }
          size = hackwaly$tinycc$sem$$align_to(size, adjusted_align);
          if (id > 0 && field.id === id || field.name === name) {
            return { offset: size, ty: field.ty, bit_offset: undefined, bit_width: undefined, bit_unit_size: undefined };
          }
          if (field.name === "") {
            _L$3: {
              _L$4: {
                const _bind$4 = hackwaly$tinycc$sem$$strip_top_qualifiers(field.ty);
                switch (_bind$4.$tag) {
                  case 6: {
                    break _L$4;
                  }
                  case 7: {
                    break _L$4;
                  }
                }
                break _L$3;
              }
              const _bind$4 = hackwaly$tinycc$backend$codegen$$record_field_access_info(ctx, field.ty, name, id, loc);
              if (_bind$4 === undefined) {
              } else {
                const _Some = _bind$4;
                const _inner = _Some;
                return { offset: size + _inner.offset | 0, ty: _inner.ty, bit_offset: _inner.bit_offset, bit_width: _inner.bit_width, bit_unit_size: _inner.bit_unit_size };
              }
            }
          }
          size = size + _field_size | 0;
        } else {
          const _Some = _bind$2;
          const _expr = _Some;
          const _p$28 = hackwaly$tinycc$sem$$const_int_from_expr(ctx, _expr, field.loc);
          const _p$29 = 0;
          let width;
          if (_p$28 === undefined) {
            width = _p$29;
          } else {
            const _p$30 = _p$28;
            width = _p$30;
          }
          const base = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(field.ty);
          const _p$30 = hackwaly$tinycc$sem$$type_size_align(ctx, base, loc);
          let _bind$3;
          if (_p$30 === undefined) {
            _bind$3 = hackwaly$tinycc$backend$codegen$$struct_field_access_info$46$tuple$47$9681;
          } else {
            const _p$31 = _p$30;
            _bind$3 = _p$31;
          }
          const _base_size = _bind$3._0;
          const _base_align = _bind$3._1;
          let field_align = _base_align;
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          if (width === 0) {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
            break _L;
          }
          if (packed && width !== 0) {
            field_align = 1;
          }
          if (field_align_override === undefined) {
          } else {
            const _Some$2 = field_align_override;
            const _value = _Some$2;
            field_align = _value;
          }
          if (field_align_override === undefined) {
            if (!packed) {
              const a8 = Math.imul(field_align, 8) | 0;
              const max_units = field_align > 0 ? _base_size / field_align | 0 : 0;
              if (a8 > 0) {
                const ofs = ((((((Math.imul(size, 8) | 0) + bit_pos | 0) % a8 | 0) + width | 0) + a8 | 0) - 1 | 0) / a8 | 0;
                if (ofs > max_units) {
                  const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
                  size = hackwaly$tinycc$sem$$align_to(size + used_bytes | 0, field_align);
                  bit_pos = 0;
                }
              }
            }
          } else {
            const used_bytes = (bit_pos + 7 | 0) / 8 | 0;
            size = hackwaly$tinycc$sem$$align_to(size + used_bytes | 0, field_align);
            bit_pos = 0;
          }
          while (true) {
            if (bit_pos >= (Math.imul(field_align, 8) | 0)) {
              size = size + field_align | 0;
              bit_pos = bit_pos - (Math.imul(field_align, 8) | 0) | 0;
              continue;
            } else {
              break;
            }
          }
          if (id > 0 && field.id === id || field.name === name) {
            const info = { offset: size, ty: field.ty, bit_offset: bit_pos, bit_width: width, bit_unit_size: undefined };
            return hackwaly$tinycc$backend$codegen$$adjust_bitfield_access_info(ctx, _struct_size, info, loc);
          }
          bit_pos = bit_pos + width | 0;
        }
        break _L;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$backend$codegen$$union_field_access_info(ctx, def, union_attrs, name, id, loc) {
  const fields = def.fields;
  const attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(def.attrs, union_attrs);
  const _bind = hackwaly$tinycc$sem$$union_size_align(ctx, fields, attrs, loc);
  const _union_size = _bind._0;
  const _len = fields.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const field = fields[_i];
      const _bind$2 = field.bit_width;
      if (_bind$2 === undefined) {
      } else {
        const _Some = _bind$2;
        const _expr = _Some;
        if (id > 0 && field.id === id || field.name === name) {
          const _bind$3 = hackwaly$tinycc$sem$$const_int_from_expr(ctx, _expr, field.loc);
          let width;
          if (_bind$3 === undefined) {
            width = 0;
          } else {
            const _Some$2 = _bind$3;
            width = _Some$2;
          }
          if (width > 0) {
            const info = { offset: 0, ty: field.ty, bit_offset: hackwaly$tinycc$backend$codegen$$union_field_access_info$46$constr$47$9750, bit_width: width, bit_unit_size: undefined };
            return hackwaly$tinycc$backend$codegen$$adjust_bitfield_access_info(ctx, _union_size, info, loc);
          }
        }
      }
      if (id > 0 && field.id === id || field.name === name) {
        return { offset: 0, ty: field.ty, bit_offset: undefined, bit_width: undefined, bit_unit_size: undefined };
      }
      if (field.name === "") {
        _L: {
          _L$2: {
            const _bind$3 = hackwaly$tinycc$sem$$strip_top_qualifiers(field.ty);
            switch (_bind$3.$tag) {
              case 6: {
                break _L$2;
              }
              case 7: {
                break _L$2;
              }
            }
            break _L;
          }
          const _bind$3 = hackwaly$tinycc$backend$codegen$$record_field_access_info(ctx, field.ty, name, id, loc);
          if (_bind$3 === undefined) {
          } else {
            const _Some = _bind$3;
            const _inner = _Some;
            return { offset: _inner.offset, ty: _inner.ty, bit_offset: _inner.bit_offset, bit_width: _inner.bit_width, bit_unit_size: _inner.bit_unit_size };
          }
        }
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$backend$codegen$$member_access_info(sem, base, name, id, is_arrow, loc) {
  const base_ty = hackwaly$tinycc$sem$$type_of_expr(sem, base);
  let record_ty;
  if (is_arrow) {
    const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(base_ty);
    if (_bind.$tag === 4) {
      const _Pointer = _bind;
      record_ty = _Pointer._0;
    } else {
      record_ty = base_ty;
    }
  } else {
    record_ty = base_ty;
  }
  return hackwaly$tinycc$backend$codegen$$record_field_access_info(sem, record_ty, name, id, loc);
}
function hackwaly$tinycc$backend$codegen$$ensure_ident_syms_capacity(tab, id) {
  if (id <= 0) {
    return undefined;
  }
  const idx = id - 1 | 0;
  const len = tab.ident_syms.length;
  if (idx < len) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i <= idx) {
      moonbitlang$core$array$$Array$push$57$(tab.ident_syms, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$link_name(name) {
  return `_${name}`;
}
function hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(tab, name, id) {
  if (id > 0) {
    hackwaly$tinycc$backend$codegen$$ensure_ident_syms_capacity(tab, id);
    const idx = id - 1 | 0;
    const _bind = moonbitlang$core$array$$Array$at$57$(tab.ident_syms, idx);
    if (_bind === undefined) {
      const link = hackwaly$tinycc$backend$codegen$$link_name(name);
      const sym = hackwaly$tinycc$backend$codegen$$sym_for_name(tab, link);
      moonbitlang$core$array$$Array$set$57$(tab.ident_syms, idx, sym);
      return sym;
    } else {
      const _Some = _bind;
      return _Some;
    }
  } else {
    const _bind = moonbitlang$core$hashmap$$HashMap$get$171$(tab.link_cache, name);
    if (_bind === undefined) {
      const link = hackwaly$tinycc$backend$codegen$$link_name(name);
      moonbitlang$core$hashmap$$HashMap$set$171$(tab.link_cache, name, link);
      return hackwaly$tinycc$backend$codegen$$sym_for_name(tab, link);
    } else {
      const _Some = _bind;
      const _link = _Some;
      return hackwaly$tinycc$backend$codegen$$sym_for_name(tab, _link);
    }
  }
}
function hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, info) {
  return hackwaly$tinycc$backend$codegen$$sym_for_name(syms, hackwaly$tinycc$backend$codegen$$link_name(info.name));
}
function hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty, loc) {
  const _bind = hackwaly$tinycc$sem$$type_size_align(sem, ty, loc);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _size = _x._0;
    const _align = _x._1;
    return { _0: _size, _1: _align };
  }
}
function hackwaly$tinycc$backend$codegen$$const_pointer_from_expr$46$inner(sem, syms, cstrings, static_locals, expr, label_ctx) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    _L$2: {
      _L$3: {
        switch (expr$2.$tag) {
          case 3: {
            const _StringLit = expr$2;
            const _value = _StringLit._0;
            return { _0: hackwaly$tinycc$backend$codegen$$cstring_sym_or_add(cstrings, syms, _value), _1: 0 };
          }
          case 4: {
            const _Ident = expr$2;
            const _name = _Ident._0;
            const _id = _Ident._1;
            const _bind = moonbitlang$core$hashmap$$HashMap$get$155$(static_locals, _id);
            if (_bind === undefined) {
              return { _0: hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, _name, _id), _1: 0 };
            } else {
              const _Some = _bind;
              const _info = _Some;
              return { _0: hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, _info), _1: 0 };
            }
          }
          case 5: {
            const _LabelAddr = expr$2;
            const _name$2 = _LabelAddr._0;
            if (label_ctx === undefined) {
              return undefined;
            } else {
              const _Some = label_ctx;
              const _ctx = _Some;
              const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$156$(_ctx.labels, _name$2);
              if (_bind$2 === undefined) {
                return undefined;
              } else {
                const _Some$2 = _bind$2;
                const _addr = _Some$2;
                return { _0: _ctx.func_sym, _1: _addr - _ctx.func_start | 0 };
              }
            }
          }
          case 21: {
            break _L$3;
          }
          case 20: {
            break _L$3;
          }
          case 9: {
            const _Unary = expr$2;
            const _x = _Unary._0;
            switch (_x) {
              case 4: {
                const _inner = _Unary._1;
                return hackwaly$tinycc$backend$codegen$$const_pointer_from_lvalue$46$inner(sem, syms, cstrings, static_locals, _inner, label_ctx);
              }
              case 0: {
                const _inner$2 = _Unary._1;
                _tmp$27 = _inner$2;
                continue _L;
              }
              default: {
                break _L$2;
              }
            }
          }
          case 10: {
            const _Cast = expr$2;
            const _inner$3 = _Cast._1;
            _tmp$27 = _inner$3;
            continue _L;
          }
          default: {
            break _L$2;
          }
        }
      }
      const _bind = hackwaly$tinycc$sem$$type_of_lvalue(sem, expr$2);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _ty = _Some;
        const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(_ty);
        if (_bind$2.$tag === 5) {
          return hackwaly$tinycc$backend$codegen$$const_pointer_from_lvalue$46$inner(sem, syms, cstrings, static_locals, expr$2, label_ctx);
        } else {
          return undefined;
        }
      }
    }
    return undefined;
  }
}
function hackwaly$tinycc$backend$codegen$$const_pointer_from_lvalue$46$inner(sem, syms, cstrings, static_locals, expr, label_ctx) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    _L$2: {
      switch (expr$2.$tag) {
        case 4: {
          const _Ident = expr$2;
          const _name = _Ident._0;
          const _id = _Ident._1;
          const _bind = moonbitlang$core$hashmap$$HashMap$get$155$(static_locals, _id);
          if (_bind === undefined) {
            return { _0: hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, _name, _id), _1: 0 };
          } else {
            const _Some = _bind;
            const _info = _Some;
            return { _0: hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, _info), _1: 0 };
          }
        }
        case 3: {
          const _StringLit = expr$2;
          const _value = _StringLit._0;
          return { _0: hackwaly$tinycc$backend$codegen$$cstring_sym_or_add(cstrings, syms, _value), _1: 0 };
        }
        case 21: {
          const _Member = expr$2;
          const _base = _Member._0;
          const _name$2 = _Member._1;
          const _id$2 = _Member._2;
          const _is_arrow = _Member._3;
          const _loc = _Member._5;
          const base_ptr = _is_arrow ? hackwaly$tinycc$backend$codegen$$const_pointer_from_expr$46$inner(sem, syms, cstrings, static_locals, _base, label_ctx) : hackwaly$tinycc$backend$codegen$$const_pointer_from_lvalue$46$inner(sem, syms, cstrings, static_locals, _base, label_ctx);
          if (base_ptr === undefined) {
            return undefined;
          } else {
            const _Some = base_ptr;
            const _x = _Some;
            const _sym = _x._0;
            const _addend = _x._1;
            const _bind$2 = hackwaly$tinycc$backend$codegen$$member_access_info(sem, _base, _name$2, _id$2, _is_arrow, _loc);
            if (_bind$2 === undefined) {
              return undefined;
            } else {
              const _Some$2 = _bind$2;
              const _info = _Some$2;
              const _bind$3 = _info.bit_width;
              return _bind$3 === undefined ? { _0: _sym, _1: _addend + _info.offset | 0 } : undefined;
            }
          }
        }
        case 20: {
          const _Index = expr$2;
          const _base$2 = _Index._0;
          const _index = _Index._1;
          const _loc$2 = _Index._3;
          const _bind$2 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _index, hackwaly$tinycc$frontend$ast$$expr_loc(_index));
          if (_bind$2 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$2;
            const _idx = _Some;
            const _bind$3 = hackwaly$tinycc$backend$codegen$$const_pointer_from_expr$46$inner(sem, syms, cstrings, static_locals, _base$2, label_ctx);
            if (_bind$3 === undefined) {
              return undefined;
            } else {
              const _Some$2 = _bind$3;
              const _x = _Some$2;
              const _sym = _x._0;
              const _addend = _x._1;
              const _bind$4 = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(hackwaly$tinycc$sem$$type_of_expr(sem, _base$2));
              if (_bind$4 === undefined) {
                return undefined;
              } else {
                const _Some$3 = _bind$4;
                const _elem_ty = _Some$3;
                const _bind$5 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, _elem_ty, _loc$2);
                if (_bind$5 === undefined) {
                  return undefined;
                } else {
                  const _Some$4 = _bind$5;
                  const _x$2 = _Some$4;
                  const _elem_size = _x$2._0;
                  return { _0: _sym, _1: _addend + (Math.imul(_idx, _elem_size) | 0) | 0 };
                }
              }
            }
          }
        }
        case 9: {
          const _Unary = expr$2;
          const _x = _Unary._0;
          switch (_x) {
            case 5: {
              const _inner = _Unary._1;
              return hackwaly$tinycc$backend$codegen$$const_pointer_from_expr$46$inner(sem, syms, cstrings, static_locals, _inner, label_ctx);
            }
            case 0: {
              const _inner$2 = _Unary._1;
              _tmp$27 = _inner$2;
              continue _L;
            }
            default: {
              break _L$2;
            }
          }
        }
        case 10: {
          const _Cast = expr$2;
          const _inner$3 = _Cast._1;
          _tmp$27 = _inner$3;
          continue _L;
        }
        default: {
          break _L$2;
        }
      }
    }
    return undefined;
  }
}
function hackwaly$tinycc$backend$codegen$$designators_with_range_index(designators, idx) {
  const result = moonbitlang$core$array$$Array$new$46$inner$37$(designators.length);
  let replaced = false;
  const _len = designators.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const des = designators[_i];
      if (des.$tag === 1) {
        const _IndexRange = des;
        const _des_loc = _IndexRange._2;
        if (!replaced) {
          const expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit(moonbitlang$core$int$$Int$to_string$46$inner(idx, 10), 0, _des_loc);
          moonbitlang$core$array$$Array$push$37$(result, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Index(expr, _des_loc));
          replaced = true;
        } else {
          moonbitlang$core$array$$Array$push$37$(result, des);
        }
      } else {
        moonbitlang$core$array$$Array$push$37$(result, des);
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return result;
}
function hackwaly$tinycc$backend$codegen$$resolve_struct_fields(ctx, tag, tag_id, fields, is_union) {
  return hackwaly$tinycc$sem$$resolve_struct_fields(ctx, tag, tag_id, fields, is_union);
}
function hackwaly$tinycc$backend$codegen$$has_single_init_field_codegen(sem, ty) {
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  switch (_bind.$tag) {
    case 6: {
      const _Struct = _bind;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const fields = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(sem, _tag, _tag_id, _field_list, false);
      if (fields.$tag === 0) {
        return false;
      } else {
        const _Some = fields;
        const _list = _Some._0;
        const _bind$2 = hackwaly$tinycc$sem$$next_init_field(_list, 0);
        if (_bind$2 === undefined) {
          return false;
        } else {
          const _Some$2 = _bind$2;
          const _x = _Some$2;
          const _next_idx = _x._1;
          const _bind$3 = hackwaly$tinycc$sem$$next_init_field(_list, _next_idx);
          return _bind$3 === undefined;
        }
      }
    }
    case 7: {
      const _Union = _bind;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const fields$2 = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(sem, _tag$2, _tag_id$2, _field_list$2, true);
      if (fields$2.$tag === 0) {
        return false;
      } else {
        const _Some = fields$2;
        const _list = _Some._0;
        const _bind$2 = hackwaly$tinycc$sem$$next_init_field(_list, 0);
        if (_bind$2 === undefined) {
          return false;
        } else {
          const _Some$2 = _bind$2;
          const _x = _Some$2;
          const _next_idx = _x._1;
          const _bind$3 = hackwaly$tinycc$sem$$next_init_field(_list, _next_idx);
          return _bind$3 === undefined;
        }
      }
    }
    default: {
      return false;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$resolve_init_designator_access_info(sem, ty, designators, loc, bag) {
  if (designators.length === 0) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: missing designator");
    return undefined;
  }
  let current = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  let off = 0;
  let result_ty = ty;
  let bit_off = undefined;
  let bit_width = undefined;
  let bit_unit_size = undefined;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < designators.length) {
      const des = moonbitlang$core$array$$Array$at$37$(designators, i);
      const is_last = i === (designators.length - 1 | 0);
      switch (des.$tag) {
        case 0: {
          const _Index = des;
          const _expr = _Index._0;
          const _des_loc = _Index._1;
          const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(current);
          if (_bind.$tag === 5) {
            const _Array = _bind;
            const _elem = _Array._0;
            const _size = _Array._1;
            const _bind$2 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, _des_loc);
            let idx;
            if (_bind$2 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator must be constant");
              idx = 0;
            } else {
              const _Some = _bind$2;
              idx = _Some;
            }
            if (_size === undefined) {
            } else {
              const _Some = _size;
              const _n = _Some;
              if (idx < 0 || idx >= _n) {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator out of bounds");
              }
            }
            const _bind$3 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, _elem, _des_loc);
            let _bind$4;
            if (_bind$3 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$3;
              _bind$4 = _Some;
            }
            const _elem_size = _bind$4._0;
            off = off + (Math.imul(idx, _elem_size) | 0) | 0;
            current = hackwaly$tinycc$sem$$strip_top_qualifiers(_elem);
            result_ty = _elem;
            bit_off = undefined;
            bit_width = undefined;
            bit_unit_size = undefined;
          } else {
            hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator on non-array");
            return undefined;
          }
          break;
        }
        case 1: {
          const _IndexRange = des;
          const _des_loc$2 = _IndexRange._2;
          hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$2, "codegen: array range designator must be expanded");
          return undefined;
        }
        default: {
          const _Field = des;
          const _name = _Field._0;
          const _id = _Field._1;
          const _des_loc$3 = _Field._2;
          _L: {
            const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(current);
            switch (_bind$2.$tag) {
              case 6: {
                break _L;
              }
              case 7: {
                break _L;
              }
              default: {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, "codegen: field designator on non-record");
                return undefined;
              }
            }
          }
          const _bind$2 = hackwaly$tinycc$backend$codegen$$record_field_access_info(sem, current, _name, _id, _des_loc$3);
          if (_bind$2 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, `codegen: unknown field '${_name}'`);
            return undefined;
          } else {
            const _Some = _bind$2;
            const _info = _Some;
            off = off + _info.offset | 0;
            result_ty = _info.ty;
            if (is_last) {
              bit_off = _info.bit_offset;
              bit_width = _info.bit_width;
              bit_unit_size = _info.bit_unit_size;
            } else {
              const _bind$3 = _info.bit_width;
              if (_bind$3 === undefined) {
              } else {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, "codegen: designator into bitfield");
                return undefined;
              }
              bit_off = undefined;
              bit_width = undefined;
              bit_unit_size = undefined;
            }
            current = hackwaly$tinycc$sem$$strip_top_qualifiers(_info.ty);
          }
        }
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { offset: off, ty: result_ty, bit_offset: bit_off, bit_width: bit_width, bit_unit_size: bit_unit_size };
}
function hackwaly$tinycc$backend$codegen$$resolve_init_designator_offset_type(sem, ty, designators, _loc, bag) {
  let current = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  let off = 0;
  const _len = designators.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const des = designators[_i];
      switch (des.$tag) {
        case 0: {
          const _Index = des;
          const _expr = _Index._0;
          const _des_loc = _Index._1;
          const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(current);
          if (_bind.$tag === 5) {
            const _Array = _bind;
            const _elem = _Array._0;
            const _size = _Array._1;
            const _bind$2 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, _des_loc);
            let idx;
            if (_bind$2 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator must be constant");
              idx = 0;
            } else {
              const _Some = _bind$2;
              idx = _Some;
            }
            if (_size === undefined) {
            } else {
              const _Some = _size;
              const _n = _Some;
              if (idx < 0 || idx >= _n) {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator out of bounds");
              }
            }
            const _bind$3 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, _elem, _des_loc);
            let _bind$4;
            if (_bind$3 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$3;
              _bind$4 = _Some;
            }
            const _elem_size = _bind$4._0;
            off = off + (Math.imul(idx, _elem_size) | 0) | 0;
            current = hackwaly$tinycc$sem$$strip_top_qualifiers(_elem);
          } else {
            hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator on non-array");
            return undefined;
          }
          break;
        }
        case 1: {
          const _IndexRange = des;
          const _des_loc$2 = _IndexRange._2;
          hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$2, "codegen: array range designator must be expanded");
          return undefined;
        }
        default: {
          const _Field = des;
          const _name = _Field._0;
          const _id = _Field._1;
          const _des_loc$3 = _Field._2;
          const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(current);
          switch (_bind$2.$tag) {
            case 6: {
              const _Struct = _bind$2;
              const _tag = _Struct._0;
              const _tag_id = _Struct._1;
              const _field_list = _Struct._2;
              const fields = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(sem, _tag, _tag_id, _field_list, false);
              if (fields.$tag === 0) {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, `codegen: incomplete struct '${_tag}'`);
                return undefined;
              }
              const _bind$3 = hackwaly$tinycc$backend$codegen$$record_field_access_info(sem, current, _name, _id, _des_loc$3);
              if (_bind$3 === undefined) {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, `codegen: unknown field '${_name}'`);
                return undefined;
              } else {
                const _Some = _bind$3;
                const _info = _Some;
                off = off + _info.offset | 0;
                current = hackwaly$tinycc$sem$$strip_top_qualifiers(_info.ty);
              }
              break;
            }
            case 7: {
              const _Union = _bind$2;
              const _tag$2 = _Union._0;
              const _tag_id$2 = _Union._1;
              const _field_list$2 = _Union._2;
              const fields$2 = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(sem, _tag$2, _tag_id$2, _field_list$2, true);
              if (fields$2.$tag === 0) {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, `codegen: incomplete union '${_tag$2}'`);
                return undefined;
              }
              const _bind$4 = hackwaly$tinycc$backend$codegen$$record_field_access_info(sem, current, _name, _id, _des_loc$3);
              if (_bind$4 === undefined) {
                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, `codegen: unknown field '${_name}'`);
                return undefined;
              } else {
                const _Some = _bind$4;
                const _info = _Some;
                off = off + _info.offset | 0;
                current = hackwaly$tinycc$sem$$strip_top_qualifiers(_info.ty);
              }
              break;
            }
            default: {
              hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$3, "codegen: field designator on non-record");
              return undefined;
            }
          }
        }
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: current, _1: off };
}
function hackwaly$tinycc$backend$codegen$$load_uint_le(buf, offset, size) {
  let v = $0L;
  let i = 0;
  while (true) {
    if (i < size) {
      if ((offset + i | 0) < buf.length) {
        const b = moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$int$$Int$to_uint64(moonbitlang$core$array$$Array$at$26$(buf, offset + i | 0)), $255L);
        v = moonbitlang$core$builtin$$BitOr$lor$6$(v, moonbitlang$core$builtin$$Shl$shl$6$(b, Math.imul(i, 8) | 0));
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return v;
}
function hackwaly$tinycc$backend$codegen$$store_uint64_le(buf, offset, size, bits) {
  hackwaly$tinycc$backend$codegen$$ensure_bytes_len(buf, offset + size | 0);
  let v = bits;
  let i = 0;
  while (true) {
    if (i < size) {
      moonbitlang$core$array$$Array$set$26$(buf, offset + i | 0, moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$BitAnd$land$6$(v, $255L)));
      v = moonbitlang$core$builtin$$Shr$shr$6$(v, 8);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$store_bitfield_int_le(buf, offset, size, bit_off, bit_width, value) {
  if (bit_width <= 0) {
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$ensure_bytes_len(buf, offset + size | 0);
  const unit_bits = Math.imul(size, 8) | 0;
  const mask = bit_width >= unit_bits ? moonbitlang$core$uint64$$UInt64$lnot($0L) : moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, bit_width), $1L);
  const unit_mask = unit_bits === 64 ? moonbitlang$core$uint64$$UInt64$lnot($0L) : moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, unit_bits), $1L);
  const cur = hackwaly$tinycc$backend$codegen$$load_uint_le(buf, offset, size);
  const val = moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$int$$Int$to_int64(value), mask);
  const mask_shift = moonbitlang$core$builtin$$Shl$shl$6$(mask, bit_off);
  const inv_mask = moonbitlang$core$builtin$$BitAnd$land$6$(unit_mask, moonbitlang$core$uint64$$UInt64$lnot(mask_shift));
  const combined = moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitAnd$land$6$(cur, inv_mask), moonbitlang$core$builtin$$BitAnd$land$6$(moonbitlang$core$builtin$$Shl$shl$6$(val, bit_off), unit_mask));
  hackwaly$tinycc$backend$codegen$$store_uint64_le(buf, offset, size, combined);
}
function hackwaly$tinycc$backend$codegen$$store_bitfield_init_le(buf, base_off, info, width, value) {
  const _bind = info.bit_offset;
  let bit_off;
  if (_bind === undefined) {
    bit_off = 0;
  } else {
    const _Some = _bind;
    bit_off = _Some;
  }
  const _bind$2 = info.bit_unit_size;
  if (_bind$2 === undefined) {
    const byte_off = bit_off / 8 | 0;
    const inner_bit = bit_off - (Math.imul(byte_off, 8) | 0) | 0;
    const bytes_needed = ((inner_bit + width | 0) + 7 | 0) / 8 | 0;
    hackwaly$tinycc$backend$codegen$$store_bitfield_int_le(buf, (base_off + info.offset | 0) + byte_off | 0, bytes_needed, inner_bit, width, value);
    return;
  } else {
    const _Some = _bind$2;
    const _unit_size = _Some;
    hackwaly$tinycc$backend$codegen$$store_bitfield_int_le(buf, base_off + info.offset | 0, _unit_size, bit_off, width, value);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$store_int64_le(buf, offset, size, value) {
  hackwaly$tinycc$backend$codegen$$ensure_bytes_len(buf, offset + size | 0);
  let v = value;
  let i = 0;
  while (true) {
    if (i < size) {
      moonbitlang$core$array$$Array$set$26$(buf, offset + i | 0, moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$BitAnd$land$6$(v, $255L)));
      v = moonbitlang$core$builtin$$Shr$shr$6$(v, 8);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$store_int_le(buf, offset, size, value) {
  hackwaly$tinycc$backend$codegen$$ensure_bytes_len(buf, offset + size | 0);
  let v = value;
  let i = 0;
  while (true) {
    if (i < size) {
      moonbitlang$core$array$$Array$set$26$(buf, offset + i | 0, v & 255);
      v = v >> 8;
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$type_is_pointer_like(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _base = _Qualified._1;
        _tmp$27 = _base;
        continue _L;
      }
      case 11: {
        const _Attributed = ty$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      case 4: {
        return true;
      }
      case 5: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, ty, init, bytes, relocs, base_off, bag, label_ctx) {
  let _tmp$27 = ty;
  let _tmp$28 = init;
  let _tmp$29 = base_off;
  _L: while (true) {
    const ty$2 = _tmp$27;
    const init$2 = _tmp$28;
    const base_off$2 = _tmp$29;
    if (init$2.$tag === 0) {
      const _Expr = init$2;
      const _expr = _Expr._0;
      const _loc = _Expr._1;
      _L$2: {
        const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty$2);
        switch (_bind.$tag) {
          case 5: {
            const _Array = _bind;
            const _elem_ty = _Array._0;
            const _bind$2 = hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(sem, ty$2, _loc);
            if (_bind$2 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: incomplete array type");
              return;
            } else {
              const _Some = _bind$2;
              const _n = _Some;
              _L$3: {
                const _bind$3 = hackwaly$tinycc$sem$$try_eval_int_const(sem, _expr);
                if (_bind$3 === undefined) {
                  break _L$3;
                } else {
                  const _Some$2 = _bind$3;
                  const _x = _Some$2;
                  if (_x === 0) {
                    const _bind$4 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, _elem_ty, _loc);
                    let _bind$5;
                    if (_bind$4 === undefined) {
                      return undefined;
                    } else {
                      const _Some$3 = _bind$4;
                      _bind$5 = _Some$3;
                    }
                    const _elem_sz = _bind$5._0;
                    if (_elem_sz > 0) {
                      hackwaly$tinycc$backend$codegen$$ensure_bytes_len(bytes, base_off$2 + (Math.imul(_n, _elem_sz) | 0) | 0);
                      return;
                    } else {
                      return;
                    }
                  } else {
                    break _L$3;
                  }
                }
              }
              if (_expr.$tag === 3) {
                const _StringLit = _expr;
                const _value = _StringLit._0;
                if (hackwaly$tinycc$sem$$is_char_type(_elem_ty)) {
                  const _bind$3 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, _elem_ty, _loc);
                  let _bind$4;
                  if (_bind$3 === undefined) {
                    return undefined;
                  } else {
                    const _Some$2 = _bind$3;
                    _bind$4 = _Some$2;
                  }
                  const _elem_sz = _bind$4._0;
                  if (_elem_sz !== 1) {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: string initializer for non-byte array");
                    return undefined;
                  }
                  let idx = 0;
                  const _arr = moonbitlang$core$encoding$utf8$$encode$46$inner({ str: _value, start: 0, end: _value.length }, false);
                  const _len = _arr.length;
                  let _tmp$30 = 0;
                  while (true) {
                    const _i = _tmp$30;
                    if (_i < _len) {
                      const b = _arr[_i];
                      if (idx >= (_n - 1 | 0)) {
                        break;
                      }
                      hackwaly$tinycc$backend$codegen$$store_int_le(bytes, base_off$2 + idx | 0, 1, b);
                      idx = idx + 1 | 0;
                      _tmp$30 = _i + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                  hackwaly$tinycc$backend$codegen$$store_int_le(bytes, base_off$2 + idx | 0, 1, 0);
                  return;
                } else {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: string initializer for non-byte array");
                  return;
                }
              } else {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: scalar initializer for array not supported");
                return;
              }
            }
          }
          case 6: {
            break _L$2;
          }
          case 7: {
            break _L$2;
          }
          default: {
            const _bind$3 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty$2, _loc);
            let _bind$4;
            if (_bind$3 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$3;
              _bind$4 = _Some;
            }
            const _size = _bind$4._0;
            hackwaly$tinycc$backend$codegen$$ensure_bytes_len(bytes, base_off$2 + _size | 0);
            const _bind$5 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ty$2);
            if (_bind$5 === undefined) {
              if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(ty$2)) {
                const _bind$6 = hackwaly$tinycc$backend$codegen$$const_pointer_from_expr$46$inner(sem, syms, cstrings, static_locals, _expr, label_ctx);
                if (_bind$6 === undefined) {
                  if (_size > 4) {
                    const _bind$7 = hackwaly$tinycc$sem$$const_int64_from_expr(sem, _expr, _loc);
                    if (_bind$7 === undefined) {
                      hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: non-constant pointer initializer");
                      return;
                    } else {
                      const _Some = _bind$7;
                      const _v = _Some;
                      hackwaly$tinycc$backend$codegen$$store_int64_le(bytes, base_off$2, _size, _v);
                      return;
                    }
                  } else {
                    const _bind$7 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, _loc);
                    if (_bind$7 === undefined) {
                      hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: non-constant pointer initializer");
                      return;
                    } else {
                      const _Some = _bind$7;
                      const _v = _Some;
                      hackwaly$tinycc$backend$codegen$$store_int_le(bytes, base_off$2, _size, _v);
                      return;
                    }
                  }
                } else {
                  const _Some = _bind$6;
                  const _x = _Some;
                  const _sym = _x._0;
                  const _addend = _x._1;
                  const addend64 = moonbitlang$core$int$$Int$to_int64(_addend);
                  if (_size > 4) {
                    hackwaly$tinycc$backend$codegen$$store_int64_le(bytes, base_off$2, _size, addend64);
                  } else {
                    hackwaly$tinycc$backend$codegen$$store_int_le(bytes, base_off$2, _size, _addend);
                  }
                  moonbitlang$core$array$$Array$push$104$(relocs, { offset: base_off$2, kind: 257, sym: _sym, addend: addend64 });
                  return;
                }
              } else {
                if (_size > 4) {
                  const _bind$6 = hackwaly$tinycc$sem$$const_int64_from_expr(sem, _expr, _loc);
                  if (_bind$6 === undefined) {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: non-constant scalar initializer");
                    return;
                  } else {
                    const _Some = _bind$6;
                    const _v = _Some;
                    hackwaly$tinycc$backend$codegen$$store_int64_le(bytes, base_off$2, _size, _v);
                    return;
                  }
                } else {
                  const _bind$6 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, _loc);
                  if (_bind$6 === undefined) {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: non-constant scalar initializer");
                    return;
                  } else {
                    const _Some = _bind$6;
                    const _v = _Some;
                    hackwaly$tinycc$backend$codegen$$store_int_le(bytes, base_off$2, _size, _v);
                    return;
                  }
                }
              }
            } else {
              const _Some = _bind$5;
              const _k_raw = _Some;
              const k = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_k_raw);
              const _bind$6 = hackwaly$tinycc$backend$codegen$$const_float_bits_from_expr(sem, _expr, k, _loc);
              if (_bind$6 === undefined) {
                if (_expr.$tag === 1) {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: invalid float initializer");
                  return;
                } else {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: non-constant float initializer");
                  return;
                }
              } else {
                const _Some$2 = _bind$6;
                const _bits = _Some$2;
                hackwaly$tinycc$backend$codegen$$store_uint64_le(bytes, base_off$2, _size, _bits);
                return;
              }
            }
          }
        }
      }
      if (_expr.$tag === 11) {
        const _CompoundLiteral = _expr;
        const _lit_ty = _CompoundLiteral._0;
        const _lit_init = _CompoundLiteral._1;
        _tmp$27 = _lit_ty;
        _tmp$28 = _lit_init;
        continue;
      } else {
        hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: aggregate initializer must be a list");
        return;
      }
    } else {
      const _List = init$2;
      const _items = _List._0;
      const _loc = _List._1;
      const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty$2);
      switch (_bind.$tag) {
        case 5: {
          const _Array = _bind;
          const _elem_ty = _Array._0;
          const _bind$2 = hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(sem, ty$2, _loc);
          let n;
          if (_bind$2 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: incomplete array type");
            return undefined;
          } else {
            const _Some = _bind$2;
            n = _Some;
          }
          const _bind$3 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, _elem_ty, _loc);
          let _bind$4;
          if (_bind$3 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$3;
            _bind$4 = _Some;
          }
          const _elem_size = _bind$4._0;
          const total_bytes = Math.imul(n, _elem_size) | 0;
          hackwaly$tinycc$backend$codegen$$ensure_bytes_len(bytes, base_off$2 + total_bytes | 0);
          let next_index = 0;
          const _len = _items.length;
          let _tmp$30 = 0;
          while (true) {
            const _i = _tmp$30;
            if (_i < _len) {
              _L$2: {
                const item = _items[_i];
                let idx = next_index;
                let has_index = false;
                let range_pos = -1;
                let range_start = undefined;
                let range_end = undefined;
                let range_loc = item.loc;
                if (item.designators.length > 0) {
                  const _bind$5 = moonbitlang$core$array$$Array$at$37$(item.designators, 0);
                  switch (_bind$5.$tag) {
                    case 0: {
                      const _Index = _bind$5;
                      const _expr = _Index._0;
                      const _des_loc = _Index._1;
                      const _bind$6 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, _des_loc);
                      if (_bind$6 === undefined) {
                      } else {
                        const _Some = _bind$6;
                        const _v = _Some;
                        idx = _v;
                        has_index = true;
                        if (idx < 0 || idx >= n) {
                          hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator out of bounds");
                        }
                      }
                      break;
                    }
                    case 1: {
                      const _IndexRange = _bind$5;
                      const _start = _IndexRange._0;
                      const _end = _IndexRange._1;
                      const _des_loc$2 = _IndexRange._2;
                      _L$3: {
                        _L$4: {
                          const _bind$7 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _start, _des_loc$2);
                          const _bind$8 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _end, _des_loc$2);
                          if (_bind$7 === undefined) {
                            break _L$4;
                          } else {
                            const _Some = _bind$7;
                            const _start_val = _Some;
                            if (_bind$8 === undefined) {
                              break _L$4;
                            } else {
                              const _Some$2 = _bind$8;
                              const _end_val = _Some$2;
                              idx = _start_val;
                              has_index = true;
                              range_start = _start_val;
                              range_end = _end_val;
                              range_loc = _des_loc$2;
                              if (idx < 0 || idx >= n) {
                                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$2, "codegen: array designator out of bounds");
                              }
                            }
                          }
                          break _L$3;
                        }
                        hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$2, "codegen: array designator must be constant");
                      }
                      break;
                    }
                  }
                  let i = 0;
                  while (true) {
                    if (i < item.designators.length) {
                      const _bind$7 = moonbitlang$core$array$$Array$at$37$(item.designators, i);
                      if (_bind$7.$tag === 1) {
                        const _IndexRange$2 = _bind$7;
                        const _start$2 = _IndexRange$2._0;
                        const _end$2 = _IndexRange$2._1;
                        const _des_loc$3 = _IndexRange$2._2;
                        range_pos = i;
                        range_loc = _des_loc$3;
                        const _bind$8 = range_start;
                        if (_bind$8 === undefined) {
                          const _bind$9 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _start$2, _des_loc$3);
                          let _tmp$31;
                          if (_bind$9 === undefined) {
                            _tmp$31 = undefined;
                          } else {
                            const _Some = _bind$9;
                            const _v = _Some;
                            _tmp$31 = _v;
                          }
                          range_start = _tmp$31;
                          const _bind$10 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _end$2, _des_loc$3);
                          let _tmp$32;
                          if (_bind$10 === undefined) {
                            _tmp$32 = undefined;
                          } else {
                            const _Some = _bind$10;
                            const _v = _Some;
                            _tmp$32 = _v;
                          }
                          range_end = _tmp$32;
                        }
                        break;
                      }
                      i = i + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                }
                if (range_pos >= 0) {
                  if (range_pos !== (item.designators.length - 1 | 0)) {
                    hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array range designator must be last");
                  } else {
                    _L$3: {
                      _L$4: {
                        const _bind$5 = range_start;
                        const _bind$6 = range_end;
                        if (_bind$5 === undefined) {
                          break _L$4;
                        } else {
                          const _Some = _bind$5;
                          const _start_idx = _Some;
                          if (_bind$6 === undefined) {
                            break _L$4;
                          } else {
                            const _Some$2 = _bind$6;
                            const _end_idx = _Some$2;
                            if (_end_idx < _start_idx) {
                              hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array designator range is empty");
                            } else {
                              if (range_pos === 0 && (_start_idx < 0 || (_end_idx < 0 || (_start_idx >= n || _end_idx >= n)))) {
                                hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array designator out of bounds");
                              }
                              let cur = _start_idx;
                              while (true) {
                                if (cur <= _end_idx) {
                                  if (range_pos === 0 && (cur < 0 || cur >= n)) {
                                    cur = cur + 1 | 0;
                                    continue;
                                  }
                                  const designators = hackwaly$tinycc$backend$codegen$$designators_with_range_index(item.designators, cur);
                                  const _bind$7 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_offset_type(sem, ty$2, designators, item.loc, bag);
                                  let _bind$8;
                                  if (_bind$7 === undefined) {
                                    _bind$8 = { _0: _elem_ty, _1: Math.imul(cur, _elem_size) | 0 };
                                  } else {
                                    const _Some$3 = _bind$7;
                                    const _x = _Some$3;
                                    const _t = _x._0;
                                    const _o = _x._1;
                                    _bind$8 = { _0: _t, _1: _o };
                                  }
                                  const _target_ty = _bind$8._0;
                                  const _rel_off = _bind$8._1;
                                  hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, _target_ty, item.value, bytes, relocs, base_off$2 + _rel_off | 0, bag, label_ctx);
                                  cur = cur + 1 | 0;
                                  continue;
                                } else {
                                  break;
                                }
                              }
                            }
                          }
                        }
                        break _L$3;
                      }
                      hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array designator must be constant");
                    }
                  }
                  if (range_pos === 0) {
                    const _bind$5 = range_end;
                    if (_bind$5 === undefined) {
                    } else {
                      const _Some = _bind$5;
                      const _end_idx = _Some;
                      if (_end_idx >= 0) {
                        next_index = _end_idx + 1 | 0;
                      }
                    }
                  } else {
                    if (has_index) {
                      if (idx >= 0) {
                        next_index = idx + 1 | 0;
                      }
                    } else {
                      next_index = next_index + 1 | 0;
                    }
                  }
                  break _L$2;
                }
                if (!has_index && idx >= n) {
                  break _L$2;
                }
                let _bind$5;
                if (item.designators.length > 0) {
                  const _bind$6 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_offset_type(sem, ty$2, item.designators, item.loc, bag);
                  if (_bind$6 === undefined) {
                    _bind$5 = { _0: _elem_ty, _1: Math.imul(idx, _elem_size) | 0 };
                  } else {
                    const _Some = _bind$6;
                    const _x = _Some;
                    const _t = _x._0;
                    const _o = _x._1;
                    _bind$5 = { _0: _t, _1: _o };
                  }
                } else {
                  _bind$5 = { _0: _elem_ty, _1: Math.imul(idx, _elem_size) | 0 };
                }
                const _target_ty = _bind$5._0;
                const _rel_off = _bind$5._1;
                hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, _target_ty, item.value, bytes, relocs, base_off$2 + _rel_off | 0, bag, label_ctx);
                if (has_index) {
                  if (idx >= 0) {
                    next_index = idx + 1 | 0;
                  }
                } else {
                  next_index = next_index + 1 | 0;
                }
                break _L$2;
              }
              _tmp$30 = _i + 1 | 0;
              continue;
            } else {
              return;
            }
          }
        }
        case 6: {
          const _Struct = _bind;
          const _tag = _Struct._0;
          const _tag_id = _Struct._1;
          const _field_list = _Struct._2;
          const fields = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(sem, _tag, _tag_id, _field_list, false);
          let list;
          if (fields.$tag === 0) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc, `codegen: incomplete struct '${_tag}'`);
            return undefined;
          } else {
            const _Some = fields;
            list = _Some._0;
          }
          const _bind$5 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty$2, _loc);
          let _bind$6;
          if (_bind$5 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$5;
            _bind$6 = _Some;
          }
          const _size = _bind$6._0;
          hackwaly$tinycc$backend$codegen$$ensure_bytes_len(bytes, base_off$2 + _size | 0);
          let index = 0;
          let item_idx = 0;
          while (true) {
            if (item_idx < _items.length) {
              const item = moonbitlang$core$array$$Array$at$38$(_items, item_idx);
              if (item.designators.length > 0) {
                const _bind$7 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_access_info(sem, ty$2, item.designators, item.loc, bag);
                if (_bind$7 === undefined) {
                } else {
                  const _Some = _bind$7;
                  const _info = _Some;
                  const _bind$8 = _info.bit_width;
                  if (_bind$8 === undefined) {
                    hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, _info.ty, item.value, bytes, relocs, base_off$2 + _info.offset | 0, bag, label_ctx);
                  } else {
                    const _Some$2 = _bind$8;
                    const _width = _Some$2;
                    const _bind$9 = item.value;
                    if (_bind$9.$tag === 0) {
                      const _Expr = _bind$9;
                      const _expr = _Expr._0;
                      const _bind$10 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, item.loc);
                      if (_bind$10 === undefined) {
                        hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: non-constant bitfield initializer");
                      } else {
                        const _Some$3 = _bind$10;
                        const _v = _Some$3;
                        hackwaly$tinycc$backend$codegen$$store_bitfield_init_le(bytes, base_off$2, _info, _width, _v);
                      }
                    } else {
                      hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: bitfield initializer must be scalar");
                    }
                  }
                }
                const _bind$8 = moonbitlang$core$array$$Array$at$37$(item.designators, 0);
                if (_bind$8.$tag === 2) {
                  const _Field = _bind$8;
                  const _name = _Field._0;
                  const _id = _Field._1;
                  const _bind$9 = hackwaly$tinycc$sem$$find_field_index_cached(sem, ty$2, _name, _id, item.loc);
                  if (_bind$9 === undefined) {
                  } else {
                    const _Some = _bind$9;
                    const _idx = _Some;
                    index = _idx + 1 | 0;
                  }
                }
                item_idx = item_idx + 1 | 0;
              } else {
                const _bind$7 = hackwaly$tinycc$sem$$next_init_field(list, index);
                if (_bind$7 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: too many initializers for aggregate");
                  item_idx = item_idx + 1 | 0;
                } else {
                  const _Some = _bind$7;
                  const _x = _Some;
                  const _field = _x._0;
                  const _next_idx = _x._1;
                  const _bind$8 = _field.bit_width;
                  let field_off;
                  if (_bind$8 === undefined) {
                    const _bind$9 = hackwaly$tinycc$sem$$eval_builtin_offsetof(sem, ty$2, [_field.name], item.loc);
                    if (_bind$9 === undefined) {
                      field_off = 0;
                    } else {
                      const _Some$2 = _bind$9;
                      field_off = _Some$2;
                    }
                  } else {
                    field_off = 0;
                  }
                  let consumed = 1;
                  let used_elision = false;
                  _L$2: {
                    _L$3: {
                      const _bind$9 = hackwaly$tinycc$sem$$strip_top_qualifiers(_field.ty);
                      const _bind$10 = item.value;
                      switch (_bind$9.$tag) {
                        case 5: {
                          if (_bind$10.$tag === 0) {
                            const _Expr = _bind$10;
                            const _expr = _Expr._0;
                            if (_expr.$tag === 3) {
                            } else {
                              const n$2 = hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(sem, _field.ty, item.loc);
                              const _bind$11 = hackwaly$tinycc$backend$codegen$$collect_elided_array_items_codegen(_items, item_idx, n$2);
                              const _elided_items = _bind$11._0;
                              const _count = _bind$11._1;
                              const init$3 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List(_elided_items, item.loc);
                              hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, _field.ty, init$3, bytes, relocs, base_off$2 + field_off | 0, bag, label_ctx);
                              consumed = _count;
                              used_elision = true;
                            }
                          }
                          break;
                        }
                        case 6: {
                          if (_bind$10.$tag === 0) {
                            break _L$3;
                          }
                          break;
                        }
                        case 7: {
                          if (_bind$10.$tag === 0) {
                            break _L$3;
                          }
                          break;
                        }
                      }
                      break _L$2;
                    }
                    if (hackwaly$tinycc$backend$codegen$$has_single_init_field_codegen(sem, _field.ty)) {
                      const init$3 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List([{ designators: [], value: item.value, loc: item.loc }], item.loc);
                      hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, _field.ty, init$3, bytes, relocs, base_off$2 + field_off | 0, bag, label_ctx);
                      used_elision = true;
                    }
                  }
                  if (!used_elision) {
                    const _bind$9 = _field.bit_width;
                    if (_bind$9 === undefined) {
                      hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, _field.ty, item.value, bytes, relocs, base_off$2 + field_off | 0, bag, label_ctx);
                    } else {
                      const _bind$10 = hackwaly$tinycc$backend$codegen$$record_field_access_info(sem, ty$2, _field.name, _field.id, item.loc);
                      if (_bind$10 === undefined) {
                        hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: missing bitfield info");
                      } else {
                        const _Some$2 = _bind$10;
                        const _info = _Some$2;
                        const _bind$11 = _info.bit_width;
                        if (_bind$11 === undefined) {
                        } else {
                          const _Some$3 = _bind$11;
                          const _width = _Some$3;
                          const _bind$12 = item.value;
                          if (_bind$12.$tag === 0) {
                            const _Expr = _bind$12;
                            const _expr = _Expr._0;
                            const _bind$13 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, item.loc);
                            if (_bind$13 === undefined) {
                              hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: non-constant bitfield initializer");
                            } else {
                              const _Some$4 = _bind$13;
                              const _v = _Some$4;
                              hackwaly$tinycc$backend$codegen$$store_bitfield_init_le(bytes, base_off$2, _info, _width, _v);
                            }
                          } else {
                            hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: bitfield initializer must be scalar");
                          }
                        }
                      }
                    }
                  }
                  index = _next_idx;
                  item_idx = item_idx + consumed | 0;
                }
              }
              continue;
            } else {
              return;
            }
          }
        }
        case 7: {
          const _Union = _bind;
          const _tag$2 = _Union._0;
          const _tag_id$2 = _Union._1;
          const _field_list$2 = _Union._2;
          const fields$2 = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(sem, _tag$2, _tag_id$2, _field_list$2, true);
          let list$2;
          if (fields$2.$tag === 0) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc, `codegen: incomplete union '${_tag$2}'`);
            return undefined;
          } else {
            const _Some = fields$2;
            list$2 = _Some._0;
          }
          const _bind$7 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty$2, _loc);
          let _bind$8;
          if (_bind$7 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$7;
            _bind$8 = _Some;
          }
          const _size$2 = _bind$8._0;
          hackwaly$tinycc$backend$codegen$$ensure_bytes_len(bytes, base_off$2 + _size$2 | 0);
          if (_items.length === 0) {
            return undefined;
          }
          const first = moonbitlang$core$array$$Array$at$38$(_items, 0);
          if (first.designators.length > 0) {
            const _bind$9 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_access_info(sem, ty$2, first.designators, first.loc, bag);
            if (_bind$9 === undefined) {
              return;
            } else {
              const _Some = _bind$9;
              const _info = _Some;
              const _bind$10 = _info.bit_width;
              if (_bind$10 === undefined) {
                _tmp$27 = _info.ty;
                _tmp$28 = first.value;
                _tmp$29 = base_off$2 + _info.offset | 0;
                continue _L;
              } else {
                const _Some$2 = _bind$10;
                const _width = _Some$2;
                const _bind$11 = first.value;
                if (_bind$11.$tag === 0) {
                  const _Expr = _bind$11;
                  const _expr = _Expr._0;
                  const _bind$12 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, first.loc);
                  if (_bind$12 === undefined) {
                    hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: non-constant bitfield initializer");
                    return;
                  } else {
                    const _Some$3 = _bind$12;
                    const _v = _Some$3;
                    hackwaly$tinycc$backend$codegen$$store_bitfield_init_le(bytes, base_off$2, _info, _width, _v);
                    return;
                  }
                } else {
                  hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: bitfield initializer must be scalar");
                  return;
                }
              }
            }
          } else {
            if (list$2.length > 0) {
              const field = moonbitlang$core$array$$Array$at$39$(list$2, 0);
              const _bind$9 = field.bit_width;
              if (_bind$9 === undefined) {
                _tmp$27 = field.ty;
                _tmp$28 = first.value;
                continue _L;
              } else {
                const _bind$10 = hackwaly$tinycc$backend$codegen$$record_field_access_info(sem, ty$2, field.name, field.id, first.loc);
                if (_bind$10 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: missing bitfield info");
                  return;
                } else {
                  const _Some = _bind$10;
                  const _info = _Some;
                  const _bind$11 = _info.bit_width;
                  if (_bind$11 === undefined) {
                    return;
                  } else {
                    const _Some$2 = _bind$11;
                    const _width = _Some$2;
                    const _bind$12 = first.value;
                    if (_bind$12.$tag === 0) {
                      const _Expr = _bind$12;
                      const _expr = _Expr._0;
                      const _bind$13 = hackwaly$tinycc$sem$$const_int_from_expr(sem, _expr, first.loc);
                      if (_bind$13 === undefined) {
                        hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: non-constant bitfield initializer");
                        return;
                      } else {
                        const _Some$3 = _bind$13;
                        const _v = _Some$3;
                        hackwaly$tinycc$backend$codegen$$store_bitfield_init_le(bytes, base_off$2, _info, _width, _v);
                        return;
                      }
                    } else {
                      hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: bitfield initializer must be scalar");
                      return;
                    }
                  }
                }
              }
            } else {
              return;
            }
          }
        }
        default: {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: initializer list for non-aggregate");
          return;
        }
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$build_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, ty, init, bag, label_ctx) {
  let init_loc;
  if (init.$tag === 0) {
    const _Expr = init;
    init_loc = _Expr._1;
  } else {
    const _List = init;
    init_loc = _List._1;
  }
  const _bind = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty, init_loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _size = _bind$2._0;
  const bytes = [];
  hackwaly$tinycc$backend$codegen$$ensure_bytes_len(bytes, _size);
  const relocs = [];
  hackwaly$tinycc$backend$codegen$$fill_global_initializer_bytes$46$inner(sem, syms, cstrings, static_locals, ty, init, bytes, relocs, 0, bag, label_ctx);
  return { _0: bytes, _1: relocs };
}
function hackwaly$tinycc$backend$codegen$$build_string_section(entries, name, align) {
  if (entries.length === 0) {
    return { _0: hackwaly$tinycc$backend$codegen$$fast_map_new$156$(undefined), _1: undefined };
  }
  let size_hint = 0;
  const _len = entries.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const entry = entries[_i];
      size_hint = (size_hint + entry.value.length | 0) + 1 | 0;
      size_hint = size_hint + 3 & -4;
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const offsets = hackwaly$tinycc$backend$codegen$$fast_map_new$156$(entries.length);
  const buf = moonbitlang$core$buffer$$new$46$inner(size_hint);
  const _len$2 = entries.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len$2) {
      const entry = entries[_i];
      const off = buf.len;
      moonbitlang$core$hashmap$$HashMap$set$156$(offsets, entry.value, off);
      const _bind = entry.value;
      moonbitlang$core$buffer$$Buffer$write_string_utf8(buf, { str: _bind, start: 0, end: _bind.length });
      moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
      while (true) {
        if ((buf.len & 3) !== 0) {
          moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
          continue;
        } else {
          break;
        }
      }
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const size_bytes = buf.len;
  const bytes = moonbitlang$core$buffer$$Buffer$view(buf);
  const words = moonbitlang$core$array$$Array$new$46$inner$24$((size_bytes + 3 | 0) / 4 | 0);
  let pos = 0;
  while (true) {
    if ((pos + 3 | 0) < size_bytes) {
      const _p$28 = moonbitlang$core$array$$ArrayView$at$11$(bytes, pos);
      const b0 = _p$28;
      const _p$29 = moonbitlang$core$array$$ArrayView$at$11$(bytes, pos + 1 | 0);
      const b1 = _p$29 << 8;
      const _p$30 = moonbitlang$core$array$$ArrayView$at$11$(bytes, pos + 2 | 0);
      const b2 = _p$30 << 16;
      const _p$31 = moonbitlang$core$array$$ArrayView$at$11$(bytes, pos + 3 | 0);
      const b3 = _p$31 << 24;
      moonbitlang$core$array$$Array$push$24$(words, b0 | b1 | b2 | b3);
      pos = pos + 4 | 0;
      continue;
    } else {
      break;
    }
  }
  const sec = { name: name, data: words, relocs: [], align: align, size_bytes: size_bytes };
  return { _0: offsets, _1: sec };
}
function hackwaly$tinycc$backend$codegen$$infer_array_size_from_init_items(items) {
  let next_index = 0;
  let max_index = -1;
  const _len = items.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const item = items[_i];
      let idx = next_index;
      let has_index = false;
      let range_end = undefined;
      if (item.designators.length > 0) {
        const _bind = moonbitlang$core$array$$Array$at$37$(item.designators, 0);
        switch (_bind.$tag) {
          case 0: {
            const _Index = _bind;
            const _expr = _Index._0;
            const _bind$2 = hackwaly$tinycc$frontend$ast$$const_i64_from_expr(_expr);
            if (_bind$2 === undefined) {
            } else {
              const _Some = _bind$2;
              const _v = _Some;
              idx = moonbitlang$core$int64$$Int64$to_int(_v);
              has_index = true;
            }
            break;
          }
          case 1: {
            const _IndexRange = _bind;
            const _start = _IndexRange._0;
            const _end = _IndexRange._1;
            const _bind$3 = hackwaly$tinycc$frontend$ast$$const_i64_from_expr(_start);
            const _bind$4 = hackwaly$tinycc$frontend$ast$$const_i64_from_expr(_end);
            if (_bind$3 === undefined) {
            } else {
              const _Some = _bind$3;
              const _start_val = _Some;
              if (_bind$4 === undefined) {
              } else {
                const _Some$2 = _bind$4;
                const _end_val = _Some$2;
                idx = moonbitlang$core$int64$$Int64$to_int(_start_val);
                has_index = true;
                range_end = moonbitlang$core$int64$$Int64$to_int(_end_val);
              }
            }
            break;
          }
        }
      }
      const _p$28 = range_end;
      const _p$29 = idx;
      let last_idx;
      if (_p$28 === undefined) {
        last_idx = _p$29;
      } else {
        const _p$30 = _p$28;
        last_idx = _p$30;
      }
      if (last_idx >= 0 && last_idx > max_index) {
        max_index = last_idx;
      }
      if (has_index) {
        if (last_idx >= 0) {
          next_index = last_idx + 1 | 0;
        }
      } else {
        next_index = next_index + 1 | 0;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return max_index < 0 ? 0 : max_index + 1 | 0;
}
function hackwaly$tinycc$backend$codegen$$static_local_base_name(func_name, local_name, id) {
  const func_part = func_name === "" ? "anonymous" : func_name;
  return `__local_static.${func_part}.${local_name}.${moonbitlang$core$builtin$$Show$to_string$90$(id)}`;
}
function hackwaly$tinycc$backend$codegen$$collect_static_local_decl(func_name, decl, locals, decls, init_maps) {
  if (moonbitlang$core$builtin$$Eq$not_equal$78$(decl.storage, 2)) {
    return undefined;
  }
  const stripped = hackwaly$tinycc$sem$$strip_top_qualifiers(decl.ty);
  if (stripped.$tag === 10) {
    return undefined;
  }
  if (decl.id <= 0) {
    return undefined;
  }
  if (moonbitlang$core$hashmap$$HashMap$contains$155$(locals, decl.id)) {
    return undefined;
  }
  let decl_ty = decl.ty;
  if (stripped.$tag === 5) {
    const _Array = stripped;
    const _elem_ty = _Array._0;
    const _x = _Array._1;
    if (_x === undefined) {
      const _x$2 = _Array._2;
      if (_x$2 === undefined) {
        const _bind = decl.init;
        if (_bind === undefined) {
        } else {
          const _Some = _bind;
          const _x$3 = _Some;
          if (_x$3.$tag === 0) {
            const _Expr = _x$3;
            const _x$4 = _Expr._0;
            if (_x$4.$tag === 3) {
              const _StringLit = _x$4;
              const _length = _StringLit._1;
              if (hackwaly$tinycc$sem$$is_char_type(_elem_ty)) {
                decl_ty = hackwaly$tinycc$sem$$apply_inferred_array_size(decl.ty, _length);
              }
            }
          } else {
            const _List = _x$3;
            const _items = _List._0;
            const len = hackwaly$tinycc$backend$codegen$$infer_array_size_from_init_items(_items);
            decl_ty = hackwaly$tinycc$sem$$apply_inferred_array_size(decl.ty, len);
          }
        }
      }
    }
  }
  const base_name = hackwaly$tinycc$backend$codegen$$static_local_base_name(func_name, decl.name, decl.id);
  moonbitlang$core$hashmap$$HashMap$set$155$(locals, decl.id, { name: base_name, ty: decl_ty });
  moonbitlang$core$hashmap$$HashMap$set$154$(init_maps, base_name, locals);
  moonbitlang$core$array$$Array$push$99$(decls, { name: base_name, id: 0, ty: decl_ty, init: decl.init, storage: 2, attrs: decl.attrs, loc: decl.loc });
}
function hackwaly$tinycc$backend$codegen$$collect_static_locals_in_stmt(func_name, stmt, locals, decls, init_maps) {
  let _tmp$27 = stmt;
  _L: while (true) {
    const stmt$2 = _tmp$27;
    switch (stmt$2.$tag) {
      case 0: {
        const _Compound = stmt$2;
        const _stmts = _Compound._0;
        const _len = _stmts.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len) {
            const s = _stmts[_i];
            hackwaly$tinycc$backend$codegen$$collect_static_locals_in_stmt(func_name, s, locals, decls, init_maps);
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 1: {
        const _If = stmt$2;
        const _cond = _If._0;
        const _then_branch = _If._1;
        const _else_branch = _If._2;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _cond, locals, decls, init_maps);
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_stmt(func_name, _then_branch, locals, decls, init_maps);
        if (_else_branch === undefined) {
          return;
        } else {
          const _Some = _else_branch;
          const _s = _Some;
          _tmp$27 = _s;
          continue _L;
        }
      }
      case 2: {
        const _While = stmt$2;
        const _cond$2 = _While._0;
        const _body = _While._1;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _cond$2, locals, decls, init_maps);
        _tmp$27 = _body;
        continue _L;
      }
      case 3: {
        const _DoWhile = stmt$2;
        const _cond$3 = _DoWhile._0;
        const _body$2 = _DoWhile._1;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_stmt(func_name, _body$2, locals, decls, init_maps);
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _cond$3, locals, decls, init_maps);
        return;
      }
      case 4: {
        const _For = stmt$2;
        const _init = _For._0;
        const _cond$4 = _For._1;
        const _step = _For._2;
        const _body$3 = _For._3;
        if (_init === undefined) {
        } else {
          const _Some = _init;
          const _s = _Some;
          hackwaly$tinycc$backend$codegen$$collect_static_locals_in_stmt(func_name, _s, locals, decls, init_maps);
        }
        if (_cond$4 === undefined) {
        } else {
          const _Some = _cond$4;
          const _e = _Some;
          hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _e, locals, decls, init_maps);
        }
        if (_step === undefined) {
        } else {
          const _Some = _step;
          const _e = _Some;
          hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _e, locals, decls, init_maps);
        }
        _tmp$27 = _body$3;
        continue _L;
      }
      case 5: {
        const _Switch = stmt$2;
        const _cond$5 = _Switch._0;
        const _body$4 = _Switch._1;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _cond$5, locals, decls, init_maps);
        _tmp$27 = _body$4;
        continue _L;
      }
      case 6: {
        const _Case = stmt$2;
        const _expr = _Case._0;
        const _end_expr = _Case._1;
        const _body$5 = _Case._2;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _expr, locals, decls, init_maps);
        if (_end_expr === undefined) {
        } else {
          const _Some = _end_expr;
          const _e = _Some;
          hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _e, locals, decls, init_maps);
        }
        _tmp$27 = _body$5;
        continue _L;
      }
      case 7: {
        const _Default = stmt$2;
        const _body$6 = _Default._0;
        _tmp$27 = _body$6;
        continue _L;
      }
      case 8: {
        const _Label = stmt$2;
        const _body$7 = _Label._1;
        _tmp$27 = _body$7;
        continue _L;
      }
      case 13: {
        const _Return = stmt$2;
        const _value = _Return._0;
        if (_value === undefined) {
          return;
        } else {
          const _Some = _value;
          const _expr$2 = _Some;
          hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _expr$2, locals, decls, init_maps);
          return;
        }
      }
      case 14: {
        const _Asm = stmt$2;
        const _asm_stmt = _Asm._0;
        const _arr = _asm_stmt.outputs;
        const _len$2 = _arr.length;
        let _tmp$29 = 0;
        while (true) {
          const _i = _tmp$29;
          if (_i < _len$2) {
            const op = _arr[_i];
            hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, op.expr, locals, decls, init_maps);
            _tmp$29 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _arr$2 = _asm_stmt.inputs;
        const _len$3 = _arr$2.length;
        let _tmp$30 = 0;
        while (true) {
          const _i = _tmp$30;
          if (_i < _len$3) {
            const op = _arr$2[_i];
            hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, op.expr, locals, decls, init_maps);
            _tmp$30 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 15: {
        const _ExprStmt = stmt$2;
        const _expr$2 = _ExprStmt._0;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _expr$2, locals, decls, init_maps);
        return;
      }
      case 16: {
        const _DeclStmt = stmt$2;
        const _items = _DeclStmt._0;
        const _len$4 = _items.length;
        let _tmp$31 = 0;
        while (true) {
          const _i = _tmp$31;
          if (_i < _len$4) {
            const d = _items[_i];
            hackwaly$tinycc$backend$codegen$$collect_static_local_decl(func_name, d, locals, decls, init_maps);
            _tmp$31 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 17: {
        return;
      }
      case 18: {
        return;
      }
      case 19: {
        return;
      }
      case 9: {
        return;
      }
      case 10: {
        return;
      }
      case 11: {
        return;
      }
      default: {
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, expr, locals, decls, init_maps) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    switch (expr$2.$tag) {
      case 9: {
        const _Unary = expr$2;
        const _inner = _Unary._1;
        _tmp$27 = _inner;
        continue _L;
      }
      case 10: {
        const _Cast = expr$2;
        const _inner$2 = _Cast._1;
        _tmp$27 = _inner$2;
        continue _L;
      }
      case 12: {
        const _StmtExpr = expr$2;
        const _stmts = _StmtExpr._0;
        const _len = _stmts.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len) {
            const s = _stmts[_i];
            hackwaly$tinycc$backend$codegen$$collect_static_locals_in_stmt(func_name, s, locals, decls, init_maps);
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 13: {
        const _SizeofExpr = expr$2;
        const _inner$3 = _SizeofExpr._0;
        _tmp$27 = _inner$3;
        continue _L;
      }
      case 15: {
        const _AlignofExpr = expr$2;
        const _inner$4 = _AlignofExpr._0;
        _tmp$27 = _inner$4;
        continue _L;
      }
      case 11: {
        const _CompoundLiteral = expr$2;
        const _init = _CompoundLiteral._1;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_initializer(func_name, _init, locals, decls, init_maps);
        return;
      }
      case 17: {
        const _Binary = expr$2;
        const _left = _Binary._1;
        const _right = _Binary._2;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _left, locals, decls, init_maps);
        _tmp$27 = _right;
        continue _L;
      }
      case 18: {
        const _Conditional = expr$2;
        const _cond = _Conditional._0;
        const _then_expr = _Conditional._1;
        const _else_expr = _Conditional._2;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _cond, locals, decls, init_maps);
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _then_expr, locals, decls, init_maps);
        _tmp$27 = _else_expr;
        continue _L;
      }
      case 19: {
        const _Call = expr$2;
        const _callee = _Call._0;
        const _args = _Call._1;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _callee, locals, decls, init_maps);
        const _len$2 = _args.length;
        let _tmp$29 = 0;
        while (true) {
          const _i = _tmp$29;
          if (_i < _len$2) {
            const a = _args[_i];
            hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, a, locals, decls, init_maps);
            _tmp$29 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 20: {
        const _Index = expr$2;
        const _base = _Index._0;
        const _index = _Index._1;
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _base, locals, decls, init_maps);
        _tmp$27 = _index;
        continue _L;
      }
      case 21: {
        const _Member = expr$2;
        const _base$2 = _Member._0;
        _tmp$27 = _base$2;
        continue _L;
      }
      case 8: {
        const _BuiltinVaArg = expr$2;
        const _list = _BuiltinVaArg._0;
        _tmp$27 = _list;
        continue _L;
      }
      default: {
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$collect_static_locals_in_initializer(func_name, init, locals, decls, init_maps) {
  if (init.$tag === 0) {
    const _Expr = init;
    const _expr = _Expr._0;
    hackwaly$tinycc$backend$codegen$$collect_static_locals_in_expr(func_name, _expr, locals, decls, init_maps);
    return;
  } else {
    const _List = init;
    const _items = _List._0;
    const _len = _items.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const item = _items[_i];
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_initializer(func_name, item.value, locals, decls, init_maps);
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$record_local_slot(alloc, name, id, slot) {
  if (id <= 0) {
    if (alloc.local_overrides.length === 0) {
      moonbitlang$core$hashmap$$HashMap$set$174$(alloc.local_values, name, slot);
      return undefined;
    }
    const idx = alloc.local_overrides.length - 1 | 0;
    const overrides = moonbitlang$core$array$$Array$at$46$(alloc.local_overrides, idx);
    moonbitlang$core$array$$Array$push$35$(overrides, { _0: name, _1: moonbitlang$core$hashmap$$HashMap$get$174$(alloc.local_values, name) });
    moonbitlang$core$array$$Array$set$46$(alloc.local_overrides, idx, overrides);
    moonbitlang$core$hashmap$$HashMap$set$174$(alloc.local_values, name, slot);
    return undefined;
  }
  if (alloc.local_id_overrides.length === 0) {
    moonbitlang$core$hashmap$$HashMap$set$175$(alloc.local_id_values, id, slot);
    return undefined;
  }
  const idx = alloc.local_id_overrides.length - 1 | 0;
  const id_overrides = moonbitlang$core$array$$Array$at$47$(alloc.local_id_overrides, idx);
  moonbitlang$core$array$$Array$push$36$(id_overrides, { _0: id, _1: moonbitlang$core$hashmap$$HashMap$get$175$(alloc.local_id_values, id) });
  moonbitlang$core$array$$Array$set$47$(alloc.local_id_overrides, idx, id_overrides);
  moonbitlang$core$hashmap$$HashMap$set$175$(alloc.local_id_values, id, slot);
}
function hackwaly$tinycc$backend$codegen$$update_local_slot(alloc, name, id, slot) {
  if (id > 0) {
    moonbitlang$core$hashmap$$HashMap$set$175$(alloc.local_id_values, id, slot);
    return;
  } else {
    moonbitlang$core$hashmap$$HashMap$set$174$(alloc.local_values, name, slot);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$alloc_local(alloc, name, id, ty, loc) {
  let _bind;
  _L: {
    _L$2: {
      const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
      if (_bind$2.$tag === 5) {
        const _Array = _bind$2;
        const _x = _Array._1;
        if (_x === undefined) {
          const _x$2 = _Array._2;
          if (_x$2 === undefined) {
            break _L$2;
          } else {
            _bind = { _0: 8, _1: 8, _2: undefined, _3: undefined };
          }
        } else {
          break _L$2;
        }
      } else {
        break _L$2;
      }
      break _L;
    }
    const _bind$2 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ty, loc);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _size = _x._0;
      const _align = _x._1;
      _bind = { _0: _size, _1: _align, _2: _size, _3: _align };
    }
  }
  const _slot_size = _bind._0;
  const _slot_align = _bind._1;
  const _type_size = _bind._2;
  const _type_align = _bind._3;
  const aligned = hackwaly$tinycc$backend$codegen$$align_up(alloc.used_bytes, _slot_align);
  alloc.used_bytes = aligned + _slot_size | 0;
  const offset = -(aligned + _slot_size | 0) | 0;
  const slot = { offset: offset, ty: ty, vla_size_offset: undefined, byref: false, type_size: _type_size, type_align: _type_align };
  const idx = alloc.scopes.length - 1 | 0;
  const scope = moonbitlang$core$array$$Array$at$33$(alloc.scopes, idx);
  const already = id > 0 && moonbitlang$core$hashmap$$HashMap$contains$175$(scope, id);
  if (id > 0) {
    moonbitlang$core$hashmap$$HashMap$set$175$(scope, id, slot);
  }
  if (!already) {
    hackwaly$tinycc$backend$codegen$$record_local_slot(alloc, name, id, slot);
  } else {
    hackwaly$tinycc$backend$codegen$$update_local_slot(alloc, name, id, slot);
  }
  hackwaly$tinycc$sem$$record_local_binding(alloc.sem, id, ty);
  return slot;
}
function hackwaly$tinycc$backend$codegen$$alloc_local_byref(alloc, name, id, ty) {
  const aligned = hackwaly$tinycc$backend$codegen$$align_up(alloc.used_bytes, 8);
  alloc.used_bytes = aligned + 8 | 0;
  const offset = -(aligned + 8 | 0) | 0;
  const slot = { offset: offset, ty: ty, vla_size_offset: undefined, byref: true, type_size: undefined, type_align: undefined };
  const idx = alloc.scopes.length - 1 | 0;
  const scope = moonbitlang$core$array$$Array$at$33$(alloc.scopes, idx);
  const already = id > 0 && moonbitlang$core$hashmap$$HashMap$contains$175$(scope, id);
  if (id > 0) {
    moonbitlang$core$hashmap$$HashMap$set$175$(scope, id, slot);
  }
  if (!already) {
    hackwaly$tinycc$backend$codegen$$record_local_slot(alloc, name, id, slot);
  } else {
    hackwaly$tinycc$backend$codegen$$update_local_slot(alloc, name, id, slot);
  }
  hackwaly$tinycc$sem$$record_local_binding(alloc.sem, id, ty);
  return slot;
}
function hackwaly$tinycc$backend$codegen$$arm64_hfa_aux(sem, ty, fsize, num, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ty);
  if (_bind === undefined) {
  } else {
    const _bind$2 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty, loc);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _size = _x._0;
      if (num >= 4 || fsize !== 0 && fsize !== _size) {
        return undefined;
      } else {
        const next_size = fsize === 0 ? _size : fsize;
        return { _0: num + 1 | 0, _1: next_size };
      }
    }
  }
  const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  switch (_bind$2.$tag) {
    case 6: {
      const _Struct = _bind$2;
      const _tag = _Struct._0;
      const _tag_id = _Struct._1;
      const _field_list = _Struct._2;
      const _struct_attrs = _Struct._3;
      const _bind$3 = hackwaly$tinycc$backend$codegen$$ensure_struct_fields(sem, _tag, _tag_id, _field_list, false, loc);
      if (_bind$3 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$3;
        const _def = _Some;
        const _arr = _def.fields;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const field = _arr[_i];
            const _bind$4 = field.bit_width;
            if (_bind$4 === undefined) {
            } else {
              return undefined;
            }
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        let num_cur = num;
        let fsize_cur = fsize;
        const _arr$2 = _def.fields;
        const _len$2 = _arr$2.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len$2) {
            const field = _arr$2[_i];
            const _bind$4 = hackwaly$tinycc$backend$codegen$$arm64_hfa_aux(sem, field.ty, fsize_cur, num_cur, loc, bag);
            if (_bind$4 === undefined) {
              return undefined;
            } else {
              const _Some$2 = _bind$4;
              const _x = _Some$2;
              const _n1 = _x._0;
              const _s1 = _x._1;
              num_cur = _n1;
              fsize_cur = _s1;
            }
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const merged = hackwaly$tinycc$frontend$ast$$merge_attrs(_def.attrs, _struct_attrs);
        const _bind$4 = hackwaly$tinycc$sem$$struct_size_align(sem, _def.fields, merged, loc);
        const _struct_size = _bind$4._0;
        return fsize_cur === 0 || _struct_size !== (Math.imul(num_cur - num | 0, fsize_cur) | 0) ? undefined : { _0: num_cur, _1: fsize_cur };
      }
    }
    case 7: {
      const _Union = _bind$2;
      const _tag$2 = _Union._0;
      const _tag_id$2 = _Union._1;
      const _field_list$2 = _Union._2;
      const _union_attrs = _Union._3;
      const _bind$4 = hackwaly$tinycc$backend$codegen$$ensure_struct_fields(sem, _tag$2, _tag_id$2, _field_list$2, true, loc);
      if (_bind$4 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$4;
        const _def = _Some;
        const _arr = _def.fields;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const field = _arr[_i];
            const _bind$5 = field.bit_width;
            if (_bind$5 === undefined) {
            } else {
              return undefined;
            }
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        let best_num = undefined;
        let best_size = 0;
        const _arr$2 = _def.fields;
        const _len$2 = _arr$2.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len$2) {
            const field = _arr$2[_i];
            const _bind$5 = hackwaly$tinycc$backend$codegen$$arm64_hfa_aux(sem, field.ty, fsize, num, loc, bag);
            if (_bind$5 === undefined) {
              return undefined;
            } else {
              const _Some$2 = _bind$5;
              const _x = _Some$2;
              const _n1 = _x._0;
              const _s1 = _x._1;
              const _bind$6 = best_num;
              if (_bind$6 === undefined) {
                best_num = _n1;
                best_size = _s1;
              } else {
                const _Some$3 = _bind$6;
                const _prev = _Some$3;
                if (_n1 < _prev) {
                  best_num = _n1;
                  best_size = _s1;
                }
              }
            }
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _bind$5 = best_num;
        if (_bind$5 === undefined) {
          return undefined;
        } else {
          const _Some$2 = _bind$5;
          const _num_best = _Some$2;
          const merged = hackwaly$tinycc$frontend$ast$$merge_attrs(_def.attrs, _union_attrs);
          const _bind$6 = hackwaly$tinycc$sem$$union_size_align(sem, _def.fields, merged, loc);
          const _union_size = _bind$6._0;
          return best_size === 0 || _union_size !== (Math.imul(_num_best - num | 0, best_size) | 0) ? undefined : { _0: _num_best, _1: best_size };
        }
      }
    }
    case 5: {
      const _Array = _bind$2;
      const _elem = _Array._0;
      const _size = _Array._1;
      if (_size === undefined) {
        return undefined;
      } else {
        const _Some = _size;
        const _count = _Some;
        if (_count === 0) {
          return { _0: num, _1: fsize };
        } else {
          const _bind$5 = hackwaly$tinycc$backend$codegen$$arm64_hfa_aux(sem, _elem, fsize, num, loc, bag);
          if (_bind$5 === undefined) {
            return undefined;
          } else {
            const _Some$2 = _bind$5;
            const _x = _Some$2;
            const _num1 = _x._0;
            const _fsize1 = _x._1;
            const elem_count = _num1 - num | 0;
            if (elem_count === 0 || elem_count !== 0 && _count > 4) {
              return undefined;
            } else {
              const total = num + (Math.imul(_count, elem_count) | 0) | 0;
              return total > 4 ? undefined : { _0: total, _1: _fsize1 };
            }
          }
        }
      }
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$arm64_hfa(sem, ty, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$arm64_hfa_aux(sem, ty, 0, 0, loc, bag);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _num = _x._0;
    const _fsize = _x._1;
    return _num > 0 && (_num <= 4 && _fsize > 0) ? { _0: _num, _1: _fsize } : undefined;
  }
}
function hackwaly$tinycc$backend$codegen$$cg_pop_scope(alloc) {
  moonbitlang$core$array$$Array$pop$33$(alloc.scopes);
  moonbitlang$core$array$$Array$pop$48$(alloc.vla_scopes);
  const _bind = moonbitlang$core$array$$Array$pop$46$(alloc.local_overrides);
  if (_bind.$tag === 1) {
    const _Some = _bind;
    const _overrides = _Some._0;
    let i = _overrides.length;
    while (true) {
      if (i > 0) {
        i = i - 1 | 0;
        const _bind$2 = moonbitlang$core$array$$Array$at$35$(_overrides, i);
        const _name = _bind$2._0;
        const _prev = _bind$2._1;
        if (_prev === undefined) {
          moonbitlang$core$hashmap$$HashMap$remove$174$(alloc.local_values, _name);
        } else {
          const _Some$2 = _prev;
          const _slot = _Some$2;
          moonbitlang$core$hashmap$$HashMap$set$174$(alloc.local_values, _name, _slot);
        }
        continue;
      } else {
        break;
      }
    }
  }
  const _bind$2 = moonbitlang$core$array$$Array$pop$47$(alloc.local_id_overrides);
  if (_bind$2.$tag === 1) {
    const _Some = _bind$2;
    const _overrides = _Some._0;
    let i = _overrides.length;
    while (true) {
      if (i > 0) {
        i = i - 1 | 0;
        const _bind$3 = moonbitlang$core$array$$Array$at$36$(_overrides, i);
        const _id = _bind$3._0;
        const _prev = _bind$3._1;
        if (_prev === undefined) {
          moonbitlang$core$hashmap$$HashMap$remove$175$(alloc.local_id_values, _id);
        } else {
          const _Some$2 = _prev;
          const _slot = _Some$2;
          moonbitlang$core$hashmap$$HashMap$set$175$(alloc.local_id_values, _id, _slot);
        }
        continue;
      } else {
        break;
      }
    }
  }
  hackwaly$tinycc$sem$$pop_scope(alloc.sem);
}
function hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc) {
  moonbitlang$core$array$$Array$push$33$(alloc.scopes, hackwaly$tinycc$backend$codegen$$fast_map_new$175$(undefined));
  moonbitlang$core$array$$Array$push$48$(alloc.vla_scopes, hackwaly$tinycc$backend$codegen$$cg_push_scope$46$record$47$10771);
  moonbitlang$core$array$$Array$push$46$(alloc.local_overrides, []);
  moonbitlang$core$array$$Array$push$47$(alloc.local_id_overrides, []);
  hackwaly$tinycc$sem$$push_scope(alloc.sem);
}
function hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, size, align) {
  const aligned = hackwaly$tinycc$backend$codegen$$align_up(alloc.used_bytes, align);
  alloc.used_bytes = aligned + size | 0;
  return -(aligned + size | 0) | 0;
}
function hackwaly$tinycc$backend$codegen$$arm64_pcs_size_align(sem, ty, loc, _bag) {
  _L: {
    const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
    switch (_bind.$tag) {
      case 5: {
        break _L;
      }
      case 10: {
        break _L;
      }
      default: {
        return hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty, loc);
      }
    }
  }
  return hackwaly$tinycc$backend$codegen$$arm64_pcs_size_align$46$constr$47$10778;
}
function hackwaly$tinycc$backend$codegen$$arm64_pcs_aux(sem, variadic_index, types, loc, bag) {
  let nx = 0;
  let nv = 0;
  let ns = 32;
  const locs = moonbitlang$core$array$$Array$new$46$inner$26$(types.length);
  const sizes = moonbitlang$core$array$$Array$new$46$inner$26$(types.length);
  const aligns = moonbitlang$core$array$$Array$new$46$inner$26$(types.length);
  const hfa_counts = moonbitlang$core$array$$Array$new$46$inner$26$(types.length);
  const hfa_sizes = moonbitlang$core$array$$Array$new$46$inner$26$(types.length);
  const is_agg_list = moonbitlang$core$array$$Array$new$46$inner$67$(types.length);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < types.length) {
      _L: {
        const ty = moonbitlang$core$array$$Array$at$29$(types, i);
        const _bind = hackwaly$tinycc$backend$codegen$$arm64_hfa(sem, ty, loc, bag);
        let _bind$2;
        if (_bind === undefined) {
          _bind$2 = hackwaly$tinycc$backend$codegen$$arm64_pcs_aux$46$tuple$47$10785;
        } else {
          const _Some = _bind;
          _bind$2 = _Some;
        }
        const _hfa_count = _bind$2._0;
        const _hfa_size = _bind$2._1;
        const _bind$3 = hackwaly$tinycc$backend$codegen$$arm64_pcs_size_align(sem, ty, loc, bag);
        let _bind$4;
        if (_bind$3 === undefined) {
          _bind$4 = hackwaly$tinycc$backend$codegen$$arm64_pcs_aux$46$tuple$47$10786;
        } else {
          const _Some = _bind$3;
          _bind$4 = _Some;
        }
        const _size0 = _bind$4._0;
        const _align0 = _bind$4._1;
        const _bind$5 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
        let is_agg;
        switch (_bind$5.$tag) {
          case 6: {
            is_agg = true;
            break;
          }
          case 7: {
            is_agg = true;
            break;
          }
          default: {
            is_agg = false;
          }
        }
        moonbitlang$core$array$$Array$push$26$(sizes, _size0);
        moonbitlang$core$array$$Array$push$26$(aligns, _align0);
        moonbitlang$core$array$$Array$push$26$(hfa_counts, _hfa_count);
        moonbitlang$core$array$$Array$push$26$(hfa_sizes, _hfa_size);
        moonbitlang$core$array$$Array$push$67$(is_agg_list, is_agg);
        const _bind$6 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ty);
        const is_float = !(_bind$6 === undefined);
        const _bind$7 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
        let is_long_double;
        if (_bind$7.$tag === 3) {
          const _Float = _bind$7;
          const _x = _Float._0;
          if (_x === 2) {
            is_long_double = true;
          } else {
            is_long_double = false;
          }
        } else {
          is_long_double = false;
        }
        let size = _size0;
        if (variadic_index > 0 && i === variadic_index) {
          nx = 8;
          nv = 8;
        }
        if (_hfa_count === 0 && size > 16) {
          if (nx < 8) {
            moonbitlang$core$array$$Array$push$26$(locs, nx << 1 | 1);
            nx = nx + 1 | 0;
          } else {
            ns = hackwaly$tinycc$backend$codegen$$align_up(ns, 8);
            moonbitlang$core$array$$Array$push$26$(locs, ns | 1);
            ns = ns + 8 | 0;
          }
          break _L;
        } else {
          if (is_agg) {
            size = hackwaly$tinycc$backend$codegen$$align_up(size, 8);
          }
        }
        if (is_float && nv < 8) {
          moonbitlang$core$array$$Array$push$26$(locs, 16 + (nv << 1) | 0);
          nv = nv + 1 | 0;
          break _L;
        }
        if (_hfa_count > 0 && (nv + _hfa_count | 0) <= 8) {
          moonbitlang$core$array$$Array$push$26$(locs, 16 + (nv << 1) | 0);
          nv = nv + _hfa_count | 0;
          break _L;
        }
        if (_hfa_count > 0) {
          nv = 8;
          size = hackwaly$tinycc$backend$codegen$$align_up(size, 8);
        }
        if (_hfa_count > 0 || is_long_double) {
          ns = hackwaly$tinycc$backend$codegen$$align_up(ns, 8);
          ns = hackwaly$tinycc$backend$codegen$$align_up(ns, _align0);
        }
        if (is_float) {
          size = 8;
        }
        if (_hfa_count > 0 || is_float) {
          moonbitlang$core$array$$Array$push$26$(locs, ns);
          ns = ns + size | 0;
          break _L;
        }
        if (!is_agg && (size <= 8 && nx < 8)) {
          moonbitlang$core$array$$Array$push$26$(locs, nx << 1);
          nx = nx + 1 | 0;
          break _L;
        }
        if (_align0 === 16) {
          nx = nx + 1 & -2;
        }
        if (!is_agg && (size === 16 && nx < 7)) {
          moonbitlang$core$array$$Array$push$26$(locs, nx << 1);
          nx = nx + 2 | 0;
          break _L;
        }
        if (is_agg && size <= (Math.imul(8 - nx | 0, 8) | 0)) {
          moonbitlang$core$array$$Array$push$26$(locs, nx << 1);
          nx = nx + (size + 7 >> 3) | 0;
          break _L;
        }
        nx = 8;
        ns = hackwaly$tinycc$backend$codegen$$align_up(ns, 8);
        ns = hackwaly$tinycc$backend$codegen$$align_up(ns, _align0);
        if (is_agg) {
          moonbitlang$core$array$$Array$push$26$(locs, ns);
          ns = ns + size | 0;
          break _L;
        }
        if (size < 8) {
          size = 8;
        }
        moonbitlang$core$array$$Array$push$26$(locs, ns);
        ns = ns + size | 0;
        break _L;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { locs: locs, stack_size: ns - 32 | 0, sizes: sizes, aligns: aligns, hfa_counts: hfa_counts, hfa_sizes: hfa_sizes, is_agg: is_agg_list };
}
function hackwaly$tinycc$backend$codegen$$arm64_pcs(sem, variadic_index, ret_ty, arg_tys, loc, bag) {
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ret_ty);
  let ret_loc;
  if (_bind.$tag === 0) {
    ret_loc = -1;
  } else {
    const ret_info = hackwaly$tinycc$backend$codegen$$arm64_pcs_aux(sem, 0, [ret_ty], loc, bag);
    const _bind$2 = moonbitlang$core$array$$Array$get$26$(ret_info.locs, 0);
    if (_bind$2 === undefined) {
      ret_loc = -1;
    } else {
      const _Some = _bind$2;
      ret_loc = _Some;
    }
  }
  const arg_info = hackwaly$tinycc$backend$codegen$$arm64_pcs_aux(sem, variadic_index, arg_tys, loc, bag);
  return { ret_loc: ret_loc, arg_locs: arg_info.locs, stack_size: arg_info.stack_size, arg_sizes: arg_info.sizes, arg_aligns: arg_info.aligns, arg_hfa_counts: arg_info.hfa_counts, arg_hfa_sizes: arg_info.hfa_sizes, arg_is_agg: arg_info.is_agg };
}
function hackwaly$tinycc$backend$codegen$$record_static_local_binding(alloc, decl) {
  if (decl.id <= 0 || hackwaly$tinycc$sem$$current_local_scope_id(alloc.sem) === 0) {
    return undefined;
  }
  const _bind = moonbitlang$core$hashmap$$HashMap$get$155$(alloc.static_locals, decl.id);
  let ty;
  if (_bind === undefined) {
    ty = decl.ty;
  } else {
    const _Some = _bind;
    const _info = _Some;
    ty = _info.ty;
  }
  hackwaly$tinycc$sem$$record_local_binding(alloc.sem, decl.id, ty);
}
function hackwaly$tinycc$backend$codegen$$vla_record_decl(alloc, vla_slot_offset) {
  const idx = alloc.vla_scopes.length - 1 | 0;
  const cur = moonbitlang$core$array$$Array$at$48$(alloc.vla_scopes, idx);
  let locorig = cur.locorig;
  let needs_save = undefined;
  if (cur.num === 0) {
    if (idx > 0) {
      const parent = moonbitlang$core$array$$Array$at$48$(alloc.vla_scopes, idx - 1 | 0);
      if (parent.num > 0) {
        locorig = parent.loc;
      } else {
        const off = hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, 8, 8);
        locorig = off;
        needs_save = off;
      }
    } else {
      const off = hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, 8, 8);
      locorig = off;
      needs_save = off;
    }
  }
  moonbitlang$core$array$$Array$set$48$(alloc.vla_scopes, idx, { num: cur.num + 1 | 0, loc: vla_slot_offset, locorig: locorig });
  return needs_save;
}
function hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, stmt, walk_exprs) {
  let _tmp$27 = stmt;
  _L: while (true) {
    const stmt$2 = _tmp$27;
    switch (stmt$2.$tag) {
      case 0: {
        const _Compound = stmt$2;
        const _stmts = _Compound._0;
        let did_scope = false;
        const _len = _stmts.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len) {
            const s = _stmts[_i];
            if (!did_scope) {
              if (s.$tag === 16) {
                hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
                did_scope = true;
              }
            }
            hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, s, walk_exprs);
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (did_scope) {
          hackwaly$tinycc$backend$codegen$$cg_pop_scope(alloc);
          return;
        } else {
          return;
        }
      }
      case 16: {
        const _DeclStmt = stmt$2;
        const _decls = _DeclStmt._0;
        const _len$2 = _decls.length;
        let _tmp$29 = 0;
        while (true) {
          const _i = _tmp$29;
          if (_i < _len$2) {
            _L$2: {
              const d = _decls[_i];
              const stripped = hackwaly$tinycc$sem$$strip_top_qualifiers(d.ty);
              if (stripped.$tag === 10) {
                break _L$2;
              }
              if (moonbitlang$core$builtin$$Eq$equal$79$(d.storage, 1)) {
                break _L$2;
              }
              if (moonbitlang$core$builtin$$Eq$equal$79$(d.storage, 2)) {
                hackwaly$tinycc$backend$codegen$$record_static_local_binding(alloc, d);
                break _L$2;
              }
              let decl_ty = d.ty;
              if (stripped.$tag === 5) {
                const _Array = stripped;
                const _elem_ty = _Array._0;
                const _x = _Array._1;
                if (_x === undefined) {
                  const _x$2 = _Array._2;
                  if (_x$2 === undefined) {
                    const _bind = d.init;
                    if (_bind === undefined) {
                    } else {
                      const _Some = _bind;
                      const _x$3 = _Some;
                      if (_x$3.$tag === 0) {
                        const _Expr = _x$3;
                        const _x$4 = _Expr._0;
                        if (_x$4.$tag === 3) {
                          const _StringLit = _x$4;
                          const _length = _StringLit._1;
                          if (hackwaly$tinycc$sem$$is_char_type(_elem_ty)) {
                            decl_ty = hackwaly$tinycc$sem$$apply_inferred_array_size(d.ty, _length);
                          }
                        }
                      } else {
                        const _List = _x$3;
                        const _items = _List._0;
                        const len = hackwaly$tinycc$backend$codegen$$infer_array_size_from_init_items(_items);
                        decl_ty = hackwaly$tinycc$sem$$apply_inferred_array_size(d.ty, len);
                      }
                    }
                  }
                }
              }
              const _bind = hackwaly$tinycc$backend$codegen$$alloc_local(alloc, d.name, d.id, decl_ty, d.loc);
              if (_bind === undefined) {
              } else {
                const _Some = _bind;
                const _slot = _Some;
                const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(_slot.ty);
                if (_bind$2.$tag === 5) {
                  const _Array = _bind$2;
                  const _x = _Array._1;
                  if (_x === undefined) {
                    const _x$2 = _Array._2;
                    if (_x$2 === undefined) {
                    } else {
                      const size_off = hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, 8, 8);
                      const updated = { offset: _slot.offset, ty: _slot.ty, vla_size_offset: size_off, byref: _slot.byref, type_size: _slot.type_size, type_align: _slot.type_align };
                      if (d.id > 0) {
                        const scope_idx = alloc.scopes.length - 1 | 0;
                        moonbitlang$core$hashmap$$HashMap$set$175$(moonbitlang$core$array$$Array$at$33$(alloc.scopes, scope_idx), d.id, updated);
                      }
                      hackwaly$tinycc$backend$codegen$$update_local_slot(alloc, d.name, d.id, updated);
                      hackwaly$tinycc$backend$codegen$$vla_record_decl(alloc, _slot.offset);
                    }
                  }
                }
              }
              const _bind$2 = d.init;
              if (_bind$2 === undefined) {
              } else {
                const _Some = _bind$2;
                const _init = _Some;
                hackwaly$tinycc$backend$codegen$$layout_initializer(alloc, _init, walk_exprs);
              }
              break _L$2;
            }
            _tmp$29 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 1: {
        const _If = stmt$2;
        const _cond = _If._0;
        const _then_branch = _If._1;
        const _else_branch = _If._2;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _cond, walk_exprs);
        hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, _then_branch, walk_exprs);
        if (_else_branch === undefined) {
          return;
        } else {
          const _Some = _else_branch;
          const _s = _Some;
          _tmp$27 = _s;
          continue _L;
        }
      }
      case 2: {
        const _While = stmt$2;
        const _cond$2 = _While._0;
        const _body = _While._1;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _cond$2, walk_exprs);
        _tmp$27 = _body;
        continue _L;
      }
      case 3: {
        const _DoWhile = stmt$2;
        const _cond$3 = _DoWhile._0;
        const _body$2 = _DoWhile._1;
        hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, _body$2, walk_exprs);
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _cond$3, walk_exprs);
        return;
      }
      case 4: {
        const _For = stmt$2;
        const _init = _For._0;
        const _cond$4 = _For._1;
        const _step = _For._2;
        const _body$3 = _For._3;
        let needs_scope;
        if (_init === undefined) {
          needs_scope = false;
        } else {
          const _Some = _init;
          const _x = _Some;
          if (_x.$tag === 16) {
            needs_scope = true;
          } else {
            needs_scope = false;
          }
        }
        if (needs_scope) {
          hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
        }
        if (_init === undefined) {
        } else {
          const _Some = _init;
          const _s = _Some;
          hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, _s, walk_exprs);
        }
        if (_cond$4 === undefined) {
        } else {
          const _Some = _cond$4;
          const _e = _Some;
          hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _e, walk_exprs);
        }
        if (_step === undefined) {
        } else {
          const _Some = _step;
          const _e = _Some;
          hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _e, walk_exprs);
        }
        hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, _body$3, walk_exprs);
        if (needs_scope) {
          hackwaly$tinycc$backend$codegen$$cg_pop_scope(alloc);
          return;
        } else {
          return;
        }
      }
      case 5: {
        const _Switch = stmt$2;
        const _cond$5 = _Switch._0;
        const _body$4 = _Switch._1;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _cond$5, walk_exprs);
        _tmp$27 = _body$4;
        continue _L;
      }
      case 6: {
        const _Case = stmt$2;
        const _expr = _Case._0;
        const _end_expr = _Case._1;
        const _body$5 = _Case._2;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _expr, walk_exprs);
        if (_end_expr === undefined) {
        } else {
          const _Some = _end_expr;
          const _e = _Some;
          hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _e, walk_exprs);
        }
        _tmp$27 = _body$5;
        continue _L;
      }
      case 7: {
        const _Default = stmt$2;
        const _body$6 = _Default._0;
        _tmp$27 = _body$6;
        continue _L;
      }
      case 8: {
        const _Label = stmt$2;
        const _body$7 = _Label._1;
        _tmp$27 = _body$7;
        continue _L;
      }
      case 13: {
        const _Return = stmt$2;
        const _value = _Return._0;
        if (_value === undefined) {
          return;
        } else {
          const _Some = _value;
          const _e = _Some;
          hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _e, walk_exprs);
          return;
        }
      }
      case 15: {
        const _ExprStmt = stmt$2;
        const _expr$2 = _ExprStmt._0;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _expr$2, walk_exprs);
        return;
      }
      case 14: {
        return;
      }
      case 9: {
        return;
      }
      case 10: {
        return;
      }
      case 11: {
        return;
      }
      case 12: {
        return;
      }
      case 17: {
        return;
      }
      case 18: {
        return;
      }
      default: {
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$layout_expr(alloc, expr, walk_exprs) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    if (!walk_exprs) {
      return undefined;
    }
    switch (expr$2.$tag) {
      case 9: {
        const _Unary = expr$2;
        const _inner = _Unary._1;
        _tmp$27 = _inner;
        continue _L;
      }
      case 10: {
        const _Cast = expr$2;
        const _inner$2 = _Cast._1;
        _tmp$27 = _inner$2;
        continue _L;
      }
      case 11: {
        const _CompoundLiteral = expr$2;
        const _init = _CompoundLiteral._1;
        hackwaly$tinycc$backend$codegen$$layout_initializer(alloc, _init, walk_exprs);
        return;
      }
      case 13: {
        return;
      }
      case 15: {
        return;
      }
      case 17: {
        const _Binary = expr$2;
        const _left = _Binary._1;
        const _right = _Binary._2;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _left, walk_exprs);
        _tmp$27 = _right;
        continue _L;
      }
      case 18: {
        const _Conditional = expr$2;
        const _cond = _Conditional._0;
        const _then_expr = _Conditional._1;
        const _else_expr = _Conditional._2;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _cond, walk_exprs);
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _then_expr, walk_exprs);
        _tmp$27 = _else_expr;
        continue _L;
      }
      case 19: {
        const _Call = expr$2;
        const _callee = _Call._0;
        const _args = _Call._1;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _callee, walk_exprs);
        const _len = _args.length;
        let _tmp$28 = 0;
        while (true) {
          const _i = _tmp$28;
          if (_i < _len) {
            const a = _args[_i];
            hackwaly$tinycc$backend$codegen$$layout_expr(alloc, a, walk_exprs);
            _tmp$28 = _i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
      case 12: {
        const _StmtExpr = expr$2;
        const _stmts = _StmtExpr._0;
        let did_scope = false;
        const _len$2 = _stmts.length;
        let _tmp$29 = 0;
        while (true) {
          const _i = _tmp$29;
          if (_i < _len$2) {
            const s = _stmts[_i];
            if (!did_scope) {
              if (s.$tag === 16) {
                hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
                did_scope = true;
              }
            }
            hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, s, walk_exprs);
            _tmp$29 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (did_scope) {
          hackwaly$tinycc$backend$codegen$$cg_pop_scope(alloc);
          return;
        } else {
          return;
        }
      }
      case 20: {
        const _Index = expr$2;
        const _base = _Index._0;
        const _index = _Index._1;
        hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _base, walk_exprs);
        _tmp$27 = _index;
        continue _L;
      }
      case 21: {
        const _Member = expr$2;
        const _base$2 = _Member._0;
        _tmp$27 = _base$2;
        continue _L;
      }
      case 8: {
        const _BuiltinVaArg = expr$2;
        const _list = _BuiltinVaArg._0;
        _tmp$27 = _list;
        continue _L;
      }
      default: {
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$layout_initializer(alloc, init, walk_exprs) {
  if (!walk_exprs) {
    return undefined;
  }
  if (init.$tag === 0) {
    const _Expr = init;
    const _expr = _Expr._0;
    hackwaly$tinycc$backend$codegen$$layout_expr(alloc, _expr, walk_exprs);
    return;
  } else {
    const _List = init;
    const _items = _List._0;
    const _len = _items.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const item = _items[_i];
        hackwaly$tinycc$backend$codegen$$layout_initializer(alloc, item.value, walk_exprs);
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$new_label_ctx() {
  return { addrs: hackwaly$tinycc$backend$codegen$$fast_map_new$156$(undefined), chains: hackwaly$tinycc$backend$codegen$$fast_map_new$156$(undefined), addr_patches: hackwaly$tinycc$backend$codegen$$fast_map_new$166$(undefined) };
}
function hackwaly$tinycc$backend$codegen$$new_local_alloc(sem, ret_ty, func_name, static_locals) {
  return { sem: sem, ret_ty: ret_ty, ret_loc: undefined, used_bytes: 0, varargs_stack_size: 0, scopes: [], vla_scopes: [], local_values: hackwaly$tinycc$backend$codegen$$fast_map_new$174$(undefined), local_overrides: [], local_id_values: hackwaly$tinycc$backend$codegen$$fast_map_new$175$(undefined), local_id_overrides: [], static_locals: static_locals, func_name: func_name, labels: hackwaly$tinycc$backend$codegen$$new_label_ctx(), compound_literal_slots: hackwaly$tinycc$backend$codegen$$fast_map_new$173$(undefined), agg_temp_offset: undefined, agg_temp_size: 0, agg_temp_align: 1, sret_offset: undefined };
}
function hackwaly$tinycc$backend$codegen$$cached_ret_loc(alloc, loc, bag) {
  const _bind = alloc.ret_loc;
  if (_bind === undefined) {
    const ret_loc = hackwaly$tinycc$backend$codegen$$arm64_pcs(alloc.sem, 0, alloc.ret_ty, [], loc, bag).ret_loc;
    alloc.ret_loc = ret_loc;
    return ret_loc;
  } else {
    const _Some = _bind;
    return _Some;
  }
}
function hackwaly$tinycc$backend$codegen$$reserve_sret_slot(alloc, loc, bag) {
  const _bind = alloc.sret_offset;
  if (_bind === undefined) {
  } else {
    return undefined;
  }
  const ret_loc = hackwaly$tinycc$backend$codegen$$cached_ret_loc(alloc, loc, bag);
  if (ret_loc === 1) {
    const off = hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, 8, 8);
    alloc.sret_offset = off;
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$compute_frame_plan(sem, func, static_locals, bag) {
  const alloc = hackwaly$tinycc$backend$codegen$$new_local_alloc(sem, func.return_type, func.name, static_locals);
  hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
  const param_tys = moonbitlang$core$array$$Array$new$46$inner$29$(func.params.length);
  const _arr = func.params;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const p = _arr[_i];
      moonbitlang$core$array$$Array$push$29$(param_tys, hackwaly$tinycc$sem$$adjust_param_type_for_local(p.ty));
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const variadic_index = func.varargs ? param_tys.length : 0;
  const layout = hackwaly$tinycc$backend$codegen$$arm64_pcs(sem, variadic_index, func.return_type, param_tys, func.loc, bag);
  const ret_loc = layout.ret_loc;
  const arg_locs = layout.arg_locs;
  const stack_size = layout.stack_size;
  alloc.ret_loc = layout.ret_loc;
  hackwaly$tinycc$backend$codegen$$reserve_sret_slot(alloc, func.loc, bag);
  let i = 0;
  while (true) {
    if (i < func.params.length) {
      const p = moonbitlang$core$array$$Array$at$28$(func.params, i);
      const param_ty = moonbitlang$core$array$$Array$at$29$(param_tys, i);
      const _p$28 = moonbitlang$core$array$$Array$get$26$(layout.arg_locs, i);
      const _p$29 = 0;
      let loc_i;
      if (_p$28 === undefined) {
        loc_i = _p$29;
      } else {
        const _p$30 = _p$28;
        loc_i = _p$30;
      }
      if ((loc_i & 1) !== 0) {
        hackwaly$tinycc$backend$codegen$$alloc_local_byref(alloc, p.name, p.id, param_ty);
      } else {
        hackwaly$tinycc$backend$codegen$$alloc_local(alloc, p.name, p.id, param_ty, p.loc);
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const func_id = func.id;
  const compound_keys = func_id > 0 ? hackwaly$tinycc$backend$codegen$$get_opt_by_id$188$(sem.func_compound_literals_by_id, func_id) : moonbitlang$core$hashmap$$HashMap$get$166$(sem.func_compound_literals, func.name);
  if (compound_keys.$tag === 1) {
    const _Some = compound_keys;
    const _keys = _Some._0;
    const _len$2 = _keys.length;
    let _tmp$28 = 0;
    while (true) {
      const _i = _tmp$28;
      if (_i < _len$2) {
        const key = _keys[_i];
        const _bind = moonbitlang$core$hashmap$$HashMap$get$173$(alloc.compound_literal_slots, key);
        if (_bind === undefined) {
          const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$167$(sem.compound_literal_sizes, key);
          if (_bind$2 === undefined) {
          } else {
            const _Some$2 = _bind$2;
            const _x = _Some$2;
            const _size = _x._0;
            const _align = _x._1;
            if (_size > 0) {
              const slot_align = _align <= 0 ? 1 : _align;
              const offset = hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, _size, slot_align);
              moonbitlang$core$hashmap$$HashMap$set$173$(alloc.compound_literal_slots, key, offset);
            }
          }
        }
        _tmp$28 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  const agg_temps = func_id > 0 ? hackwaly$tinycc$backend$codegen$$get_opt_by_id$68$(sem.func_agg_temps_by_id, func_id) : moonbitlang$core$hashmap$$HashMap$get$165$(sem.func_agg_temps, func.name);
  if (agg_temps === undefined) {
  } else {
    const _Some = agg_temps;
    const _x = _Some;
    const _size = _x._0;
    const _align = _x._1;
    alloc.agg_temp_size = _size;
    alloc.agg_temp_align = _align;
  }
  if (alloc.agg_temp_size > 0) {
    const _bind = alloc.agg_temp_offset;
    if (_bind === undefined) {
      const align = alloc.agg_temp_align <= 0 ? 1 : alloc.agg_temp_align;
      const off = hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, alloc.agg_temp_size, align);
      alloc.agg_temp_offset = off;
    }
  }
  const used_bytes_after_hidden = alloc.used_bytes;
  const agg_temp_size = alloc.agg_temp_size;
  const agg_temp_align = alloc.agg_temp_align;
  const agg_temp_offset = alloc.agg_temp_offset;
  const compound_literal_slots = alloc.compound_literal_slots;
  let walk_exprs;
  if (func_id > 0) {
    const _p$28 = hackwaly$tinycc$backend$codegen$$get_opt_by_id$67$(sem.func_has_stmt_expr_by_id, func_id);
    const _p$29 = false;
    walk_exprs = _p$28 === -1 ? _p$29 : _p$28;
  } else {
    const _p$28 = moonbitlang$core$hashmap$$HashMap$get$161$(sem.func_has_stmt_expr, func.name);
    const _p$29 = false;
    walk_exprs = _p$28 === -1 ? _p$29 : _p$28;
  }
  let has_local_decls;
  if (func_id > 0) {
    const _p$28 = hackwaly$tinycc$backend$codegen$$get_opt_by_id$67$(sem.func_has_local_decl_by_id, func_id);
    const _p$29 = false;
    has_local_decls = _p$28 === -1 ? _p$29 : _p$28;
  } else {
    const _p$28 = moonbitlang$core$hashmap$$HashMap$get$161$(sem.func_has_local_decl, func.name);
    const _p$29 = false;
    has_local_decls = _p$28 === -1 ? _p$29 : _p$28;
  }
  if (has_local_decls) {
    hackwaly$tinycc$backend$codegen$$layout_stmt(alloc, func.body, walk_exprs);
  }
  const frame_size = hackwaly$tinycc$backend$codegen$$align_up(alloc.used_bytes, 16);
  hackwaly$tinycc$backend$codegen$$cg_pop_scope(alloc);
  return { frame_size: frame_size, used_bytes_after_hidden: used_bytes_after_hidden, agg_temp_size: agg_temp_size, agg_temp_align: agg_temp_align, agg_temp_offset: agg_temp_offset, compound_literal_slots: compound_literal_slots, ret_loc: ret_loc, arg_locs: arg_locs, stack_size: stack_size, param_tys: param_tys };
}
function hackwaly$tinycc$backend$codegen$$give_reg(pool, r) {
  moonbitlang$core$array$$Array$push$26$(pool.free, r);
}
function hackwaly$tinycc$backend$codegen$$take_reg(pool) {
  const _bind = moonbitlang$core$array$$Array$pop$26$(pool.free);
  if (_bind === undefined) {
    return moonbitlang$core$builtin$$fail$26$("codegen: out of temporary registers", "@hackwaly/tinycc/backend/codegen:codegen_arm64_ast.mbt:63:13-63:56");
  } else {
    const _Some = _bind;
    const _r = _Some;
    return new Result$Ok$25$(_r);
  }
}
function hackwaly$tinycc$backend$codegen$$emit_copy_bytes(emitter, pool, src_reg, src_off, dst_reg, dst_off, size_bytes, loc, bag) {
  let tmp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        tmp = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  let off = 0;
  while (true) {
    if ((off + 8 | 0) <= size_bytes) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, src_reg, moonbitlang$core$int$$Int$to_int64(src_off + off | 0));
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
      off = off + 8 | 0;
      continue;
    } else {
      break;
    }
  }
  if ((off + 4 | 0) <= size_bytes) {
    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, tmp, src_reg, moonbitlang$core$int$$Int$to_int64(src_off + off | 0));
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 2, tmp, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
    off = off + 4 | 0;
  }
  if ((off + 2 | 0) <= size_bytes) {
    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 1, tmp, src_reg, moonbitlang$core$int$$Int$to_int64(src_off + off | 0));
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 1, tmp, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
    off = off + 2 | 0;
  }
  while (true) {
    if (off < size_bytes) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, tmp, src_reg, moonbitlang$core$int$$Int$to_int64(src_off + off | 0));
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 0, tmp, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
      off = off + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
}
function hackwaly$tinycc$backend$codegen$$emit_epilogue(emitter, frame_size) {
  const regs = hackwaly$tinycc$backend$codegen$$callee_saved_regs_list;
  const callee_save_bytes = Math.imul(regs.length, 8) | 0;
  const total_size = frame_size + callee_save_bytes | 0;
  const base_off = -total_size | 0;
  let i = 0;
  while (true) {
    if (i < regs.length) {
      const off = base_off + (Math.imul(i, 8) | 0) | 0;
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, moonbitlang$core$array$$Array$at$26$(regs, i), 29, moonbitlang$core$int$$Int$to_int64(off));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (total_size > 0) {
    hackwaly$tinycc$backend$arm64$$arm64_spoff(emitter, 31, moonbitlang$core$int$$Int$to_uint64(total_size));
  }
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1463714819);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -698416192);
}
function hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, xdst, dsrc) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1637482496 | xdst | dsrc << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, wdst, ssrc) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, 505806848 | wdst | ssrc << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_prologue(emitter, frame_size) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1447068675);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862269955);
  const regs = hackwaly$tinycc$backend$codegen$$callee_saved_regs_list;
  const callee_save_bytes = Math.imul(regs.length, 8) | 0;
  const total_size = frame_size + callee_save_bytes | 0;
  if (total_size > 0) {
    const off = moonbitlang$core$builtin$$Sub$sub$6$($0L, moonbitlang$core$int$$Int$to_uint64(total_size));
    hackwaly$tinycc$backend$arm64$$arm64_spoff(emitter, 31, off);
  }
  const base_off = -total_size | 0;
  let i = 0;
  while (true) {
    if (i < regs.length) {
      const off = base_off + (Math.imul(i, 8) | 0) | 0;
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, moonbitlang$core$array$$Array$at$26$(regs, i), 29, moonbitlang$core$int$$Int$to_int64(off));
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$emit_restore_sp_to_frame_base(emitter, frame_size) {
  const callee_save_bytes = Math.imul(hackwaly$tinycc$backend$codegen$$callee_saved_regs_list.length, 8) | 0;
  const total_size = frame_size + callee_save_bytes | 0;
  if (total_size <= 0) {
    return undefined;
  }
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862270017);
  const off = moonbitlang$core$builtin$$Sub$sub$6$($0L, moonbitlang$core$int$$Int$to_uint64(total_size));
  hackwaly$tinycc$backend$arm64$$arm64_spoff(emitter, 31, off);
}
function hackwaly$tinycc$backend$codegen$$emit_store_gp_regs_to_addr$46$emit_store_reg_bytes$124$3007(emitter, reg, dst_reg, dst_off, len) {
  let off = 0;
  if (len <= 0) {
    return undefined;
  }
  if ((off + 8 | 0) <= len) {
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, reg, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
    off = off + 8 | 0;
  }
  if ((off + 4 | 0) <= len) {
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 2, reg, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
    off = off + 4 | 0;
  }
  if ((off + 2 | 0) <= len) {
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 1, reg, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
    off = off + 2 | 0;
  }
  while (true) {
    if (off < len) {
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 0, reg, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + off | 0));
      off = off + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$emit_store_gp_regs_to_addr(emitter, reg0, reg1, size, base_reg, base_off, loc, bag) {
  if (size <= 0) {
    return undefined;
  }
  if (size <= 8) {
    hackwaly$tinycc$backend$codegen$$emit_store_gp_regs_to_addr$46$emit_store_reg_bytes$124$3007(emitter, reg0, base_reg, base_off, size);
    return undefined;
  }
  if (size <= 16) {
    const rest = size - 8 | 0;
    hackwaly$tinycc$backend$codegen$$emit_store_gp_regs_to_addr$46$emit_store_reg_bytes$124$3007(emitter, reg0, base_reg, base_off, 8);
    hackwaly$tinycc$backend$codegen$$emit_store_gp_regs_to_addr$46$emit_store_reg_bytes$124$3007(emitter, reg1, base_reg, base_off + 8 | 0, rest);
    return undefined;
  }
  hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: aggregate return >16 bytes not supported yet");
}
function hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(size) {
  switch (size) {
    case 1: {
      return hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11130;
    }
    case 2: {
      return hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11131;
    }
    case 4: {
      return hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11132;
    }
    case 8: {
      return hackwaly$tinycc$backend$codegen$$arm64_sz_from_size$46$constr$47$11133;
    }
    default: {
      return undefined;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, ty, loc) {
  let base = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(ty);
  while (true) {
    const _bind = base;
    if (_bind.$tag === 11) {
      const _Attributed = _bind;
      const _inner = _Attributed._1;
      base = _inner;
    } else {
      break;
    }
    continue;
  }
  _L: {
    _L$2: {
      const _bind = base;
      switch (_bind.$tag) {
        case 1: {
          return hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$constr$47$11138;
        }
        case 2: {
          const _Int = _bind;
          const _kind = _Int._0;
          const _unsigned = _Int._1;
          return { _0: hackwaly$tinycc$sem$$int_size(_kind), _1: !_unsigned };
        }
        case 3: {
          const _Float = _bind;
          const _kind$2 = _Float._0;
          return { _0: hackwaly$tinycc$sem$$float_size(_kind$2), _1: false };
        }
        case 4: {
          break _L$2;
        }
        case 10: {
          break _L$2;
        }
      }
      break _L;
    }
    return hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error$46$constr$47$11136;
  }
  const _bind = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, ty, loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _size = _bind$2._0;
  const _bind$3 = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(ty);
  let signed;
  if (_bind$3.$tag === 2) {
    const _Int = _bind$3;
    const _unsigned = _Int._1;
    signed = !_unsigned;
  } else {
    signed = false;
  }
  return { _0: _size, _1: signed };
}
function hackwaly$tinycc$backend$codegen$$emit_store_local_scalar(emitter, sem, ty, src, off, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, ty, loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _size = _bind$2._0;
  const _bind$3 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
  let sz;
  if (_bind$3 === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported scalar size");
    return undefined;
  } else {
    const _Some = _bind$3;
    sz = _Some;
  }
  const off_u64 = moonbitlang$core$int$$Int$to_int64(off);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz, src, 29, off_u64);
}
function hackwaly$tinycc$backend$codegen$$emit_vla_sp_restore(emitter, slot_offset) {
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, 30, 29, moonbitlang$core$int$$Int$to_int64(slot_offset));
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862269985);
}
function hackwaly$tinycc$backend$codegen$$emit_vla_leave(emitter, alloc, target_depth) {
  let restore_off = 0;
  let i = alloc.vla_scopes.length;
  while (true) {
    if (i > target_depth) {
      i = i - 1 | 0;
      const scope = moonbitlang$core$array$$Array$at$48$(alloc.vla_scopes, i);
      if (scope.num > 0) {
        restore_off = scope.locorig;
      }
      continue;
    } else {
      break;
    }
  }
  if (restore_off !== 0) {
    hackwaly$tinycc$backend$codegen$$emit_vla_sp_restore(emitter, restore_off);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$cg_pop_scope_codegen(emitter, alloc) {
  const target_depth = alloc.scopes.length - 1 | 0;
  hackwaly$tinycc$backend$codegen$$emit_vla_leave(emitter, alloc, target_depth);
  hackwaly$tinycc$backend$codegen$$cg_pop_scope(alloc);
}
function hackwaly$tinycc$backend$codegen$$collect_switch_labels$46$walk$124$814(sem, stmt, cases, has_default) {
  let _tmp$27 = stmt;
  let _tmp$28 = has_default;
  _L: while (true) {
    const stmt$2 = _tmp$27;
    const has_default$2 = _tmp$28;
    switch (stmt$2.$tag) {
      case 6: {
        const _Case = stmt$2;
        const _expr = _Case._0;
        const _end_expr = _Case._1;
        const _body = _Case._2;
        const _p$28 = hackwaly$tinycc$sem$$const_int64_from_expr(sem, _expr, hackwaly$tinycc$frontend$ast$$expr_loc(_expr));
        const _p$29 = $0L;
        let start;
        if (_p$28 === undefined) {
          start = _p$29;
        } else {
          const _p$30 = _p$28;
          start = _p$30;
        }
        let end;
        if (_end_expr === undefined) {
          end = start;
        } else {
          const _Some = _end_expr;
          const _e = _Some;
          const _p$30 = hackwaly$tinycc$sem$$const_int64_from_expr(sem, _e, hackwaly$tinycc$frontend$ast$$expr_loc(_e));
          if (_p$30 === undefined) {
            end = start;
          } else {
            const _p$31 = _p$30;
            end = _p$31;
          }
        }
        moonbitlang$core$array$$Array$push$34$(cases, { start: start, end: end });
        _tmp$27 = _body;
        continue _L;
      }
      case 7: {
        const _Default = stmt$2;
        const _body$2 = _Default._0;
        _tmp$27 = _body$2;
        _tmp$28 = true;
        continue _L;
      }
      case 5: {
        return has_default$2;
      }
      case 0: {
        const _Compound = stmt$2;
        const _stmts = _Compound._0;
        let flag = has_default$2;
        const _len = _stmts.length;
        let _tmp$29 = 0;
        while (true) {
          const _i = _tmp$29;
          if (_i < _len) {
            const s = _stmts[_i];
            flag = hackwaly$tinycc$backend$codegen$$collect_switch_labels$46$walk$124$814(sem, s, cases, flag);
            _tmp$29 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return flag;
      }
      case 1: {
        const _If = stmt$2;
        const _then_branch = _If._1;
        const _else_branch = _If._2;
        const flag$2 = hackwaly$tinycc$backend$codegen$$collect_switch_labels$46$walk$124$814(sem, _then_branch, cases, has_default$2);
        if (_else_branch === undefined) {
          return flag$2;
        } else {
          const _Some = _else_branch;
          const _e = _Some;
          _tmp$27 = _e;
          _tmp$28 = flag$2;
          continue _L;
        }
      }
      case 2: {
        const _While = stmt$2;
        const _body$3 = _While._1;
        _tmp$27 = _body$3;
        continue _L;
      }
      case 3: {
        const _DoWhile = stmt$2;
        const _body$4 = _DoWhile._1;
        _tmp$27 = _body$4;
        continue _L;
      }
      case 4: {
        const _For = stmt$2;
        const _init = _For._0;
        const _body$5 = _For._3;
        if (_init === undefined) {
          _tmp$27 = _body$5;
          continue _L;
        } else {
          const _Some = _init;
          const _s = _Some;
          const flag$3 = hackwaly$tinycc$backend$codegen$$collect_switch_labels$46$walk$124$814(sem, _s, cases, has_default$2);
          _tmp$27 = _body$5;
          _tmp$28 = flag$3;
          continue _L;
        }
      }
      case 8: {
        const _Label = stmt$2;
        const _body$6 = _Label._1;
        _tmp$27 = _body$6;
        continue _L;
      }
      default: {
        return has_default$2;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$collect_switch_labels(sem, stmt) {
  const cases = [];
  const has_default = hackwaly$tinycc$backend$codegen$$collect_switch_labels$46$walk$124$814(sem, stmt, cases, false);
  return { _0: cases, _1: has_default };
}
function hackwaly$tinycc$backend$codegen$$current_scope_vla_loc(alloc) {
  if (alloc.vla_scopes.length === 0) {
    return undefined;
  }
  const idx = alloc.vla_scopes.length - 1 | 0;
  const scope = moonbitlang$core$array$$Array$at$48$(alloc.vla_scopes, idx);
  return scope.num > 0 ? scope.loc : undefined;
}
function hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, dst, off, _loc, _bag) {
  const imm = off < 0 ? -off | 0 : off;
  if (imm <= 4095) {
    if (off < 0) {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, -788529152 | dst | 928 | imm << 10);
    } else {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862270976 | dst | 928 | imm << 10);
    }
    return undefined;
  }
  hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(imm));
  const base = off < 0 ? -889192448 : -1962934272;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | 928 | dst << 16);
}
function hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, cond) {
  const at = emitter.code_len << 2;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, 1409286144 | cond & 15);
  return at;
}
function hackwaly$tinycc$backend$codegen$$emit_br(emitter, reg) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -702611456 | reg << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, sdst, wsrc) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, 505872384 | sdst | wsrc << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, ddst, xsrc) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1637416960 | ddst | xsrc << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, sem, from_ty, reg, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, from_ty, loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _from_size = _bind$2._0;
  const _from_signed = _bind$2._1;
  if (_from_size >= 8) {
    return undefined;
  }
  const shift = Math.imul(8 - _from_size | 0, 8) | 0;
  if (shift <= 0) {
    return undefined;
  }
  if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 60, 1, false, moonbitlang$core$int$$Int$to_uint64(shift), reg, reg)) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported integer extension");
    return undefined;
  }
  const tok = _from_signed ? 62 : 139;
  if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, tok, 1, false, moonbitlang$core$int$$Int$to_uint64(shift), reg, reg)) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported integer extension");
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, sem, from_ty, to_ty, reg, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, to_ty, loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _to_size = _bind$2._0;
  const _to_signed = _bind$2._1;
  if (_to_size >= 8) {
    hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, sem, from_ty, reg, loc, bag);
    return undefined;
  }
  const shift = Math.imul(8 - _to_size | 0, 8) | 0;
  if (shift <= 0) {
    return undefined;
  }
  if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 60, 1, false, moonbitlang$core$int$$Int$to_uint64(shift), reg, reg)) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported integer cast");
    return undefined;
  }
  const tok = _to_signed ? 62 : 139;
  if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, tok, 1, false, moonbitlang$core$int$$Int$to_uint64(shift), reg, reg)) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported integer cast");
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$emit_cast_value(emitter, sem, from_ty, to_ty, reg, loc, bag) {
  const from_float = hackwaly$tinycc$backend$codegen$$float_kind_of_type(from_ty);
  const to_float = hackwaly$tinycc$backend$codegen$$float_kind_of_type(to_ty);
  if (from_float === undefined) {
    if (to_float === undefined) {
      if (hackwaly$tinycc$sem$$is_int_like(to_ty) || hackwaly$tinycc$backend$codegen$$type_is_pointer_like(to_ty)) {
        hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, sem, from_ty, to_ty, reg, loc, bag);
        return;
      } else {
        return;
      }
    } else {
      const _Some = to_float;
      const _to_kind_raw = _Some;
      if (!hackwaly$tinycc$backend$codegen$$float_kind_supported(_to_kind_raw)) {
        hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported float type");
        return undefined;
      }
      const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(from_ty);
      let is_unsigned;
      if (_bind.$tag === 2) {
        const _Int = _bind;
        is_unsigned = _Int._1;
      } else {
        is_unsigned = false;
      }
      const _bind$2 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, from_ty, loc);
      let from_size;
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some$2 = _bind$2;
        const _x = _Some$2;
        from_size = _x._0;
      }
      const sf_bit = from_size === 8 ? -2147483648 : 0;
      const norm_target = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_to_kind_raw);
      if (moonbitlang$core$builtin$$Eq$equal$83$(norm_target, 0)) {
        const base = is_unsigned ? 505610240 : 505544704;
        hackwaly$tinycc$backend$arm64$$emit32(emitter, base | sf_bit | reg << 5);
        hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, reg, 0);
        return;
      } else {
        const base = is_unsigned ? 509804544 : 509739008;
        hackwaly$tinycc$backend$arm64$$emit32(emitter, base | sf_bit | reg << 5);
        hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, reg, 0);
        return;
      }
    }
  } else {
    const _Some = from_float;
    const _from_kind_raw = _Some;
    if (to_float === undefined) {
      if (!hackwaly$tinycc$sem$$is_int_like(to_ty) && !hackwaly$tinycc$backend$codegen$$type_is_pointer_like(to_ty)) {
        return undefined;
      }
      if (!hackwaly$tinycc$backend$codegen$$float_kind_supported(_from_kind_raw)) {
        hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported float type");
        return undefined;
      }
      if (moonbitlang$core$builtin$$Eq$equal$83$(_from_kind_raw, 1)) {
        hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, reg);
      } else {
        hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, reg);
      }
      const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(to_ty);
      let to_unsigned;
      if (_bind.$tag === 2) {
        const _Int = _bind;
        to_unsigned = _Int._1;
      } else {
        to_unsigned = false;
      }
      const _bind$2 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, to_ty, loc);
      let is64;
      if (_bind$2 === undefined) {
        is64 = false;
      } else {
        const _Some$2 = _bind$2;
        const _x = _Some$2;
        const _size = _x._0;
        is64 = _size === 8;
      }
      let inst = 506986496;
      if (to_unsigned) {
        inst = inst | 65536;
      }
      if (is64) {
        inst = inst | -2147483648;
      }
      if (moonbitlang$core$builtin$$Eq$not_equal$82$(_from_kind_raw, 0)) {
        inst = inst | 4194304;
      }
      hackwaly$tinycc$backend$arm64$$emit32(emitter, inst | reg | 0);
      hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, sem, to_ty, to_ty, reg, loc, bag);
      return;
    } else {
      const _Some$2 = to_float;
      const _to_kind_raw = _Some$2;
      const from_kind = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_from_kind_raw);
      const to_kind = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_to_kind_raw);
      if (moonbitlang$core$builtin$$Eq$equal$83$(from_kind, to_kind)) {
        return undefined;
      }
      if (moonbitlang$core$builtin$$Eq$equal$83$(from_kind, 0) && moonbitlang$core$builtin$$Eq$equal$83$(to_kind, 1)) {
        hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, reg);
        hackwaly$tinycc$backend$arm64$$emit32(emitter, 505593856);
        hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, reg, 0);
        return;
      } else {
        if (moonbitlang$core$builtin$$Eq$equal$83$(from_kind, 1) && moonbitlang$core$builtin$$Eq$equal$83$(to_kind, 0)) {
          hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, reg);
          hackwaly$tinycc$backend$arm64$$emit32(emitter, 509755392);
          hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, reg, 0);
          return;
        } else {
          hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported float conversion");
          return;
        }
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, is64, a, b) {
  const base = is64 ? -352321505 : 1795162143;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | a << 5 | b << 16);
}
function hackwaly$tinycc$backend$codegen$$emit_vla_sp_save(emitter, slot_offset) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862269954);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, 30, 29, moonbitlang$core$int$$Int$to_int64(slot_offset));
}
function hackwaly$tinycc$backend$codegen$$emit_zero_bytes(emitter, base_reg, base_off, size_bytes) {
  let off = 0;
  while (true) {
    if ((off + 8 | 0) <= size_bytes) {
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, 31, base_reg, moonbitlang$core$int$$Int$to_int64(base_off + off | 0));
      off = off + 8 | 0;
      continue;
    } else {
      break;
    }
  }
  if ((off + 4 | 0) <= size_bytes) {
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 2, 31, base_reg, moonbitlang$core$int$$Int$to_int64(base_off + off | 0));
    off = off + 4 | 0;
  }
  if ((off + 2 | 0) <= size_bytes) {
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 1, 31, base_reg, moonbitlang$core$int$$Int$to_int64(base_off + off | 0));
    off = off + 2 | 0;
  }
  while (true) {
    if (off < size_bytes) {
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 0, 31, base_reg, moonbitlang$core$int$$Int$to_int64(base_off + off | 0));
      off = off + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$emit_store_agg_return_gp_to_addr(emitter, size, base_reg, base_off, loc, bag) {
  hackwaly$tinycc$backend$codegen$$emit_store_gp_regs_to_addr(emitter, 0, 1, size, base_reg, base_off, loc, bag);
}
function hackwaly$tinycc$backend$codegen$$emit_blr(emitter, reg) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -700514304 | reg << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_mov(emitter, is64, dst, src) {
  const base = is64 ? -1442839584 : 704644064;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | src << 16);
}
function hackwaly$tinycc$backend$codegen$$emit_call(emitter, sym) {
  const ind = emitter.code_len << 2;
  hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, ind, 283, $0L);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1811939328);
}
function hackwaly$tinycc$backend$codegen$$emit_store_scalar_at(emitter, sem, ty, value_reg, base_reg, off, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, ty, loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _size = _bind$2._0;
  const _bind$3 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
  let sz;
  if (_bind$3 === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported scalar size");
    return undefined;
  } else {
    const _Some = _bind$3;
    sz = _Some;
  }
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz, value_reg, base_reg, moonbitlang$core$int$$Int$to_int64(off));
}
function hackwaly$tinycc$backend$codegen$$arm64_add_imm(emitter, dst, src, imm) {
  if (imm < 0 || imm > 4095) {
    return undefined;
  }
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862270976 | imm << 10 | src << 5 | dst);
}
function hackwaly$tinycc$backend$codegen$$emit_addr_sp(emitter, dst, off, _loc, _bag) {
  const imm = off < 0 ? -off | 0 : off;
  if (imm <= 4095) {
    if (off < 0) {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, -788529152 | dst | 992 | imm << 10);
      return;
    } else {
      hackwaly$tinycc$backend$codegen$$arm64_add_imm(emitter, dst, 31, imm);
      return;
    }
  } else {
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(imm));
    const base = off < 0 ? -889192448 : -1962934272;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | 992 | dst << 16);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$emit_addr_reg(emitter, dst, base_reg, off, loc, bag) {
  if (base_reg === 29) {
    hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, dst, off, loc, bag);
    return undefined;
  }
  if (base_reg === 31) {
    hackwaly$tinycc$backend$codegen$$emit_addr_sp(emitter, dst, off, loc, bag);
    return undefined;
  }
  const imm = off < 0 ? -off | 0 : off;
  if (imm <= 4095) {
    const base = off < 0 ? -788529152 : -1862270976;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | base_reg << 5 | imm << 10);
    return;
  } else {
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(imm));
    const base = off < 0 ? -889192448 : -1962934272;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | base_reg << 5 | dst << 16);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$deref_pointee_type(sem, inner, loc, bag) {
  const inner_ty = hackwaly$tinycc$sem$$type_of_expr(sem, inner);
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(inner_ty);
  if (_bind.$tag === 4) {
    const _Pointer = _bind;
    const _pointee = _Pointer._0;
    return _pointee;
  } else {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: cannot dereference non-pointer");
    return undefined;
  }
}
function hackwaly$tinycc$backend$codegen$$sym_is_external(syms, sym) {
  const _bind = moonbitlang$core$hashmap$$HashMap$get$170$(syms.externals, sym.id);
  return _bind === -1 ? true : _bind;
}
function hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, dst) {
  if (hackwaly$tinycc$backend$codegen$$sym_is_external(syms, sym)) {
    const ind0 = emitter.code_len << 2;
    hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, ind0, 311, $0L);
    hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$($2415919104L, moonbitlang$core$int$$Int$to_uint64(dst))));
    const ind1 = emitter.code_len << 2;
    hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, ind1, 312, $0L);
    hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($4181721088L, moonbitlang$core$int$$Int$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(dst), 5))));
    return;
  } else {
    const adrp_off = emitter.code_len << 2;
    hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, adrp_off, 275, $0L);
    hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$($2415919104L, moonbitlang$core$int$$Int$to_uint64(dst))));
    const add_off = emitter.code_len << 2;
    hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, add_off, 277, $0L);
    hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2432696320L, moonbitlang$core$int$$Int$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(dst), 5))));
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$emit_and_reg(emitter, is64, dst, lhs, rhs) {
  const base = is64 ? -1979711488 : 167772160;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | lhs << 5 | rhs << 16);
}
function hackwaly$tinycc$backend$codegen$$emit_or_reg(emitter, is64, dst, lhs, rhs) {
  const base = is64 ? -1442840576 : 704643072;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | lhs << 5 | rhs << 16);
}
function hackwaly$tinycc$backend$codegen$$emit_bitfield_load_packed(emitter, alloc, pool, addr_reg, info, dst, loc, bag) {
  const _bind = info.bit_width;
  let width;
  if (_bind === undefined) {
    width = 0;
  } else {
    const _Some = _bind;
    width = _Some;
  }
  const _bind$2 = info.bit_offset;
  let bit_off;
  if (_bind$2 === undefined) {
    bit_off = 0;
  } else {
    const _Some = _bind$2;
    bit_off = _Some;
  }
  if (width <= 0) {
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, $0L);
    return undefined;
  }
  const _bind$3 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, info.ty, loc);
  let _bind$4;
  if (_bind$3 === undefined) {
    return undefined;
  } else {
    const _Some = _bind$3;
    _bind$4 = _Some;
  }
  const __decl_size = _bind$4._0;
  const _signed = _bind$4._1;
  const is64 = __decl_size === 8 || width > 32;
  const l = is64 ? 1 : 0;
  const unit_bits = is64 ? 64 : 32;
  hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, $0L);
  let tmp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind$5 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind$5.$tag === 1) {
        const _ok = _bind$5;
        tmp = _ok._0;
      } else {
        const _err = _bind$5;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  let remaining = width;
  let bits_collected = 0;
  let bit_in = bit_off & 7;
  let byte_off = bit_off / 8 | 0;
  while (true) {
    if (remaining > 0) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, tmp, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset + byte_off | 0));
      if (bit_in > 0) {
        hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 139, l, false, moonbitlang$core$int$$Int$to_uint64(bit_in), tmp, tmp);
      }
      const n = remaining < (8 - bit_in | 0) ? remaining : 8 - bit_in | 0;
      if (n < 8) {
        const mask = moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, n), $1L);
        if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 38, l, false, mask, tmp, tmp)) {
          let mask_reg;
          let _try_err$2;
          _L$2: {
            _L$3: {
              const _bind$5 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$5.$tag === 1) {
                const _ok = _bind$5;
                mask_reg = _ok._0;
              } else {
                const _err = _bind$5;
                const _tmp$27 = _err._0;
                _try_err$2 = _tmp$27;
                break _L$3;
              }
              break _L$2;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
            hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
            return undefined;
          }
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, mask_reg, mask);
          hackwaly$tinycc$backend$codegen$$emit_and_reg(emitter, is64, tmp, tmp, mask_reg);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, mask_reg);
        }
      }
      if (bits_collected > 0) {
        hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 60, l, false, moonbitlang$core$int$$Int$to_uint64(bits_collected), tmp, tmp);
      }
      hackwaly$tinycc$backend$codegen$$emit_or_reg(emitter, is64, dst, dst, tmp);
      remaining = remaining - n | 0;
      bits_collected = bits_collected + n | 0;
      bit_in = 0;
      byte_off = byte_off + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
  if (_signed && width < unit_bits) {
    const shift = unit_bits - width | 0;
    hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 60, l, false, moonbitlang$core$int$$Int$to_uint64(shift), dst, dst);
    hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 62, l, false, moonbitlang$core$int$$Int$to_uint64(shift), dst, dst);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$emit_bitfield_load(emitter, alloc, pool, addr_reg, info, dst, loc, bag) {
  const _bind = info.bit_width;
  let width;
  if (_bind === undefined) {
    width = 0;
  } else {
    const _Some = _bind;
    width = _Some;
  }
  const _bind$2 = info.bit_offset;
  let bit_off;
  if (_bind$2 === undefined) {
    bit_off = 0;
  } else {
    const _Some = _bind$2;
    bit_off = _Some;
  }
  if (width <= 0) {
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, $0L);
    return undefined;
  }
  const _bind$3 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, info.ty, loc);
  let _bind$4;
  if (_bind$3 === undefined) {
    return undefined;
  } else {
    const _Some = _bind$3;
    _bind$4 = _Some;
  }
  const _signed = _bind$4._1;
  const _bind$5 = info.bit_unit_size;
  let unit_size;
  if (_bind$5 === undefined) {
    hackwaly$tinycc$backend$codegen$$emit_bitfield_load_packed(emitter, alloc, pool, addr_reg, info, dst, loc, bag);
    return undefined;
  } else {
    const _Some = _bind$5;
    unit_size = _Some;
  }
  const unit_bits = Math.imul(unit_size, 8) | 0;
  const _bind$6 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(unit_size);
  let sz;
  if (_bind$6 === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported bitfield size");
    return undefined;
  } else {
    const _Some = _bind$6;
    sz = _Some;
  }
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, sz, dst, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset));
  const l = unit_size === 8 ? 1 : 0;
  if (bit_off > 0) {
    hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 139, l, false, moonbitlang$core$int$$Int$to_uint64(bit_off), dst, dst);
  }
  if (width < unit_bits) {
    const mask = width >= unit_bits ? moonbitlang$core$uint64$$UInt64$lnot($0L) : moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, width), $1L);
    if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 38, l, false, mask, dst, dst)) {
      let tmp;
      let _try_err;
      _L: {
        _L$2: {
          const _bind$7 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
          if (_bind$7.$tag === 1) {
            const _ok = _bind$7;
            tmp = _ok._0;
          } else {
            const _err = _bind$7;
            const _tmp$27 = _err._0;
            _try_err = _tmp$27;
            break _L$2;
          }
          break _L;
        }
        hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
        return undefined;
      }
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, mask);
      hackwaly$tinycc$backend$codegen$$emit_and_reg(emitter, l !== 0, dst, dst, tmp);
      hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
    }
  }
  if (_signed && width < unit_bits) {
    const shift = unit_bits - width | 0;
    hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 60, l, false, moonbitlang$core$int$$Int$to_uint64(shift), dst, dst);
    hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 62, l, false, moonbitlang$core$int$$Int$to_uint64(shift), dst, dst);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$emit_bitfield_store_packed(emitter, alloc, pool, addr_reg, info, value_reg, loc, bag) {
  const _bind = info.bit_width;
  let width;
  if (_bind === undefined) {
    width = 0;
  } else {
    const _Some = _bind;
    width = _Some;
  }
  const _bind$2 = info.bit_offset;
  let bit_off;
  if (_bind$2 === undefined) {
    bit_off = 0;
  } else {
    const _Some = _bind$2;
    bit_off = _Some;
  }
  if (width <= 0) {
    return undefined;
  }
  const _bind$3 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, info.ty, loc);
  let _bind$4;
  if (_bind$3 === undefined) {
    return undefined;
  } else {
    const _Some = _bind$3;
    _bind$4 = _Some;
  }
  const _decl_size = _bind$4._0;
  const is64 = _decl_size === 8 || width > 32;
  const l = is64 ? 1 : 0;
  let tmp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind$5 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind$5.$tag === 1) {
        const _ok = _bind$5;
        tmp = _ok._0;
      } else {
        const _err = _bind$5;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  let chunk;
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _bind$5 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind$5.$tag === 1) {
        const _ok = _bind$5;
        chunk = _ok._0;
      } else {
        const _err = _bind$5;
        const _tmp$27 = _err._0;
        _try_err$2 = _tmp$27;
        break _L$3;
      }
      break _L$2;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
    hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
    return undefined;
  }
  let remaining = width;
  let bits_used = 0;
  let bit_in = bit_off & 7;
  let byte_off = bit_off / 8 | 0;
  while (true) {
    if (remaining > 0) {
      const n = remaining < (8 - bit_in | 0) ? remaining : 8 - bit_in | 0;
      hackwaly$tinycc$backend$codegen$$emit_mov(emitter, is64, chunk, value_reg);
      if (bits_used > 0) {
        hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 139, l, false, moonbitlang$core$int$$Int$to_uint64(bits_used), chunk, chunk);
      }
      if (bit_in > 0) {
        hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 60, l, false, moonbitlang$core$int$$Int$to_uint64(bit_in), chunk, chunk);
      }
      const mask = moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, n), $1L), bit_in);
      if (n < 8) {
        if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 38, l, false, mask, chunk, chunk)) {
          let mask_reg;
          let _try_err$3;
          _L$3: {
            _L$4: {
              const _bind$5 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$5.$tag === 1) {
                const _ok = _bind$5;
                mask_reg = _ok._0;
              } else {
                const _err = _bind$5;
                const _tmp$27 = _err._0;
                _try_err$3 = _tmp$27;
                break _L$4;
              }
              break _L$3;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
            hackwaly$tinycc$backend$codegen$$give_reg(pool, chunk);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
            return undefined;
          }
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, mask_reg, mask);
          hackwaly$tinycc$backend$codegen$$emit_and_reg(emitter, is64, chunk, chunk, mask_reg);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, mask_reg);
        }
      }
      if (n === 8 && bit_in === 0) {
        hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 0, chunk, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset + byte_off | 0));
      } else {
        hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, tmp, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset + byte_off | 0));
        const inv_mask = moonbitlang$core$builtin$$BitAnd$land$6$($255L, moonbitlang$core$uint64$$UInt64$lnot(mask));
        if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 38, l, false, inv_mask, tmp, tmp)) {
          let mask_reg;
          let _try_err$3;
          _L$3: {
            _L$4: {
              const _bind$5 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$5.$tag === 1) {
                const _ok = _bind$5;
                mask_reg = _ok._0;
              } else {
                const _err = _bind$5;
                const _tmp$27 = _err._0;
                _try_err$3 = _tmp$27;
                break _L$4;
              }
              break _L$3;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
            hackwaly$tinycc$backend$codegen$$give_reg(pool, chunk);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
            return undefined;
          }
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, mask_reg, inv_mask);
          hackwaly$tinycc$backend$codegen$$emit_and_reg(emitter, is64, tmp, tmp, mask_reg);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, mask_reg);
        }
        hackwaly$tinycc$backend$codegen$$emit_or_reg(emitter, is64, tmp, tmp, chunk);
        hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 0, tmp, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset + byte_off | 0));
      }
      remaining = remaining - n | 0;
      bits_used = bits_used + n | 0;
      bit_in = 0;
      byte_off = byte_off + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$backend$codegen$$give_reg(pool, chunk);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
}
function hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, addr_reg, info, value_reg, loc, bag) {
  const _bind = info.bit_width;
  let width;
  if (_bind === undefined) {
    width = 0;
  } else {
    const _Some = _bind;
    width = _Some;
  }
  const _bind$2 = info.bit_offset;
  let bit_off;
  if (_bind$2 === undefined) {
    bit_off = 0;
  } else {
    const _Some = _bind$2;
    bit_off = _Some;
  }
  if (width <= 0) {
    return undefined;
  }
  const _bind$3 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, info.ty, loc);
  let _bind$4;
  if (_bind$3 === undefined) {
    return undefined;
  } else {
    const _Some = _bind$3;
    _bind$4 = _Some;
  }
  const _bind$5 = info.bit_unit_size;
  let unit_size;
  if (_bind$5 === undefined) {
    hackwaly$tinycc$backend$codegen$$emit_bitfield_store_packed(emitter, alloc, pool, addr_reg, info, value_reg, loc, bag);
    return undefined;
  } else {
    const _Some = _bind$5;
    unit_size = _Some;
  }
  const unit_bits = Math.imul(unit_size, 8) | 0;
  const _bind$6 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(unit_size);
  let sz;
  if (_bind$6 === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported bitfield size");
    return undefined;
  } else {
    const _Some = _bind$6;
    sz = _Some;
  }
  const is64 = unit_size === 8;
  if (width === unit_bits && bit_off === 0) {
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz, value_reg, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset));
    return undefined;
  }
  let unit_reg;
  let _try_err;
  _L: {
    _L$2: {
      const _bind$7 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind$7.$tag === 1) {
        const _ok = _bind$7;
        unit_reg = _ok._0;
      } else {
        const _err = _bind$7;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, sz, unit_reg, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset));
  let val_reg;
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _bind$7 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind$7.$tag === 1) {
        const _ok = _bind$7;
        val_reg = _ok._0;
      } else {
        const _err = _bind$7;
        const _tmp$27 = _err._0;
        _try_err$2 = _tmp$27;
        break _L$3;
      }
      break _L$2;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
    hackwaly$tinycc$backend$codegen$$give_reg(pool, unit_reg);
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$emit_mov(emitter, is64, val_reg, value_reg);
  const l = is64 ? 1 : 0;
  if (width < unit_bits) {
    const mask = width >= unit_bits ? moonbitlang$core$uint64$$UInt64$lnot($0L) : moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, width), $1L);
    if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 38, l, false, mask, val_reg, val_reg)) {
      let tmp;
      let _try_err$3;
      _L$3: {
        _L$4: {
          const _bind$7 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
          if (_bind$7.$tag === 1) {
            const _ok = _bind$7;
            tmp = _ok._0;
          } else {
            const _err = _bind$7;
            const _tmp$27 = _err._0;
            _try_err$3 = _tmp$27;
            break _L$4;
          }
          break _L$3;
        }
        hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
        hackwaly$tinycc$backend$codegen$$give_reg(pool, val_reg);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, unit_reg);
        return undefined;
      }
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, mask);
      hackwaly$tinycc$backend$codegen$$emit_and_reg(emitter, is64, val_reg, val_reg, tmp);
      hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
    }
  }
  if (bit_off > 0) {
    hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 60, l, false, moonbitlang$core$int$$Int$to_uint64(bit_off), val_reg, val_reg);
  }
  if (width < unit_bits) {
    const mask = width >= unit_bits ? moonbitlang$core$uint64$$UInt64$lnot($0L) : moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, width), $1L);
    const mask_shift = moonbitlang$core$builtin$$Shl$shl$6$(mask, bit_off);
    const unit_mask = unit_bits === 64 ? moonbitlang$core$uint64$$UInt64$lnot($0L) : moonbitlang$core$builtin$$Sub$sub$6$(moonbitlang$core$builtin$$Shl$shl$6$($1L, unit_bits), $1L);
    const inv_mask = moonbitlang$core$builtin$$BitAnd$land$6$(unit_mask, moonbitlang$core$uint64$$UInt64$lnot(mask_shift));
    if (!hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, 38, l, false, inv_mask, unit_reg, unit_reg)) {
      let tmp;
      let _try_err$3;
      _L$3: {
        _L$4: {
          const _bind$7 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
          if (_bind$7.$tag === 1) {
            const _ok = _bind$7;
            tmp = _ok._0;
          } else {
            const _err = _bind$7;
            const _tmp$27 = _err._0;
            _try_err$3 = _tmp$27;
            break _L$4;
          }
          break _L$3;
        }
        hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
        hackwaly$tinycc$backend$codegen$$give_reg(pool, val_reg);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, unit_reg);
        return undefined;
      }
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, inv_mask);
      hackwaly$tinycc$backend$codegen$$emit_and_reg(emitter, is64, unit_reg, unit_reg, tmp);
      hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
    }
  }
  hackwaly$tinycc$backend$codegen$$emit_or_reg(emitter, is64, unit_reg, unit_reg, val_reg);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz, unit_reg, addr_reg, moonbitlang$core$int$$Int$to_int64(info.offset));
  hackwaly$tinycc$backend$codegen$$give_reg(pool, val_reg);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, unit_reg);
}
function hackwaly$tinycc$backend$codegen$$emit_cset_from_fp_tok(emitter, tok, dst) {
  let base;
  switch (tok) {
    case 148: {
      base = 446633952;
      break;
    }
    case 149: {
      base = 446629856;
      break;
    }
    case 156: {
      base = 446650336;
      break;
    }
    case 158: {
      base = 446662624;
      break;
    }
    case 159: {
      base = 446683104;
      break;
    }
    case 157: {
      base = 446674912;
      break;
    }
    default: {
      const _bind = moonbitlang$core$builtin$$fail$26$("codegen: unsupported fp comparison token", "@hackwaly/tinycc/backend/codegen:codegen_arm64_ast.mbt:2060:10-2060:58");
      if (_bind.$tag === 1) {
        const _ok = _bind;
        base = _ok._0;
      } else {
        return _bind;
      }
    }
  }
  return new Result$Ok$26$(hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst));
}
function hackwaly$tinycc$backend$codegen$$emit_cset(emitter, cond, dst) {
  const cond_inv = cond ^ 1;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, 446629856 | dst | cond_inv << 12);
}
function hackwaly$tinycc$backend$codegen$$emit_cset_from_tok(emitter, tok, dst, is_unsigned) {
  let cond;
  switch (tok) {
    case 148: {
      cond = 0;
      break;
    }
    case 149: {
      cond = 1;
      break;
    }
    case 156: {
      cond = is_unsigned ? 3 : 11;
      break;
    }
    case 158: {
      cond = is_unsigned ? 9 : 13;
      break;
    }
    case 159: {
      cond = is_unsigned ? 8 : 12;
      break;
    }
    case 157: {
      cond = is_unsigned ? 2 : 10;
      break;
    }
    default: {
      const _bind = moonbitlang$core$builtin$$fail$26$("codegen: unsupported comparison token", "@hackwaly/tinycc/backend/codegen:codegen_arm64_ast.mbt:2040:10-2040:55");
      if (_bind.$tag === 1) {
        const _ok = _bind;
        cond = _ok._0;
      } else {
        return _bind;
      }
    }
  }
  return new Result$Ok$26$(hackwaly$tinycc$backend$codegen$$emit_cset(emitter, cond, dst));
}
function hackwaly$tinycc$backend$codegen$$emit_fcmp(emitter, is_double, lhs, rhs) {
  const base = is_double ? 509616128 : 505421824;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | lhs << 5 | rhs << 16);
}
function hackwaly$tinycc$backend$codegen$$emit_fcmp_zero(emitter, is_double, lhs) {
  const base = is_double ? 509616136 : 505421832;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | lhs << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_load_local_scalar(emitter, sem, ty, dst, off, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(sem, ty, loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _size = _bind$2._0;
  const _signed = _bind$2._1;
  const _bind$3 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
  let sz;
  if (_bind$3 === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported scalar size");
    return undefined;
  } else {
    const _Some = _bind$3;
    sz = _Some;
  }
  const off_u64 = moonbitlang$core$int$$Int$to_int64(off);
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed, sz, dst, 29, off_u64);
}
function hackwaly$tinycc$backend$codegen$$float_is_double(kind) {
  return moonbitlang$core$builtin$$Eq$not_equal$82$(kind, 0);
}
function hackwaly$tinycc$backend$codegen$$encode_adr(rd, diff) {
  if (diff < -1048576 || diff >= 1048576) {
    return undefined;
  }
  const immlo = diff & 3;
  const immhi = diff >> 2 & 524287;
  return 268435456 | immlo << 29 | immhi << 5 | rd;
}
function hackwaly$tinycc$backend$codegen$$emit_adr(emitter, rd, diff, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$encode_adr(rd, diff);
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: label address out of range");
    return;
  } else {
    const _Some = _bind;
    const _insn = _Some;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, _insn);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$emit_fp_binop(emitter, base_s, base_d, is_double, dst, lhs, rhs) {
  const base = is_double ? base_d : base_s;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | lhs << 5 | rhs << 16);
}
function hackwaly$tinycc$backend$codegen$$emit_fadd(emitter, is_double, dst, lhs, rhs) {
  hackwaly$tinycc$backend$codegen$$emit_fp_binop(emitter, 505423872, 509618176, is_double, dst, lhs, rhs);
}
function hackwaly$tinycc$backend$codegen$$emit_fdiv(emitter, is_double, dst, lhs, rhs) {
  hackwaly$tinycc$backend$codegen$$emit_fp_binop(emitter, 505419776, 509614080, is_double, dst, lhs, rhs);
}
function hackwaly$tinycc$backend$codegen$$emit_fmul(emitter, is_double, dst, lhs, rhs) {
  hackwaly$tinycc$backend$codegen$$emit_fp_binop(emitter, 505415680, 509609984, is_double, dst, lhs, rhs);
}
function hackwaly$tinycc$backend$codegen$$emit_fneg(emitter, is_double, dst, src) {
  const base = is_double ? 509689856 : 505495552;
  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | src << 5);
}
function hackwaly$tinycc$backend$codegen$$emit_fsub(emitter, is_double, dst, lhs, rhs) {
  hackwaly$tinycc$backend$codegen$$emit_fp_binop(emitter, 505427968, 509622272, is_double, dst, lhs, rhs);
}
function hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, at_, target_, cond) {
  const diff = target_ - at_ | 0;
  if ((diff & 3) !== 0) {
    const _bind = moonbitlang$core$builtin$$fail$8$("codegen: unaligned b.cond target", "@hackwaly/tinycc/backend/codegen:codegen_arm64_ast.mbt:2003:5-2003:45");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  const imm = diff >> 2;
  if (imm < -262144 || imm >= 262144) {
    const _bind = moonbitlang$core$builtin$$fail$8$("codegen: conditional branch out of range", "@hackwaly/tinycc/backend/codegen:codegen_arm64_ast.mbt:2008:5-2008:53");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  const imm19 = imm & 524287;
  return new Result$Ok$26$(moonbitlang$core$array$$Array$set$24$(emitter.code, at_ >> 2, 1409286144 | (imm19 & 524287) << 5 | cond & 15));
}
function hackwaly$tinycc$backend$codegen$$type_is_aggregate(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _base = _Qualified._1;
        _tmp$27 = _base;
        continue _L;
      }
      case 11: {
        const _Attributed = ty$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      case 6: {
        return true;
      }
      case 7: {
        return true;
      }
      case 5: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$lookup_local(alloc, name, id) {
  if (id > 0) {
    return moonbitlang$core$hashmap$$HashMap$get$175$(alloc.local_id_values, id);
  }
  return moonbitlang$core$hashmap$$HashMap$get$174$(alloc.local_values, name);
}
function hackwaly$tinycc$backend$codegen$$lookup_static_local(alloc, id) {
  if (id <= 0) {
    return undefined;
  }
  return moonbitlang$core$hashmap$$HashMap$get$155$(alloc.static_locals, id);
}
function hackwaly$tinycc$backend$codegen$$parse_float_literal_bits(text, kind) {
  if (!hackwaly$tinycc$backend$codegen$$float_kind_supported(kind)) {
    return undefined;
  }
  const _bind = hackwaly$tinycc$backend$codegen$$parse_float_literal_value(text);
  if (_bind.$tag === 0) {
    return undefined;
  } else {
    const _Some = _bind;
    const _d = _Some._0;
    if (moonbitlang$core$builtin$$Eq$equal$83$(kind, 0)) {
      const f = Math.fround(_d);
      return moonbitlang$core$uint$$UInt$to_uint64($i32_reinterpret_f32(f));
    } else {
      return moonbitlang$core$double$$Double$reinterpret_as_uint64(_d);
    }
  }
}
function hackwaly$tinycc$backend$codegen$$member_bitfield_info(alloc, expr) {
  if (expr.$tag === 21) {
    const _Member = expr;
    const _base = _Member._0;
    const _name = _Member._1;
    const _id = _Member._2;
    const _is_arrow = _Member._3;
    const _loc = _Member._5;
    const _bind = hackwaly$tinycc$backend$codegen$$member_access_info(alloc.sem, _base, _name, _id, _is_arrow, _loc);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _info = _Some;
      const _bind$2 = _info.bit_width;
      return _bind$2 === undefined ? undefined : { _0: _base, _1: _is_arrow, _2: _info };
    }
  } else {
    return undefined;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_func_name_addr(emitter, syms, cstrings, alloc, dst, loc, bag) {
  if (alloc.func_name === "") {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: missing __func__ string literal");
    return false;
  }
  const sym = hackwaly$tinycc$backend$codegen$$cstring_sym_or_add(cstrings, syms, alloc.func_name);
  const adrp_off = emitter.code_len << 2;
  hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, adrp_off, 275, $0L);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$($2415919104L, moonbitlang$core$int$$Int$to_uint64(dst))));
  const add_off = emitter.code_len << 2;
  hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, add_off, 277, $0L);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2432696320L, moonbitlang$core$int$$Int$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(dst), 5))));
  return true;
}
function hackwaly$tinycc$backend$codegen$$emit_sxtw(emitter, dst, src) {
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1824490496 | dst | src << 5);
}
function hackwaly$tinycc$backend$codegen$$member_access_info_from_base_type(sem, base_ty, name, id, is_arrow, loc) {
  let record_ty;
  if (is_arrow) {
    const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(base_ty);
    if (_bind.$tag === 4) {
      const _Pointer = _bind;
      record_ty = _Pointer._0;
    } else {
      record_ty = base_ty;
    }
  } else {
    record_ty = base_ty;
  }
  return hackwaly$tinycc$backend$codegen$$record_field_access_info(sem, record_ty, name, id, loc);
}
function hackwaly$tinycc$backend$codegen$$record_label_addr_patch(labels, name, at) {
  const _bind = moonbitlang$core$hashmap$$HashMap$get$166$(labels.addr_patches, name);
  if (_bind.$tag === 0) {
    const entries = [];
    moonbitlang$core$array$$Array$push$26$(entries, at);
    moonbitlang$core$hashmap$$HashMap$set$166$(labels.addr_patches, name, entries);
    return;
  } else {
    const _Some = _bind;
    const _entries = _Some._0;
    moonbitlang$core$array$$Array$push$26$(_entries, at);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_string_init_to_addr(emitter, syms, pool, cstrings, value, length, dst_reg, dst_off, bag, loc) {
  const sym = hackwaly$tinycc$backend$codegen$$cstring_sym_or_add(cstrings, syms, value);
  let src_reg;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        src_reg = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, src_reg);
  let i = 0;
  while (true) {
    if (i < length) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 0, 0, src_reg, moonbitlang$core$int$$Int$to_uint64(i));
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 0, 0, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + i | 0));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$backend$codegen$$give_reg(pool, src_reg);
}
function hackwaly$tinycc$backend$codegen$$gen_builtin_frame_address(emitter, alloc, pool, args, is_return, loc, bag) {
  if (args.length !== 1) {
    const name = is_return ? "__builtin_return_address" : "__builtin_frame_address";
    hackwaly$tinycc$support$diag$$add_error(bag, loc, `${name} expects 1 argument`);
    return undefined;
  }
  const _bind = hackwaly$tinycc$sem$$const_int_from_expr(alloc.sem, moonbitlang$core$array$$Array$at$55$(args, 0), loc);
  let level;
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: builtin expects constant integer level");
    return undefined;
  } else {
    const _Some = _bind;
    level = _Some;
  }
  if (level < 0) {
    const name = is_return ? "__builtin_return_address" : "__builtin_frame_address";
    hackwaly$tinycc$support$diag$$add_error(bag, loc, `${name} only takes non-negative integers`);
    return undefined;
  }
  let tmp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind$2 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        tmp = _ok._0;
      } else {
        const _err = _bind$2;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, tmp, 29);
  let i = 0;
  while (true) {
    if (i < level) {
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, tmp, $0L);
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (is_return) {
    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, tmp, $8L);
  }
  hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, 0, tmp);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
}
function hackwaly$tinycc$backend$codegen$$ensure_call_layout_capacity(tab, id) {
  if (id <= 0) {
    return undefined;
  }
  const idx = id - 1 | 0;
  const len = tab.call_layout_cache.length;
  if (idx < len) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i <= idx) {
      moonbitlang$core$array$$Array$push$66$(tab.call_layout_cache, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$promote_vararg_type(ty) {
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  if (_bind.$tag === 3) {
    const _Float = _bind;
    const _kind = _Float._0;
    return moonbitlang$core$builtin$$Eq$equal$83$(_kind, 0) ? hackwaly$tinycc$backend$codegen$$promote_vararg_type$46$constr$47$11757 : ty;
  } else {
    return ty;
  }
}
function hackwaly$tinycc$backend$codegen$$loop_append_break(loops, emitter, loc, bag) {
  const idx = loops.length - 1 | 0;
  const _bind = moonbitlang$core$array$$Array$get$109$(loops, idx);
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: break outside of loop");
    return;
  } else {
    const _Some = _bind;
    const _info = _Some;
    const chain = hackwaly$tinycc$backend$arm64$$gjmp(emitter, _info.break_chain);
    moonbitlang$core$array$$Array$set$109$(loops, idx, { break_chain: chain, cont_chain: _info.cont_chain, break_depth: _info.break_depth, cont_depth: _info.cont_depth });
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$loop_append_continue(loops, emitter, loc, bag) {
  const idx = loops.length - 1 | 0;
  const _bind = moonbitlang$core$array$$Array$get$109$(loops, idx);
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: continue outside of loop");
    return;
  } else {
    const _Some = _bind;
    const _info = _Some;
    const chain = hackwaly$tinycc$backend$arm64$$gjmp(emitter, _info.cont_chain);
    moonbitlang$core$array$$Array$set$109$(loops, idx, { break_chain: _info.break_chain, cont_chain: chain, break_depth: _info.break_depth, cont_depth: _info.cont_depth });
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$patch_adr(emitter, at, target, loc, bag) {
  const idx = at >> 2;
  if (idx < 0 || idx >= emitter.code_len) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: invalid label address patch");
    return undefined;
  }
  const rd = moonbitlang$core$array$$Array$at$24$(emitter.code, idx) & 31;
  const diff = target - at | 0;
  const _bind = hackwaly$tinycc$backend$codegen$$encode_adr(rd, diff);
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: label address out of range");
    return;
  } else {
    const _Some = _bind;
    const _insn = _Some;
    moonbitlang$core$array$$Array$set$24$(emitter.code, idx, _insn);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$patch_label_addr_uses(emitter, labels, name, addr, loc, bag) {
  const _bind = moonbitlang$core$hashmap$$HashMap$get$166$(labels.addr_patches, name);
  if (_bind.$tag === 1) {
    const _Some = _bind;
    const _entries = _Some._0;
    const _len = _entries.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const at = _entries[_i];
        hackwaly$tinycc$backend$codegen$$patch_adr(emitter, at, addr, loc, bag);
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$hashmap$$HashMap$remove$166$(labels.addr_patches, name);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$slot_type_size_align(alloc, slot, loc) {
  _L: {
    const _bind = slot.type_size;
    const _bind$2 = slot.type_align;
    if (_bind === undefined) {
      break _L;
    } else {
      const _Some = _bind;
      const _size = _Some;
      if (_bind$2 === undefined) {
        break _L;
      } else {
        const _Some$2 = _bind$2;
        const _align = _Some$2;
        return { _0: _size, _1: _align };
      }
    }
  }
  return hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, slot.ty, loc);
}
function hackwaly$tinycc$backend$codegen$$stmt_loc(stmt) {
  switch (stmt.$tag) {
    case 0: {
      const _Compound = stmt;
      return _Compound._1;
    }
    case 1: {
      const _If = stmt;
      return _If._3;
    }
    case 2: {
      const _While = stmt;
      return _While._2;
    }
    case 3: {
      const _DoWhile = stmt;
      return _DoWhile._2;
    }
    case 4: {
      const _For = stmt;
      return _For._4;
    }
    case 5: {
      const _Switch = stmt;
      return _Switch._2;
    }
    case 6: {
      const _Case = stmt;
      return _Case._3;
    }
    case 7: {
      const _Default = stmt;
      return _Default._1;
    }
    case 8: {
      const _Label = stmt;
      return _Label._2;
    }
    case 9: {
      const _Goto = stmt;
      return _Goto._1;
    }
    case 10: {
      const _GotoExpr = stmt;
      return _GotoExpr._1;
    }
    case 11: {
      const _Break = stmt;
      return _Break._0;
    }
    case 12: {
      const _Continue = stmt;
      return _Continue._0;
    }
    case 13: {
      const _Return = stmt;
      return _Return._1;
    }
    case 14: {
      const _Asm = stmt;
      const _stmt = _Asm._0;
      return _stmt.loc;
    }
    case 15: {
      const _ExprStmt = stmt;
      return _ExprStmt._1;
    }
    case 16: {
      const _DeclStmt = stmt;
      return _DeclStmt._1;
    }
    case 17: {
      const _TagDef = stmt;
      return _TagDef._1;
    }
    case 18: {
      const _StaticAssert = stmt;
      const _v = _StaticAssert._0;
      return _v.loc;
    }
    default: {
      const _Empty = stmt;
      return _Empty._0;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$switch_append_break(switches, emitter, loc, bag) {
  const idx = switches.length - 1 | 0;
  const _bind = moonbitlang$core$array$$Array$get$110$(switches, idx);
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: break outside of loop/switch");
    return;
  } else {
    const _Some = _bind;
    const _info = _Some;
    const chain = hackwaly$tinycc$backend$arm64$$gjmp(emitter, _info.break_chain);
    moonbitlang$core$array$$Array$set$110$(switches, idx, { break_chain: chain, break_depth: _info.break_depth });
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, stmt, bag, return_chain) {
  let _tmp$27 = stmt;
  _L: while (true) {
    const stmt$2 = _tmp$27;
    _L$2: {
      switch (stmt$2.$tag) {
        case 0: {
          const _Compound = stmt$2;
          const _stmts = _Compound._0;
          let did_scope = false;
          let chain = return_chain;
          const _len = _stmts.length;
          let _tmp$28 = 0;
          while (true) {
            const _i = _tmp$28;
            if (_i < _len) {
              const s = _stmts[_i];
              if (!did_scope) {
                if (s.$tag === 16) {
                  hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
                  did_scope = true;
                }
              }
              chain = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, s, bag, chain);
              _tmp$28 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          if (did_scope) {
            hackwaly$tinycc$backend$codegen$$cg_pop_scope_codegen(emitter, alloc);
          }
          return chain;
        }
        case 16: {
          const _DeclStmt = stmt$2;
          const _decls = _DeclStmt._0;
          const _len$2 = _decls.length;
          let _tmp$29 = 0;
          while (true) {
            const _i = _tmp$29;
            if (_i < _len$2) {
              _L$3: {
                const d = _decls[_i];
                const stripped = hackwaly$tinycc$sem$$strip_top_qualifiers(d.ty);
                if (stripped.$tag === 10) {
                  break _L$3;
                }
                if (moonbitlang$core$builtin$$Eq$equal$79$(d.storage, 1)) {
                  break _L$3;
                }
                if (moonbitlang$core$builtin$$Eq$equal$79$(d.storage, 2)) {
                  hackwaly$tinycc$backend$codegen$$record_static_local_binding(alloc, d);
                  break _L$3;
                }
                let decl_ty = d.ty;
                if (stripped.$tag === 5) {
                  const _Array = stripped;
                  const _elem_ty = _Array._0;
                  const _x = _Array._1;
                  if (_x === undefined) {
                    const _x$2 = _Array._2;
                    if (_x$2 === undefined) {
                      const _bind = d.init;
                      if (_bind === undefined) {
                      } else {
                        const _Some = _bind;
                        const _x$3 = _Some;
                        if (_x$3.$tag === 0) {
                          const _Expr = _x$3;
                          const _x$4 = _Expr._0;
                          if (_x$4.$tag === 3) {
                            const _StringLit = _x$4;
                            const _length = _StringLit._1;
                            if (hackwaly$tinycc$sem$$is_char_type(_elem_ty)) {
                              decl_ty = hackwaly$tinycc$sem$$apply_inferred_array_size(d.ty, _length);
                            }
                          }
                        } else {
                          const _List = _x$3;
                          const _items = _List._0;
                          const len = hackwaly$tinycc$backend$codegen$$infer_array_size_from_init_items(_items);
                          decl_ty = hackwaly$tinycc$sem$$apply_inferred_array_size(d.ty, len);
                        }
                      }
                    }
                  }
                }
                const _bind = hackwaly$tinycc$backend$codegen$$alloc_local(alloc, d.name, d.id, decl_ty, d.loc);
                if (_bind === undefined) {
                } else {
                  const _Some = _bind;
                  const _slot = _Some;
                  let slot0 = _slot;
                  let slot_stripped = hackwaly$tinycc$sem$$strip_top_qualifiers(slot0.ty);
                  const _bind$2 = slot_stripped;
                  if (_bind$2.$tag === 5) {
                    const _Array = _bind$2;
                    const _x = _Array._1;
                    if (_x === undefined) {
                      const _x$2 = _Array._2;
                      if (_x$2 === undefined) {
                      } else {
                        const size_off = hackwaly$tinycc$backend$codegen$$alloc_hidden_slot(alloc, 8, 8);
                        const updated = { offset: slot0.offset, ty: slot0.ty, vla_size_offset: size_off, byref: slot0.byref, type_size: slot0.type_size, type_align: slot0.type_align };
                        if (d.id > 0) {
                          const scope_idx = alloc.scopes.length - 1 | 0;
                          moonbitlang$core$hashmap$$HashMap$set$175$(moonbitlang$core$array$$Array$at$33$(alloc.scopes, scope_idx), d.id, updated);
                        }
                        hackwaly$tinycc$backend$codegen$$update_local_slot(alloc, d.name, d.id, updated);
                        slot0 = updated;
                        slot_stripped = hackwaly$tinycc$sem$$strip_top_qualifiers(slot0.ty);
                        const _bind$3 = hackwaly$tinycc$backend$codegen$$vla_record_decl(alloc, slot0.offset);
                        if (_bind$3 === undefined) {
                        } else {
                          const _Some$2 = _bind$3;
                          const _off = _Some$2;
                          hackwaly$tinycc$backend$codegen$$emit_vla_sp_save(emitter, _off);
                        }
                      }
                    }
                  }
                  const _bind$3 = slot_stripped;
                  if (_bind$3.$tag === 5) {
                    const _Array = _bind$3;
                    const _x = _Array._1;
                    if (_x === undefined) {
                      const _x$2 = _Array._2;
                      if (_x$2 === undefined) {
                      } else {
                        hackwaly$tinycc$backend$codegen$$gen_vla_alloc_to_local_slot(emitter, alloc, syms, pool, cstrings, slot0.offset, slot0.vla_size_offset, slot0.ty, d.loc, bag);
                      }
                    }
                  }
                  const _bind$4 = d.init;
                  if (_bind$4 === undefined) {
                  } else {
                    const _Some$2 = _bind$4;
                    const _init = _Some$2;
                    const needs_zero = hackwaly$tinycc$backend$codegen$$type_is_aggregate(slot0.ty);
                    if (needs_zero) {
                      const _bind$5 = hackwaly$tinycc$backend$codegen$$slot_type_size_align(alloc, slot0, d.loc);
                      if (_bind$5 === undefined) {
                      } else {
                        const _Some$3 = _bind$5;
                        const _x = _Some$3;
                        const _size = _x._0;
                        if (_size > 0) {
                          hackwaly$tinycc$backend$codegen$$emit_zero_bytes(emitter, 29, slot0.offset, _size);
                        }
                      }
                    }
                    hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, 29, slot0.offset, slot0.ty, _init, bag);
                  }
                }
                break _L$3;
              }
              _tmp$29 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          return return_chain;
        }
        case 17: {
          break _L$2;
        }
        case 18: {
          break _L$2;
        }
        case 1: {
          const _If = stmt$2;
          const _cond = _If._0;
          const _then_branch = _If._1;
          const _else_branch = _If._2;
          const _loc = _If._3;
          hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond, bag);
          const br_false = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
          const chain1 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _then_branch, bag, return_chain);
          if (_else_branch === undefined) {
            const end_pc = emitter.code_len << 2;
            let _try_err;
            _L$3: {
              _L$4: {
                const _bind = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_false, end_pc, 0);
                if (_bind.$tag === 1) {
                  const _ok = _bind;
                  _ok._0;
                } else {
                  const _err = _bind;
                  const _tmp$30 = _err._0;
                  _try_err = _tmp$30;
                  break _L$4;
                }
                break _L$3;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
            }
            return chain1;
          } else {
            const _Some = _else_branch;
            const _else_stmt = _Some;
            const after_then = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
            const else_pc = emitter.code_len << 2;
            let _try_err;
            _L$3: {
              _L$4: {
                const _bind = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_false, else_pc, 0);
                if (_bind.$tag === 1) {
                  const _ok = _bind;
                  _ok._0;
                } else {
                  const _err = _bind;
                  const _tmp$30 = _err._0;
                  _try_err = _tmp$30;
                  break _L$4;
                }
                break _L$3;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
            }
            const chain2 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _else_stmt, bag, chain1);
            const end_pc = emitter.code_len << 2;
            let _try_err$2;
            _L$4: {
              _L$5: {
                const _bind = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, after_then, end_pc);
                if (_bind.$tag === 1) {
                  const _ok = _bind;
                  _ok._0;
                } else {
                  const _err = _bind;
                  const _tmp$30 = _err._0;
                  _try_err$2 = _tmp$30;
                  break _L$5;
                }
                break _L$4;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
            }
            return chain2;
          }
        }
        case 2: {
          const _While = stmt$2;
          const _cond$2 = _While._0;
          const _body = _While._1;
          const _loc$2 = _While._2;
          const start_pc = emitter.code_len << 2;
          hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond$2, bag);
          const br_end = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
          const loop_depth = alloc.scopes.length;
          moonbitlang$core$array$$Array$push$109$(loops, { break_chain: 0, cont_chain: 0, break_depth: loop_depth, cont_depth: loop_depth });
          moonbitlang$core$array$$Array$push$26$(breakables, 0);
          const chain1$2 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _body, bag, return_chain);
          moonbitlang$core$array$$Array$pop$26$(breakables);
          const _p$28 = moonbitlang$core$array$$Array$pop$109$(loops);
          let loop_info;
          if (_p$28 === undefined) {
            loop_info = hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11846;
          } else {
            const _p$29 = _p$28;
            loop_info = _p$29;
          }
          let _try_err;
          _L$3: {
            _L$4: {
              const _bind = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, loop_info.cont_chain, start_pc);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err = _tmp$30;
                break _L$4;
              }
              break _L$3;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
          }
          let _try_err$2;
          _L$4: {
            _L$5: {
              const _bind = hackwaly$tinycc$backend$arm64$$gjmp_addr(emitter, start_pc);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$2 = _tmp$30;
                break _L$5;
              }
              break _L$4;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
          }
          const end_pc = emitter.code_len << 2;
          let _try_err$3;
          _L$5: {
            _L$6: {
              const _bind = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_end, end_pc, 0);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$3 = _tmp$30;
                break _L$6;
              }
              break _L$5;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
          }
          let _try_err$4;
          _L$6: {
            _L$7: {
              const _bind = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, loop_info.break_chain, end_pc);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$4 = _tmp$30;
                break _L$7;
              }
              break _L$6;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$4));
          }
          return chain1$2;
        }
        case 3: {
          const _DoWhile = stmt$2;
          const _cond$3 = _DoWhile._0;
          const _body$2 = _DoWhile._1;
          const _loc$3 = _DoWhile._2;
          const start_pc$2 = emitter.code_len << 2;
          const loop_depth$2 = alloc.scopes.length;
          moonbitlang$core$array$$Array$push$109$(loops, { break_chain: 0, cont_chain: 0, break_depth: loop_depth$2, cont_depth: loop_depth$2 });
          moonbitlang$core$array$$Array$push$26$(breakables, 0);
          const chain1$3 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _body$2, bag, return_chain);
          moonbitlang$core$array$$Array$pop$26$(breakables);
          const cond_pc = emitter.code_len << 2;
          const _p$29 = moonbitlang$core$array$$Array$pop$109$(loops);
          let loop_info$2;
          if (_p$29 === undefined) {
            loop_info$2 = hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11847;
          } else {
            const _p$30 = _p$29;
            loop_info$2 = _p$30;
          }
          let _try_err$5;
          _L$7: {
            _L$8: {
              const _bind = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, loop_info$2.cont_chain, cond_pc);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$5 = _tmp$30;
                break _L$8;
              }
              break _L$7;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
          }
          hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond$3, bag);
          const br_back = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 1);
          let _try_err$6;
          _L$8: {
            _L$9: {
              const _bind = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_back, start_pc$2, 1);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$6 = _tmp$30;
                break _L$9;
              }
              break _L$8;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
          }
          const end_pc$2 = emitter.code_len << 2;
          let _try_err$7;
          _L$9: {
            _L$10: {
              const _bind = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, loop_info$2.break_chain, end_pc$2);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$7 = _tmp$30;
                break _L$10;
              }
              break _L$9;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
          }
          return chain1$3;
        }
        case 4: {
          const _For = stmt$2;
          const _init = _For._0;
          const _cond$4 = _For._1;
          const _step = _For._2;
          const _body$3 = _For._3;
          const _loc$4 = _For._4;
          hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
          const cont_depth = alloc.scopes.length;
          const break_depth = cont_depth - 1 | 0;
          let chain0 = return_chain;
          if (_init === undefined) {
          } else {
            const _Some = _init;
            const _s = _Some;
            chain0 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _s, bag, chain0);
          }
          const cond_pc$2 = emitter.code_len << 2;
          let br_end$2;
          if (_cond$4 === undefined) {
            br_end$2 = undefined;
          } else {
            const _Some = _cond$4;
            const _e = _Some;
            hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _e, bag);
            br_end$2 = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
          }
          moonbitlang$core$array$$Array$push$109$(loops, { break_chain: 0, cont_chain: 0, break_depth: break_depth, cont_depth: cont_depth });
          moonbitlang$core$array$$Array$push$26$(breakables, 0);
          const chain1$4 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _body$3, bag, chain0);
          const step_pc = emitter.code_len << 2;
          moonbitlang$core$array$$Array$pop$26$(breakables);
          const _p$30 = moonbitlang$core$array$$Array$pop$109$(loops);
          let loop_info$3;
          if (_p$30 === undefined) {
            loop_info$3 = hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11848;
          } else {
            const _p$31 = _p$30;
            loop_info$3 = _p$31;
          }
          const continue_target = _step === undefined ? cond_pc$2 : step_pc;
          let _try_err$8;
          _L$10: {
            _L$11: {
              const _bind = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, loop_info$3.cont_chain, continue_target);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$8 = _tmp$30;
                break _L$11;
              }
              break _L$10;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$4, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$8));
          }
          if (_step === undefined) {
          } else {
            const _Some = _step;
            const _e = _Some;
            hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _e, bag);
          }
          let _try_err$9;
          _L$11: {
            _L$12: {
              const _bind = hackwaly$tinycc$backend$arm64$$gjmp_addr(emitter, cond_pc$2);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$9 = _tmp$30;
                break _L$12;
              }
              break _L$11;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$4, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$9));
          }
          const end_pc$3 = emitter.code_len << 2;
          if (br_end$2 === undefined) {
          } else {
            const _Some = br_end$2;
            const _at = _Some;
            let _try_err$10;
            _L$12: {
              _L$13: {
                const _bind = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, _at, end_pc$3, 0);
                if (_bind.$tag === 1) {
                  const _ok = _bind;
                  _ok._0;
                } else {
                  const _err = _bind;
                  const _tmp$30 = _err._0;
                  _try_err$10 = _tmp$30;
                  break _L$13;
                }
                break _L$12;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$4, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$10));
            }
          }
          let _try_err$10;
          _L$12: {
            _L$13: {
              const _bind = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, loop_info$3.break_chain, end_pc$3);
              if (_bind.$tag === 1) {
                const _ok = _bind;
                _ok._0;
              } else {
                const _err = _bind;
                const _tmp$30 = _err._0;
                _try_err$10 = _tmp$30;
                break _L$13;
              }
              break _L$12;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$4, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$10));
          }
          hackwaly$tinycc$backend$codegen$$cg_pop_scope_codegen(emitter, alloc);
          return chain1$4;
        }
        case 5: {
          const _Switch = stmt$2;
          const _cond$5 = _Switch._0;
          const _body$4 = _Switch._1;
          const _loc$5 = _Switch._2;
          const _bind = hackwaly$tinycc$backend$codegen$$collect_switch_labels(alloc.sem, _body$4);
          const _cases = _bind._0;
          const cond_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _cond$5);
          const _bind$2 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, cond_ty, _loc$5);
          let _bind$3;
          if (_bind$2 === undefined) {
            _bind$3 = hackwaly$tinycc$backend$codegen$$gen_stmt$46$tuple$47$11849;
          } else {
            const _Some = _bind$2;
            const _x = _Some;
            const _size = _x._0;
            const _signed = _x._1;
            _bind$3 = { _0: _size === 8, _1: !_signed };
          }
          const _cond_is64 = _bind$3._0;
          const _cond_unsigned = _bind$3._1;
          const range_cond_lt = _cond_unsigned ? 3 : 11;
          const range_cond_gt = _cond_unsigned ? 8 : 12;
          const case_addrs = [];
          const _len$3 = _cases.length;
          let _tmp$30 = 0;
          while (true) {
            const _i = _tmp$30;
            if (_i < _len$3) {
              _cases[_i];
              moonbitlang$core$array$$Array$push$26$(case_addrs, 0);
              _tmp$30 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          let default_addr = undefined;
          hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _cond$5, 0, bag, cond_ty);
          const eq_branches = [];
          const range_jmps = [];
          let _tmp$31 = 0;
          while (true) {
            const i = _tmp$31;
            if (i < _cases.length) {
              const info = moonbitlang$core$array$$Array$at$34$(_cases, i);
              if (moonbitlang$core$builtin$$Eq$equal$7$(info.start, info.end)) {
                let tmp;
                let _try_err$11;
                _L$13: {
                  _L$14: {
                    const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                    if (_bind$4.$tag === 1) {
                      const _ok = _bind$4;
                      tmp = _ok._0;
                    } else {
                      const _err = _bind$4;
                      const _tmp$32 = _err._0;
                      _try_err$11 = _tmp$32;
                      break _L$14;
                    }
                    break _L$13;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$11));
                  tmp = 9;
                }
                hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, info.start);
                hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, _cond_is64, 0, tmp);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                const at = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
                moonbitlang$core$array$$Array$push$68$(eq_branches, { _0: at, _1: i });
              } else {
                let tmp;
                let _try_err$11;
                _L$13: {
                  _L$14: {
                    const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                    if (_bind$4.$tag === 1) {
                      const _ok = _bind$4;
                      tmp = _ok._0;
                    } else {
                      const _err = _bind$4;
                      const _tmp$32 = _err._0;
                      _try_err$11 = _tmp$32;
                      break _L$14;
                    }
                    break _L$13;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$11));
                  tmp = 9;
                }
                hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, info.start);
                hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, _cond_is64, 0, tmp);
                const skip1 = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, range_cond_lt);
                hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, info.end);
                hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, _cond_is64, 0, tmp);
                const skip2 = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, range_cond_gt);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                const jmp = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
                moonbitlang$core$array$$Array$push$68$(range_jmps, { _0: jmp, _1: i });
                const next_pc = emitter.code_len << 2;
                let _try_err$12;
                _L$14: {
                  _L$15: {
                    const _bind$4 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, skip1, next_pc, range_cond_lt);
                    if (_bind$4.$tag === 1) {
                      const _ok = _bind$4;
                      _ok._0;
                    } else {
                      const _err = _bind$4;
                      const _tmp$32 = _err._0;
                      _try_err$12 = _tmp$32;
                      break _L$15;
                    }
                    break _L$14;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$12));
                }
                let _try_err$13;
                _L$15: {
                  _L$16: {
                    const _bind$4 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, skip2, next_pc, range_cond_gt);
                    if (_bind$4.$tag === 1) {
                      const _ok = _bind$4;
                      _ok._0;
                    } else {
                      const _err = _bind$4;
                      const _tmp$32 = _err._0;
                      _try_err$13 = _tmp$32;
                      break _L$16;
                    }
                    break _L$15;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$13));
                }
              }
              _tmp$31 = i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          const default_jmp = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
          const break_depth$2 = alloc.scopes.length;
          moonbitlang$core$array$$Array$push$110$(switches, { break_chain: 0, break_depth: break_depth$2 });
          moonbitlang$core$array$$Array$push$26$(breakables, 1);
          const _bind$4 = hackwaly$tinycc$backend$codegen$$gen_switch_body(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _body$4, bag, return_chain, case_addrs, default_addr, 0);
          const _chain1 = _bind$4._0;
          const _new_default = _bind$4._1;
          default_addr = _new_default;
          const end_pc$4 = emitter.code_len << 2;
          moonbitlang$core$array$$Array$pop$26$(breakables);
          const _p$31 = moonbitlang$core$array$$Array$pop$110$(switches);
          let sw_info;
          if (_p$31 === undefined) {
            sw_info = hackwaly$tinycc$backend$codegen$$gen_stmt$46$record$47$11850;
          } else {
            const _p$32 = _p$31;
            sw_info = _p$32;
          }
          let _try_err$11;
          _L$13: {
            _L$14: {
              const _bind$5 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, sw_info.break_chain, end_pc$4);
              if (_bind$5.$tag === 1) {
                const _ok = _bind$5;
                _ok._0;
              } else {
                const _err = _bind$5;
                const _tmp$32 = _err._0;
                _try_err$11 = _tmp$32;
                break _L$14;
              }
              break _L$13;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$11));
          }
          const _p$32 = default_addr;
          let default_target;
          if (_p$32 === undefined) {
            default_target = end_pc$4;
          } else {
            const _p$33 = _p$32;
            default_target = _p$33;
          }
          let _try_err$12;
          _L$14: {
            _L$15: {
              const _bind$5 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, default_jmp, default_target);
              if (_bind$5.$tag === 1) {
                const _ok = _bind$5;
                _ok._0;
              } else {
                const _err = _bind$5;
                const _tmp$32 = _err._0;
                _try_err$12 = _tmp$32;
                break _L$15;
              }
              break _L$14;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$12));
          }
          const _len$4 = eq_branches.length;
          let _tmp$32 = 0;
          while (true) {
            const _i = _tmp$32;
            if (_i < _len$4) {
              const item = eq_branches[_i];
              const _at = item._0;
              const _idx = item._1;
              if (_idx < case_addrs.length) {
                let _try_err$13;
                _L$15: {
                  _L$16: {
                    const _bind$5 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, _at, moonbitlang$core$array$$Array$at$26$(case_addrs, _idx), 0);
                    if (_bind$5.$tag === 1) {
                      const _ok = _bind$5;
                      _ok._0;
                    } else {
                      const _err = _bind$5;
                      const _tmp$33 = _err._0;
                      _try_err$13 = _tmp$33;
                      break _L$16;
                    }
                    break _L$15;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$13));
                }
              }
              _tmp$32 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          const _len$5 = range_jmps.length;
          let _tmp$33 = 0;
          while (true) {
            const _i = _tmp$33;
            if (_i < _len$5) {
              const item = range_jmps[_i];
              const _jmp = item._0;
              const _idx = item._1;
              if (_idx < case_addrs.length) {
                let _try_err$13;
                _L$15: {
                  _L$16: {
                    const _bind$5 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, _jmp, moonbitlang$core$array$$Array$at$26$(case_addrs, _idx));
                    if (_bind$5.$tag === 1) {
                      const _ok = _bind$5;
                      _ok._0;
                    } else {
                      const _err = _bind$5;
                      const _tmp$34 = _err._0;
                      _try_err$13 = _tmp$34;
                      break _L$16;
                    }
                    break _L$15;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$13));
                }
              }
              _tmp$33 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          return _chain1;
        }
        case 9: {
          const _Goto = stmt$2;
          const _name = _Goto._0;
          const _loc$6 = _Goto._1;
          hackwaly$tinycc$backend$codegen$$emit_vla_leave(emitter, alloc, 0);
          const _bind$5 = moonbitlang$core$hashmap$$HashMap$get$156$(labels.addrs, _name);
          if (_bind$5 === undefined) {
            const _p$33 = moonbitlang$core$hashmap$$HashMap$get$156$(labels.chains, _name);
            const _p$34 = 0;
            let chain$2;
            if (_p$33 === undefined) {
              chain$2 = _p$34;
            } else {
              const _p$35 = _p$33;
              chain$2 = _p$35;
            }
            const new_chain = hackwaly$tinycc$backend$arm64$$gjmp(emitter, chain$2);
            moonbitlang$core$hashmap$$HashMap$set$156$(labels.chains, _name, new_chain);
          } else {
            const _Some = _bind$5;
            const _addr = _Some;
            let _try_err$13;
            _L$15: {
              _L$16: {
                const _bind$6 = hackwaly$tinycc$backend$arm64$$gjmp_addr(emitter, _addr);
                if (_bind$6.$tag === 1) {
                  const _ok = _bind$6;
                  _ok._0;
                } else {
                  const _err = _bind$6;
                  const _tmp$34 = _err._0;
                  _try_err$13 = _tmp$34;
                  break _L$16;
                }
                break _L$15;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$6, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$13));
            }
          }
          return return_chain;
        }
        case 10: {
          const _GotoExpr = stmt$2;
          const _expr = _GotoExpr._0;
          hackwaly$tinycc$backend$codegen$$emit_vla_leave(emitter, alloc, 0);
          hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _expr, 0, bag);
          hackwaly$tinycc$backend$codegen$$emit_br(emitter, 0);
          return return_chain;
        }
        case 8: {
          const _Label = stmt$2;
          const _name$2 = _Label._0;
          const _body$5 = _Label._1;
          const _loc$7 = _Label._2;
          const addr = emitter.code_len << 2;
          const _bind$6 = moonbitlang$core$hashmap$$HashMap$get$156$(labels.addrs, _name$2);
          if (_bind$6 === undefined) {
          } else {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$7, "codegen: duplicate label");
          }
          const _bind$7 = moonbitlang$core$hashmap$$HashMap$get$156$(labels.chains, _name$2);
          if (_bind$7 === undefined) {
          } else {
            const _Some = _bind$7;
            const _chain = _Some;
            if (_chain !== 0) {
              let _try_err$13;
              _L$15: {
                _L$16: {
                  const _bind$8 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, _chain, addr);
                  if (_bind$8.$tag === 1) {
                    const _ok = _bind$8;
                    _ok._0;
                  } else {
                    const _err = _bind$8;
                    const _tmp$34 = _err._0;
                    _try_err$13 = _tmp$34;
                    break _L$16;
                  }
                  break _L$15;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$7, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$13));
              }
            }
          }
          moonbitlang$core$hashmap$$HashMap$set$156$(labels.addrs, _name$2, addr);
          moonbitlang$core$hashmap$$HashMap$set$156$(labels.chains, _name$2, 0);
          hackwaly$tinycc$backend$codegen$$patch_label_addr_uses(emitter, labels, _name$2, addr, _loc$7, bag);
          const _bind$8 = hackwaly$tinycc$backend$codegen$$current_scope_vla_loc(alloc);
          if (_bind$8 === undefined) {
          } else {
            const _Some = _bind$8;
            const _off = _Some;
            hackwaly$tinycc$backend$codegen$$emit_vla_sp_restore(emitter, _off);
          }
          _tmp$27 = _body$5;
          continue _L;
        }
        case 11: {
          const _Break = stmt$2;
          const _loc$8 = _Break._0;
          const idx = breakables.length - 1 | 0;
          const _bind$9 = moonbitlang$core$array$$Array$get$26$(breakables, idx);
          if (_bind$9 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$8, "codegen: break outside of loop/switch");
          } else {
            const _Some = _bind$9;
            const _kind = _Some;
            if (_kind === 0) {
              const _bind$10 = moonbitlang$core$array$$Array$get$109$(loops, loops.length - 1 | 0);
              if (_bind$10 === undefined) {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$8, "codegen: break outside of loop");
              } else {
                const _Some$2 = _bind$10;
                const _info = _Some$2;
                hackwaly$tinycc$backend$codegen$$emit_vla_leave(emitter, alloc, _info.break_depth);
              }
              hackwaly$tinycc$backend$codegen$$loop_append_break(loops, emitter, _loc$8, bag);
            } else {
              const _bind$10 = moonbitlang$core$array$$Array$get$110$(switches, switches.length - 1 | 0);
              if (_bind$10 === undefined) {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$8, "codegen: break outside of switch");
              } else {
                const _Some$2 = _bind$10;
                const _info = _Some$2;
                hackwaly$tinycc$backend$codegen$$emit_vla_leave(emitter, alloc, _info.break_depth);
              }
              hackwaly$tinycc$backend$codegen$$switch_append_break(switches, emitter, _loc$8, bag);
            }
          }
          return return_chain;
        }
        case 12: {
          const _Continue = stmt$2;
          const _loc$9 = _Continue._0;
          const _bind$10 = moonbitlang$core$array$$Array$get$109$(loops, loops.length - 1 | 0);
          if (_bind$10 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: continue outside of loop");
          } else {
            const _Some = _bind$10;
            const _info = _Some;
            hackwaly$tinycc$backend$codegen$$emit_vla_leave(emitter, alloc, _info.cont_depth);
          }
          hackwaly$tinycc$backend$codegen$$loop_append_continue(loops, emitter, _loc$9, bag);
          return return_chain;
        }
        case 15: {
          const _ExprStmt = stmt$2;
          const _expr$2 = _ExprStmt._0;
          hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _expr$2, bag);
          return return_chain;
        }
        case 14: {
          const _Asm = stmt$2;
          const _stmt = _Asm._0;
          if (_stmt.is_volatile || moonbitlang$core$array$$Array$contains$19$(_stmt.clobbers, "memory")) {
            hackwaly$tinycc$backend$arm64$$emit32(emitter, -721208385);
          }
          return return_chain;
        }
        case 13: {
          const _Return = stmt$2;
          const _value = _Return._0;
          const _loc$10 = _Return._1;
          const rt = hackwaly$tinycc$sem$$strip_top_qualifiers(alloc.ret_ty);
          if (_value === undefined) {
            const _bind$11 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(rt);
            if (_bind$11 === undefined) {
              hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 0, $0L);
            } else {
              const _Some = _bind$11;
              const _k = _Some;
              hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, 0, $0L);
              if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1)) {
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, 0);
              } else {
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, 0);
              }
            }
          } else {
            const _Some = _value;
            const _expr$3 = _Some;
            const _bind$11 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(rt);
            if (_bind$11 === undefined) {
              _L$15: {
                _L$16: {
                  switch (rt.$tag) {
                    case 6: {
                      break _L$16;
                    }
                    case 7: {
                      break _L$16;
                    }
                    default: {
                      const expr_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _expr$3);
                      hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, _expr$3, expr_ty, 0, bag);
                      hackwaly$tinycc$backend$codegen$$emit_cast_value(emitter, alloc.sem, expr_ty, alloc.ret_ty, 0, _loc$10, bag);
                    }
                  }
                  break _L$15;
                }
                const _bind$12 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, rt, _loc$10);
                if (_bind$12 === undefined) {
                } else {
                  const _Some$2 = _bind$12;
                  const _x = _Some$2;
                  const _size = _x._0;
                  if (_size === 0) {
                  } else {
                    const ret_loc = hackwaly$tinycc$backend$codegen$$cached_ret_loc(alloc, _loc$10, bag);
                    if (ret_loc === 1) {
                      const _bind$13 = alloc.sret_offset;
                      if (_bind$13 === undefined) {
                        hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: missing sret slot");
                      } else {
                        const _Some$3 = _bind$13;
                        const _off = _Some$3;
                        let tmp;
                        let _try_err$13;
                        _L$17: {
                          _L$18: {
                            const _bind$14 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                            if (_bind$14.$tag === 1) {
                              const _ok = _bind$14;
                              tmp = _ok._0;
                            } else {
                              const _err = _bind$14;
                              const _tmp$34 = _err._0;
                              _try_err$13 = _tmp$34;
                              break _L$18;
                            }
                            break _L$17;
                          }
                          hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$13));
                          return hackwaly$tinycc$backend$arm64$$gjmp(emitter, return_chain);
                        }
                        hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, 29, moonbitlang$core$int$$Int$to_int64(_off));
                        hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _expr$3, tmp, 0, alloc.ret_ty, _loc$10, bag);
                        hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                      }
                    } else {
                      if (ret_loc === 16) {
                        if (_expr$3.$tag === 19) {
                          const _Call = _expr$3;
                          const _callee = _Call._0;
                          const _args = _Call._1;
                          hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, _callee, _args, _loc$10, bag);
                        } else {
                          if (hackwaly$tinycc$frontend$ast$$expr_is_lvalue_simple(_expr$3)) {
                            hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _expr$3, 0, bag);
                          } else {
                            const _bind$13 = alloc.agg_temp_offset;
                            if (_bind$13 === undefined) {
                              hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: missing aggregate temp for return");
                              return hackwaly$tinycc$backend$arm64$$gjmp(emitter, return_chain);
                            } else {
                              const _Some$3 = _bind$13;
                              const _off = _Some$3;
                              hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _expr$3, 29, _off, alloc.ret_ty, _loc$10, bag);
                              hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, 0, _off, _loc$10, bag);
                            }
                          }
                          const _bind$13 = hackwaly$tinycc$backend$codegen$$arm64_hfa(alloc.sem, rt, _loc$10, bag);
                          if (_bind$13 === undefined) {
                            hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: expected HFA return");
                          } else {
                            const _Some$3 = _bind$13;
                            const _x$2 = _Some$3;
                            const _count = _x$2._0;
                            const _fsize = _x$2._1;
                            let j = 0;
                            while (true) {
                              if (j < _count) {
                                let tmp;
                                let _try_err$13;
                                _L$17: {
                                  _L$18: {
                                    const _bind$14 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                                    if (_bind$14.$tag === 1) {
                                      const _ok = _bind$14;
                                      tmp = _ok._0;
                                    } else {
                                      const _err = _bind$14;
                                      const _tmp$34 = _err._0;
                                      _try_err$13 = _tmp$34;
                                      break _L$18;
                                    }
                                    break _L$17;
                                  }
                                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$13));
                                  return hackwaly$tinycc$backend$arm64$$gjmp(emitter, return_chain);
                                }
                                if (_fsize === 8) {
                                  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, 0, moonbitlang$core$int$$Int$to_int64(Math.imul(j, 8) | 0));
                                  hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, j, tmp);
                                } else {
                                  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, tmp, 0, moonbitlang$core$int$$Int$to_int64(Math.imul(j, 4) | 0));
                                  hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, j, tmp);
                                }
                                hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                                j = j + 1 | 0;
                                continue;
                              } else {
                                break;
                              }
                            }
                          }
                        }
                      } else {
                        if (_expr$3.$tag === 19) {
                          const _Call = _expr$3;
                          const _callee = _Call._0;
                          const _args = _Call._1;
                          hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, _callee, _args, _loc$10, bag);
                        } else {
                          if (hackwaly$tinycc$frontend$ast$$expr_is_lvalue_simple(_expr$3)) {
                            hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _expr$3, 0, bag);
                          } else {
                            const _bind$13 = alloc.agg_temp_offset;
                            if (_bind$13 === undefined) {
                              hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: missing aggregate temp for return");
                              return hackwaly$tinycc$backend$arm64$$gjmp(emitter, return_chain);
                            } else {
                              const _Some$3 = _bind$13;
                              const _off = _Some$3;
                              hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _expr$3, 29, _off, alloc.ret_ty, _loc$10, bag);
                              hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, 0, _off, _loc$10, bag);
                            }
                          }
                          hackwaly$tinycc$backend$arm64$$arm64_ldrs(emitter, 0, _size);
                        }
                      }
                    }
                  }
                }
              }
            } else {
              const _Some$2 = _bind$11;
              const _k = _Some$2;
              const expr_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _expr$3);
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, _expr$3, expr_ty, _k, 0, bag);
              if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1)) {
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, 0);
              } else {
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, 0);
              }
            }
          }
          return hackwaly$tinycc$backend$arm64$$gjmp(emitter, return_chain);
        }
        case 19: {
          return return_chain;
        }
        default: {
          hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$backend$codegen$$stmt_loc(stmt$2), "codegen: unsupported statement");
          return return_chain;
        }
      }
    }
    return return_chain;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, expr, dst_reg, dst_off, ty, loc, bag) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    const _bind = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ty, loc);
    let _bind$2;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      _bind$2 = _Some;
    }
    const _size = _bind$2._0;
    if (_size <= 0) {
      return undefined;
    }
    _L$2: {
      switch (expr$2.$tag) {
        case 19: {
          const _Call = expr$2;
          const _callee = _Call._0;
          const _args = _Call._1;
          const ret_loc = hackwaly$tinycc$backend$codegen$$arm64_pcs(alloc.sem, 0, ty, [], loc, bag).ret_loc;
          if (ret_loc === 1) {
            hackwaly$tinycc$backend$codegen$$gen_call_expr_with_sret(emitter, alloc, syms, pool, cstrings, _callee, _args, dst_reg, dst_off, loc, bag);
            return undefined;
          }
          hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, _callee, _args, loc, bag);
          if (_size <= 0) {
            return undefined;
          }
          if (ret_loc === 16) {
            const _bind$3 = hackwaly$tinycc$backend$codegen$$arm64_hfa(alloc.sem, ty, loc, bag);
            if (_bind$3 === undefined) {
              hackwaly$tinycc$backend$codegen$$emit_store_agg_return_gp_to_addr(emitter, _size, dst_reg, dst_off, loc, bag);
              return;
            } else {
              const _Some = _bind$3;
              const _x = _Some;
              const _count = _x._0;
              const _fsize = _x._1;
              let i = 0;
              while (true) {
                if (i < _count) {
                  let tmp;
                  let _try_err;
                  _L$3: {
                    _L$4: {
                      const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                      if (_bind$4.$tag === 1) {
                        const _ok = _bind$4;
                        tmp = _ok._0;
                      } else {
                        const _err = _bind$4;
                        const _tmp$28 = _err._0;
                        _try_err = _tmp$28;
                        break _L$4;
                      }
                      break _L$3;
                    }
                    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                    return undefined;
                  }
                  if (_fsize === 8) {
                    hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, tmp, i);
                    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + (Math.imul(i, 8) | 0) | 0));
                  } else {
                    hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, tmp, i);
                    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 2, tmp, dst_reg, moonbitlang$core$int$$Int$to_int64(dst_off + (Math.imul(i, 4) | 0) | 0));
                  }
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                  i = i + 1 | 0;
                  continue;
                } else {
                  return;
                }
              }
            }
          } else {
            hackwaly$tinycc$backend$codegen$$emit_store_agg_return_gp_to_addr(emitter, _size, dst_reg, dst_off, loc, bag);
            return;
          }
        }
        case 17: {
          const _Binary = expr$2;
          const _x = _Binary._0;
          switch (_x) {
            case 0: {
              const _left = _Binary._1;
              const _right = _Binary._2;
              const _loc = _Binary._4;
              const lhs_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left);
              _L$3: {
                const _bind$3 = hackwaly$tinycc$sem$$strip_top_qualifiers(lhs_ty);
                switch (_bind$3.$tag) {
                  case 6: {
                    break _L$3;
                  }
                  case 7: {
                    break _L$3;
                  }
                  default: {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: aggregate assignment expects record lhs");
                    return;
                  }
                }
              }
              let lhs_addr;
              let _try_err;
              _L$4: {
                _L$5: {
                  const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$3.$tag === 1) {
                    const _ok = _bind$3;
                    lhs_addr = _ok._0;
                  } else {
                    const _err = _bind$3;
                    const _tmp$28 = _err._0;
                    _try_err = _tmp$28;
                    break _L$5;
                  }
                  break _L$4;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                return undefined;
              }
              hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _left, lhs_addr, bag);
              hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _right, lhs_addr, 0, lhs_ty, _loc, bag);
              hackwaly$tinycc$backend$codegen$$emit_copy_bytes(emitter, pool, lhs_addr, 0, dst_reg, dst_off, _size, _loc, bag);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, lhs_addr);
              return;
            }
            case 11: {
              const _left$2 = _Binary._1;
              const _right$2 = _Binary._2;
              hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _left$2, bag);
              _tmp$27 = _right$2;
              continue _L;
            }
            default: {
              break _L$2;
            }
          }
        }
        case 10: {
          const _Cast = expr$2;
          const _inner = _Cast._1;
          _tmp$27 = _inner;
          continue _L;
        }
        case 0: {
          const _IntLit = expr$2;
          const _value = _IntLit._0;
          const _loc$2 = _IntLit._2;
          const _bind$3 = hackwaly$tinycc$frontend$ast$$parse_int64_literal(_value);
          if (_bind$3 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, "codegen: invalid integer literal");
            return;
          } else {
            const _Some = _bind$3;
            const _v = _Some;
            if (moonbitlang$core$builtin$$Eq$equal$7$(_v, $0L)) {
              hackwaly$tinycc$backend$codegen$$emit_zero_bytes(emitter, dst_reg, dst_off, _size);
              return;
            } else {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, "codegen: non-zero scalar for aggregate");
              return;
            }
          }
        }
        case 18: {
          const _Conditional = expr$2;
          const _cond = _Conditional._0;
          const _then_expr = _Conditional._1;
          const _else_expr = _Conditional._2;
          const _loc$3 = _Conditional._4;
          hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond, bag);
          const br_else = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
          hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _then_expr, dst_reg, dst_off, ty, _loc$3, bag);
          const br_end = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
          const else_pc = emitter.code_len << 2;
          let _try_err$2;
          _L$5: {
            _L$6: {
              const _bind$4 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_else, else_pc, 0);
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _ok._0;
              } else {
                const _err = _bind$4;
                const _tmp$28 = _err._0;
                _try_err$2 = _tmp$28;
                break _L$6;
              }
              break _L$5;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
          }
          hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _else_expr, dst_reg, dst_off, ty, _loc$3, bag);
          const end_pc = emitter.code_len << 2;
          let _try_err$3;
          _L$6: {
            const _bind$4 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, br_end, end_pc);
            if (_bind$4.$tag === 1) {
              const _ok = _bind$4;
              _ok._0;
              return;
            } else {
              const _err = _bind$4;
              const _tmp$28 = _err._0;
              _try_err$3 = _tmp$28;
              break _L$6;
            }
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
          return;
        }
        case 12: {
          const _StmtExpr = expr$2;
          const _stmts = _StmtExpr._0;
          const _loc$4 = _StmtExpr._2;
          hackwaly$tinycc$backend$codegen$$gen_stmt_expr_with(emitter, alloc, syms, pool, cstrings, _stmts, 0, true, _loc$4, bag, (expr$3, _discard_) => {
            hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, expr$3, dst_reg, dst_off, ty, _loc$4, bag);
          });
          return;
        }
        default: {
          break _L$2;
        }
      }
    }
    let src_addr;
    let _try_err;
    _L$3: {
      _L$4: {
        const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind$3.$tag === 1) {
          const _ok = _bind$3;
          src_addr = _ok._0;
        } else {
          const _err = _bind$3;
          const _tmp$28 = _err._0;
          _try_err = _tmp$28;
          break _L$4;
        }
        break _L$3;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      return undefined;
    }
    hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, expr$2, src_addr, bag);
    hackwaly$tinycc$backend$codegen$$emit_copy_bytes(emitter, pool, src_addr, 0, dst_reg, dst_off, _size, loc, bag);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, src_addr);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, callee, args, loc, bag) {
  hackwaly$tinycc$backend$codegen$$gen_call_expr_impl(emitter, alloc, syms, pool, cstrings, callee, args, undefined, loc, bag);
}
function hackwaly$tinycc$backend$codegen$$gen_call_expr_impl(emitter, alloc, syms, pool, cstrings, callee, args, sret, loc, bag) {
  if (callee.$tag === 4) {
    const _Ident = callee;
    const _name = _Ident._0;
    const _id = _Ident._1;
    if (_name === "__builtin_alloca" || _name === "alloca") {
      hackwaly$tinycc$backend$codegen$$gen_builtin_alloca(emitter, alloc, syms, pool, cstrings, args, loc, bag);
      return undefined;
    }
    const _bind = hackwaly$tinycc$sem$$builtin_call_kind(alloc.sem, _name, _id);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _x = _Some;
      switch (_x) {
        case 1: {
          if (args.length !== 2) {
            hackwaly$tinycc$support$diag$$add_error(bag, loc, "__builtin_expect expects 2 arguments");
            return undefined;
          }
          let tmp;
          let _try_err;
          _L: {
            _L$2: {
              const _bind$2 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$2.$tag === 1) {
                const _ok = _bind$2;
                tmp = _ok._0;
              } else {
                const _err = _bind$2;
                const _tmp$27 = _err._0;
                _try_err = _tmp$27;
                break _L$2;
              }
              break _L;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
            return undefined;
          }
          const ret_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, moonbitlang$core$array$$Array$at$55$(args, 0));
          const _bind$2 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ret_ty);
          if (_bind$2 === undefined) {
            if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(ret_ty)) {
              hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 0), tmp, bag);
            } else {
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 0), tmp, bag, ret_ty);
            }
          } else {
            const _Some$2 = _bind$2;
            const _k = _Some$2;
            hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 0), ret_ty, _k, tmp, bag);
          }
          hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 1), bag);
          hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, 0, tmp);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
          return undefined;
        }
        case 5: {
          hackwaly$tinycc$backend$codegen$$gen_builtin_va_start(emitter, alloc, syms, pool, cstrings, args, loc, bag);
          return undefined;
        }
        case 6: {
          hackwaly$tinycc$backend$codegen$$gen_builtin_va_copy(emitter, alloc, syms, pool, cstrings, args, loc, bag);
          return undefined;
        }
        case 7: {
          return undefined;
        }
        case 4: {
          if (args.length !== 0) {
            hackwaly$tinycc$support$diag$$add_error(bag, loc, "__sync_synchronize expects no args");
          }
          hackwaly$tinycc$backend$arm64$$emit32(emitter, -721208385);
          return undefined;
        }
        case 8: {
          hackwaly$tinycc$backend$codegen$$gen_builtin_frame_address(emitter, alloc, pool, args, false, loc, bag);
          return undefined;
        }
        case 9: {
          hackwaly$tinycc$backend$codegen$$gen_builtin_frame_address(emitter, alloc, pool, args, true, loc, bag);
          return undefined;
        }
      }
    }
    if (hackwaly$tinycc$backend$codegen$$gen_atomic_builtin_call(emitter, alloc, syms, pool, cstrings, _name, _id, args, loc, bag)) {
      return undefined;
    }
    const has_func = _id > 0 ? hackwaly$tinycc$sem$$has_function_by_id(alloc.sem, _id) : moonbitlang$core$hashmap$$HashMap$contains$160$(alloc.sem.functions, _name);
    const _bind$2 = hackwaly$tinycc$backend$codegen$$lookup_local(alloc, _name, _id);
    if (_bind$2 === undefined) {
      const _bind$3 = hackwaly$tinycc$backend$codegen$$lookup_static_local(alloc, _id);
      if (_bind$3 === undefined) {
        if (has_func) {
          const ret_ty = hackwaly$tinycc$backend$codegen$$gen_call_direct$46$inner(emitter, alloc, syms, pool, cstrings, _name, _id, args, sret, loc, bag);
          const _bind$4 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ret_ty);
          if (_bind$4 === undefined) {
          } else {
            const _Some = _bind$4;
            const _k = _Some;
            if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1)) {
              hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, 0, 0);
            } else {
              hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, 0, 0);
            }
          }
          return undefined;
        }
      }
    }
  }
  const callee_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, callee);
  let param_tys = [];
  let is_varargs = false;
  let ret_ty = hackwaly$tinycc$sem$$default_int_type();
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(callee_ty);
  switch (_bind.$tag) {
    case 4: {
      const _Pointer = _bind;
      const _inner = _Pointer._0;
      const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(_inner);
      if (_bind$2.$tag === 10) {
        const _Function = _bind$2;
        const _return_type = _Function._0;
        const _params = _Function._1;
        const _varargs = _Function._2;
        param_tys = _params;
        is_varargs = _varargs;
        ret_ty = _return_type;
      }
      break;
    }
    case 10: {
      const _Function = _bind;
      const _return_type = _Function._0;
      const _params = _Function._1;
      const _varargs = _Function._2;
      param_tys = _params;
      is_varargs = _varargs;
      ret_ty = _return_type;
      break;
    }
  }
  let arg_tys = [];
  if (!is_varargs && args.length === param_tys.length) {
    arg_tys = param_tys;
  } else {
    const built = moonbitlang$core$array$$Array$new$46$inner$29$(args.length);
    let i = 0;
    while (true) {
      if (i < args.length) {
        const param_ty = i < param_tys.length ? moonbitlang$core$array$$Array$at$29$(param_tys, i) : hackwaly$tinycc$sem$$type_of_expr(alloc.sem, moonbitlang$core$array$$Array$at$55$(args, i));
        const store_ty = is_varargs && i >= param_tys.length ? hackwaly$tinycc$backend$codegen$$promote_vararg_type(param_ty) : param_ty;
        moonbitlang$core$array$$Array$push$29$(built, store_ty);
        i = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    arg_tys = built;
  }
  const variadic_index = is_varargs ? param_tys.length : 0;
  let fn_reg;
  let _try_err;
  _L: {
    _L$2: {
      const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind$3.$tag === 1) {
        const _ok = _bind$3;
        fn_reg = _ok._0;
      } else {
        const _err = _bind$3;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, callee, fn_reg, bag);
  const emit_call_fn = () => {
    hackwaly$tinycc$backend$codegen$$emit_blr(emitter, fn_reg);
  };
  hackwaly$tinycc$backend$codegen$$gen_call_with_layout(emitter, alloc, syms, pool, cstrings, args, arg_tys, ret_ty, variadic_index, sret, loc, bag, emit_call_fn, undefined);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, fn_reg);
  const _bind$3 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ret_ty);
  if (_bind$3 === undefined) {
  } else {
    const _Some = _bind$3;
    const _k = _Some;
    if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1)) {
      hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, 0, 0);
    } else {
      hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, 0, 0);
    }
  }
  const _bind$4 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ret_ty);
  if (_bind$4 === undefined) {
    if (hackwaly$tinycc$sem$$is_int_like(ret_ty)) {
      const _bind$5 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ret_ty, loc);
      if (_bind$5 === undefined) {
        return;
      } else {
        const _Some = _bind$5;
        const _x = _Some;
        const _size = _x._0;
        if (_size > 0 && _size < 8) {
          hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, ret_ty, ret_ty, 0, loc, bag);
          return;
        } else {
          return;
        }
      }
    } else {
      return;
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_atomic_builtin_call(emitter, alloc, syms, pool, cstrings, name, id, args, loc, bag) {
  const _bind = hackwaly$tinycc$sem$$atomic_builtin_template_from_ident(alloc.sem, name, id);
  let template;
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    template = _Some;
  }
  let dot_index = 0;
  while (true) {
    let _tmp$27;
    if (dot_index < template.length) {
      const _tmp$28 = dot_index;
      $bound_check(template, _tmp$28);
      const _p$28 = template.charCodeAt(_tmp$28);
      const _p$29 = 46;
      _tmp$27 = _p$28 !== _p$29;
    } else {
      _tmp$27 = false;
    }
    if (_tmp$27) {
      dot_index = dot_index + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (dot_index >= (template.length - 1 | 0)) {
    return false;
  }
  const arg_spec_len = dot_index;
  if (args.length !== arg_spec_len) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, `${name} expects ${moonbitlang$core$builtin$$Show$to_string$90$(arg_spec_len)} arguments`);
  }
  let atom_type = undefined;
  let atom_size = 0;
  const call_args = moonbitlang$core$array$$Array$new$46$inner$55$(arg_spec_len);
  const call_arg_tys = moonbitlang$core$array$$Array$new$46$inner$29$(arg_spec_len);
  let save_arg = undefined;
  let i = 0;
  while (true) {
    if (i < arg_spec_len && i < args.length) {
      const _tmp$27 = i;
      $bound_check(template, _tmp$27);
      const spec = template.charCodeAt(_tmp$27);
      const arg = moonbitlang$core$array$$Array$at$55$(args, i);
      _L: {
        _L$2: {
          switch (spec) {
            case 97: {
              break _L$2;
            }
            case 65: {
              break _L$2;
            }
            case 112: {
              moonbitlang$core$array$$Array$push$55$(call_args, arg);
              moonbitlang$core$array$$Array$push$29$(call_arg_tys, hackwaly$tinycc$sem$$type_of_expr(alloc.sem, arg));
              break;
            }
            case 108: {
              const deref = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(5, arg, 0, hackwaly$tinycc$frontend$ast$$expr_loc(arg));
              moonbitlang$core$array$$Array$push$55$(call_args, deref);
              const _bind$2 = atom_type;
              let ty;
              if (_bind$2 === undefined) {
                ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, deref);
              } else {
                const _Some = _bind$2;
                ty = _Some;
              }
              moonbitlang$core$array$$Array$push$29$(call_arg_tys, ty);
              break;
            }
            case 115: {
              save_arg = arg;
              break;
            }
            case 118: {
              moonbitlang$core$array$$Array$push$55$(call_args, arg);
              const _bind$3 = atom_type;
              let ty$2;
              if (_bind$3 === undefined) {
                ty$2 = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, arg);
              } else {
                const _Some = _bind$3;
                ty$2 = _Some;
              }
              moonbitlang$core$array$$Array$push$29$(call_arg_tys, ty$2);
              break;
            }
            case 109: {
              moonbitlang$core$array$$Array$push$55$(call_args, arg);
              moonbitlang$core$array$$Array$push$29$(call_arg_tys, hackwaly$tinycc$sem$$default_int_type());
              break;
            }
            case 98: {
              moonbitlang$core$array$$Array$push$55$(call_args, arg);
              moonbitlang$core$array$$Array$push$29$(call_arg_tys, $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Bool);
              break;
            }
          }
          break _L;
        }
        const ptr_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, arg);
        const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(ptr_ty);
        if (_bind$2.$tag === 4) {
          const _Pointer = _bind$2;
          const _pointee = _Pointer._0;
          const _bind$3 = atom_type;
          if (_bind$3 === undefined) {
            atom_type = _pointee;
            const _bind$4 = hackwaly$tinycc$sem$$type_size_align(alloc.sem, _pointee, loc);
            if (_bind$4 === undefined) {
            } else {
              const _Some = _bind$4;
              const _x = _Some;
              const _size = _x._0;
              atom_size = _size;
            }
          }
        } else {
          hackwaly$tinycc$support$diag$$add_error(bag, loc, `${name} expects pointer argument`);
        }
        moonbitlang$core$array$$Array$push$55$(call_args, arg);
        moonbitlang$core$array$$Array$push$29$(call_arg_tys, ptr_ty);
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (atom_size <= 0) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: atomic builtin requires 1/2/4/8-byte target type");
    return true;
  }
  const helper_name = `${name}_${moonbitlang$core$builtin$$Show$to_string$90$(atom_size)}`;
  const _bind$2 = hackwaly$tinycc$sem$$atomic_builtin_return_type(alloc.sem, name, id, args, loc);
  let ret_ty;
  if (_bind$2 === undefined) {
    ret_ty = hackwaly$tinycc$sem$$default_int_type();
  } else {
    const _Some = _bind$2;
    ret_ty = _Some;
  }
  const sym = hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, helper_name, 0);
  const emit_call_fn = () => {
    hackwaly$tinycc$backend$codegen$$emit_call(emitter, sym);
  };
  hackwaly$tinycc$backend$codegen$$gen_call_with_layout(emitter, alloc, syms, pool, cstrings, call_args, call_arg_tys, ret_ty, 0, undefined, loc, bag, emit_call_fn, undefined);
  const _bind$3 = save_arg;
  if (_bind$3 === undefined) {
  } else {
    const _Some = _bind$3;
    const _dest = _Some;
    let addr;
    let _try_err;
    _L: {
      _L$2: {
        const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind$4.$tag === 1) {
          const _ok = _bind$4;
          addr = _ok._0;
        } else {
          const _err = _bind$4;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$2;
        }
        break _L;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      return true;
    }
    hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _dest, addr, bag);
    const _bind$4 = atom_type;
    let store_ty;
    if (_bind$4 === undefined) {
      store_ty = ret_ty;
    } else {
      const _Some$2 = _bind$4;
      store_ty = _Some$2;
    }
    hackwaly$tinycc$backend$codegen$$emit_store_scalar_at(emitter, alloc.sem, store_ty, 0, addr, 0, loc, bag);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
  }
  return true;
}
function hackwaly$tinycc$backend$codegen$$gen_call_with_layout(emitter, alloc, syms, pool, cstrings, args, arg_tys, ret_ty, variadic_index, sret, loc, bag, emit_call, layout) {
  let layout$2;
  if (layout === undefined) {
    layout$2 = hackwaly$tinycc$backend$codegen$$arm64_pcs(alloc.sem, variadic_index, ret_ty, arg_tys, loc, bag);
  } else {
    const _Some = layout;
    layout$2 = _Some;
  }
  const arg_locs = layout$2.arg_locs;
  const arg_sizes = layout$2.arg_sizes;
  const arg_aligns = layout$2.arg_aligns;
  const arg_hfa_counts = layout$2.arg_hfa_counts;
  const arg_hfa_sizes = layout$2.arg_hfa_sizes;
  const arg_is_agg = layout$2.arg_is_agg;
  const stack_args_size = hackwaly$tinycc$backend$codegen$$align_up(layout$2.stack_size, 16);
  const spill_offs = moonbitlang$core$array$$Array$new$46$inner$17$(args.length);
  const copy_offs = moonbitlang$core$array$$Array$new$46$inner$17$(args.length);
  let scratch_off = stack_args_size;
  let i = 0;
  while (true) {
    if (i < args.length) {
      const _p$28 = moonbitlang$core$array$$Array$get$26$(arg_locs, i);
      const _p$29 = 0;
      let loc_i;
      if (_p$28 === undefined) {
        loc_i = _p$29;
      } else {
        const _p$30 = _p$28;
        loc_i = _p$30;
      }
      const byref = (loc_i & 1) !== 0;
      const is_stack = loc_i >= 32;
      const is_agg = moonbitlang$core$array$$Array$at$67$(arg_is_agg, i);
      const needs_copy = byref || is_agg && !is_stack;
      if (needs_copy) {
        const align = moonbitlang$core$array$$Array$at$26$(arg_aligns, i);
        const size = moonbitlang$core$array$$Array$at$26$(arg_sizes, i);
        const aligned = hackwaly$tinycc$backend$codegen$$align_up(scratch_off, align);
        moonbitlang$core$array$$Array$push$17$(copy_offs, aligned);
        scratch_off = aligned + size | 0;
      } else {
        moonbitlang$core$array$$Array$push$17$(copy_offs, undefined);
      }
      if (!is_stack) {
        if (needs_copy && !byref) {
          moonbitlang$core$array$$Array$push$17$(spill_offs, moonbitlang$core$array$$Array$at$17$(copy_offs, i));
        } else {
          let spill_size;
          if (byref) {
            spill_size = 8;
          } else {
            const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(moonbitlang$core$array$$Array$at$29$(arg_tys, i));
            if (_bind === undefined) {
              spill_size = 8;
            } else {
              const _Some = _bind;
              const _k = _Some;
              spill_size = moonbitlang$core$builtin$$Eq$equal$83$(_k, 0) ? 4 : 8;
            }
          }
          const spill_align = spill_size < 8 ? 4 : 8;
          const aligned = hackwaly$tinycc$backend$codegen$$align_up(scratch_off, spill_align);
          moonbitlang$core$array$$Array$push$17$(spill_offs, aligned);
          scratch_off = aligned + spill_size | 0;
        }
      } else {
        moonbitlang$core$array$$Array$push$17$(spill_offs, undefined);
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let sret_addr = sret;
  if (layout$2.ret_loc === 1) {
    const _bind = sret_addr;
    if (_bind === undefined) {
      const _bind$2 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ret_ty, loc);
      if (_bind$2 === undefined) {
      } else {
        const _Some = _bind$2;
        const _x = _Some;
        const _ret_size = _x._0;
        const _ret_align = _x._1;
        const aligned = hackwaly$tinycc$backend$codegen$$align_up(scratch_off, _ret_align);
        sret_addr = { base_reg: 31, off: aligned };
        scratch_off = aligned + _ret_size | 0;
      }
    }
  }
  const caller_save_off = hackwaly$tinycc$backend$codegen$$align_up(scratch_off, 8);
  scratch_off = caller_save_off + (Math.imul(hackwaly$tinycc$backend$codegen$$caller_saved_regs_list.length, 8) | 0) | 0;
  const total_stack = hackwaly$tinycc$backend$codegen$$align_up(scratch_off, 16);
  if (total_stack > 0) {
    const off = moonbitlang$core$builtin$$Sub$sub$6$($0L, moonbitlang$core$int$$Int$to_uint64(total_stack));
    hackwaly$tinycc$backend$arm64$$arm64_spoff(emitter, 31, off);
  }
  if (layout$2.ret_loc === 1) {
    const _bind = sret_addr;
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _addr = _Some;
      const base = _addr.base_reg;
      let off = _addr.off;
      if (base === 31) {
        off = off + total_stack | 0;
      }
      hackwaly$tinycc$backend$codegen$$emit_addr_reg(emitter, 8, base, off, loc, bag);
    }
  }
  i = 0;
  while (true) {
    if (i < args.length) {
      const _p$28 = moonbitlang$core$array$$Array$get$26$(arg_locs, i);
      const _p$29 = 0;
      let loc_i;
      if (_p$28 === undefined) {
        loc_i = _p$29;
      } else {
        const _p$30 = _p$28;
        loc_i = _p$30;
      }
      const byref = (loc_i & 1) !== 0;
      const is_stack = loc_i >= 32;
      const stack_off = is_stack ? (loc_i & -2) - 32 | 0 : 0;
      if (byref) {
        const _p$30 = moonbitlang$core$array$$Array$at$17$(copy_offs, i);
        const _p$31 = 0;
        let copy_off;
        if (_p$30 === undefined) {
          copy_off = _p$31;
        } else {
          const _p$32 = _p$30;
          copy_off = _p$32;
        }
        hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, i), 31, copy_off, moonbitlang$core$array$$Array$at$29$(arg_tys, i), loc, bag);
        let tmp;
        let _try_err;
        _L: {
          _L$2: {
            const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind.$tag === 1) {
              const _ok = _bind;
              tmp = _ok._0;
            } else {
              const _err = _bind;
              const _tmp$27 = _err._0;
              _try_err = _tmp$27;
              break _L$2;
            }
            break _L;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
          return undefined;
        }
        hackwaly$tinycc$backend$codegen$$emit_addr_sp(emitter, tmp, copy_off, loc, bag);
        if (is_stack) {
          hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, 31, moonbitlang$core$int$$Int$to_int64(stack_off));
        } else {
          const _p$32 = moonbitlang$core$array$$Array$at$17$(spill_offs, i);
          const _p$33 = 0;
          let spill;
          if (_p$32 === undefined) {
            spill = _p$33;
          } else {
            const _p$34 = _p$32;
            spill = _p$34;
          }
          hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, 31, moonbitlang$core$int$$Int$to_int64(spill));
        }
        hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
      } else {
        let slot_off;
        if (is_stack) {
          slot_off = stack_off;
        } else {
          const _p$30 = moonbitlang$core$array$$Array$at$17$(spill_offs, i);
          const _p$31 = 0;
          if (_p$30 === undefined) {
            slot_off = _p$31;
          } else {
            const _p$32 = _p$30;
            slot_off = _p$32;
          }
        }
        hackwaly$tinycc$backend$codegen$$store_call_arg_to_slot(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, i), moonbitlang$core$array$$Array$at$29$(arg_tys, i), moonbitlang$core$int$$Int$to_uint64(slot_off), loc, bag);
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  i = 0;
  while (true) {
    if (i < args.length) {
      const _p$28 = moonbitlang$core$array$$Array$get$26$(arg_locs, i);
      const _p$29 = 0;
      let loc_i;
      if (_p$28 === undefined) {
        loc_i = _p$29;
      } else {
        const _p$30 = _p$28;
        loc_i = _p$30;
      }
      if (loc_i < 16) {
        const _p$30 = moonbitlang$core$array$$Array$at$17$(spill_offs, i);
        const _p$31 = 0;
        let spill_off;
        if (_p$30 === undefined) {
          spill_off = _p$31;
        } else {
          const _p$32 = _p$30;
          spill_off = _p$32;
        }
        const reg = loc_i >> 1;
        if (moonbitlang$core$array$$Array$at$67$(arg_is_agg, i)) {
          const size = moonbitlang$core$array$$Array$at$26$(arg_sizes, i);
          hackwaly$tinycc$backend$codegen$$emit_addr_sp(emitter, reg, spill_off, loc, bag);
          hackwaly$tinycc$backend$arm64$$arm64_ldrs(emitter, reg, size);
        } else {
          hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, reg, 31, moonbitlang$core$int$$Int$to_int64(spill_off));
        }
      } else {
        if (loc_i < 32) {
          const _p$30 = moonbitlang$core$array$$Array$at$17$(spill_offs, i);
          const _p$31 = 0;
          let spill_off;
          if (_p$30 === undefined) {
            spill_off = _p$31;
          } else {
            const _p$32 = _p$30;
            spill_off = _p$32;
          }
          const fp_base = (loc_i >> 1) - 8 | 0;
          const hfa_count = moonbitlang$core$array$$Array$at$26$(arg_hfa_counts, i);
          const hfa_size = moonbitlang$core$array$$Array$at$26$(arg_hfa_sizes, i);
          if (hfa_count > 0) {
            let j = 0;
            while (true) {
              if (j < hfa_count) {
                let tmp;
                let _try_err;
                _L: {
                  _L$2: {
                    const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                    if (_bind.$tag === 1) {
                      const _ok = _bind;
                      tmp = _ok._0;
                    } else {
                      const _err = _bind;
                      const _tmp$27 = _err._0;
                      _try_err = _tmp$27;
                      break _L$2;
                    }
                    break _L;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                  return undefined;
                }
                if (hfa_size === 8) {
                  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, 31, moonbitlang$core$int$$Int$to_int64(spill_off + (Math.imul(j, 8) | 0) | 0));
                  hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, fp_base + j | 0, tmp);
                } else {
                  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, tmp, 31, moonbitlang$core$int$$Int$to_int64(spill_off + (Math.imul(j, 4) | 0) | 0));
                  hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, fp_base + j | 0, tmp);
                }
                hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                j = j + 1 | 0;
                continue;
              } else {
                break;
              }
            }
          } else {
            let tmp;
            let _try_err;
            _L: {
              _L$2: {
                const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind.$tag === 1) {
                  const _ok = _bind;
                  tmp = _ok._0;
                } else {
                  const _err = _bind;
                  const _tmp$27 = _err._0;
                  _try_err = _tmp$27;
                  break _L$2;
                }
                break _L;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
              return undefined;
            }
            const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(moonbitlang$core$array$$Array$at$29$(arg_tys, i));
            if (_bind === undefined) {
            } else {
              const _Some = _bind;
              const _k = _Some;
              if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1) || moonbitlang$core$builtin$$Eq$equal$83$(_k, 2)) {
                hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, 31, moonbitlang$core$int$$Int$to_int64(spill_off));
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, fp_base, tmp);
              } else {
                hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, tmp, 31, moonbitlang$core$int$$Int$to_int64(spill_off));
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, fp_base, tmp);
              }
            }
            hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
          }
        }
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const used_caller_regs = moonbitlang$core$array$$Array$new$46$inner$68$(hackwaly$tinycc$backend$codegen$$caller_saved_regs_list.length);
  i = 0;
  while (true) {
    if (i < hackwaly$tinycc$backend$codegen$$caller_saved_regs_list.length) {
      const reg = moonbitlang$core$array$$Array$at$26$(hackwaly$tinycc$backend$codegen$$caller_saved_regs_list, i);
      if (!moonbitlang$core$array$$Array$contains$26$(pool.free, reg)) {
        const off = caller_save_off + (Math.imul(i, 8) | 0) | 0;
        hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, reg, 31, moonbitlang$core$int$$Int$to_int64(off));
        moonbitlang$core$array$$Array$push$68$(used_caller_regs, { _0: reg, _1: off });
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  emit_call();
  i = 0;
  while (true) {
    if (i < used_caller_regs.length) {
      const _bind = moonbitlang$core$array$$Array$at$68$(used_caller_regs, i);
      const _reg = _bind._0;
      const _off = _bind._1;
      hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, _reg, 31, moonbitlang$core$int$$Int$to_int64(_off));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (total_stack > 0) {
    hackwaly$tinycc$backend$arm64$$arm64_spoff(emitter, 31, moonbitlang$core$int$$Int$to_uint64(total_stack));
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$store_call_arg_to_slot(emitter, alloc, syms, pool, cstrings, arg, ty, slot_off, loc, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ty);
  if (_bind === undefined) {
    _L: {
      const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
      switch (_bind$2.$tag) {
        case 6: {
          break _L;
        }
        case 7: {
          break _L;
        }
        default: {
          let tmp;
          let _try_err;
          _L$2: {
            _L$3: {
              const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$3.$tag === 1) {
                const _ok = _bind$3;
                tmp = _ok._0;
              } else {
                const _err = _bind$3;
                const _tmp$27 = _err._0;
                _try_err = _tmp$27;
                break _L$3;
              }
              break _L$2;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
            return undefined;
          }
          if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(ty)) {
            hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, arg, tmp, bag);
          } else {
            const from_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, arg);
            hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, arg, tmp, bag, from_ty);
            hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, from_ty, ty, tmp, loc, bag);
          }
          hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, 31, slot_off);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
          return;
        }
      }
    }
    const _bind$2 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ty, loc);
    if (_bind$2 === undefined) {
      return;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _size = _x._0;
      if (_size <= 16) {
        hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, arg, 31, moonbitlang$core$uint64$$UInt64$to_int(slot_off), ty, loc, bag);
        return;
      } else {
        hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: struct args >16 bytes not supported yet");
        return;
      }
    }
  } else {
    const _Some = _bind;
    const _k = _Some;
    let tmp;
    let _try_err;
    _L: {
      _L$2: {
        const _bind$2 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          tmp = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$2;
        }
        break _L;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      return undefined;
    }
    hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, arg, _k, tmp, bag);
    if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1)) {
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, 31, slot_off);
    } else {
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 2, tmp, 31, slot_off);
    }
    hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, expr, dst, bag, expr_ty) {
  let _tmp$27 = expr;
  let _tmp$28 = expr_ty;
  _L: while (true) {
    const expr$2 = _tmp$27;
    const expr_ty$2 = _tmp$28;
    switch (expr$2.$tag) {
      case 0: {
        const _IntLit = expr$2;
        const _value = _IntLit._0;
        const _loc = _IntLit._2;
        const _bind = hackwaly$tinycc$frontend$ast$$parse_int64_literal(_value);
        if (_bind === undefined) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: invalid integer literal");
          return;
        } else {
          const _Some = _bind;
          const _v = _Some;
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, _v);
          return;
        }
      }
      case 2: {
        const _CharLit = expr$2;
        const _value$2 = _CharLit._0;
        hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(_value$2));
        return;
      }
      case 12: {
        const _StmtExpr = expr$2;
        const _stmts = _StmtExpr._0;
        const _loc$2 = _StmtExpr._2;
        hackwaly$tinycc$backend$codegen$$gen_stmt_expr_with(emitter, alloc, syms, pool, cstrings, _stmts, dst, false, _loc$2, bag, (expr$3, dst$2) => {
          hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, expr$3, dst$2, bag, undefined);
        });
        return;
      }
      case 4: {
        const _Ident = expr$2;
        const _name = _Ident._0;
        const _id = _Ident._1;
        const _loc$3 = _Ident._3;
        const _bind$2 = hackwaly$tinycc$sem$$enum_const_value(alloc.sem, _name, _id);
        if (_bind$2 === undefined) {
        } else {
          const _Some = _bind$2;
          const _v = _Some;
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(_v));
          return undefined;
        }
        if (_name === "__func__" || (_name === "__FUNCTION__" || _name === "__PRETTY_FUNCTION__")) {
          if (hackwaly$tinycc$backend$codegen$$gen_func_name_addr(emitter, syms, cstrings, alloc, dst, _loc$3, bag)) {
            return undefined;
          }
        }
        const _bind$3 = hackwaly$tinycc$backend$codegen$$lookup_local(alloc, _name, _id);
        if (_bind$3 === undefined) {
          const _bind$4 = hackwaly$tinycc$backend$codegen$$lookup_static_local(alloc, _id);
          if (_bind$4 === undefined) {
            const sym = hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, _name, _id);
            const global_ty = _id > 0 ? hackwaly$tinycc$sem$$get_global_by_id(alloc.sem, _id) : undefined;
            let ty;
            if (global_ty === undefined) {
              const _bind$5 = moonbitlang$core$hashmap$$HashMap$get$159$(alloc.sem.globals, _name);
              if (_bind$5 === undefined) {
                if (expr_ty$2 === undefined) {
                  ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
                } else {
                  const _Some = expr_ty$2;
                  ty = _Some;
                }
              } else {
                const _Some = _bind$5;
                const _gty = _Some;
                ty = hackwaly$tinycc$sem$$decay_type(_gty);
              }
            } else {
              const _Some = global_ty;
              const _gty = _Some;
              ty = hackwaly$tinycc$sem$$decay_type(_gty);
            }
            hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, dst);
            const _bind$5 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty, _loc$3);
            let _bind$6;
            if (_bind$5 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$5;
              _bind$6 = _Some;
            }
            const _size = _bind$6._0;
            const _signed = _bind$6._1;
            const _bind$7 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
            let sz;
            if (_bind$7 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, "codegen: unsupported scalar size");
              return undefined;
            } else {
              const _Some = _bind$7;
              sz = _Some;
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed, sz, dst, dst, $0L);
            return;
          } else {
            const _Some = _bind$4;
            const _info = _Some;
            const sym = hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, _info);
            const ty = hackwaly$tinycc$sem$$decay_type(_info.ty);
            hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, dst);
            const _bind$5 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty, _loc$3);
            let _bind$6;
            if (_bind$5 === undefined) {
              return undefined;
            } else {
              const _Some$2 = _bind$5;
              _bind$6 = _Some$2;
            }
            const _size = _bind$6._0;
            const _signed = _bind$6._1;
            const _bind$7 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
            let sz;
            if (_bind$7 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, "codegen: unsupported scalar size");
              return undefined;
            } else {
              const _Some$2 = _bind$7;
              sz = _Some$2;
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed, sz, dst, dst, $0L);
            return;
          }
        } else {
          const _Some = _bind$3;
          const _slot = _Some;
          hackwaly$tinycc$backend$codegen$$emit_load_local_scalar(emitter, alloc.sem, _slot.ty, dst, _slot.offset, _loc$3, bag);
          return;
        }
      }
      case 20: {
        const _Index = expr$2;
        const _base = _Index._0;
        const _index = _Index._1;
        const _loc$4 = _Index._3;
        let addr;
        let _try_err;
        _L$2: {
          _L$3: {
            const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$4.$tag === 1) {
              const _ok = _bind$4;
              addr = _ok._0;
            } else {
              const _err = _bind$4;
              const _tmp$29 = _err._0;
              _try_err = _tmp$29;
              break _L$3;
            }
            break _L$2;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$4, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
          return undefined;
        }
        const _bind$4 = hackwaly$tinycc$backend$codegen$$gen_index_addr_with_elem_type(emitter, alloc, syms, pool, cstrings, _base, _index, addr, _loc$4, bag);
        let elem_ty;
        if (_bind$4 === undefined) {
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
          return undefined;
        } else {
          const _Some = _bind$4;
          elem_ty = _Some;
        }
        const _bind$5 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, elem_ty, _loc$4);
        let _bind$6;
        if (_bind$5 === undefined) {
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
          return undefined;
        } else {
          const _Some = _bind$5;
          _bind$6 = _Some;
        }
        const _size = _bind$6._0;
        const _signed = _bind$6._1;
        const _bind$7 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
        let sz;
        if (_bind$7 === undefined) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$4, "codegen: unsupported scalar size");
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
          return undefined;
        } else {
          const _Some = _bind$7;
          sz = _Some;
        }
        hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed, sz, dst, addr, $0L);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
        return;
      }
      case 21: {
        const _Member = expr$2;
        const _base$2 = _Member._0;
        const _name$2 = _Member._1;
        const _id$2 = _Member._2;
        const _is_arrow = _Member._3;
        const _loc$5 = _Member._5;
        const base_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _base$2);
        const info = hackwaly$tinycc$backend$codegen$$member_access_info_from_base_type(alloc.sem, base_ty, _name$2, _id$2, _is_arrow, _loc$5);
        if (info === undefined) {
        } else {
          const _Some = info;
          const _access_info = _Some;
          const _bind$8 = _access_info.bit_width;
          if (_bind$8 === undefined) {
          } else {
            let addr$2;
            let _try_err$2;
            _L$3: {
              _L$4: {
                const _bind$9 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$9.$tag === 1) {
                  const _ok = _bind$9;
                  addr$2 = _ok._0;
                } else {
                  const _err = _bind$9;
                  const _tmp$29 = _err._0;
                  _try_err$2 = _tmp$29;
                  break _L$4;
                }
                break _L$3;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_member_base_addr(emitter, alloc, syms, pool, cstrings, _base$2, _is_arrow, addr$2, bag);
            hackwaly$tinycc$backend$codegen$$emit_bitfield_load(emitter, alloc, pool, addr$2, _access_info, dst, _loc$5, bag);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
            return undefined;
          }
        }
        let addr$2;
        let _try_err$2;
        _L$3: {
          _L$4: {
            const _bind$8 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$8.$tag === 1) {
              const _ok = _bind$8;
              addr$2 = _ok._0;
            } else {
              const _err = _bind$8;
              const _tmp$29 = _err._0;
              _try_err$2 = _tmp$29;
              break _L$4;
            }
            break _L$3;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
          return undefined;
        }
        if (info === undefined) {
          hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, expr$2, addr$2, bag);
          let ty;
          if (expr_ty$2 === undefined) {
            ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
          } else {
            const _Some = expr_ty$2;
            ty = _Some;
          }
          const _bind$8 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty, _loc$5);
          let _bind$9;
          if (_bind$8 === undefined) {
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
            return undefined;
          } else {
            const _Some = _bind$8;
            _bind$9 = _Some;
          }
          const _size$2 = _bind$9._0;
          const _signed$2 = _bind$9._1;
          const _bind$10 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size$2);
          let sz$2;
          if (_bind$10 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, "codegen: unsupported scalar size");
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
            return undefined;
          } else {
            const _Some = _bind$10;
            sz$2 = _Some;
          }
          hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed$2, sz$2, dst, addr$2, $0L);
        } else {
          const _Some = info;
          const _info = _Some;
          hackwaly$tinycc$backend$codegen$$gen_member_addr_with_info(emitter, alloc, syms, pool, cstrings, _base$2, base_ty, _is_arrow, _info, addr$2, _loc$5, bag);
          const _bind$8 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, _info.ty, _loc$5);
          let _bind$9;
          if (_bind$8 === undefined) {
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
            return undefined;
          } else {
            const _Some$2 = _bind$8;
            _bind$9 = _Some$2;
          }
          const _size$2 = _bind$9._0;
          const _signed$2 = _bind$9._1;
          const _bind$10 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size$2);
          let sz$2;
          if (_bind$10 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, "codegen: unsupported scalar size");
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
            return undefined;
          } else {
            const _Some$2 = _bind$10;
            sz$2 = _Some$2;
          }
          hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed$2, sz$2, dst, addr$2, $0L);
        }
        hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
        return;
      }
      case 11: {
        const _CompoundLiteral = expr$2;
        const _ty = _CompoundLiteral._0;
        const _init = _CompoundLiteral._1;
        const _node_id = _CompoundLiteral._2;
        const _loc$6 = _CompoundLiteral._3;
        let addr$3;
        let _try_err$3;
        _L$4: {
          _L$5: {
            const _bind$8 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$8.$tag === 1) {
              const _ok = _bind$8;
              addr$3 = _ok._0;
            } else {
              const _err = _bind$8;
              const _tmp$29 = _err._0;
              _try_err$3 = _tmp$29;
              break _L$5;
            }
            break _L$4;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$6, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
          return undefined;
        }
        const _bind$8 = hackwaly$tinycc$backend$codegen$$gen_compound_literal_addr_with_type(emitter, alloc, syms, pool, cstrings, _ty, _init, _loc$6, _node_id, addr$3, bag);
        let resolved;
        if (_bind$8 === undefined) {
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
          return undefined;
        } else {
          const _Some = _bind$8;
          resolved = _Some;
        }
        const _bind$9 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, resolved, _loc$6);
        let _bind$10;
        if (_bind$9 === undefined) {
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
          return undefined;
        } else {
          const _Some = _bind$9;
          _bind$10 = _Some;
        }
        const _size$2 = _bind$10._0;
        const _signed$2 = _bind$10._1;
        const _bind$11 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size$2);
        let sz$2;
        if (_bind$11 === undefined) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$6, "codegen: unsupported scalar size");
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
          return undefined;
        } else {
          const _Some = _bind$11;
          sz$2 = _Some;
        }
        hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed$2, sz$2, dst, addr$3, $0L);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
        return;
      }
      case 8: {
        const _BuiltinVaArg = expr$2;
        const _list = _BuiltinVaArg._0;
        const _ty$2 = _BuiltinVaArg._1;
        const _loc$7 = _BuiltinVaArg._3;
        const _bind$12 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(hackwaly$tinycc$sem$$strip_top_qualifiers(_ty$2));
        if (_bind$12 === undefined) {
          if (!hackwaly$tinycc$backend$codegen$$gen_builtin_va_arg_load(emitter, alloc, syms, pool, cstrings, _list, _ty$2, dst, bag)) {
            return;
          } else {
            return;
          }
        } else {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$7, "codegen: va_arg for float handled elsewhere");
          return;
        }
      }
      case 7: {
        const _BuiltinOffsetof = expr$2;
        const _ty$3 = _BuiltinOffsetof._0;
        const _path = _BuiltinOffsetof._1;
        const _loc$8 = _BuiltinOffsetof._3;
        const _bind$13 = hackwaly$tinycc$sem$$eval_builtin_offsetof(alloc.sem, _ty$3, _path, _loc$8);
        if (_bind$13 === undefined) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$8, "codegen: unsupported expression");
          return;
        } else {
          const _Some = _bind$13;
          const _off = _Some;
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(_off));
          return;
        }
      }
      case 9: {
        const _Unary = expr$2;
        const _op = _Unary._0;
        const _inner = _Unary._1;
        const _loc$9 = _Unary._3;
        _L$5: {
          switch (_op) {
            case 0: {
              _tmp$27 = _inner;
              _tmp$28 = undefined;
              continue _L;
            }
            case 1: {
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _inner, dst, bag, undefined);
              let ty;
              if (expr_ty$2 === undefined) {
                ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
              } else {
                const _Some = expr_ty$2;
                ty = _Some;
              }
              const _bind$14 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty, _loc$9);
              let _bind$15;
              if (_bind$14 === undefined) {
                return undefined;
              } else {
                const _Some = _bind$14;
                _bind$15 = _Some;
              }
              const _size$3 = _bind$15._0;
              const base = _size$3 === 8 ? -889191456 : 1258292192;
              hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | dst << 16);
              return;
            }
            case 3: {
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _inner, dst, bag, undefined);
              let ty$2;
              if (expr_ty$2 === undefined) {
                ty$2 = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
              } else {
                const _Some = expr_ty$2;
                ty$2 = _Some;
              }
              const _bind$16 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty$2, _loc$9);
              let _bind$17;
              if (_bind$16 === undefined) {
                return undefined;
              } else {
                const _Some = _bind$16;
                _bind$17 = _Some;
              }
              const _size$4 = _bind$17._0;
              const base$2 = _size$4 === 8 ? -1440742432 : 706741216;
              hackwaly$tinycc$backend$arm64$$emit32(emitter, base$2 | dst | dst << 16);
              return;
            }
            case 2: {
              hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _inner, bag);
              hackwaly$tinycc$backend$arm64$$emit32(emitter, 446633952 | dst);
              return;
            }
            case 4: {
              hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _inner, dst, bag);
              return;
            }
            case 5: {
              let addr$4;
              let _try_err$4;
              _L$6: {
                _L$7: {
                  const _bind$18 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$18.$tag === 1) {
                    const _ok = _bind$18;
                    addr$4 = _ok._0;
                  } else {
                    const _err = _bind$18;
                    const _tmp$29 = _err._0;
                    _try_err$4 = _tmp$29;
                    break _L$7;
                  }
                  break _L$6;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$4));
                return undefined;
              }
              hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _inner, addr$4, bag);
              const _bind$18 = hackwaly$tinycc$backend$codegen$$deref_pointee_type(alloc.sem, _inner, _loc$9, bag);
              let ty$3;
              if (_bind$18 === undefined) {
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
                return undefined;
              } else {
                const _Some = _bind$18;
                ty$3 = _Some;
              }
              const _bind$19 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty$3, _loc$9);
              let _bind$20;
              if (_bind$19 === undefined) {
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
                return undefined;
              } else {
                const _Some = _bind$19;
                _bind$20 = _Some;
              }
              const _size$5 = _bind$20._0;
              const _signed$3 = _bind$20._1;
              const _bind$21 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size$5);
              let sz$3;
              if (_bind$21 === undefined) {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: unsupported scalar size");
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
                return undefined;
              } else {
                const _Some = _bind$21;
                sz$3 = _Some;
              }
              hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed$3, sz$3, dst, addr$4, $0L);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
              return;
            }
            case 6: {
              break _L$5;
            }
            case 7: {
              break _L$5;
            }
            case 8: {
              break _L$5;
            }
            default: {
              break _L$5;
            }
          }
        }
        const _bind$14 = hackwaly$tinycc$backend$codegen$$member_bitfield_info(alloc, _inner);
        if (_bind$14 === undefined) {
        } else {
          const _Some = _bind$14;
          const _x = _Some;
          const _base$3 = _x._0;
          const _is_arrow$2 = _x._1;
          const _info = _x._2;
          let addr$4;
          let _try_err$4;
          _L$6: {
            _L$7: {
              const _bind$15 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$15.$tag === 1) {
                const _ok = _bind$15;
                addr$4 = _ok._0;
              } else {
                const _err = _bind$15;
                const _tmp$29 = _err._0;
                _try_err$4 = _tmp$29;
                break _L$7;
              }
              break _L$6;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$4));
            return undefined;
          }
          hackwaly$tinycc$backend$codegen$$gen_member_base_addr(emitter, alloc, syms, pool, cstrings, _base$3, _is_arrow$2, addr$4, bag);
          hackwaly$tinycc$backend$codegen$$emit_bitfield_load(emitter, alloc, pool, addr$4, _info, dst, _loc$9, bag);
          const _bind$15 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, _info.ty, _loc$9);
          let _bind$16;
          if (_bind$15 === undefined) {
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
            return undefined;
          } else {
            const _Some$2 = _bind$15;
            _bind$16 = _Some$2;
          }
          const _size$3 = _bind$16._0;
          const is64 = _size$3 === 8;
          let one;
          let _try_err$5;
          _L$7: {
            _L$8: {
              const _bind$17 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$17.$tag === 1) {
                const _ok = _bind$17;
                one = _ok._0;
              } else {
                const _err = _bind$17;
                const _tmp$29 = _err._0;
                _try_err$5 = _tmp$29;
                break _L$8;
              }
              break _L$7;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
            return undefined;
          }
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, one, $1L);
          if (moonbitlang$core$builtin$$Eq$equal$179$(_op, 8) || moonbitlang$core$builtin$$Eq$equal$179$(_op, 9)) {
            let updated;
            let _try_err$6;
            _L$8: {
              _L$9: {
                const _bind$17 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$17.$tag === 1) {
                  const _ok = _bind$17;
                  updated = _ok._0;
                } else {
                  const _err = _bind$17;
                  const _tmp$29 = _err._0;
                  _try_err$6 = _tmp$29;
                  break _L$9;
                }
                break _L$8;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, one);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, is64, updated, dst);
            const base_post = moonbitlang$core$builtin$$Eq$equal$179$(_op, 9) ? (is64 ? -889192448 : 1258291200) : is64 ? -1962934272 : 184549376;
            hackwaly$tinycc$backend$arm64$$emit32(emitter, base_post | updated | updated << 5 | one << 16);
            hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, addr$4, _info, updated, _loc$9, bag);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, updated);
          } else {
            const base_pre = moonbitlang$core$builtin$$Eq$equal$179$(_op, 7) ? (is64 ? -889192448 : 1258291200) : is64 ? -1962934272 : 184549376;
            hackwaly$tinycc$backend$arm64$$emit32(emitter, base_pre | dst | dst << 5 | one << 16);
            hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, addr$4, _info, dst, _loc$9, bag);
            hackwaly$tinycc$backend$codegen$$emit_bitfield_load(emitter, alloc, pool, addr$4, _info, dst, _loc$9, bag);
          }
          hackwaly$tinycc$backend$codegen$$give_reg(pool, one);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
          return undefined;
        }
        const ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _inner);
        if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(ty)) {
          const _bind$15 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ty, _loc$9);
          let ptr_size;
          if (_bind$15 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$15;
            const _x = _Some;
            ptr_size = _x._0;
          }
          const _bind$16 = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(ty);
          let elem_ty$2;
          if (_bind$16 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: pointer inc/dec missing element type");
            return undefined;
          } else {
            const _Some = _bind$16;
            elem_ty$2 = _Some;
          }
          const _bind$17 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, elem_ty$2, _loc$9);
          let _bind$18;
          if (_bind$17 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$17;
            _bind$18 = _Some;
          }
          const _elem_size = _bind$18._0;
          let addr$4;
          let _try_err$4;
          _L$6: {
            _L$7: {
              const _bind$19 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$19.$tag === 1) {
                const _ok = _bind$19;
                addr$4 = _ok._0;
              } else {
                const _err = _bind$19;
                const _tmp$29 = _err._0;
                _try_err$4 = _tmp$29;
                break _L$7;
              }
              break _L$6;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$4));
            return undefined;
          }
          hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _inner, addr$4, bag);
          const _bind$19 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(ptr_size);
          let sz$3;
          if (_bind$19 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: unsupported pointer size");
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
            return undefined;
          } else {
            const _Some = _bind$19;
            sz$3 = _Some;
          }
          hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, sz$3, dst, addr$4, $0L);
          let delta_reg;
          let _try_err$5;
          _L$7: {
            _L$8: {
              const _bind$20 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$20.$tag === 1) {
                const _ok = _bind$20;
                delta_reg = _ok._0;
              } else {
                const _err = _bind$20;
                const _tmp$29 = _err._0;
                _try_err$5 = _tmp$29;
                break _L$8;
              }
              break _L$7;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
            return undefined;
          }
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, delta_reg, moonbitlang$core$int$$Int$to_uint64(_elem_size));
          let updated_reg = dst;
          if (moonbitlang$core$builtin$$Eq$equal$179$(_op, 8) || moonbitlang$core$builtin$$Eq$equal$179$(_op, 9)) {
            let _tmp$29;
            let _try_err$6;
            _L$8: {
              _L$9: {
                const _bind$20 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$20.$tag === 1) {
                  const _ok = _bind$20;
                  _tmp$29 = _ok._0;
                } else {
                  const _err = _bind$20;
                  const _tmp$30 = _err._0;
                  _try_err$6 = _tmp$30;
                  break _L$9;
                }
                break _L$8;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, delta_reg);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
              return undefined;
            }
            updated_reg = _tmp$29;
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, updated_reg, dst);
          }
          const base = moonbitlang$core$builtin$$Eq$equal$179$(_op, 7) || moonbitlang$core$builtin$$Eq$equal$179$(_op, 9) ? -889192448 : -1962934272;
          hackwaly$tinycc$backend$arm64$$emit32(emitter, base | updated_reg | updated_reg << 5 | delta_reg << 16);
          hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz$3, updated_reg, addr$4, $0L);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, delta_reg);
          if (updated_reg !== dst) {
            hackwaly$tinycc$backend$codegen$$give_reg(pool, updated_reg);
          }
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
          return undefined;
        }
        const _bind$15 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty, _loc$9);
        let _bind$16;
        if (_bind$15 === undefined) {
          return undefined;
        } else {
          const _Some = _bind$15;
          _bind$16 = _Some;
        }
        const _size$3 = _bind$16._0;
        const _signed$3 = _bind$16._1;
        const _bind$17 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size$3);
        let sz$3;
        if (_bind$17 === undefined) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: unsupported scalar size");
          return undefined;
        } else {
          const _Some = _bind$17;
          sz$3 = _Some;
        }
        const is64 = _size$3 === 8;
        let addr$4;
        let _try_err$4;
        _L$6: {
          _L$7: {
            const _bind$18 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$18.$tag === 1) {
              const _ok = _bind$18;
              addr$4 = _ok._0;
            } else {
              const _err = _bind$18;
              const _tmp$29 = _err._0;
              _try_err$4 = _tmp$29;
              break _L$7;
            }
            break _L$6;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$4));
          return undefined;
        }
        hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _inner, addr$4, bag);
        hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed$3, sz$3, dst, addr$4, $0L);
        let one;
        let _try_err$5;
        _L$7: {
          _L$8: {
            const _bind$18 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$18.$tag === 1) {
              const _ok = _bind$18;
              one = _ok._0;
            } else {
              const _err = _bind$18;
              const _tmp$29 = _err._0;
              _try_err$5 = _tmp$29;
              break _L$8;
            }
            break _L$7;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
          return undefined;
        }
        hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, one, $1L);
        if (moonbitlang$core$builtin$$Eq$equal$179$(_op, 8) || moonbitlang$core$builtin$$Eq$equal$179$(_op, 9)) {
          let updated;
          let _try_err$6;
          _L$8: {
            _L$9: {
              const _bind$18 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$18.$tag === 1) {
                const _ok = _bind$18;
                updated = _ok._0;
              } else {
                const _err = _bind$18;
                const _tmp$29 = _err._0;
                _try_err$6 = _tmp$29;
                break _L$9;
              }
              break _L$8;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
            hackwaly$tinycc$backend$codegen$$give_reg(pool, one);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
            return undefined;
          }
          hackwaly$tinycc$backend$codegen$$emit_mov(emitter, is64, updated, dst);
          const base_post = moonbitlang$core$builtin$$Eq$equal$179$(_op, 8) ? (is64 ? -1962934272 : 184549376) : is64 ? -889192448 : 1258291200;
          hackwaly$tinycc$backend$arm64$$emit32(emitter, base_post | updated | updated << 5 | one << 16);
          hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz$3, updated, addr$4, $0L);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, updated);
        } else {
          const base_pre = moonbitlang$core$builtin$$Eq$equal$179$(_op, 6) ? (is64 ? -1962934272 : 184549376) : is64 ? -889192448 : 1258291200;
          hackwaly$tinycc$backend$arm64$$emit32(emitter, base_pre | dst | dst << 5 | one << 16);
          hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz$3, dst, addr$4, $0L);
          if (_size$3 < 4) {
            hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, ty, ty, dst, _loc$9, bag);
          }
        }
        hackwaly$tinycc$backend$codegen$$give_reg(pool, one);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
        return;
      }
      case 17: {
        const _Binary = expr$2;
        const _op$2 = _Binary._0;
        const _left = _Binary._1;
        const _right = _Binary._2;
        const _loc$10 = _Binary._4;
        _L$8: {
          _L$9: {
            _L$10: {
              switch (_op$2) {
                case 11: {
                  hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _left, bag);
                  if (expr_ty$2 === undefined) {
                    _tmp$27 = _right;
                    _tmp$28 = undefined;
                    continue _L;
                  } else {
                    const _Some = expr_ty$2;
                    const _ty$4 = _Some;
                    _tmp$27 = _right;
                    _tmp$28 = _ty$4;
                    continue _L;
                  }
                }
                case 0: {
                  const lhs_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left);
                  _L$11: {
                    const _bind$18 = hackwaly$tinycc$sem$$strip_top_qualifiers(lhs_ty);
                    switch (_bind$18.$tag) {
                      case 6: {
                        break _L$11;
                      }
                      case 7: {
                        break _L$11;
                      }
                      default: {
                        _L$12: {
                          _L$13: {
                            switch (_left.$tag) {
                              case 4: {
                                const rhs_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
                                hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, _right, rhs_ty, dst, bag);
                                hackwaly$tinycc$backend$codegen$$emit_cast_value(emitter, alloc.sem, rhs_ty, lhs_ty, dst, _loc$10, bag);
                                hackwaly$tinycc$backend$codegen$$store_lvalue_scalar(emitter, alloc, syms, pool, cstrings, _left, dst, lhs_ty, bag);
                                return;
                              }
                              case 9: {
                                const _Unary$2 = _left;
                                const _x = _Unary$2._0;
                                if (_x === 5) {
                                  break _L$13;
                                } else {
                                  break _L$12;
                                }
                              }
                              case 20: {
                                break _L$13;
                              }
                              case 21: {
                                break _L$13;
                              }
                              default: {
                                break _L$12;
                              }
                            }
                          }
                          const rhs_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
                          hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, _right, rhs_ty, dst, bag);
                          hackwaly$tinycc$backend$codegen$$emit_cast_value(emitter, alloc.sem, rhs_ty, lhs_ty, dst, _loc$10, bag);
                          hackwaly$tinycc$backend$codegen$$store_lvalue_scalar(emitter, alloc, syms, pool, cstrings, _left, dst, lhs_ty, bag);
                          return;
                        }
                        hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: unsupported assignment lhs for now");
                        return;
                      }
                    }
                  }
                  const _bind$18 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, lhs_ty, _loc$10);
                  if (_bind$18 === undefined) {
                    return;
                  } else {
                    const _Some = _bind$18;
                    const _x = _Some;
                    const _size$4 = _x._0;
                    if (_size$4 <= 0) {
                      return undefined;
                    }
                    let dst_addr;
                    let _try_err$6;
                    _L$12: {
                      _L$13: {
                        const _bind$19 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                        if (_bind$19.$tag === 1) {
                          const _ok = _bind$19;
                          dst_addr = _ok._0;
                        } else {
                          const _err = _bind$19;
                          const _tmp$29 = _err._0;
                          _try_err$6 = _tmp$29;
                          break _L$13;
                        }
                        break _L$12;
                      }
                      hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
                      return undefined;
                    }
                    hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _left, dst_addr, bag);
                    hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _right, dst_addr, 0, lhs_ty, _loc$10, bag);
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, dst_addr);
                    return;
                  }
                }
                case 1: {
                  break _L$10;
                }
                case 2: {
                  break _L$10;
                }
                case 3: {
                  break _L$10;
                }
                case 4: {
                  break _L$10;
                }
                case 5: {
                  break _L$10;
                }
                case 6: {
                  break _L$10;
                }
                case 7: {
                  break _L$10;
                }
                case 8: {
                  break _L$10;
                }
                case 10: {
                  break _L$10;
                }
                case 9: {
                  break _L$10;
                }
                case 28: {
                  break _L$9;
                }
                case 29: {
                  break _L$9;
                }
                case 12: {
                  break _L$8;
                }
                case 13: {
                  break _L$8;
                }
                case 14: {
                  break _L$8;
                }
                case 15: {
                  break _L$8;
                }
                case 16: {
                  break _L$8;
                }
                case 25: {
                  break _L$8;
                }
                case 27: {
                  break _L$8;
                }
                case 26: {
                  break _L$8;
                }
                case 19: {
                  break _L$8;
                }
                case 20: {
                  break _L$8;
                }
                case 21: {
                  break _L$8;
                }
                case 22: {
                  break _L$8;
                }
                case 23: {
                  break _L$8;
                }
                case 24: {
                  break _L$8;
                }
                case 17: {
                  break _L$8;
                }
                default: {
                  break _L$8;
                }
              }
            }
            const left_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left);
            if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty)) {
              _L$11: {
                _L$12: {
                  switch (_op$2) {
                    case 1: {
                      break _L$12;
                    }
                    case 2: {
                      break _L$12;
                    }
                    default: {
                      hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: compound assign pointer lhs not supported yet");
                    }
                  }
                  break _L$11;
                }
                let addr$5;
                let _try_err$6;
                _L$13: {
                  _L$14: {
                    const _bind$18 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                    if (_bind$18.$tag === 1) {
                      const _ok = _bind$18;
                      addr$5 = _ok._0;
                    } else {
                      const _err = _bind$18;
                      const _tmp$29 = _err._0;
                      _try_err$6 = _tmp$29;
                      break _L$14;
                    }
                    break _L$13;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
                  return undefined;
                }
                hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _left, addr$5, bag);
                let base_reg;
                let _try_err$7;
                _L$14: {
                  _L$15: {
                    const _bind$18 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                    if (_bind$18.$tag === 1) {
                      const _ok = _bind$18;
                      base_reg = _ok._0;
                    } else {
                      const _err = _bind$18;
                      const _tmp$29 = _err._0;
                      _try_err$7 = _tmp$29;
                      break _L$15;
                    }
                    break _L$14;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
                  return undefined;
                }
                hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, base_reg, addr$5, $0L);
                let idx;
                let _try_err$8;
                _L$15: {
                  _L$16: {
                    const _bind$18 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                    if (_bind$18.$tag === 1) {
                      const _ok = _bind$18;
                      idx = _ok._0;
                    } else {
                      const _err = _bind$18;
                      const _tmp$29 = _err._0;
                      _try_err$8 = _tmp$29;
                      break _L$16;
                    }
                    break _L$15;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$8));
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, base_reg);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
                  return undefined;
                }
                const idx_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
                hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _right, idx, bag, idx_ty);
                hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, idx_ty, idx, _loc$10, bag);
                const _bind$18 = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(left_ty);
                let elem_ty$2;
                if (_bind$18 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: pointer arithmetic missing element type");
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
                  return undefined;
                } else {
                  const _Some = _bind$18;
                  elem_ty$2 = _Some;
                }
                const _bind$19 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, elem_ty$2, _loc$10);
                let _bind$20;
                if (_bind$19 === undefined) {
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
                  return undefined;
                } else {
                  const _Some = _bind$19;
                  _bind$20 = _Some;
                }
                const _elem_size = _bind$20._0;
                if (_elem_size !== 1) {
                  let scale;
                  let _try_err$9;
                  _L$16: {
                    _L$17: {
                      const _bind$21 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                      if (_bind$21.$tag === 1) {
                        const _ok = _bind$21;
                        scale = _ok._0;
                      } else {
                        const _err = _bind$21;
                        const _tmp$29 = _err._0;
                        _try_err$9 = _tmp$29;
                        break _L$17;
                      }
                      break _L$16;
                    }
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$9));
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
                    return undefined;
                  }
                  hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(_elem_size));
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1694467072 | idx | idx << 5 | scale << 16);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
                }
                const base = moonbitlang$core$builtin$$Eq$equal$178$(_op$2, 1) ? -1962934272 : -889192448;
                hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | base_reg << 5 | idx << 16);
                hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, dst, addr$5, $0L);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, base_reg);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
              }
              return undefined;
            }
            const _bind$18 = hackwaly$tinycc$backend$codegen$$member_bitfield_info(alloc, _left);
            if (_bind$18 === undefined) {
            } else {
              const _Some = _bind$18;
              const _x = _Some;
              const _base$3 = _x._0;
              const _is_arrow$2 = _x._1;
              const _info = _x._2;
              const _bind$19 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, _info.ty, _loc$10);
              let _bind$20;
              if (_bind$19 === undefined) {
                return undefined;
              } else {
                const _Some$2 = _bind$19;
                _bind$20 = _Some$2;
              }
              const _lhs_size = _bind$20._0;
              const _lhs_signed = _bind$20._1;
              const is_unsigned = !_lhs_signed;
              const is64$2 = _lhs_size === 8;
              const _bind$21 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_lhs_size);
              if (_bind$21 === undefined) {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: unsupported scalar size");
                return undefined;
              }
              let addr$5;
              let _try_err$6;
              _L$11: {
                _L$12: {
                  const _bind$22 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$22.$tag === 1) {
                    const _ok = _bind$22;
                    addr$5 = _ok._0;
                  } else {
                    const _err = _bind$22;
                    const _tmp$29 = _err._0;
                    _try_err$6 = _tmp$29;
                    break _L$12;
                  }
                  break _L$11;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
                return undefined;
              }
              hackwaly$tinycc$backend$codegen$$gen_member_base_addr(emitter, alloc, syms, pool, cstrings, _base$3, _is_arrow$2, addr$5, bag);
              hackwaly$tinycc$backend$codegen$$emit_bitfield_load(emitter, alloc, pool, addr$5, _info, dst, _loc$10, bag);
              let tmp_old;
              let _try_err$7;
              _L$12: {
                _L$13: {
                  const _bind$22 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$22.$tag === 1) {
                    const _ok = _bind$22;
                    tmp_old = _ok._0;
                  } else {
                    const _err = _bind$22;
                    const _tmp$29 = _err._0;
                    _try_err$7 = _tmp$29;
                    break _L$13;
                  }
                  break _L$12;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
                return undefined;
              }
              hackwaly$tinycc$backend$codegen$$emit_mov(emitter, is64$2, tmp_old, dst);
              const right_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _right, dst, bag, right_ty);
              if (is64$2) {
                hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, right_ty, dst, _loc$10, bag);
              }
              switch (_op$2) {
                case 1: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1962934272 : 184549376) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 2: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -889192448 : 1258291200) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 3: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1694467072 : 453016576) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 4: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is_unsigned ? (is64$2 ? -1698691072 : 448792576) : is64$2 ? -1698690048 : 448793600) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 5: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is_unsigned ? (is64$2 ? -1698691072 : 448792576) : is64$2 ? -1698690048 : 448793600) | 30 | tmp_old << 5 | dst << 16);
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1694466048 : 453017600) | dst | 960 | dst << 16 | tmp_old << 10);
                  break;
                }
                case 6: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, 448798720 | (is64$2 ? -2147483648 : 0) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 7: {
                  const base = is_unsigned ? 448799744 : 448800768;
                  const base64 = is64$2 ? base | -2147483648 : base;
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, base64 | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 8: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1979711488 : 167772160) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 10: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1442840576 : 704643072) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
                case 9: {
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -905969664 : 1241513984) | dst | tmp_old << 5 | dst << 16);
                  break;
                }
              }
              hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, addr$5, _info, dst, _loc$10, bag);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp_old);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
              return undefined;
            }
            const _bind$19 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, left_ty, _loc$10);
            let _bind$20;
            if (_bind$19 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$19;
              _bind$20 = _Some;
            }
            const _lhs_size = _bind$20._0;
            const _lhs_signed = _bind$20._1;
            const _bind$21 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_lhs_size);
            let sz$4;
            if (_bind$21 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: unsupported scalar size");
              return undefined;
            } else {
              const _Some = _bind$21;
              sz$4 = _Some;
            }
            const is_unsigned = !_lhs_signed;
            const is64$2 = _lhs_size === 8;
            let addr$5;
            let _try_err$6;
            _L$11: {
              _L$12: {
                const _bind$22 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$22.$tag === 1) {
                  const _ok = _bind$22;
                  addr$5 = _ok._0;
                } else {
                  const _err = _bind$22;
                  const _tmp$29 = _err._0;
                  _try_err$6 = _tmp$29;
                  break _L$12;
                }
                break _L$11;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _left, addr$5, bag);
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _lhs_signed, sz$4, dst, addr$5, $0L);
            let tmp_old;
            let _try_err$7;
            _L$12: {
              _L$13: {
                const _bind$22 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$22.$tag === 1) {
                  const _ok = _bind$22;
                  tmp_old = _ok._0;
                } else {
                  const _err = _bind$22;
                  const _tmp$29 = _err._0;
                  _try_err$7 = _tmp$29;
                  break _L$13;
                }
                break _L$12;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, is64$2, tmp_old, dst);
            const right_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
            hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _right, dst, bag, right_ty);
            if (is64$2) {
              hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, right_ty, dst, _loc$10, bag);
            }
            switch (_op$2) {
              case 1: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1962934272 : 184549376) | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 2: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -889192448 : 1258291200) | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 3: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1694467072 : 453016576) | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 4: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is_unsigned ? (is64$2 ? -1698691072 : 448792576) : is64$2 ? -1698690048 : 448793600) | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 5: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is_unsigned ? (is64$2 ? -1698691072 : 448792576) : is64$2 ? -1698690048 : 448793600) | 30 | tmp_old << 5 | dst << 16);
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1694466048 : 453017600) | dst | 960 | dst << 16 | tmp_old << 10);
                break;
              }
              case 6: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, 448798720 | (is64$2 ? -2147483648 : 0) | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 7: {
                const base = is_unsigned ? 448799744 : 448800768;
                const base64 = is64$2 ? base | -2147483648 : base;
                hackwaly$tinycc$backend$arm64$$emit32(emitter, base64 | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 8: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1979711488 : 167772160) | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 10: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1442840576 : 704643072) | dst | tmp_old << 5 | dst << 16);
                break;
              }
              case 9: {
                hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -905969664 : 1241513984) | dst | tmp_old << 5 | dst << 16);
                break;
              }
            }
            hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz$4, dst, addr$5, $0L);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp_old);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
            return;
          }
          const left_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left);
          const _bind$18 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(left_ty);
          let left_fk;
          if (_bind$18 === undefined) {
            left_fk = undefined;
          } else {
            const _Some = _bind$18;
            const _k = _Some;
            left_fk = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_k);
          }
          if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty)) {
            hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _left, dst, bag);
            hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, true, dst, 31);
          } else {
            if (left_fk === undefined) {
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _left, dst, bag, left_ty);
              const _bind$19 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, left_ty, hackwaly$tinycc$frontend$ast$$expr_loc(_left));
              let left_is64;
              if (_bind$19 === undefined) {
                left_is64 = false;
              } else {
                const _Some = _bind$19;
                const _x = _Some;
                const _size$4 = _x._0;
                left_is64 = _size$4 === 8;
              }
              hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, left_is64, dst, 31);
            } else {
              const _Some = left_fk;
              const _k = _Some;
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, _left, left_ty, _k, dst, bag);
              if (hackwaly$tinycc$backend$codegen$$float_is_double(_k)) {
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, dst);
                hackwaly$tinycc$backend$codegen$$emit_fcmp_zero(emitter, true, 0);
              } else {
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, dst);
                hackwaly$tinycc$backend$codegen$$emit_fcmp_zero(emitter, false, 0);
              }
            }
          }
          const br_short = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, moonbitlang$core$builtin$$Eq$equal$178$(_op$2, 28) ? 0 : 1);
          const right_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
          const _bind$19 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(right_ty);
          let right_fk;
          if (_bind$19 === undefined) {
            right_fk = undefined;
          } else {
            const _Some = _bind$19;
            const _k = _Some;
            right_fk = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_k);
          }
          if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(right_ty)) {
            hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _right, dst, bag);
            hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, true, dst, 31);
          } else {
            if (right_fk === undefined) {
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _right, dst, bag, right_ty);
              const _bind$20 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, right_ty, hackwaly$tinycc$frontend$ast$$expr_loc(_right));
              let right_is64;
              if (_bind$20 === undefined) {
                right_is64 = false;
              } else {
                const _Some = _bind$20;
                const _x = _Some;
                const _size$4 = _x._0;
                right_is64 = _size$4 === 8;
              }
              hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, right_is64, dst, 31);
            } else {
              const _Some = right_fk;
              const _k = _Some;
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, _right, right_ty, _k, dst, bag);
              if (hackwaly$tinycc$backend$codegen$$float_is_double(_k)) {
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, dst);
                hackwaly$tinycc$backend$codegen$$emit_fcmp_zero(emitter, true, 0);
              } else {
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, dst);
                hackwaly$tinycc$backend$codegen$$emit_fcmp_zero(emitter, false, 0);
              }
            }
          }
          if (right_fk === undefined) {
            let _try_err$6;
            _L$10: {
              _L$11: {
                const _bind$20 = hackwaly$tinycc$backend$codegen$$emit_cset_from_tok(emitter, 149, dst, false);
                if (_bind$20.$tag === 1) {
                  const _ok = _bind$20;
                  _ok._0;
                } else {
                  const _err = _bind$20;
                  const _tmp$29 = _err._0;
                  _try_err$6 = _tmp$29;
                  break _L$11;
                }
                break _L$10;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
            }
          } else {
            let _try_err$6;
            _L$10: {
              _L$11: {
                const _bind$20 = hackwaly$tinycc$backend$codegen$$emit_cset_from_fp_tok(emitter, 149, dst);
                if (_bind$20.$tag === 1) {
                  const _ok = _bind$20;
                  _ok._0;
                } else {
                  const _err = _bind$20;
                  const _tmp$29 = _err._0;
                  _try_err$6 = _tmp$29;
                  break _L$11;
                }
                break _L$10;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
            }
          }
          const br_end = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
          const short_pc = emitter.code_len << 2;
          let _try_err$6;
          _L$10: {
            _L$11: {
              const _bind$20 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_short, short_pc, moonbitlang$core$builtin$$Eq$equal$178$(_op$2, 28) ? 0 : 1);
              if (_bind$20.$tag === 1) {
                const _ok = _bind$20;
                _ok._0;
              } else {
                const _err = _bind$20;
                const _tmp$29 = _err._0;
                _try_err$6 = _tmp$29;
                break _L$11;
              }
              break _L$10;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
          }
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$builtin$$Eq$equal$178$(_op$2, 28) ? $0L : $1L);
          const end_pc = emitter.code_len << 2;
          let _try_err$7;
          _L$11: {
            const _bind$20 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, br_end, end_pc);
            if (_bind$20.$tag === 1) {
              const _ok = _bind$20;
              _ok._0;
              return;
            } else {
              const _err = _bind$20;
              const _tmp$29 = _err._0;
              _try_err$7 = _tmp$29;
              break _L$11;
            }
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
          return;
        }
        const left_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left);
        const right_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
        const _bind$18 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(left_ty);
        let left_fk;
        if (_bind$18 === undefined) {
          left_fk = undefined;
        } else {
          const _Some = _bind$18;
          const _k = _Some;
          left_fk = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_k);
        }
        const _bind$19 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(right_ty);
        let right_fk;
        if (_bind$19 === undefined) {
          right_fk = undefined;
        } else {
          const _Some = _bind$19;
          const _k = _Some;
          right_fk = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_k);
        }
        let float_kind;
        let k;
        _L$9: {
          _L$10: {
            if (left_fk === undefined) {
              if (right_fk === undefined) {
                float_kind = undefined;
              } else {
                const _Some = right_fk;
                const _k = _Some;
                k = _k;
                break _L$10;
              }
            } else {
              const _Some = left_fk;
              const _lk = _Some;
              if (right_fk === undefined) {
                k = _lk;
                break _L$10;
              } else {
                const _Some$2 = right_fk;
                const _rk = _Some$2;
                float_kind = hackwaly$tinycc$backend$codegen$$float_is_double(_lk) || hackwaly$tinycc$backend$codegen$$float_is_double(_rk) ? hackwaly$tinycc$backend$codegen$$gen_expr_int32$46$constr$47$12504 : hackwaly$tinycc$backend$codegen$$gen_expr_int32$46$constr$47$12505;
              }
            }
            break _L$9;
          }
          float_kind = k;
        }
        if (float_kind === undefined) {
        } else {
          const _Some = float_kind;
          const _k = _Some;
          let rhs_reg;
          let _try_err$6;
          _L$10: {
            _L$11: {
              const _bind$20 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$20.$tag === 1) {
                const _ok = _bind$20;
                rhs_reg = _ok._0;
              } else {
                const _err = _bind$20;
                const _tmp$29 = _err._0;
                _try_err$6 = _tmp$29;
                break _L$11;
              }
              break _L$10;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
            return undefined;
          }
          hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, _left, left_ty, _k, dst, bag);
          hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, _right, right_ty, _k, rhs_reg, bag);
          const is_double = hackwaly$tinycc$backend$codegen$$float_is_double(_k);
          if (is_double) {
            hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, dst);
            hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 1, rhs_reg);
          } else {
            hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, dst);
            hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 1, rhs_reg);
          }
          hackwaly$tinycc$backend$codegen$$emit_fcmp(emitter, is_double, 0, 1);
          let tok;
          switch (_op$2) {
            case 19: {
              tok = 148;
              break;
            }
            case 20: {
              tok = 149;
              break;
            }
            case 21: {
              tok = 156;
              break;
            }
            case 22: {
              tok = 158;
              break;
            }
            case 23: {
              tok = 159;
              break;
            }
            case 24: {
              tok = 157;
              break;
            }
            default: {
              tok = 148;
            }
          }
          let _try_err$7;
          _L$11: {
            _L$12: {
              const _bind$20 = hackwaly$tinycc$backend$codegen$$emit_cset_from_fp_tok(emitter, tok, dst);
              if (_bind$20.$tag === 1) {
                const _ok = _bind$20;
                _ok._0;
              } else {
                const _err = _bind$20;
                const _tmp$29 = _err._0;
                _try_err$7 = _tmp$29;
                break _L$12;
              }
              break _L$11;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
          }
          hackwaly$tinycc$backend$codegen$$give_reg(pool, rhs_reg);
          return undefined;
        }
        const has_ptr = hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty) || hackwaly$tinycc$backend$codegen$$type_is_pointer_like(right_ty);
        if (has_ptr) {
          _L$10: {
            switch (_op$2) {
              case 19: {
                break _L$10;
              }
              case 20: {
                break _L$10;
              }
              case 21: {
                break _L$10;
              }
              case 22: {
                break _L$10;
              }
              case 23: {
                break _L$10;
              }
              case 24: {
                break _L$10;
              }
              case 13: {
                if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty) && hackwaly$tinycc$backend$codegen$$type_is_pointer_like(right_ty)) {
                  let left_reg;
                  let _try_err$6;
                  _L$11: {
                    _L$12: {
                      const _bind$20 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                      if (_bind$20.$tag === 1) {
                        const _ok = _bind$20;
                        left_reg = _ok._0;
                      } else {
                        const _err = _bind$20;
                        const _tmp$29 = _err._0;
                        _try_err$6 = _tmp$29;
                        break _L$12;
                      }
                      break _L$11;
                    }
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
                    return undefined;
                  }
                  hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _left, left_reg, bag);
                  hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _right, dst, bag);
                  const _bind$20 = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(left_ty);
                  let elem_ty$2;
                  if (_bind$20 === undefined) {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: pointer arithmetic missing element type");
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, left_reg);
                    return undefined;
                  } else {
                    const _Some = _bind$20;
                    elem_ty$2 = _Some;
                  }
                  const _bind$21 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, elem_ty$2, _loc$10);
                  let _bind$22;
                  if (_bind$21 === undefined) {
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, left_reg);
                    return undefined;
                  } else {
                    const _Some = _bind$21;
                    _bind$22 = _Some;
                  }
                  const _elem_size = _bind$22._0;
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, -889192448 | dst | left_reg << 5 | dst << 16);
                  if (_elem_size !== 1) {
                    let scale;
                    let _try_err$7;
                    _L$12: {
                      _L$13: {
                        const _bind$23 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                        if (_bind$23.$tag === 1) {
                          const _ok = _bind$23;
                          scale = _ok._0;
                        } else {
                          const _err = _bind$23;
                          const _tmp$29 = _err._0;
                          _try_err$7 = _tmp$29;
                          break _L$13;
                        }
                        break _L$12;
                      }
                      hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
                      hackwaly$tinycc$backend$codegen$$give_reg(pool, left_reg);
                      return undefined;
                    }
                    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(_elem_size));
                    hackwaly$tinycc$backend$arm64$$emit32(emitter, -1698690048 | dst | dst << 5 | scale << 16);
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
                  }
                  hackwaly$tinycc$backend$codegen$$emit_mov(emitter, false, dst, dst);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, left_reg);
                  return undefined;
                } else {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: pointer +/- pointer not supported yet");
                  return undefined;
                }
              }
              default: {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: unsupported pointer expression");
                return undefined;
              }
            }
          }
          let tmp;
          let _try_err$6;
          _L$11: {
            _L$12: {
              const _bind$20 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$20.$tag === 1) {
                const _ok = _bind$20;
                tmp = _ok._0;
              } else {
                const _err = _bind$20;
                const _tmp$29 = _err._0;
                _try_err$6 = _tmp$29;
                break _L$12;
              }
              break _L$11;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
            return undefined;
          }
          if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty)) {
            hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _left, tmp, bag);
          } else {
            hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _left, tmp, bag, left_ty);
            hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, left_ty, tmp, _loc$10, bag);
          }
          if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(right_ty)) {
            hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _right, dst, bag);
          } else {
            hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _right, dst, bag, right_ty);
            hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, right_ty, dst, _loc$10, bag);
          }
          hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, true, tmp, dst);
          let tok;
          switch (_op$2) {
            case 19: {
              tok = 148;
              break;
            }
            case 20: {
              tok = 149;
              break;
            }
            case 21: {
              tok = 156;
              break;
            }
            case 22: {
              tok = 158;
              break;
            }
            case 23: {
              tok = 159;
              break;
            }
            case 24: {
              tok = 157;
              break;
            }
            default: {
              tok = 148;
            }
          }
          let _try_err$7;
          _L$12: {
            _L$13: {
              const _bind$20 = hackwaly$tinycc$backend$codegen$$emit_cset_from_tok(emitter, tok, dst, true);
              if (_bind$20.$tag === 1) {
                const _ok = _bind$20;
                _ok._0;
              } else {
                const _err = _bind$20;
                const _tmp$29 = _err._0;
                _try_err$7 = _tmp$29;
                break _L$13;
              }
              break _L$12;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
          }
          hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
          return undefined;
        }
        hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _left, dst, bag, left_ty);
        let tmp;
        let _try_err$6;
        _L$10: {
          _L$11: {
            const _bind$20 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$20.$tag === 1) {
              const _ok = _bind$20;
              tmp = _ok._0;
            } else {
              const _err = _bind$20;
              const _tmp$29 = _err._0;
              _try_err$6 = _tmp$29;
              break _L$11;
            }
            break _L$10;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
          return undefined;
        }
        hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, tmp, dst);
        hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _right, dst, bag, right_ty);
        _L$11: {
          _L$12: {
            _L$13: {
              _L$14: {
                switch (_op$2) {
                  case 19: {
                    break _L$14;
                  }
                  case 20: {
                    break _L$14;
                  }
                  case 21: {
                    break _L$14;
                  }
                  case 22: {
                    break _L$14;
                  }
                  case 23: {
                    break _L$14;
                  }
                  case 24: {
                    break _L$14;
                  }
                  case 17: {
                    break _L$12;
                  }
                  case 18: {
                    break _L$12;
                  }
                  default: {
                    let result_ty;
                    if (expr_ty$2 === undefined) {
                      result_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
                    } else {
                      const _Some = expr_ty$2;
                      result_ty = _Some;
                    }
                    const _bind$20 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, result_ty, _loc$10);
                    let _bind$21;
                    if (_bind$20 === undefined) {
                      hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                      return undefined;
                    } else {
                      const _Some = _bind$20;
                      _bind$21 = _Some;
                    }
                    const _res_size = _bind$21._0;
                    const _res_signed = _bind$21._1;
                    const is64$2 = _res_size === 8;
                    const is_unsigned = !_res_signed;
                    hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, left_ty, result_ty, tmp, _loc$10, bag);
                    hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, right_ty, result_ty, dst, _loc$10, bag);
                    switch (_op$2) {
                      case 12: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1962934272 : 184549376) | dst | tmp << 5 | dst << 16);
                        break;
                      }
                      case 13: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -889192448 : 1258291200) | dst | tmp << 5 | dst << 16);
                        break;
                      }
                      case 14: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1694467072 : 453016576) | dst | tmp << 5 | dst << 16);
                        break;
                      }
                      case 15: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is_unsigned ? (is64$2 ? -1698691072 : 448792576) : is64$2 ? -1698690048 : 448793600) | dst | tmp << 5 | dst << 16);
                        break;
                      }
                      case 16: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is_unsigned ? (is64$2 ? -1698691072 : 448792576) : is64$2 ? -1698690048 : 448793600) | 30 | tmp << 5 | dst << 16);
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1694466048 : 453017600) | dst | 960 | dst << 16 | tmp << 10);
                        break;
                      }
                      case 25: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1979711488 : 167772160) | dst | tmp << 5 | dst << 16);
                        break;
                      }
                      case 27: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -1442840576 : 704643072) | dst | tmp << 5 | dst << 16);
                        break;
                      }
                      case 26: {
                        hackwaly$tinycc$backend$arm64$$emit32(emitter, (is64$2 ? -905969664 : 1241513984) | dst | tmp << 5 | dst << 16);
                        break;
                      }
                    }
                  }
                }
                break _L$13;
              }
              const common = hackwaly$tinycc$sem$$common_int_type(alloc.sem, left_ty, right_ty);
              const _bind$20 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, common, _loc$10);
              let _bind$21;
              if (_bind$20 === undefined) {
                hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                return undefined;
              } else {
                const _Some = _bind$20;
                _bind$21 = _Some;
              }
              const _cmp_size = _bind$21._0;
              const _cmp_signed = _bind$21._1;
              const cmp_is64 = _cmp_size === 8;
              const cmp_unsigned = !_cmp_signed;
              hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, left_ty, common, tmp, _loc$10, bag);
              hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, right_ty, common, dst, _loc$10, bag);
              hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, cmp_is64, tmp, dst);
              let tok;
              switch (_op$2) {
                case 19: {
                  tok = 148;
                  break;
                }
                case 20: {
                  tok = 149;
                  break;
                }
                case 21: {
                  tok = 156;
                  break;
                }
                case 22: {
                  tok = 158;
                  break;
                }
                case 23: {
                  tok = 159;
                  break;
                }
                case 24: {
                  tok = 157;
                  break;
                }
                default: {
                  tok = 148;
                }
              }
              let _try_err$7;
              _L$15: {
                _L$16: {
                  const _bind$22 = hackwaly$tinycc$backend$codegen$$emit_cset_from_tok(emitter, tok, dst, cmp_unsigned);
                  if (_bind$22.$tag === 1) {
                    const _ok = _bind$22;
                    _ok._0;
                  } else {
                    const _err = _bind$22;
                    const _tmp$29 = _err._0;
                    _try_err$7 = _tmp$29;
                    break _L$16;
                  }
                  break _L$15;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
              }
            }
            break _L$11;
          }
          let result_ty;
          if (expr_ty$2 === undefined) {
            result_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
          } else {
            const _Some = expr_ty$2;
            result_ty = _Some;
          }
          const _bind$20 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, result_ty, _loc$10);
          let _bind$21;
          if (_bind$20 === undefined) {
            hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
            return undefined;
          } else {
            const _Some = _bind$20;
            _bind$21 = _Some;
          }
          const _res_size = _bind$21._0;
          const _res_signed = _bind$21._1;
          const is64$2 = _res_size === 8;
          hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, left_ty, result_ty, tmp, _loc$10, bag);
          hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, right_ty, dst, _loc$10, bag);
          const _bind$22 = hackwaly$tinycc$frontend$ast$$const_i64_from_expr(_right);
          if (_bind$22 === undefined) {
            const base_raw = moonbitlang$core$builtin$$Eq$equal$178$(_op$2, 17) ? 448798720 : _res_signed ? 448800768 : 448799744;
            const base = is64$2 ? base_raw | -2147483648 : base_raw;
            hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | tmp << 5 | dst << 16);
          } else {
            const _Some = _bind$22;
            const _v = _Some;
            const shift_tok = moonbitlang$core$builtin$$Eq$equal$178$(_op$2, 17) ? 60 : _res_signed ? 62 : 139;
            hackwaly$tinycc$backend$arm64$$arm64_gen_opic(emitter, shift_tok, is64$2 ? 1 : 0, false, _v, dst, tmp);
          }
        }
        hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
        return;
      }
      case 19: {
        const _Call = expr$2;
        const _callee = _Call._0;
        const _args = _Call._1;
        const _loc$11 = _Call._3;
        hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, _callee, _args, _loc$11, bag);
        if (dst !== 0) {
          hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, 0);
          return;
        } else {
          return;
        }
      }
      case 13: {
        const _SizeofExpr = expr$2;
        const _inner$2 = _SizeofExpr._0;
        const _loc$12 = _SizeofExpr._2;
        if (_inner$2.$tag === 4) {
          const _Ident$2 = _inner$2;
          const _name$3 = _Ident$2._0;
          const _id$3 = _Ident$2._1;
          const _bind$20 = hackwaly$tinycc$backend$codegen$$lookup_local(alloc, _name$3, _id$3);
          if (_bind$20 === undefined) {
          } else {
            const _Some = _bind$20;
            const _slot = _Some;
            const _bind$21 = hackwaly$tinycc$sem$$strip_top_qualifiers(_slot.ty);
            if (_bind$21.$tag === 5) {
              const _Array = _bind$21;
              const _x = _Array._1;
              if (_x === undefined) {
                const _x$2 = _Array._2;
                if (_x$2 === undefined) {
                } else {
                  const _bind$22 = _slot.vla_size_offset;
                  if (_bind$22 === undefined) {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc$12, "codegen: missing VLA byte size slot");
                  } else {
                    const _Some$2 = _bind$22;
                    const _off = _Some$2;
                    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, 29, moonbitlang$core$int$$Int$to_int64(_off));
                    return undefined;
                  }
                }
              }
            }
          }
        }
        const ty$2 = hackwaly$tinycc$sem$$type_for_sizeof(alloc.sem, _inner$2);
        _L$12: {
          const _bind$20 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty$2);
          if (_bind$20.$tag === 5) {
            const _Array = _bind$20;
            const _elem_ty = _Array._0;
            const _x = _Array._1;
            if (_x === undefined) {
              const _x$2 = _Array._2;
              if (_x$2 === undefined) {
                break _L$12;
              } else {
                const _Some = _x$2;
                const _expr = _Some;
                hackwaly$tinycc$backend$codegen$$gen_vla_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, _elem_ty, _expr, dst, _loc$12, bag);
                return;
              }
            } else {
              break _L$12;
            }
          } else {
            break _L$12;
          }
        }
        const _bind$20 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ty$2, _loc$12);
        if (_bind$20 === undefined) {
          return;
        } else {
          const _Some = _bind$20;
          const _x = _Some;
          const _size$4 = _x._0;
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(_size$4));
          return;
        }
      }
      case 14: {
        const _SizeofType = expr$2;
        const _ty$4 = _SizeofType._0;
        const _loc$13 = _SizeofType._2;
        _L$13: {
          const _bind$21 = hackwaly$tinycc$sem$$strip_top_qualifiers(_ty$4);
          if (_bind$21.$tag === 5) {
            const _Array = _bind$21;
            const _elem_ty = _Array._0;
            const _x = _Array._1;
            if (_x === undefined) {
              const _x$2 = _Array._2;
              if (_x$2 === undefined) {
                break _L$13;
              } else {
                const _Some = _x$2;
                const _expr = _Some;
                hackwaly$tinycc$backend$codegen$$gen_vla_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, _elem_ty, _expr, dst, _loc$13, bag);
                return;
              }
            } else {
              break _L$13;
            }
          } else {
            break _L$13;
          }
        }
        const _bind$21 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, _ty$4, _loc$13);
        if (_bind$21 === undefined) {
          return;
        } else {
          const _Some = _bind$21;
          const _x = _Some;
          const _size$4 = _x._0;
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(_size$4));
          return;
        }
      }
      case 10: {
        const _Cast = expr$2;
        const _to_ty = _Cast._0;
        const _inner$3 = _Cast._1;
        const _cast_loc = _Cast._3;
        const from_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _inner$3);
        const _bind$22 = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(_to_ty);
        const _bind$23 = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(from_ty);
        if (_bind$22.$tag === 2) {
          const _Int = _bind$22;
          const _to_kind = _Int._0;
          const _to_unsigned = _Int._1;
          if (_bind$23.$tag === 3) {
            const _Float = _bind$23;
            const _from_kind = _Float._0;
            if (!hackwaly$tinycc$backend$codegen$$float_kind_supported(_from_kind)) {
              hackwaly$tinycc$support$diag$$add_error(bag, _cast_loc, "codegen: unsupported float type");
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _inner$3, dst, bag, from_ty);
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, _inner$3, from_ty, _from_kind, dst, bag);
            if (moonbitlang$core$builtin$$Eq$equal$83$(_from_kind, 1)) {
              hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, dst);
            } else {
              hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, dst);
            }
            let inst = 506986496;
            if (_to_unsigned) {
              inst = inst | 65536;
            }
            if (hackwaly$tinycc$sem$$int_size(_to_kind) === 8) {
              inst = inst | -2147483648;
            }
            if (moonbitlang$core$builtin$$Eq$not_equal$82$(_from_kind, 0)) {
              inst = inst | 4194304;
            }
            hackwaly$tinycc$backend$arm64$$emit32(emitter, inst | dst | 0);
            hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, _to_ty, _to_ty, dst, _cast_loc, bag);
            return;
          } else {
            if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(from_ty)) {
              hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _inner$3, dst, bag);
            } else {
              hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _inner$3, dst, bag, from_ty);
            }
            hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, from_ty, _to_ty, dst, _cast_loc, bag);
            return;
          }
        } else {
          _tmp$27 = _inner$3;
          _tmp$28 = from_ty;
          continue _L;
        }
      }
      case 18: {
        const _Conditional = expr$2;
        const _cond = _Conditional._0;
        const _then_expr = _Conditional._1;
        const _else_expr = _Conditional._2;
        const _loc$14 = _Conditional._4;
        let result_ty;
        if (expr_ty$2 === undefined) {
          result_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
        } else {
          const _Some = expr_ty$2;
          result_ty = _Some;
        }
        const then_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _then_expr);
        const else_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _else_expr);
        hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond, bag);
        const br_else = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
        hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _then_expr, dst, bag, then_ty);
        hackwaly$tinycc$backend$codegen$$emit_cast_value(emitter, alloc.sem, then_ty, result_ty, dst, _loc$14, bag);
        const br_end = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
        const else_pc = emitter.code_len << 2;
        let _try_err$7;
        _L$14: {
          _L$15: {
            const _bind$24 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_else, else_pc, 0);
            if (_bind$24.$tag === 1) {
              const _ok = _bind$24;
              _ok._0;
            } else {
              const _err = _bind$24;
              const _tmp$29 = _err._0;
              _try_err$7 = _tmp$29;
              break _L$15;
            }
            break _L$14;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$14, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
        }
        hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _else_expr, dst, bag, else_ty);
        hackwaly$tinycc$backend$codegen$$emit_cast_value(emitter, alloc.sem, else_ty, result_ty, dst, _loc$14, bag);
        const end_pc = emitter.code_len << 2;
        let _try_err$8;
        _L$15: {
          const _bind$24 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, br_end, end_pc);
          if (_bind$24.$tag === 1) {
            const _ok = _bind$24;
            _ok._0;
            return;
          } else {
            const _err = _bind$24;
            const _tmp$29 = _err._0;
            _try_err$8 = _tmp$29;
            break _L$15;
          }
        }
        hackwaly$tinycc$support$diag$$add_error(bag, _loc$14, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$8));
        return;
      }
      case 3: {
        const _StringLit = expr$2;
        const _value$3 = _StringLit._0;
        const sym = hackwaly$tinycc$backend$codegen$$cstring_sym_or_add(cstrings, syms, _value$3);
        const adrp_off = emitter.code_len << 2;
        hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, adrp_off, 275, $0L);
        hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$($2415919104L, moonbitlang$core$int$$Int$to_uint64(dst))));
        const add_off = emitter.code_len << 2;
        hackwaly$tinycc$backend$arm64$$greloca(emitter, sym, add_off, 277, $0L);
        hackwaly$tinycc$backend$arm64$$emit32(emitter, moonbitlang$core$uint64$$UInt64$to_uint(moonbitlang$core$builtin$$BitOr$lor$6$(moonbitlang$core$builtin$$BitOr$lor$6$($2432696320L, moonbitlang$core$int$$Int$to_uint64(dst)), moonbitlang$core$builtin$$Shl$shl$6$(moonbitlang$core$int$$Int$to_uint64(dst), 5))));
        return;
      }
      default: {
        hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(expr$2), "codegen: unsupported expression");
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$gen_builtin_va_arg_load(emitter, alloc, syms, pool, cstrings, list_expr, ty, dst, bag) {
  const loc = hackwaly$tinycc$frontend$ast$$expr_loc(list_expr);
  let ap_addr;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        ap_addr = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return false;
  }
  hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, list_expr, ap_addr, bag);
  let cur;
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        cur = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$2 = _tmp$27;
        break _L$3;
      }
      break _L$2;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
    hackwaly$tinycc$backend$codegen$$give_reg(pool, ap_addr);
    return false;
  }
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, cur, ap_addr, $0L);
  const base_ty = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(base_ty);
  let _bind$2;
  if (_bind === undefined) {
    if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(base_ty)) {
      _bind$2 = hackwaly$tinycc$backend$codegen$$gen_builtin_va_arg_load$46$tuple$47$13056;
    } else {
      const _bind$3 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, base_ty, loc);
      if (_bind$3 === undefined) {
        hackwaly$tinycc$backend$codegen$$give_reg(pool, cur);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, ap_addr);
        return false;
      } else {
        const _Some = _bind$3;
        _bind$2 = _Some;
      }
    }
  } else {
    const _Some = _bind;
    const _k = _Some;
    const sz = moonbitlang$core$builtin$$Eq$equal$83$(_k, 1) ? 8 : 4;
    _bind$2 = { _0: sz, _1: false };
  }
  const _size = _bind$2._0;
  const _signed = _bind$2._1;
  const _bind$3 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
  let load_sz;
  if (_bind$3 === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported va_arg size");
    hackwaly$tinycc$backend$codegen$$give_reg(pool, cur);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, ap_addr);
    return false;
  } else {
    const _Some = _bind$3;
    load_sz = _Some;
  }
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed, load_sz, dst, cur, $0L);
  const bump = hackwaly$tinycc$backend$codegen$$align_up(_size, 8);
  hackwaly$tinycc$backend$codegen$$arm64_add_imm(emitter, cur, cur, bump);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, cur, ap_addr, $0L);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, cur);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, ap_addr);
  return true;
}
function hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, expr, dst, bag) {
  _L: {
    switch (expr.$tag) {
      case 4: {
        const _Ident = expr;
        const _name = _Ident._0;
        const _id = _Ident._1;
        const _loc = _Ident._3;
        if (_name === "__func__" || (_name === "__FUNCTION__" || _name === "__PRETTY_FUNCTION__")) {
          if (hackwaly$tinycc$backend$codegen$$gen_func_name_addr(emitter, syms, cstrings, alloc, dst, _loc, bag)) {
            return undefined;
          }
        }
        const _bind = hackwaly$tinycc$backend$codegen$$lookup_local(alloc, _name, _id);
        if (_bind === undefined) {
          const _bind$2 = hackwaly$tinycc$backend$codegen$$lookup_static_local(alloc, _id);
          let sym;
          if (_bind$2 === undefined) {
            sym = hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, _name, _id);
          } else {
            const _Some = _bind$2;
            const _info = _Some;
            sym = hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, _info);
          }
          hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, dst);
          return;
        } else {
          const _Some = _bind;
          const _slot = _Some;
          if (_slot.byref) {
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, 29, moonbitlang$core$int$$Int$to_int64(_slot.offset));
            return;
          } else {
            _L$2: {
              const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(_slot.ty);
              if (_bind$2.$tag === 5) {
                const _Array = _bind$2;
                const _x = _Array._1;
                if (_x === undefined) {
                  const _x$2 = _Array._2;
                  if (_x$2 === undefined) {
                    break _L$2;
                  } else {
                    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, 29, moonbitlang$core$int$$Int$to_int64(_slot.offset));
                    return;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            }
            hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, dst, _slot.offset, _loc, bag);
            return;
          }
        }
      }
      case 11: {
        const _CompoundLiteral = expr;
        const _ty = _CompoundLiteral._0;
        const _init = _CompoundLiteral._1;
        const _node_id = _CompoundLiteral._2;
        const _loc$2 = _CompoundLiteral._3;
        hackwaly$tinycc$backend$codegen$$gen_compound_literal_addr_with_type(emitter, alloc, syms, pool, cstrings, _ty, _init, _loc$2, _node_id, dst, bag);
        return;
      }
      case 12: {
        const _StmtExpr = expr;
        const _stmts = _StmtExpr._0;
        const _loc$3 = _StmtExpr._2;
        let last_is_expr = false;
        if (_stmts.length > 0) {
          const _bind$2 = moonbitlang$core$array$$Array$at$49$(_stmts, _stmts.length - 1 | 0);
          if (_bind$2.$tag === 15) {
            last_is_expr = true;
          }
        }
        hackwaly$tinycc$backend$codegen$$gen_stmt_expr_with(emitter, alloc, syms, pool, cstrings, _stmts, dst, true, _loc$3, bag, (expr$2, dst$2) => {
          hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, expr$2, dst$2, bag);
        });
        if (!last_is_expr) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, "codegen: statement expression is not assignable");
          return;
        } else {
          return;
        }
      }
      case 9: {
        const _Unary = expr;
        const _x = _Unary._0;
        if (_x === 5) {
          const _inner = _Unary._1;
          hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _inner, dst, bag);
          return;
        } else {
          break _L;
        }
      }
      case 20: {
        const _Index = expr;
        const _base = _Index._0;
        const _index = _Index._1;
        const _loc$4 = _Index._3;
        hackwaly$tinycc$backend$codegen$$gen_index_addr_with_elem_type(emitter, alloc, syms, pool, cstrings, _base, _index, dst, _loc$4, bag);
        return;
      }
      case 21: {
        const _Member = expr;
        const _base$2 = _Member._0;
        const _name$2 = _Member._1;
        const _id$2 = _Member._2;
        const _is_arrow = _Member._3;
        const _loc$5 = _Member._5;
        const base_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _base$2);
        if (_is_arrow) {
          hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _base$2, dst, bag);
        } else {
          if (!hackwaly$tinycc$frontend$ast$$expr_is_lvalue_simple(_base$2)) {
            _L$2: {
              _L$3: {
                const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(base_ty);
                switch (_bind$2.$tag) {
                  case 6: {
                    break _L$3;
                  }
                  case 7: {
                    break _L$3;
                  }
                  default: {
                    hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _base$2, dst, bag);
                  }
                }
                break _L$2;
              }
              const _bind$2 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, base_ty, _loc$5);
              if (_bind$2 === undefined) {
              } else {
                const _Some = _bind$2;
                const _x$2 = _Some;
                const _size = _x$2._0;
                const _bind$3 = alloc.agg_temp_offset;
                if (_bind$3 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, "codegen: missing aggregate temp slot");
                } else {
                  const _Some$2 = _bind$3;
                  const _tmp_off = _Some$2;
                  if (_size > alloc.agg_temp_size) {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, "codegen: aggregate temp too small");
                    return undefined;
                  }
                  hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _base$2, 29, _tmp_off, base_ty, _loc$5, bag);
                  hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, dst, _tmp_off, _loc$5, bag);
                }
              }
            }
          } else {
            hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _base$2, dst, bag);
          }
        }
        let record_ty;
        if (_is_arrow) {
          const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(base_ty);
          if (_bind$2.$tag === 4) {
            const _Pointer = _bind$2;
            record_ty = _Pointer._0;
          } else {
            record_ty = base_ty;
          }
        } else {
          record_ty = base_ty;
        }
        const _bind$2 = hackwaly$tinycc$backend$codegen$$record_field_access_info(alloc.sem, record_ty, _name$2, _id$2, _loc$5);
        let off;
        if (_bind$2 === undefined) {
          off = 0;
        } else {
          const _Some = _bind$2;
          const _info = _Some;
          off = _info.offset;
        }
        if (off !== 0) {
          if (off >= 0 && off <= 4095) {
            hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862270976 | dst | dst << 5 | off << 10);
            return;
          } else {
            let tmp;
            let _try_err;
            _L$2: {
              _L$3: {
                const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$3.$tag === 1) {
                  const _ok = _bind$3;
                  tmp = _ok._0;
                } else {
                  const _err = _bind$3;
                  const _tmp$27 = _err._0;
                  _try_err = _tmp$27;
                  break _L$3;
                }
                break _L$2;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
              return undefined;
            }
            const imm = off < 0 ? -off | 0 : off;
            hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, moonbitlang$core$int$$Int$to_uint64(imm));
            const base = off < 0 ? -889192448 : -1962934272;
            hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | dst << 5 | tmp << 16);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
            return;
          }
        } else {
          return;
        }
      }
      default: {
        break _L;
      }
    }
  }
  hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(expr), "codegen: unsupported lvalue for now");
}
function hackwaly$tinycc$backend$codegen$$gen_compound_literal_addr_with_type(emitter, alloc, syms, pool, cstrings, ty, init, loc, node_id, dst, bag) {
  const key = hackwaly$tinycc$sem$$compound_literal_key(node_id);
  const _bind = moonbitlang$core$hashmap$$HashMap$get$173$(alloc.compound_literal_slots, key);
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: missing compound literal slot");
    return undefined;
  } else {
    const _Some = _bind;
    const _off = _Some;
    const resolved = hackwaly$tinycc$sem$$compound_literal_type(alloc.sem, ty, init, loc, node_id);
    const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$167$(alloc.sem.compound_literal_sizes, key);
    let size_align;
    if (_bind$2 === undefined) {
      size_align = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, resolved, loc);
    } else {
      const _Some$2 = _bind$2;
      const _value = _Some$2;
      size_align = _value;
    }
    if (size_align === undefined) {
    } else {
      const _Some$2 = size_align;
      const _x = _Some$2;
      const _size = _x._0;
      if (_size > 0) {
        hackwaly$tinycc$backend$codegen$$emit_zero_bytes(emitter, 29, _off, _size);
      }
    }
    hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, 29, _off, resolved, init, bag);
    hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, dst, _off, loc, bag);
    return resolved;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, base_reg, base_off, ty, init, bag) {
  let _tmp$27 = base_off;
  let _tmp$28 = ty;
  let _tmp$29 = init;
  _L: while (true) {
    const base_off$2 = _tmp$27;
    const ty$2 = _tmp$28;
    const init$2 = _tmp$29;
    if (init$2.$tag === 0) {
      const _Expr = init$2;
      const _expr = _Expr._0;
      const _loc = _Expr._1;
      _L$2: {
        const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty$2);
        switch (_bind.$tag) {
          case 5: {
            const _Array = _bind;
            const _elem = _Array._0;
            _L$3: {
              const _bind$2 = hackwaly$tinycc$sem$$try_eval_int_const(alloc.sem, _expr);
              if (_bind$2 === undefined) {
                break _L$3;
              } else {
                const _Some = _bind$2;
                const _x = _Some;
                if (_x === 0) {
                  const _bind$3 = hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(alloc.sem, ty$2, _loc);
                  if (_bind$3 === undefined) {
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: incomplete array type");
                    return;
                  } else {
                    const _Some$2 = _bind$3;
                    const _n = _Some$2;
                    const _bind$4 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, _elem, _loc);
                    let _bind$5;
                    if (_bind$4 === undefined) {
                      return undefined;
                    } else {
                      const _Some$3 = _bind$4;
                      _bind$5 = _Some$3;
                    }
                    const _elem_size = _bind$5._0;
                    if (_elem_size > 0) {
                      hackwaly$tinycc$backend$codegen$$emit_zero_bytes(emitter, base_reg, base_off$2, Math.imul(_n, _elem_size) | 0);
                      return;
                    } else {
                      return;
                    }
                  }
                } else {
                  break _L$3;
                }
              }
            }
            if (_expr.$tag === 3) {
              const _StringLit = _expr;
              const _value = _StringLit._0;
              const _length = _StringLit._1;
              if (hackwaly$tinycc$sem$$is_char_type(_elem)) {
                const _bind$2 = hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(alloc.sem, ty$2, _loc);
                if (_bind$2 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: incomplete array type");
                  return;
                } else {
                  const _Some = _bind$2;
                  const _n = _Some;
                  const copy_len = _length > _n ? _n : _length;
                  hackwaly$tinycc$backend$codegen$$gen_string_init_to_addr(emitter, syms, pool, cstrings, _value, copy_len, base_reg, base_off$2, bag, _loc);
                  return;
                }
              } else {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: string initializer for non-char array");
                return;
              }
            } else {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: scalar initializer for array not supported");
              return;
            }
          }
          case 6: {
            break _L$2;
          }
          case 7: {
            break _L$2;
          }
          default: {
            const expr_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _expr);
            hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, _expr, expr_ty, 0, bag);
            hackwaly$tinycc$backend$codegen$$emit_cast_value(emitter, alloc.sem, expr_ty, ty$2, 0, _loc, bag);
            hackwaly$tinycc$backend$codegen$$emit_store_scalar_at(emitter, alloc.sem, ty$2, 0, base_reg, base_off$2, _loc, bag);
            return;
          }
        }
      }
      const _bind = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ty$2, _loc);
      let _bind$2;
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        _bind$2 = _Some;
      }
      const _size = _bind$2._0;
      if (_size <= 0) {
        return undefined;
      }
      hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, _expr, base_reg, base_off$2, ty$2, _loc, bag);
      return;
    } else {
      const _List = init$2;
      const _items = _List._0;
      const _loc = _List._1;
      const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty$2);
      switch (_bind.$tag) {
        case 5: {
          const _Array = _bind;
          const _elem_ty = _Array._0;
          const _bind$2 = hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(alloc.sem, ty$2, _loc);
          let n;
          if (_bind$2 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: incomplete array type");
            return undefined;
          } else {
            const _Some = _bind$2;
            n = _Some;
          }
          const _bind$3 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, _elem_ty, _loc);
          let _bind$4;
          if (_bind$3 === undefined) {
            return undefined;
          } else {
            const _Some = _bind$3;
            _bind$4 = _Some;
          }
          const _elem_size = _bind$4._0;
          let next_index = 0;
          const _len = _items.length;
          let _tmp$30 = 0;
          while (true) {
            const _i = _tmp$30;
            if (_i < _len) {
              _L$2: {
                const item = _items[_i];
                let idx = next_index;
                let has_index = false;
                let range_pos = -1;
                let range_start = undefined;
                let range_end = undefined;
                let range_loc = item.loc;
                if (item.designators.length > 0) {
                  const _bind$5 = moonbitlang$core$array$$Array$at$37$(item.designators, 0);
                  switch (_bind$5.$tag) {
                    case 0: {
                      const _Index = _bind$5;
                      const _expr = _Index._0;
                      const _des_loc = _Index._1;
                      const _bind$6 = hackwaly$tinycc$sem$$const_int_from_expr(alloc.sem, _expr, _des_loc);
                      if (_bind$6 === undefined) {
                      } else {
                        const _Some = _bind$6;
                        const _v = _Some;
                        idx = _v;
                        has_index = true;
                        if (idx < 0 || idx >= n) {
                          hackwaly$tinycc$support$diag$$add_error(bag, _des_loc, "codegen: array designator out of bounds");
                        }
                      }
                      break;
                    }
                    case 1: {
                      const _IndexRange = _bind$5;
                      const _start = _IndexRange._0;
                      const _end = _IndexRange._1;
                      const _des_loc$2 = _IndexRange._2;
                      _L$3: {
                        _L$4: {
                          const _bind$7 = hackwaly$tinycc$sem$$const_int_from_expr(alloc.sem, _start, _des_loc$2);
                          const _bind$8 = hackwaly$tinycc$sem$$const_int_from_expr(alloc.sem, _end, _des_loc$2);
                          if (_bind$7 === undefined) {
                            break _L$4;
                          } else {
                            const _Some = _bind$7;
                            const _start_val = _Some;
                            if (_bind$8 === undefined) {
                              break _L$4;
                            } else {
                              const _Some$2 = _bind$8;
                              const _end_val = _Some$2;
                              idx = _start_val;
                              has_index = true;
                              range_start = _start_val;
                              range_end = _end_val;
                              range_loc = _des_loc$2;
                              if (idx < 0 || idx >= n) {
                                hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$2, "codegen: array designator out of bounds");
                              }
                            }
                          }
                          break _L$3;
                        }
                        hackwaly$tinycc$support$diag$$add_error(bag, _des_loc$2, "codegen: array designator must be constant");
                      }
                      break;
                    }
                  }
                  let i = 0;
                  while (true) {
                    if (i < item.designators.length) {
                      const _bind$7 = moonbitlang$core$array$$Array$at$37$(item.designators, i);
                      if (_bind$7.$tag === 1) {
                        const _IndexRange$2 = _bind$7;
                        const _start$2 = _IndexRange$2._0;
                        const _end$2 = _IndexRange$2._1;
                        const _des_loc$3 = _IndexRange$2._2;
                        range_pos = i;
                        range_loc = _des_loc$3;
                        const _bind$8 = range_start;
                        if (_bind$8 === undefined) {
                          range_start = hackwaly$tinycc$sem$$const_int_from_expr(alloc.sem, _start$2, _des_loc$3);
                          range_end = hackwaly$tinycc$sem$$const_int_from_expr(alloc.sem, _end$2, _des_loc$3);
                        }
                        break;
                      }
                      i = i + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                }
                if (range_pos >= 0) {
                  if (range_pos !== (item.designators.length - 1 | 0)) {
                    hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array range designator must be last");
                  } else {
                    _L$3: {
                      _L$4: {
                        const _bind$5 = range_start;
                        const _bind$6 = range_end;
                        if (_bind$5 === undefined) {
                          break _L$4;
                        } else {
                          const _Some = _bind$5;
                          const _start_idx = _Some;
                          if (_bind$6 === undefined) {
                            break _L$4;
                          } else {
                            const _Some$2 = _bind$6;
                            const _end_idx = _Some$2;
                            if (_end_idx < _start_idx) {
                              hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array designator range is empty");
                            } else {
                              if (range_pos === 0 && (_start_idx < 0 || (_end_idx < 0 || (_start_idx >= n || _end_idx >= n)))) {
                                hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array designator out of bounds");
                              }
                              let cur = _start_idx;
                              while (true) {
                                if (cur <= _end_idx) {
                                  if (range_pos === 0 && (cur < 0 || cur >= n)) {
                                    cur = cur + 1 | 0;
                                    continue;
                                  }
                                  const designators = hackwaly$tinycc$backend$codegen$$designators_with_range_index(item.designators, cur);
                                  const _bind$7 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_offset_type(alloc.sem, ty$2, designators, item.loc, bag);
                                  let _bind$8;
                                  if (_bind$7 === undefined) {
                                    _bind$8 = { _0: _elem_ty, _1: Math.imul(cur, _elem_size) | 0 };
                                  } else {
                                    const _Some$3 = _bind$7;
                                    const _x = _Some$3;
                                    const _t = _x._0;
                                    const _o = _x._1;
                                    _bind$8 = { _0: _t, _1: _o };
                                  }
                                  const _target_ty = _bind$8._0;
                                  const _rel_off = _bind$8._1;
                                  hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, base_reg, base_off$2 + _rel_off | 0, _target_ty, item.value, bag);
                                  cur = cur + 1 | 0;
                                  continue;
                                } else {
                                  break;
                                }
                              }
                            }
                          }
                        }
                        break _L$3;
                      }
                      hackwaly$tinycc$support$diag$$add_error(bag, range_loc, "codegen: array designator must be constant");
                    }
                  }
                  if (range_pos === 0) {
                    const _bind$5 = range_end;
                    if (_bind$5 === undefined) {
                    } else {
                      const _Some = _bind$5;
                      const _end_idx = _Some;
                      if (_end_idx >= 0) {
                        next_index = _end_idx + 1 | 0;
                      }
                    }
                  } else {
                    if (has_index) {
                      if (idx >= 0) {
                        next_index = idx + 1 | 0;
                      }
                    } else {
                      next_index = next_index + 1 | 0;
                    }
                  }
                  break _L$2;
                }
                if (!has_index) {
                  if (idx >= n) {
                    break _L$2;
                  }
                }
                let _bind$5;
                if (item.designators.length > 0) {
                  const _bind$6 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_offset_type(alloc.sem, ty$2, item.designators, item.loc, bag);
                  if (_bind$6 === undefined) {
                    _bind$5 = { _0: _elem_ty, _1: Math.imul(idx, _elem_size) | 0 };
                  } else {
                    const _Some = _bind$6;
                    const _x = _Some;
                    const _t = _x._0;
                    const _o = _x._1;
                    _bind$5 = { _0: _t, _1: _o };
                  }
                } else {
                  _bind$5 = { _0: _elem_ty, _1: Math.imul(idx, _elem_size) | 0 };
                }
                const _target_ty = _bind$5._0;
                const _rel_off = _bind$5._1;
                hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, base_reg, base_off$2 + _rel_off | 0, _target_ty, item.value, bag);
                if (has_index) {
                  if (idx >= 0) {
                    next_index = idx + 1 | 0;
                  }
                } else {
                  next_index = next_index + 1 | 0;
                }
                break _L$2;
              }
              _tmp$30 = _i + 1 | 0;
              continue;
            } else {
              return;
            }
          }
        }
        case 6: {
          const _Struct = _bind;
          const _tag = _Struct._0;
          const _tag_id = _Struct._1;
          const _field_list = _Struct._2;
          const fields = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(alloc.sem, _tag, _tag_id, _field_list, false);
          let list;
          if (fields.$tag === 0) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc, `codegen: incomplete struct '${_tag}'`);
            return undefined;
          } else {
            const _Some = fields;
            list = _Some._0;
          }
          let index = 0;
          let item_idx = 0;
          while (true) {
            if (item_idx < _items.length) {
              const item = moonbitlang$core$array$$Array$at$38$(_items, item_idx);
              if (item.designators.length > 0) {
                const _bind$5 = moonbitlang$core$array$$Array$at$37$(item.designators, 0);
                if (_bind$5.$tag === 2) {
                  const _Field = _bind$5;
                  const _name = _Field._0;
                  const _id = _Field._1;
                  const _bind$6 = hackwaly$tinycc$sem$$find_field_index_cached(alloc.sem, ty$2, _name, _id, item.loc);
                  if (_bind$6 === undefined) {
                  } else {
                    const _Some = _bind$6;
                    const _idx = _Some;
                    index = _idx + 1 | 0;
                  }
                }
                const _bind$6 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_access_info(alloc.sem, ty$2, item.designators, item.loc, bag);
                if (_bind$6 === undefined) {
                } else {
                  const _Some = _bind$6;
                  const _info = _Some;
                  const _bind$7 = _info.bit_width;
                  if (_bind$7 === undefined) {
                    hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, base_reg, base_off$2 + _info.offset | 0, _info.ty, item.value, bag);
                  } else {
                    const info_at = { offset: base_off$2 + _info.offset | 0, ty: _info.ty, bit_offset: _info.bit_offset, bit_width: _info.bit_width, bit_unit_size: _info.bit_unit_size };
                    const _bind$8 = item.value;
                    if (_bind$8.$tag === 0) {
                      const _Expr = _bind$8;
                      const _expr = _Expr._0;
                      let tmp;
                      let _try_err;
                      _L$2: {
                        _L$3: {
                          const _bind$9 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                          if (_bind$9.$tag === 1) {
                            const _ok = _bind$9;
                            tmp = _ok._0;
                          } else {
                            const _err = _bind$9;
                            const _tmp$31 = _err._0;
                            _try_err = _tmp$31;
                            break _L$3;
                          }
                          break _L$2;
                        }
                        hackwaly$tinycc$support$diag$$add_error(bag, item.loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                        return undefined;
                      }
                      hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _expr, tmp, bag, undefined);
                      hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, base_reg, info_at, tmp, item.loc, bag);
                      hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                    } else {
                      hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: bitfield initializer must be scalar");
                    }
                  }
                }
                item_idx = item_idx + 1 | 0;
              } else {
                const _bind$5 = hackwaly$tinycc$sem$$next_init_field(list, index);
                if (_bind$5 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: too many initializers for aggregate");
                  item_idx = item_idx + 1 | 0;
                } else {
                  const _Some = _bind$5;
                  const _x = _Some;
                  const _field = _x._0;
                  const _next_idx = _x._1;
                  const _bind$6 = _field.bit_width;
                  let field_off;
                  if (_bind$6 === undefined) {
                    const _bind$7 = hackwaly$tinycc$sem$$eval_builtin_offsetof(alloc.sem, ty$2, [_field.name], item.loc);
                    if (_bind$7 === undefined) {
                      field_off = 0;
                    } else {
                      const _Some$2 = _bind$7;
                      field_off = _Some$2;
                    }
                  } else {
                    field_off = 0;
                  }
                  let consumed = 1;
                  let used_elision = false;
                  _L$2: {
                    _L$3: {
                      const _bind$7 = hackwaly$tinycc$sem$$strip_top_qualifiers(_field.ty);
                      const _bind$8 = item.value;
                      switch (_bind$7.$tag) {
                        case 5: {
                          if (_bind$8.$tag === 0) {
                            const _Expr = _bind$8;
                            const _expr = _Expr._0;
                            if (_expr.$tag === 3) {
                            } else {
                              const n$2 = hackwaly$tinycc$backend$codegen$$array_len_from_type_for_init(alloc.sem, _field.ty, item.loc);
                              const _bind$9 = hackwaly$tinycc$backend$codegen$$collect_elided_array_items_codegen(_items, item_idx, n$2);
                              const _elided_items = _bind$9._0;
                              const _count = _bind$9._1;
                              const init$3 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List(_elided_items, item.loc);
                              hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, base_reg, base_off$2 + field_off | 0, _field.ty, init$3, bag);
                              consumed = _count;
                              used_elision = true;
                            }
                          }
                          break;
                        }
                        case 6: {
                          if (_bind$8.$tag === 0) {
                            break _L$3;
                          }
                          break;
                        }
                        case 7: {
                          if (_bind$8.$tag === 0) {
                            break _L$3;
                          }
                          break;
                        }
                      }
                      break _L$2;
                    }
                    if (hackwaly$tinycc$backend$codegen$$has_single_init_field_codegen(alloc.sem, _field.ty)) {
                      const init$3 = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List([{ designators: [], value: item.value, loc: item.loc }], item.loc);
                      hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, base_reg, base_off$2 + field_off | 0, _field.ty, init$3, bag);
                      used_elision = true;
                    }
                  }
                  if (!used_elision) {
                    const _bind$7 = _field.bit_width;
                    if (_bind$7 === undefined) {
                      hackwaly$tinycc$backend$codegen$$gen_initializer_to_addr(emitter, alloc, syms, pool, cstrings, base_reg, base_off$2 + field_off | 0, _field.ty, item.value, bag);
                    } else {
                      const _bind$8 = hackwaly$tinycc$backend$codegen$$record_field_access_info(alloc.sem, ty$2, _field.name, _field.id, item.loc);
                      if (_bind$8 === undefined) {
                        hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: missing bitfield info");
                      } else {
                        const _Some$2 = _bind$8;
                        const _info = _Some$2;
                        const info_at = { offset: base_off$2 + _info.offset | 0, ty: _info.ty, bit_offset: _info.bit_offset, bit_width: _info.bit_width, bit_unit_size: _info.bit_unit_size };
                        const _bind$9 = item.value;
                        if (_bind$9.$tag === 0) {
                          const _Expr = _bind$9;
                          const _expr = _Expr._0;
                          let tmp;
                          let _try_err;
                          _L$3: {
                            _L$4: {
                              const _bind$10 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                              if (_bind$10.$tag === 1) {
                                const _ok = _bind$10;
                                tmp = _ok._0;
                              } else {
                                const _err = _bind$10;
                                const _tmp$31 = _err._0;
                                _try_err = _tmp$31;
                                break _L$4;
                              }
                              break _L$3;
                            }
                            hackwaly$tinycc$support$diag$$add_error(bag, item.loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                            return undefined;
                          }
                          hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _expr, tmp, bag, undefined);
                          hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, base_reg, info_at, tmp, item.loc, bag);
                          hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                        } else {
                          hackwaly$tinycc$support$diag$$add_error(bag, item.loc, "codegen: bitfield initializer must be scalar");
                        }
                      }
                    }
                  }
                  index = _next_idx;
                  item_idx = item_idx + consumed | 0;
                }
              }
              continue;
            } else {
              return;
            }
          }
        }
        case 7: {
          const _Union = _bind;
          const _tag$2 = _Union._0;
          const _tag_id$2 = _Union._1;
          const _field_list$2 = _Union._2;
          const fields$2 = hackwaly$tinycc$backend$codegen$$resolve_struct_fields(alloc.sem, _tag$2, _tag_id$2, _field_list$2, true);
          let list$2;
          if (fields$2.$tag === 0) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc, `codegen: incomplete union '${_tag$2}'`);
            return undefined;
          } else {
            const _Some = fields$2;
            list$2 = _Some._0;
          }
          if (_items.length === 0) {
            return undefined;
          }
          const first = moonbitlang$core$array$$Array$at$38$(_items, 0);
          if (first.designators.length > 0) {
            const _bind$5 = hackwaly$tinycc$backend$codegen$$resolve_init_designator_access_info(alloc.sem, ty$2, first.designators, first.loc, bag);
            if (_bind$5 === undefined) {
              return;
            } else {
              const _Some = _bind$5;
              const _info = _Some;
              const _bind$6 = _info.bit_width;
              if (_bind$6 === undefined) {
                _tmp$27 = base_off$2 + _info.offset | 0;
                _tmp$28 = _info.ty;
                _tmp$29 = first.value;
                continue _L;
              } else {
                const info_at = { offset: base_off$2 + _info.offset | 0, ty: _info.ty, bit_offset: _info.bit_offset, bit_width: _info.bit_width, bit_unit_size: _info.bit_unit_size };
                const _bind$7 = first.value;
                if (_bind$7.$tag === 0) {
                  const _Expr = _bind$7;
                  const _expr = _Expr._0;
                  let tmp;
                  let _try_err;
                  _L$2: {
                    _L$3: {
                      const _bind$8 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                      if (_bind$8.$tag === 1) {
                        const _ok = _bind$8;
                        tmp = _ok._0;
                      } else {
                        const _err = _bind$8;
                        const _tmp$31 = _err._0;
                        _try_err = _tmp$31;
                        break _L$3;
                      }
                      break _L$2;
                    }
                    hackwaly$tinycc$support$diag$$add_error(bag, first.loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                    return undefined;
                  }
                  hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _expr, tmp, bag, undefined);
                  hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, base_reg, info_at, tmp, first.loc, bag);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                  return;
                } else {
                  hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: bitfield initializer must be scalar");
                  return;
                }
              }
            }
          } else {
            if (list$2.length > 0) {
              const field = moonbitlang$core$array$$Array$at$39$(list$2, 0);
              const _bind$5 = field.bit_width;
              if (_bind$5 === undefined) {
                _tmp$28 = field.ty;
                _tmp$29 = first.value;
                continue _L;
              } else {
                const _bind$6 = hackwaly$tinycc$backend$codegen$$record_field_access_info(alloc.sem, ty$2, field.name, field.id, first.loc);
                if (_bind$6 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: missing bitfield info");
                  return;
                } else {
                  const _Some = _bind$6;
                  const _info = _Some;
                  const info_at = { offset: base_off$2 + _info.offset | 0, ty: _info.ty, bit_offset: _info.bit_offset, bit_width: _info.bit_width, bit_unit_size: _info.bit_unit_size };
                  const _bind$7 = first.value;
                  if (_bind$7.$tag === 0) {
                    const _Expr = _bind$7;
                    const _expr = _Expr._0;
                    let tmp;
                    let _try_err;
                    _L$2: {
                      _L$3: {
                        const _bind$8 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                        if (_bind$8.$tag === 1) {
                          const _ok = _bind$8;
                          tmp = _ok._0;
                        } else {
                          const _err = _bind$8;
                          const _tmp$31 = _err._0;
                          _try_err = _tmp$31;
                          break _L$3;
                        }
                        break _L$2;
                      }
                      hackwaly$tinycc$support$diag$$add_error(bag, first.loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                      return undefined;
                    }
                    hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _expr, tmp, bag, undefined);
                    hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, base_reg, info_at, tmp, first.loc, bag);
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                    return;
                  } else {
                    hackwaly$tinycc$support$diag$$add_error(bag, first.loc, "codegen: bitfield initializer must be scalar");
                    return;
                  }
                }
              }
            } else {
              return;
            }
          }
        }
        default: {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: initializer list for non-aggregate");
          return;
        }
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, expr, ty, dst, bag) {
  const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(ty);
  if (_bind === undefined) {
    if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(ty)) {
      hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, expr, dst, bag);
      return;
    } else {
      hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, expr, dst, bag, ty);
      return;
    }
  } else {
    const _Some = _bind;
    const _k = _Some;
    hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, expr, ty, _k, dst, bag);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, expr, dst, bag) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    switch (expr$2.$tag) {
      case 0: {
        const _IntLit = expr$2;
        const _value = _IntLit._0;
        const _loc = _IntLit._2;
        const _bind = hackwaly$tinycc$frontend$ast$$parse_int64_literal(_value);
        if (_bind === undefined) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: invalid integer literal");
          return;
        } else {
          const _Some = _bind;
          const _v = _Some;
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, _v);
          return;
        }
      }
      case 2: {
        const _CharLit = expr$2;
        const _value$2 = _CharLit._0;
        hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(_value$2));
        return;
      }
      case 12: {
        const _StmtExpr = expr$2;
        const _stmts = _StmtExpr._0;
        const _loc$2 = _StmtExpr._2;
        hackwaly$tinycc$backend$codegen$$gen_stmt_expr_with(emitter, alloc, syms, pool, cstrings, _stmts, dst, true, _loc$2, bag, (expr$3, dst$2) => {
          hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, expr$3, dst$2, bag);
        });
        return;
      }
      case 3: {
        const _StringLit = expr$2;
        const _value$3 = _StringLit._0;
        const sym = hackwaly$tinycc$backend$codegen$$cstring_sym_or_add(cstrings, syms, _value$3);
        hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, dst);
        return;
      }
      case 5: {
        const _LabelAddr = expr$2;
        const _name = _LabelAddr._0;
        const _loc$3 = _LabelAddr._3;
        const _bind$2 = moonbitlang$core$hashmap$$HashMap$get$156$(alloc.labels.addrs, _name);
        if (_bind$2 === undefined) {
          const at = emitter.code_len << 2;
          hackwaly$tinycc$backend$arm64$$emit32(emitter, 268435456 | dst);
          hackwaly$tinycc$backend$codegen$$record_label_addr_patch(alloc.labels, _name, at);
          return;
        } else {
          const _Some = _bind$2;
          const _addr = _Some;
          hackwaly$tinycc$backend$codegen$$emit_adr(emitter, dst, _addr - (emitter.code_len << 2) | 0, _loc$3, bag);
          return;
        }
      }
      case 4: {
        const _Ident = expr$2;
        const _name$2 = _Ident._0;
        const _id = _Ident._1;
        const _loc$4 = _Ident._3;
        if (_name$2 === "__func__" || (_name$2 === "__FUNCTION__" || _name$2 === "__PRETTY_FUNCTION__")) {
          if (hackwaly$tinycc$backend$codegen$$gen_func_name_addr(emitter, syms, cstrings, alloc, dst, _loc$4, bag)) {
            return undefined;
          }
        }
        const _bind$3 = hackwaly$tinycc$backend$codegen$$lookup_local(alloc, _name$2, _id);
        if (_bind$3 === undefined) {
          const _bind$4 = hackwaly$tinycc$backend$codegen$$lookup_static_local(alloc, _id);
          if (_bind$4 === undefined) {
            const sym$2 = hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, _name$2, _id);
            hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym$2, dst);
            const has_func = _id > 0 ? hackwaly$tinycc$sem$$has_function_by_id(alloc.sem, _id) || moonbitlang$core$hashmap$$HashMap$contains$160$(alloc.sem.functions, _name$2) : moonbitlang$core$hashmap$$HashMap$contains$160$(alloc.sem.functions, _name$2);
            if (has_func) {
              return undefined;
            }
            const global_ty = _id > 0 ? hackwaly$tinycc$sem$$get_global_by_id(alloc.sem, _id) : undefined;
            let global_ty$2;
            if (global_ty === undefined) {
              global_ty$2 = moonbitlang$core$hashmap$$HashMap$get$159$(alloc.sem.globals, _name$2);
            } else {
              const _Some = global_ty;
              const _found = _Some;
              global_ty$2 = _found;
            }
            if (global_ty$2 === undefined) {
            } else {
              const _Some = global_ty$2;
              const _gty = _Some;
              const _bind$5 = hackwaly$tinycc$sem$$strip_top_qualifiers(_gty);
              if (_bind$5.$tag === 5) {
                return undefined;
              }
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, dst, $0L);
            return;
          } else {
            const _Some = _bind$4;
            const _info = _Some;
            const sym$2 = hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, _info);
            hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym$2, dst);
            _L$2: {
              _L$3: {
                const _bind$5 = hackwaly$tinycc$sem$$strip_top_qualifiers(_info.ty);
                switch (_bind$5.$tag) {
                  case 5: {
                    break _L$3;
                  }
                  case 10: {
                    break _L$3;
                  }
                }
                break _L$2;
              }
              return undefined;
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, dst, $0L);
            return;
          }
        } else {
          const _Some = _bind$3;
          const _slot = _Some;
          _L$2: {
            const _bind$4 = hackwaly$tinycc$sem$$strip_top_qualifiers(_slot.ty);
            if (_bind$4.$tag === 5) {
              const _Array = _bind$4;
              const _x = _Array._1;
              if (_x === undefined) {
                const _x$2 = _Array._2;
                if (_x$2 === undefined) {
                  break _L$2;
                } else {
                  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, 29, moonbitlang$core$int$$Int$to_int64(_slot.offset));
                  return;
                }
              } else {
                break _L$2;
              }
            } else {
              hackwaly$tinycc$backend$codegen$$emit_load_local_scalar(emitter, alloc.sem, _slot.ty, dst, _slot.offset, _loc$4, bag);
              return;
            }
          }
          hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, dst, _slot.offset, _loc$4, bag);
          return;
        }
      }
      case 21: {
        const _Member = expr$2;
        const _base = _Member._0;
        const _name$3 = _Member._1;
        const _id$2 = _Member._2;
        const _is_arrow = _Member._3;
        const _loc$5 = _Member._5;
        let addr;
        let _try_err;
        _L$2: {
          _L$3: {
            const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$4.$tag === 1) {
              const _ok = _bind$4;
              addr = _ok._0;
            } else {
              const _err = _bind$4;
              const _tmp$28 = _err._0;
              _try_err = _tmp$28;
              break _L$3;
            }
            break _L$2;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$5, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
          return undefined;
        }
        const base_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _base);
        const info = hackwaly$tinycc$backend$codegen$$member_access_info_from_base_type(alloc.sem, base_ty, _name$3, _id$2, _is_arrow, _loc$5);
        if (info === undefined) {
          hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, expr$2, addr, bag);
          const _bind$4 = hackwaly$tinycc$sem$$type_of_lvalue(alloc.sem, expr$2);
          if (_bind$4 === undefined) {
          } else {
            const _Some = _bind$4;
            const _lty = _Some;
            _L$3: {
              _L$4: {
                const _bind$5 = hackwaly$tinycc$sem$$strip_top_qualifiers(_lty);
                switch (_bind$5.$tag) {
                  case 5: {
                    break _L$4;
                  }
                  case 10: {
                    break _L$4;
                  }
                  default: {
                    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, addr, $0L);
                  }
                }
                break _L$3;
              }
              if (dst !== addr) {
                hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, addr);
              }
            }
          }
        } else {
          const _Some = info;
          const _info = _Some;
          hackwaly$tinycc$backend$codegen$$gen_member_addr_with_info(emitter, alloc, syms, pool, cstrings, _base, base_ty, _is_arrow, _info, addr, _loc$5, bag);
          _L$3: {
            _L$4: {
              const _bind$4 = hackwaly$tinycc$sem$$strip_top_qualifiers(_info.ty);
              switch (_bind$4.$tag) {
                case 5: {
                  break _L$4;
                }
                case 10: {
                  break _L$4;
                }
                default: {
                  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, addr, $0L);
                }
              }
              break _L$3;
            }
            if (dst !== addr) {
              hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, addr);
            }
          }
        }
        hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
        return;
      }
      case 20: {
        const _Index = expr$2;
        const _base$2 = _Index._0;
        const _index = _Index._1;
        const _loc$6 = _Index._3;
        let addr$2;
        let _try_err$2;
        _L$3: {
          _L$4: {
            const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$4.$tag === 1) {
              const _ok = _bind$4;
              addr$2 = _ok._0;
            } else {
              const _err = _bind$4;
              const _tmp$28 = _err._0;
              _try_err$2 = _tmp$28;
              break _L$4;
            }
            break _L$3;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$6, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
          return undefined;
        }
        const _bind$4 = hackwaly$tinycc$backend$codegen$$gen_index_addr_with_elem_type(emitter, alloc, syms, pool, cstrings, _base$2, _index, addr$2, _loc$6, bag);
        let elem_ty;
        if (_bind$4 === undefined) {
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
          return undefined;
        } else {
          const _Some = _bind$4;
          elem_ty = _Some;
        }
        _L$4: {
          _L$5: {
            const _bind$5 = hackwaly$tinycc$sem$$strip_top_qualifiers(elem_ty);
            switch (_bind$5.$tag) {
              case 5: {
                break _L$5;
              }
              case 10: {
                break _L$5;
              }
              default: {
                hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, dst, addr$2, $0L);
              }
            }
            break _L$4;
          }
          if (dst !== addr$2) {
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, addr$2);
          }
        }
        hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$2);
        return;
      }
      case 11: {
        const _CompoundLiteral = expr$2;
        const _ty = _CompoundLiteral._0;
        const _init = _CompoundLiteral._1;
        const _node_id = _CompoundLiteral._2;
        const _loc$7 = _CompoundLiteral._3;
        let addr$3;
        let _try_err$3;
        _L$5: {
          _L$6: {
            const _bind$5 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$5.$tag === 1) {
              const _ok = _bind$5;
              addr$3 = _ok._0;
            } else {
              const _err = _bind$5;
              const _tmp$28 = _err._0;
              _try_err$3 = _tmp$28;
              break _L$6;
            }
            break _L$5;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$7, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
          return undefined;
        }
        const _bind$5 = hackwaly$tinycc$backend$codegen$$gen_compound_literal_addr_with_type(emitter, alloc, syms, pool, cstrings, _ty, _init, _loc$7, _node_id, addr$3, bag);
        let resolved;
        if (_bind$5 === undefined) {
          hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
          return undefined;
        } else {
          const _Some = _bind$5;
          resolved = _Some;
        }
        _L$6: {
          _L$7: {
            const _bind$6 = hackwaly$tinycc$sem$$strip_top_qualifiers(resolved);
            switch (_bind$6.$tag) {
              case 5: {
                break _L$7;
              }
              case 10: {
                break _L$7;
              }
              default: {
                const _bind$7 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, resolved, _loc$7);
                let _bind$8;
                if (_bind$7 === undefined) {
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
                  return undefined;
                } else {
                  const _Some = _bind$7;
                  _bind$8 = _Some;
                }
                const _size = _bind$8._0;
                const _signed = _bind$8._1;
                const _bind$9 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
                let sz;
                if (_bind$9 === undefined) {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$7, "codegen: unsupported scalar size");
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
                  return undefined;
                } else {
                  const _Some = _bind$9;
                  sz = _Some;
                }
                hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed, sz, dst, addr$3, $0L);
              }
            }
            break _L$6;
          }
          if (dst !== addr$3) {
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, addr$3);
          }
        }
        hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$3);
        return;
      }
      case 9: {
        const _Unary = expr$2;
        const _x = _Unary._0;
        switch (_x) {
          case 4: {
            const _inner = _Unary._1;
            hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _inner, dst, bag);
            return;
          }
          case 5: {
            const _inner$2 = _Unary._1;
            const _loc$8 = _Unary._3;
            hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _inner$2, dst, bag);
            const _bind$6 = hackwaly$tinycc$backend$codegen$$deref_pointee_type(alloc.sem, _inner$2, _loc$8, bag);
            let ty;
            if (_bind$6 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$6;
              ty = _Some;
            }
            _L$7: {
              _L$8: {
                const _bind$7 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
                switch (_bind$7.$tag) {
                  case 5: {
                    break _L$8;
                  }
                  case 10: {
                    break _L$8;
                  }
                }
                break _L$7;
              }
              return undefined;
            }
            const _bind$7 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, ty, _loc$8);
            let _bind$8;
            if (_bind$7 === undefined) {
              return undefined;
            } else {
              const _Some = _bind$7;
              _bind$8 = _Some;
            }
            const _size = _bind$8._0;
            const _signed = _bind$8._1;
            const _bind$9 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_size);
            let sz;
            if (_bind$9 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$8, "codegen: unsupported scalar size");
              return undefined;
            } else {
              const _Some = _bind$9;
              sz = _Some;
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, _signed, sz, dst, dst, $0L);
            return;
          }
          default: {
            const _inner$3 = _Unary._1;
            const _loc$9 = _Unary._3;
            _L$8: {
              switch (_x) {
                case 6: {
                  break _L$8;
                }
                case 7: {
                  break _L$8;
                }
                case 8: {
                  break _L$8;
                }
                case 9: {
                  break _L$8;
                }
                default: {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: unsupported pointer unary operator");
                  return;
                }
              }
            }
            const ty$2 = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _inner$3);
            const _bind$10 = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(ty$2);
            let elem_ty$2;
            if (_bind$10 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: pointer inc/dec missing element type");
              return undefined;
            } else {
              const _Some = _bind$10;
              elem_ty$2 = _Some;
            }
            const _bind$11 = hackwaly$tinycc$sem$$strip_top_qualifiers(elem_ty$2);
            let elem_size;
            switch (_bind$11.$tag) {
              case 0: {
                elem_size = 1;
                break;
              }
              case 10: {
                elem_size = 1;
                break;
              }
              default: {
                const _bind$12 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, elem_ty$2, _loc$9);
                if (_bind$12 === undefined) {
                  return undefined;
                } else {
                  const _Some = _bind$12;
                  const _x$2 = _Some;
                  elem_size = _x$2._0;
                }
              }
            }
            let addr$4;
            let _try_err$4;
            _L$9: {
              _L$10: {
                const _bind$13 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$13.$tag === 1) {
                  const _ok = _bind$13;
                  addr$4 = _ok._0;
                } else {
                  const _err = _bind$13;
                  const _tmp$28 = _err._0;
                  _try_err$4 = _tmp$28;
                  break _L$10;
                }
                break _L$9;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$4));
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _inner$3, addr$4, bag);
            let value_reg;
            if (dst === addr$4) {
              let _try_err$5;
              _L$10: {
                _L$11: {
                  const _bind$13 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$13.$tag === 1) {
                    const _ok = _bind$13;
                    value_reg = _ok._0;
                  } else {
                    const _err = _bind$13;
                    const _tmp$28 = _err._0;
                    _try_err$5 = _tmp$28;
                    break _L$11;
                  }
                  break _L$10;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
                return undefined;
              }
            } else {
              value_reg = dst;
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, value_reg, addr$4, $0L);
            const is_add = moonbitlang$core$builtin$$Eq$equal$179$(_x, 6) || moonbitlang$core$builtin$$Eq$equal$179$(_x, 8);
            const is_post = moonbitlang$core$builtin$$Eq$equal$179$(_x, 8) || moonbitlang$core$builtin$$Eq$equal$179$(_x, 9);
            if (is_post) {
              let updated;
              let _try_err$5;
              _L$10: {
                _L$11: {
                  const _bind$13 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$13.$tag === 1) {
                    const _ok = _bind$13;
                    updated = _ok._0;
                  } else {
                    const _err = _bind$13;
                    const _tmp$28 = _err._0;
                    _try_err$5 = _tmp$28;
                    break _L$11;
                  }
                  break _L$10;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
                if (value_reg !== dst) {
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, value_reg);
                }
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
                return undefined;
              }
              hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, updated, value_reg);
              if (elem_size !== 0) {
                if (elem_size <= 4095) {
                  const base = is_add ? -1862270976 : -788529152;
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | updated | updated << 5 | elem_size << 10);
                } else {
                  let scale;
                  let _try_err$6;
                  _L$11: {
                    _L$12: {
                      const _bind$13 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                      if (_bind$13.$tag === 1) {
                        const _ok = _bind$13;
                        scale = _ok._0;
                      } else {
                        const _err = _bind$13;
                        const _tmp$28 = _err._0;
                        _try_err$6 = _tmp$28;
                        break _L$12;
                      }
                      break _L$11;
                    }
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, updated);
                    if (value_reg !== dst) {
                      hackwaly$tinycc$backend$codegen$$give_reg(pool, value_reg);
                    }
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
                    return undefined;
                  }
                  hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(elem_size));
                  const base = is_add ? -1962934272 : -889192448;
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | updated | updated << 5 | scale << 16);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
                }
              }
              hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, updated, addr$4, $0L);
              if (value_reg !== dst) {
                hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, value_reg);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, value_reg);
              }
              hackwaly$tinycc$backend$codegen$$give_reg(pool, updated);
            } else {
              if (elem_size !== 0) {
                if (elem_size <= 4095) {
                  const base = is_add ? -1862270976 : -788529152;
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | value_reg | value_reg << 5 | elem_size << 10);
                } else {
                  let scale;
                  let _try_err$5;
                  _L$10: {
                    _L$11: {
                      const _bind$13 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                      if (_bind$13.$tag === 1) {
                        const _ok = _bind$13;
                        scale = _ok._0;
                      } else {
                        const _err = _bind$13;
                        const _tmp$28 = _err._0;
                        _try_err$5 = _tmp$28;
                        break _L$11;
                      }
                      break _L$10;
                    }
                    hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
                    if (value_reg !== dst) {
                      hackwaly$tinycc$backend$codegen$$give_reg(pool, value_reg);
                    }
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
                    return undefined;
                  }
                  hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(elem_size));
                  const base = is_add ? -1962934272 : -889192448;
                  hackwaly$tinycc$backend$arm64$$emit32(emitter, base | value_reg | value_reg << 5 | scale << 16);
                  hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
                }
              }
              hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, value_reg, addr$4, $0L);
              if (value_reg !== dst) {
                hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, value_reg);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, value_reg);
              }
            }
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$4);
            return;
          }
        }
      }
      case 8: {
        const _BuiltinVaArg = expr$2;
        const _list = _BuiltinVaArg._0;
        const _ty$2 = _BuiltinVaArg._1;
        const _loc$10 = _BuiltinVaArg._3;
        if (!hackwaly$tinycc$backend$codegen$$type_is_pointer_like(_ty$2)) {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$10, "codegen: expected pointer type for va_arg");
          return undefined;
        }
        hackwaly$tinycc$backend$codegen$$gen_builtin_va_arg_load(emitter, alloc, syms, pool, cstrings, _list, _ty$2, dst, bag);
        return;
      }
      case 17: {
        const _Binary = expr$2;
        const _x$2 = _Binary._0;
        if (_x$2 === 0) {
          const _left = _Binary._1;
          const _right = _Binary._2;
          hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _right, dst, bag);
          hackwaly$tinycc$backend$codegen$$store_lvalue_scalar(emitter, alloc, syms, pool, cstrings, _left, dst, hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left), bag);
          return;
        } else {
          const _left = _Binary._1;
          const _right = _Binary._2;
          const _loc$11 = _Binary._4;
          _L$10: {
            _L$11: {
              switch (_x$2) {
                case 11: {
                  hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _left, bag);
                  _tmp$27 = _right;
                  continue _L;
                }
                case 1: {
                  break _L$11;
                }
                case 2: {
                  break _L$11;
                }
                case 12: {
                  break _L$10;
                }
                case 13: {
                  break _L$10;
                }
                default: {
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, "codegen: unsupported pointer expression");
                  return;
                }
              }
            }
            const lhs_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left);
            if (!hackwaly$tinycc$backend$codegen$$type_is_pointer_like(lhs_ty)) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, "codegen: compound assign pointer op needs pointer lhs");
              return undefined;
            }
            const _bind$13 = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(lhs_ty);
            let elem_ty$3;
            if (_bind$13 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, "codegen: pointer arithmetic missing element type");
              return undefined;
            } else {
              const _Some = _bind$13;
              elem_ty$3 = _Some;
            }
            const _bind$14 = hackwaly$tinycc$sem$$strip_top_qualifiers(elem_ty$3);
            let elem_size$2;
            switch (_bind$14.$tag) {
              case 0: {
                elem_size$2 = 1;
                break;
              }
              case 10: {
                elem_size$2 = 1;
                break;
              }
              default: {
                const _bind$15 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, elem_ty$3, _loc$11);
                if (_bind$15 === undefined) {
                  return undefined;
                } else {
                  const _Some = _bind$15;
                  const _x$3 = _Some;
                  elem_size$2 = _x$3._0;
                }
              }
            }
            let addr$5;
            let _try_err$5;
            _L$12: {
              _L$13: {
                const _bind$16 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$16.$tag === 1) {
                  const _ok = _bind$16;
                  addr$5 = _ok._0;
                } else {
                  const _err = _bind$16;
                  const _tmp$28 = _err._0;
                  _try_err$5 = _tmp$28;
                  break _L$13;
                }
                break _L$12;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _left, addr$5, bag);
            let base_reg;
            let _try_err$6;
            _L$13: {
              _L$14: {
                const _bind$16 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$16.$tag === 1) {
                  const _ok = _bind$16;
                  base_reg = _ok._0;
                } else {
                  const _err = _bind$16;
                  const _tmp$28 = _err._0;
                  _try_err$6 = _tmp$28;
                  break _L$14;
                }
                break _L$13;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
              return undefined;
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, base_reg, addr$5, $0L);
            let idx;
            let _try_err$7;
            _L$14: {
              _L$15: {
                const _bind$16 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$16.$tag === 1) {
                  const _ok = _bind$16;
                  idx = _ok._0;
                } else {
                  const _err = _bind$16;
                  const _tmp$28 = _err._0;
                  _try_err$7 = _tmp$28;
                  break _L$15;
                }
                break _L$14;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$7));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, base_reg);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _right, idx, bag, undefined);
            const idx_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
            hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, idx_ty, idx, _loc$11, bag);
            if (elem_size$2 !== 1) {
              let scale;
              let _try_err$8;
              _L$15: {
                _L$16: {
                  const _bind$16 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$16.$tag === 1) {
                    const _ok = _bind$16;
                    scale = _ok._0;
                  } else {
                    const _err = _bind$16;
                    const _tmp$28 = _err._0;
                    _try_err$8 = _tmp$28;
                    break _L$16;
                  }
                  break _L$15;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$8));
                hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, base_reg);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
                return undefined;
              }
              hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(elem_size$2));
              hackwaly$tinycc$backend$arm64$$emit32(emitter, -1694467072 | idx | idx << 5 | scale << 16);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
            }
            const base = moonbitlang$core$builtin$$Eq$equal$178$(_x$2, 1) ? -1962934272 : -889192448;
            hackwaly$tinycc$backend$arm64$$emit32(emitter, base | base_reg | base_reg << 5 | idx << 16);
            hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, base_reg, addr$5, $0L);
            if (base_reg !== dst) {
              hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, base_reg);
            }
            hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, base_reg);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, addr$5);
            return;
          }
          const left_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left);
          const right_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _right);
          if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty) && hackwaly$tinycc$backend$codegen$$type_is_pointer_like(right_ty)) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, "codegen: pointer +/- pointer not supported yet");
            return undefined;
          }
          if (moonbitlang$core$builtin$$Eq$equal$178$(_x$2, 13) && (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(right_ty) && !hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty))) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, "codegen: int - pointer not supported");
            return undefined;
          }
          let _bind$13;
          if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(left_ty)) {
            _bind$13 = { _0: _left, _1: _right, _2: left_ty };
          } else {
            if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(right_ty)) {
              _bind$13 = { _0: _right, _1: _left, _2: right_ty };
            } else {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, "codegen: pointer add/sub needs a pointer operand");
              return undefined;
            }
          }
          const _ptr_expr = _bind$13._0;
          const _int_expr = _bind$13._1;
          const _ptr_ty = _bind$13._2;
          hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _ptr_expr, dst, bag);
          let base_reg = dst;
          let saved_reg = undefined;
          if (hackwaly$tinycc$frontend$ast$$expr_may_call(_int_expr) && dst < 19) {
            let tmp;
            let _try_err$5;
            _L$11: {
              _L$12: {
                const _bind$14 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$14.$tag === 1) {
                  const _ok = _bind$14;
                  tmp = _ok._0;
                } else {
                  const _err = _bind$14;
                  const _tmp$28 = _err._0;
                  _try_err$5 = _tmp$28;
                  break _L$12;
                }
                break _L$11;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, tmp, dst);
            base_reg = tmp;
            saved_reg = tmp;
          }
          let idx;
          let _try_err$5;
          _L$11: {
            _L$12: {
              const _bind$14 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$14.$tag === 1) {
                const _ok = _bind$14;
                idx = _ok._0;
              } else {
                const _err = _bind$14;
                const _tmp$28 = _err._0;
                _try_err$5 = _tmp$28;
                break _L$12;
              }
              break _L$11;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
            const _bind$14 = saved_reg;
            if (_bind$14 === undefined) {
            } else {
              const _Some = _bind$14;
              const _r = _Some;
              hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
            }
            return undefined;
          }
          hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _int_expr, idx, bag, undefined);
          const idx_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _int_expr);
          hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, idx_ty, idx, _loc$11, bag);
          const _bind$14 = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(_ptr_ty);
          let elem_ty$3;
          if (_bind$14 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, "codegen: pointer arithmetic missing element type");
            hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
            return undefined;
          } else {
            const _Some = _bind$14;
            elem_ty$3 = _Some;
          }
          const _bind$15 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, elem_ty$3, _loc$11);
          let _bind$16;
          if (_bind$15 === undefined) {
            hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
            return undefined;
          } else {
            const _Some = _bind$15;
            _bind$16 = _Some;
          }
          const _elem_size = _bind$16._0;
          if (_elem_size !== 1) {
            let scale;
            let _try_err$6;
            _L$12: {
              _L$13: {
                const _bind$17 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$17.$tag === 1) {
                  const _ok = _bind$17;
                  scale = _ok._0;
                } else {
                  const _err = _bind$17;
                  const _tmp$28 = _err._0;
                  _try_err$6 = _tmp$28;
                  break _L$13;
                }
                break _L$12;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
              return undefined;
            }
            hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(_elem_size));
            hackwaly$tinycc$backend$arm64$$emit32(emitter, -1694467072 | idx | idx << 5 | scale << 16);
            hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
          }
          const base = moonbitlang$core$builtin$$Eq$equal$178$(_x$2, 12) ? -1962934272 : -889192448;
          hackwaly$tinycc$backend$arm64$$emit32(emitter, base | dst | base_reg << 5 | idx << 16);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
          const _bind$17 = saved_reg;
          if (_bind$17 === undefined) {
            return;
          } else {
            const _Some = _bind$17;
            const _r = _Some;
            hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
            return;
          }
        }
      }
      case 10: {
        const _Cast = expr$2;
        const _to_ty = _Cast._0;
        const _inner$4 = _Cast._1;
        const _cast_loc = _Cast._3;
        const inner_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _inner$4);
        if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(inner_ty)) {
          _tmp$27 = _inner$4;
          continue _L;
        } else {
          hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _inner$4, dst, bag, undefined);
          hackwaly$tinycc$backend$codegen$$emit_int_cast(emitter, alloc.sem, inner_ty, _to_ty, dst, _cast_loc, bag);
          return;
        }
      }
      case 19: {
        const _Call = expr$2;
        const _callee = _Call._0;
        const _args = _Call._1;
        const _loc$11 = _Call._3;
        hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, _callee, _args, _loc$11, bag);
        if (dst !== 0) {
          hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, 0);
          return;
        } else {
          return;
        }
      }
      case 18: {
        const _Conditional = expr$2;
        const _cond = _Conditional._0;
        const _then_expr = _Conditional._1;
        const _else_expr = _Conditional._2;
        const _loc$12 = _Conditional._4;
        hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond, bag);
        const br_else = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
        hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _then_expr, dst, bag);
        const br_end = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
        const else_pc = emitter.code_len << 2;
        let _try_err$5;
        _L$10: {
          _L$11: {
            const _bind$13 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_else, else_pc, 0);
            if (_bind$13.$tag === 1) {
              const _ok = _bind$13;
              _ok._0;
            } else {
              const _err = _bind$13;
              const _tmp$28 = _err._0;
              _try_err$5 = _tmp$28;
              break _L$11;
            }
            break _L$10;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$12, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$5));
        }
        hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, _else_expr, dst, bag);
        const end_pc = emitter.code_len << 2;
        let _try_err$6;
        _L$11: {
          const _bind$13 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, br_end, end_pc);
          if (_bind$13.$tag === 1) {
            const _ok = _bind$13;
            _ok._0;
            return;
          } else {
            const _err = _bind$13;
            const _tmp$28 = _err._0;
            _try_err$6 = _tmp$28;
            break _L$11;
          }
        }
        hackwaly$tinycc$support$diag$$add_error(bag, _loc$12, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$6));
        return;
      }
      default: {
        hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(expr$2), "codegen: unsupported pointer expression");
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, cond, bag) {
  const cond_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, cond);
  let tmp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        tmp = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(cond), moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  if (hackwaly$tinycc$backend$codegen$$type_is_pointer_like(cond_ty)) {
    hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, cond, tmp, bag);
    hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, true, tmp, 31);
  } else {
    const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(cond_ty);
    if (_bind === undefined) {
      hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, cond, tmp, bag, cond_ty);
      const _bind$2 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, cond_ty, hackwaly$tinycc$frontend$ast$$expr_loc(cond));
      let is64;
      if (_bind$2 === undefined) {
        is64 = false;
      } else {
        const _Some = _bind$2;
        const _x = _Some;
        const _size = _x._0;
        is64 = _size === 8;
      }
      hackwaly$tinycc$backend$codegen$$emit_cmp(emitter, is64, tmp, 31);
    } else {
      const _Some = _bind;
      const _k = _Some;
      hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, cond, cond_ty, _k, tmp, bag);
      if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1)) {
        hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, tmp);
        hackwaly$tinycc$backend$codegen$$emit_fcmp_zero(emitter, true, 0);
      } else {
        hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, tmp);
        hackwaly$tinycc$backend$codegen$$emit_fcmp_zero(emitter, false, 0);
      }
    }
  }
  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
}
function hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, expr, src_ty, target_kind, dst, bag) {
  const norm_target = hackwaly$tinycc$backend$codegen$$normalize_float_kind(target_kind);
  if (!hackwaly$tinycc$backend$codegen$$float_kind_supported(norm_target)) {
    hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(expr), "codegen: unsupported float type");
    return undefined;
  }
  const _bind = hackwaly$tinycc$backend$codegen$$float_kind_of_type(src_ty);
  if (_bind === undefined) {
    hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, expr, dst, bag, src_ty);
    const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers_keep_attrs(src_ty);
    let is_unsigned;
    if (_bind$2.$tag === 2) {
      const _Int = _bind$2;
      is_unsigned = _Int._1;
    } else {
      is_unsigned = false;
    }
    const _bind$3 = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, src_ty, hackwaly$tinycc$frontend$ast$$expr_loc(expr));
    let src_size;
    if (_bind$3 === undefined) {
      return undefined;
    } else {
      const _Some = _bind$3;
      const _x = _Some;
      src_size = _x._0;
    }
    const sf_bit = src_size === 8 ? -2147483648 : 0;
    if (moonbitlang$core$builtin$$Eq$equal$83$(norm_target, 0)) {
      const base = is_unsigned ? 505610240 : 505544704;
      hackwaly$tinycc$backend$arm64$$emit32(emitter, base | sf_bit | dst << 5);
      hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, dst, 0);
      return;
    } else {
      const base = is_unsigned ? 509804544 : 509739008;
      hackwaly$tinycc$backend$arm64$$emit32(emitter, base | sf_bit | dst << 5);
      hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, dst, 0);
      return;
    }
  } else {
    const _Some = _bind;
    const _src_kind_raw = _Some;
    const src_kind = hackwaly$tinycc$backend$codegen$$normalize_float_kind(_src_kind_raw);
    hackwaly$tinycc$backend$codegen$$gen_expr_floatbits(emitter, alloc, syms, pool, cstrings, expr, _src_kind_raw, dst, bag);
    if (moonbitlang$core$builtin$$Eq$equal$83$(src_kind, norm_target)) {
      return undefined;
    }
    if (moonbitlang$core$builtin$$Eq$equal$83$(src_kind, 0) && moonbitlang$core$builtin$$Eq$equal$83$(norm_target, 1)) {
      hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, dst);
      hackwaly$tinycc$backend$arm64$$emit32(emitter, 505593856);
      hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, dst, 0);
      return;
    } else {
      if (moonbitlang$core$builtin$$Eq$equal$83$(src_kind, 1) && moonbitlang$core$builtin$$Eq$equal$83$(norm_target, 0)) {
        hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, dst);
        hackwaly$tinycc$backend$arm64$$emit32(emitter, 509755392);
        hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, dst, 0);
        return;
      } else {
        hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(expr), "codegen: unsupported float conversion");
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$gen_expr_floatbits(emitter, alloc, syms, pool, cstrings, expr, kind_raw, dst, bag) {
  const kind = hackwaly$tinycc$backend$codegen$$normalize_float_kind(kind_raw);
  if (!hackwaly$tinycc$backend$codegen$$float_kind_supported(kind)) {
    hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(expr), "codegen: unsupported float type");
    return undefined;
  }
  const is_double = hackwaly$tinycc$backend$codegen$$float_is_double(kind);
  _L: {
    let loc;
    _L$2: {
      switch (expr.$tag) {
        case 1: {
          const _FloatLit = expr;
          const _value = _FloatLit._0;
          const _loc = _FloatLit._2;
          const _bind = hackwaly$tinycc$backend$codegen$$parse_float_literal_bits(_value, kind);
          if (_bind === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: invalid float literal");
            return;
          } else {
            const _Some = _bind;
            const _bits = _Some;
            hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, _bits);
            return;
          }
        }
        case 12: {
          const _StmtExpr = expr;
          const _stmts = _StmtExpr._0;
          const _loc$2 = _StmtExpr._2;
          hackwaly$tinycc$backend$codegen$$gen_stmt_expr_with(emitter, alloc, syms, pool, cstrings, _stmts, dst, true, _loc$2, bag, (expr$2, dst$2) => {
            hackwaly$tinycc$backend$codegen$$gen_expr_floatbits(emitter, alloc, syms, pool, cstrings, expr$2, kind_raw, dst$2, bag);
          });
          return;
        }
        case 8: {
          const _BuiltinVaArg = expr;
          const _list = _BuiltinVaArg._0;
          const _ty = _BuiltinVaArg._1;
          const _loc$3 = _BuiltinVaArg._3;
          const _bind$2 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(hackwaly$tinycc$sem$$strip_top_qualifiers(_ty));
          if (_bind$2 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$3, "codegen: expected float type for va_arg");
            return;
          } else {
            hackwaly$tinycc$backend$codegen$$gen_builtin_va_arg_load(emitter, alloc, syms, pool, cstrings, _list, _ty, dst, bag);
            return;
          }
        }
        case 4: {
          const _Ident = expr;
          const _name = _Ident._0;
          const _id = _Ident._1;
          const _loc$4 = _Ident._3;
          const _bind$3 = hackwaly$tinycc$backend$codegen$$lookup_local(alloc, _name, _id);
          if (_bind$3 === undefined) {
            const _bind$4 = hackwaly$tinycc$backend$codegen$$lookup_static_local(alloc, _id);
            let sym;
            if (_bind$4 === undefined) {
              sym = hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, _name, _id);
            } else {
              const _Some = _bind$4;
              const _info = _Some;
              sym = hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, _info);
            }
            hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, 16);
            const size = is_double ? 8 : 4;
            const _bind$5 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(size);
            let sz;
            if (_bind$5 === undefined) {
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$4, "codegen: unsupported float size");
              return undefined;
            } else {
              const _Some = _bind$5;
              sz = _Some;
            }
            hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, sz, dst, 16, $0L);
            return;
          } else {
            const _Some = _bind$3;
            const _slot = _Some;
            hackwaly$tinycc$backend$codegen$$emit_load_local_scalar(emitter, alloc.sem, _slot.ty, dst, _slot.offset, _loc$4, bag);
            return;
          }
        }
        case 20: {
          const _Index = expr;
          const _loc$5 = _Index._3;
          loc = _loc$5;
          break _L$2;
        }
        case 21: {
          const _Member = expr;
          const _loc$6 = _Member._5;
          loc = _loc$6;
          break _L$2;
        }
        case 9: {
          const _Unary = expr;
          const _x = _Unary._0;
          switch (_x) {
            case 5: {
              const _loc$7 = _Unary._3;
              loc = _loc$7;
              break _L$2;
            }
            case 0: {
              const _inner = _Unary._1;
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _inner, kind, dst, bag);
              return;
            }
            case 1: {
              const _inner$2 = _Unary._1;
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _inner$2, kind, dst, bag);
              if (is_double) {
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, dst);
                hackwaly$tinycc$backend$codegen$$emit_fneg(emitter, true, 0, 0);
                hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, dst, 0);
                return;
              } else {
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, dst);
                hackwaly$tinycc$backend$codegen$$emit_fneg(emitter, false, 0, 0);
                hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, dst, 0);
                return;
              }
            }
            default: {
              break _L;
            }
          }
        }
        case 11: {
          const _CompoundLiteral = expr;
          const _loc$8 = _CompoundLiteral._3;
          loc = _loc$8;
          break _L$2;
        }
        case 17: {
          const _Binary = expr;
          const _x$2 = _Binary._0;
          switch (_x$2) {
            case 11: {
              const _left = _Binary._1;
              const _right = _Binary._2;
              hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _left, bag);
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _right, kind, dst, bag);
              return;
            }
            case 0: {
              const _left$2 = _Binary._1;
              const _right$2 = _Binary._2;
              const lhs_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, _left$2);
              const _p$28 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(lhs_ty);
              let lhs_kind;
              if (_p$28 === undefined) {
                lhs_kind = kind;
              } else {
                const _p$29 = _p$28;
                lhs_kind = _p$29;
              }
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _right$2, lhs_kind, dst, bag);
              hackwaly$tinycc$backend$codegen$$store_lvalue_scalar(emitter, alloc, syms, pool, cstrings, _left$2, dst, lhs_ty, bag);
              if (moonbitlang$core$builtin$$Eq$not_equal$82$(lhs_kind, kind)) {
                hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _right$2, kind, dst, bag);
                return;
              } else {
                return;
              }
            }
            default: {
              const _left$3 = _Binary._1;
              const _right$3 = _Binary._2;
              const _loc$9 = _Binary._4;
              _L$3: {
                _L$4: {
                  switch (_x$2) {
                    case 11: {
                      hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _left$3, bag);
                      hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _right$3, kind, dst, bag);
                      return;
                    }
                    case 12: {
                      break _L$4;
                    }
                    case 13: {
                      break _L$4;
                    }
                    case 14: {
                      break _L$4;
                    }
                    case 15: {
                      break _L$4;
                    }
                    case 1: {
                      break _L$3;
                    }
                    case 2: {
                      break _L$3;
                    }
                    case 3: {
                      break _L$3;
                    }
                    case 4: {
                      break _L$3;
                    }
                    default: {
                      hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: unsupported float binary operator");
                      return;
                    }
                  }
                }
                let tmp;
                let _try_err;
                _L$5: {
                  _L$6: {
                    const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                    if (_bind$4.$tag === 1) {
                      const _ok = _bind$4;
                      tmp = _ok._0;
                    } else {
                      const _err = _bind$4;
                      const _tmp$27 = _err._0;
                      _try_err = _tmp$27;
                      break _L$6;
                    }
                    break _L$5;
                  }
                  hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                  return undefined;
                }
                hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _left$3, kind, tmp, bag);
                hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _right$3, kind, dst, bag);
                if (is_double) {
                  hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, tmp);
                  hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 1, dst);
                } else {
                  hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, tmp);
                  hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 1, dst);
                }
                switch (_x$2) {
                  case 12: {
                    hackwaly$tinycc$backend$codegen$$emit_fadd(emitter, is_double, 0, 0, 1);
                    break;
                  }
                  case 13: {
                    hackwaly$tinycc$backend$codegen$$emit_fsub(emitter, is_double, 0, 0, 1);
                    break;
                  }
                  case 14: {
                    hackwaly$tinycc$backend$codegen$$emit_fmul(emitter, is_double, 0, 0, 1);
                    break;
                  }
                  case 15: {
                    hackwaly$tinycc$backend$codegen$$emit_fdiv(emitter, is_double, 0, 0, 1);
                    break;
                  }
                }
                if (is_double) {
                  hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, dst, 0);
                } else {
                  hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, dst, 0);
                }
                hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                return;
              }
              let addr;
              let _try_err;
              _L$4: {
                _L$5: {
                  const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$4.$tag === 1) {
                    const _ok = _bind$4;
                    addr = _ok._0;
                  } else {
                    const _err = _bind$4;
                    const _tmp$27 = _err._0;
                    _try_err = _tmp$27;
                    break _L$5;
                  }
                  break _L$4;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                return undefined;
              }
              hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, _left$3, addr, bag);
              let old;
              let _try_err$2;
              _L$5: {
                _L$6: {
                  const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$4.$tag === 1) {
                    const _ok = _bind$4;
                    old = _ok._0;
                  } else {
                    const _err = _bind$4;
                    const _tmp$27 = _err._0;
                    _try_err$2 = _tmp$27;
                    break _L$6;
                  }
                  break _L$5;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
                return undefined;
              }
              const size = is_double ? 8 : 4;
              const _bind$4 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(size);
              let sz;
              if (_bind$4 === undefined) {
                hackwaly$tinycc$support$diag$$add_error(bag, _loc$9, "codegen: unsupported float size");
                hackwaly$tinycc$backend$codegen$$give_reg(pool, old);
                hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
                return undefined;
              } else {
                const _Some = _bind$4;
                sz = _Some;
              }
              hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, sz, old, addr, $0L);
              hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _right$3, kind, dst, bag);
              if (is_double) {
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 0, old);
                hackwaly$tinycc$backend$codegen$$emit_fmov_x_to_d(emitter, 1, dst);
              } else {
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 0, old);
                hackwaly$tinycc$backend$codegen$$emit_fmov_w_to_s(emitter, 1, dst);
              }
              switch (_x$2) {
                case 1: {
                  hackwaly$tinycc$backend$codegen$$emit_fadd(emitter, is_double, 0, 0, 1);
                  break;
                }
                case 2: {
                  hackwaly$tinycc$backend$codegen$$emit_fsub(emitter, is_double, 0, 0, 1);
                  break;
                }
                case 3: {
                  hackwaly$tinycc$backend$codegen$$emit_fmul(emitter, is_double, 0, 0, 1);
                  break;
                }
                case 4: {
                  hackwaly$tinycc$backend$codegen$$emit_fdiv(emitter, is_double, 0, 0, 1);
                  break;
                }
              }
              if (is_double) {
                hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, dst, 0);
              } else {
                hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, dst, 0);
              }
              hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz, dst, addr, $0L);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, old);
              hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
              return;
            }
          }
        }
        case 10: {
          const _Cast = expr;
          const _to_ty = _Cast._0;
          const _inner$3 = _Cast._1;
          const _bind$5 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(_to_ty);
          let target_kind;
          if (_bind$5 === undefined) {
            target_kind = kind;
          } else {
            const _Some = _bind$5;
            target_kind = _Some;
          }
          hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _inner$3, target_kind, dst, bag);
          return;
        }
        case 19: {
          const _Call = expr;
          const _callee = _Call._0;
          const _args = _Call._1;
          const _loc$10 = _Call._3;
          hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, _callee, _args, _loc$10, bag);
          if (dst !== 0) {
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, 0);
            return;
          } else {
            return;
          }
        }
        case 18: {
          const _Conditional = expr;
          const _cond = _Conditional._0;
          const _then_expr = _Conditional._1;
          const _else_expr = _Conditional._2;
          const _loc$11 = _Conditional._4;
          hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond, bag);
          const br_else = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
          hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _then_expr, kind, dst, bag);
          const br_end = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
          const else_pc = emitter.code_len << 2;
          let _try_err$3;
          _L$6: {
            _L$7: {
              const _bind$6 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_else, else_pc, 0);
              if (_bind$6.$tag === 1) {
                const _ok = _bind$6;
                _ok._0;
              } else {
                const _err = _bind$6;
                const _tmp$27 = _err._0;
                _try_err$3 = _tmp$27;
                break _L$7;
              }
              break _L$6;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
          }
          hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, _else_expr, kind, dst, bag);
          const end_pc = emitter.code_len << 2;
          let _try_err$4;
          _L$7: {
            const _bind$6 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, br_end, end_pc);
            if (_bind$6.$tag === 1) {
              const _ok = _bind$6;
              _ok._0;
              return;
            } else {
              const _err = _bind$6;
              const _tmp$27 = _err._0;
              _try_err$4 = _tmp$27;
              break _L$7;
            }
          }
          hackwaly$tinycc$support$diag$$add_error(bag, _loc$11, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$4));
          return;
        }
        default: {
          break _L;
        }
      }
    }
    let addr;
    let _try_err;
    _L$3: {
      _L$4: {
        const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind.$tag === 1) {
          const _ok = _bind;
          addr = _ok._0;
        } else {
          const _err = _bind;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$4;
        }
        break _L$3;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      return undefined;
    }
    hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, expr, addr, bag);
    const size = is_double ? 8 : 4;
    const _bind = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(size);
    let sz;
    if (_bind === undefined) {
      hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported float size");
      hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
      return undefined;
    } else {
      const _Some = _bind;
      sz = _Some;
    }
    hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, sz, dst, addr, $0L);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
    return;
  }
  hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$frontend$ast$$expr_loc(expr), "codegen: unsupported float expression");
}
function hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, expr, bag) {
  let _tmp$27 = expr;
  _L: while (true) {
    const expr$2 = _tmp$27;
    if (expr$2.$tag === 17) {
      const _Binary = expr$2;
      const _x = _Binary._0;
      if (_x === 0) {
        hackwaly$tinycc$backend$codegen$$gen_expr_any(emitter, alloc, syms, pool, cstrings, expr$2, 0, bag);
        return undefined;
      }
    }
    const ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr$2);
    const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
    if (_bind.$tag === 0) {
      _L$2: {
        switch (expr$2.$tag) {
          case 10: {
            const _Cast = expr$2;
            const _inner = _Cast._1;
            _tmp$27 = _inner;
            continue _L;
          }
          case 19: {
            const _Call = expr$2;
            const _callee = _Call._0;
            const _args = _Call._1;
            const _loc = _Call._3;
            hackwaly$tinycc$backend$codegen$$gen_call_expr(emitter, alloc, syms, pool, cstrings, _callee, _args, _loc, bag);
            return;
          }
          case 17: {
            const _Binary = expr$2;
            const _x = _Binary._0;
            if (_x === 11) {
              const _left = _Binary._1;
              const _right = _Binary._2;
              hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _left, bag);
              _tmp$27 = _right;
              continue _L;
            } else {
              break _L$2;
            }
          }
          case 18: {
            const _Conditional = expr$2;
            const _cond = _Conditional._0;
            const _then_expr = _Conditional._1;
            const _else_expr = _Conditional._2;
            const _loc$2 = _Conditional._4;
            hackwaly$tinycc$backend$codegen$$gen_cond_expr_cmp_zero(emitter, alloc, syms, pool, cstrings, _cond, bag);
            const br_else = hackwaly$tinycc$backend$codegen$$emit_b_cond_placeholder(emitter, 0);
            hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _then_expr, bag);
            const br_end = hackwaly$tinycc$backend$arm64$$gjmp(emitter, 0);
            const else_pc = emitter.code_len << 2;
            let _try_err;
            _L$3: {
              _L$4: {
                const _bind$2 = hackwaly$tinycc$backend$codegen$$patch_b_cond(emitter, br_else, else_pc, 0);
                if (_bind$2.$tag === 1) {
                  const _ok = _bind$2;
                  _ok._0;
                } else {
                  const _err = _bind$2;
                  const _tmp$28 = _err._0;
                  _try_err = _tmp$28;
                  break _L$4;
                }
                break _L$3;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
            }
            hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, _else_expr, bag);
            const end_pc = emitter.code_len << 2;
            let _try_err$2;
            _L$4: {
              const _bind$2 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, br_end, end_pc);
              if (_bind$2.$tag === 1) {
                const _ok = _bind$2;
                _ok._0;
                return;
              } else {
                const _err = _bind$2;
                const _tmp$28 = _err._0;
                _try_err$2 = _tmp$28;
                break _L$4;
              }
            }
            hackwaly$tinycc$support$diag$$add_error(bag, _loc$2, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
            return;
          }
          case 12: {
            const _StmtExpr = expr$2;
            const _stmts = _StmtExpr._0;
            const _loc$3 = _StmtExpr._2;
            hackwaly$tinycc$backend$codegen$$gen_stmt_expr_with(emitter, alloc, syms, pool, cstrings, _stmts, 0, true, _loc$3, bag, (expr$3, _discard_) => {
              hackwaly$tinycc$backend$codegen$$gen_expr_discard(emitter, alloc, syms, pool, cstrings, expr$3, bag);
            });
            return;
          }
          default: {
            break _L$2;
          }
        }
      }
      hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, expr$2, ty, 0, bag);
      return;
    } else {
      if (hackwaly$tinycc$backend$codegen$$type_is_aggregate(ty)) {
        const loc = hackwaly$tinycc$frontend$ast$$expr_loc(expr$2);
        const _bind$2 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, ty, loc);
        let _bind$3;
        if (_bind$2 === undefined) {
          return undefined;
        } else {
          const _Some = _bind$2;
          _bind$3 = _Some;
        }
        const _size = _bind$3._0;
        if (_size <= 0) {
          return undefined;
        }
        const _bind$4 = alloc.agg_temp_offset;
        if (_bind$4 === undefined) {
          hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: missing aggregate temp slot");
          return;
        } else {
          const _Some = _bind$4;
          const _tmp_off = _Some;
          if (_size > alloc.agg_temp_size) {
            hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: aggregate temp too small");
            return undefined;
          }
          hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, expr$2, 29, _tmp_off, ty, loc, bag);
          return;
        }
      } else {
        hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, expr$2, ty, 0, bag);
        return;
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$gen_expr_any(emitter, alloc, syms, pool, cstrings, expr, dst, bag) {
  const ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr);
  hackwaly$tinycc$backend$codegen$$gen_expr_any_with_type(emitter, alloc, syms, pool, cstrings, expr, ty, dst, bag);
}
function hackwaly$tinycc$backend$codegen$$gen_stmt_expr_with(emitter, alloc, syms, pool, cstrings, stmts, dst, zero_is64, loc, bag, gen_last) {
  let did_scope = false;
  const loops = [];
  const switches = [];
  const breakables = [];
  const labels = alloc.labels;
  let chain = 0;
  const len = stmts.length;
  if (len === 0) {
    if (dst !== 0) {
      hackwaly$tinycc$backend$codegen$$emit_mov(emitter, zero_is64, dst, 31);
    }
    if (did_scope) {
      hackwaly$tinycc$backend$codegen$$cg_pop_scope_codegen(emitter, alloc);
    }
    return undefined;
  }
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      const stmt = moonbitlang$core$array$$Array$at$49$(stmts, i);
      if (!did_scope) {
        if (stmt.$tag === 16) {
          hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
          did_scope = true;
        }
      }
      if (i === (len - 1 | 0)) {
        if (stmt.$tag === 15) {
          const _ExprStmt = stmt;
          const _expr = _ExprStmt._0;
          gen_last(_expr, dst);
        } else {
          chain = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, stmt, bag, chain);
          if (dst !== 0) {
            hackwaly$tinycc$backend$codegen$$emit_mov(emitter, zero_is64, dst, 31);
          }
        }
      } else {
        chain = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, stmt, bag, chain);
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (chain !== 0) {
    let _try_err;
    _L: {
      _L$2: {
        const _bind = hackwaly$tinycc$backend$arm64$$gsym(emitter, chain);
        if (_bind.$tag === 1) {
          const _ok = _bind;
          _ok._0;
        } else {
          const _err = _bind;
          const _tmp$28 = _err._0;
          _try_err = _tmp$28;
          break _L$2;
        }
        break _L;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: return in statement expression not supported");
  }
  if (did_scope) {
    hackwaly$tinycc$backend$codegen$$cg_pop_scope_codegen(emitter, alloc);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits(emitter, alloc, syms, pool, cstrings, expr, target_kind, dst, bag) {
  const src_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, expr);
  hackwaly$tinycc$backend$codegen$$gen_expr_to_float_kind_bits_with_type(emitter, alloc, syms, pool, cstrings, expr, src_ty, target_kind, dst, bag);
}
function hackwaly$tinycc$backend$codegen$$store_lvalue_scalar(emitter, alloc, syms, pool, cstrings, lvalue, value_reg, value_ty, bag) {
  const loc = hackwaly$tinycc$frontend$ast$$expr_loc(lvalue);
  const _bind = hackwaly$tinycc$backend$codegen$$scalar_size_signed_or_error(alloc.sem, value_ty, loc);
  let _bind$2;
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    _bind$2 = _Some;
  }
  const _value_size = _bind$2._0;
  let saved_reg = undefined;
  let store_reg = value_reg;
  if (hackwaly$tinycc$frontend$ast$$expr_may_call(lvalue)) {
    let tmp;
    let _try_err;
    _L: {
      _L$2: {
        const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind$3.$tag === 1) {
          const _ok = _bind$3;
          tmp = _ok._0;
        } else {
          const _err = _bind$3;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$2;
        }
        break _L;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      return undefined;
    }
    hackwaly$tinycc$backend$codegen$$emit_mov(emitter, _value_size === 8, tmp, value_reg);
    saved_reg = tmp;
    store_reg = tmp;
  }
  const _bind$3 = hackwaly$tinycc$backend$codegen$$member_bitfield_info(alloc, lvalue);
  if (_bind$3 === undefined) {
  } else {
    const _Some = _bind$3;
    const _x = _Some;
    const _base = _x._0;
    const _is_arrow = _x._1;
    const _info = _x._2;
    let addr;
    let _try_err;
    _L: {
      _L$2: {
        const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind$4.$tag === 1) {
          const _ok = _bind$4;
          addr = _ok._0;
        } else {
          const _err = _bind$4;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$2;
        }
        break _L;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      const _bind$4 = saved_reg;
      if (_bind$4 === undefined) {
      } else {
        const _Some$2 = _bind$4;
        const _r = _Some$2;
        hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
      }
      return undefined;
    }
    hackwaly$tinycc$backend$codegen$$gen_member_base_addr(emitter, alloc, syms, pool, cstrings, _base, _is_arrow, addr, bag);
    hackwaly$tinycc$backend$codegen$$emit_bitfield_store(emitter, alloc, pool, addr, _info, store_reg, loc, bag);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
    const _bind$4 = saved_reg;
    if (_bind$4 === undefined) {
    } else {
      const _Some$2 = _bind$4;
      const _r = _Some$2;
      hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
    }
    return undefined;
  }
  if (lvalue.$tag === 4) {
    const _Ident = lvalue;
    const _name = _Ident._0;
    const _id = _Ident._1;
    const _bind$4 = hackwaly$tinycc$backend$codegen$$lookup_local(alloc, _name, _id);
    if (_bind$4 === undefined) {
      const _bind$5 = hackwaly$tinycc$backend$codegen$$lookup_static_local(alloc, _id);
      let sym;
      if (_bind$5 === undefined) {
        sym = hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, _name, _id);
      } else {
        const _Some = _bind$5;
        const _info = _Some;
        sym = hackwaly$tinycc$backend$codegen$$sym_for_static_local(syms, _info);
      }
      hackwaly$tinycc$backend$codegen$$emit_addr_global(emitter, syms, sym, 16);
      const _bind$6 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_value_size);
      let sz;
      if (_bind$6 === undefined) {
        hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported scalar size");
        const _bind$7 = saved_reg;
        if (_bind$7 === undefined) {
        } else {
          const _Some = _bind$7;
          const _r = _Some;
          hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
        }
        return undefined;
      } else {
        const _Some = _bind$6;
        sz = _Some;
      }
      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz, store_reg, 16, $0L);
    } else {
      const _Some = _bind$4;
      const _slot = _Some;
      hackwaly$tinycc$backend$codegen$$emit_store_local_scalar(emitter, alloc.sem, _slot.ty, store_reg, _slot.offset, loc, bag);
    }
  } else {
    let addr;
    let _try_err;
    _L: {
      _L$2: {
        const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind$4.$tag === 1) {
          const _ok = _bind$4;
          addr = _ok._0;
        } else {
          const _err = _bind$4;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$2;
        }
        break _L;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      const _bind$4 = saved_reg;
      if (_bind$4 === undefined) {
      } else {
        const _Some = _bind$4;
        const _r = _Some;
        hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
      }
      return undefined;
    }
    hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, lvalue, addr, bag);
    const _bind$4 = hackwaly$tinycc$backend$codegen$$arm64_sz_from_size(_value_size);
    let sz;
    if (_bind$4 === undefined) {
      hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported scalar size");
      hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
      const _bind$5 = saved_reg;
      if (_bind$5 === undefined) {
      } else {
        const _Some = _bind$5;
        const _r = _Some;
        hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
      }
      return undefined;
    } else {
      const _Some = _bind$4;
      sz = _Some;
    }
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, sz, store_reg, addr, $0L);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, addr);
  }
  const _bind$4 = saved_reg;
  if (_bind$4 === undefined) {
    return;
  } else {
    const _Some = _bind$4;
    const _r = _Some;
    hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_member_base_addr(emitter, alloc, syms, pool, cstrings, base, is_arrow, dst, bag) {
  if (is_arrow) {
    hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, base, dst, bag);
    return;
  } else {
    hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, base, dst, bag);
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_index_addr_with_elem_type(emitter, alloc, syms, pool, cstrings, base, index, dst, loc, bag) {
  hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, base, dst, bag);
  let base_reg = dst;
  let saved_reg = undefined;
  if (hackwaly$tinycc$frontend$ast$$expr_may_call(index) && dst < 19) {
    let tmp;
    let _try_err;
    _L: {
      _L$2: {
        const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
        if (_bind.$tag === 1) {
          const _ok = _bind;
          tmp = _ok._0;
        } else {
          const _err = _bind;
          const _tmp$27 = _err._0;
          _try_err = _tmp$27;
          break _L$2;
        }
        break _L;
      }
      hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
      return undefined;
    }
    hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, tmp, dst);
    base_reg = tmp;
    saved_reg = tmp;
  }
  let idx;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        idx = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    const _bind = saved_reg;
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _r = _Some;
      hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
    }
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, index, idx, bag, undefined);
  const idx_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, index);
  hackwaly$tinycc$backend$codegen$$emit_int_extend_to_64(emitter, alloc.sem, idx_ty, idx, loc, bag);
  const base_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, base);
  const _bind = hackwaly$tinycc$backend$codegen$$element_type_for_pointer_arith(base_ty);
  let elem_ty;
  if (_bind === undefined) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: index base is not pointer/array");
    hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
    const _bind$2 = saved_reg;
    if (_bind$2 === undefined) {
    } else {
      const _Some = _bind$2;
      const _r = _Some;
      hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
    }
    return undefined;
  } else {
    const _Some = _bind;
    elem_ty = _Some;
  }
  let elem_size_reg = undefined;
  let elem_size_const = undefined;
  _L$2: {
    _L$3: {
      const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(elem_ty);
      if (_bind$2.$tag === 5) {
        const _Array = _bind$2;
        const _x = _Array._1;
        if (_x === undefined) {
          const _x$2 = _Array._2;
          if (_x$2 === undefined) {
            break _L$3;
          } else {
            let scale;
            let _try_err$2;
            _L$4: {
              _L$5: {
                const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                if (_bind$3.$tag === 1) {
                  const _ok = _bind$3;
                  scale = _ok._0;
                } else {
                  const _err = _bind$3;
                  const _tmp$27 = _err._0;
                  _try_err$2 = _tmp$27;
                  break _L$5;
                }
                break _L$4;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
              const _bind$3 = saved_reg;
              if (_bind$3 === undefined) {
              } else {
                const _Some = _bind$3;
                const _r = _Some;
                hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
              }
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_type_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, elem_ty, scale, loc, bag);
            elem_size_reg = scale;
          }
        } else {
          break _L$3;
        }
      } else {
        break _L$3;
      }
      break _L$2;
    }
    const _bind$2 = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, elem_ty, loc);
    if (_bind$2 === undefined) {
      hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
      const _bind$3 = saved_reg;
      if (_bind$3 === undefined) {
      } else {
        const _Some = _bind$3;
        const _r = _Some;
        hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
      }
      return undefined;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _sz = _x._0;
      elem_size_const = _sz;
    }
  }
  const _bind$2 = elem_size_reg;
  if (_bind$2 === undefined) {
    const _bind$3 = elem_size_const;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _elem_size = _Some;
      if (_elem_size !== 1) {
        let scale;
        let _try_err$2;
        _L$3: {
          _L$4: {
            const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$4.$tag === 1) {
              const _ok = _bind$4;
              scale = _ok._0;
            } else {
              const _err = _bind$4;
              const _tmp$27 = _err._0;
              _try_err$2 = _tmp$27;
              break _L$4;
            }
            break _L$3;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
          hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
          const _bind$4 = saved_reg;
          if (_bind$4 === undefined) {
          } else {
            const _Some$2 = _bind$4;
            const _r = _Some$2;
            hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
          }
          return undefined;
        }
        hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(_elem_size));
        hackwaly$tinycc$backend$arm64$$emit32(emitter, -1694467072 | idx | idx << 5 | scale << 16);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
      }
    }
  } else {
    const _Some = _bind$2;
    const _scale = _Some;
    hackwaly$tinycc$backend$arm64$$emit32(emitter, -1694467072 | idx | idx << 5 | _scale << 16);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, _scale);
  }
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1962934272 | base_reg | base_reg << 5 | idx << 16);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, idx);
  const _bind$3 = saved_reg;
  if (_bind$3 === undefined) {
  } else {
    const _Some = _bind$3;
    const _r = _Some;
    if (base_reg !== dst) {
      hackwaly$tinycc$backend$codegen$$emit_mov(emitter, true, dst, base_reg);
    }
    hackwaly$tinycc$backend$codegen$$give_reg(pool, _r);
  }
  return elem_ty;
}
function hackwaly$tinycc$backend$codegen$$gen_type_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, ty, dst, loc, bag) {
  const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
  if (_bind.$tag === 5) {
    const _Array = _bind;
    const _elem_ty = _Array._0;
    const _x = _Array._1;
    if (_x === undefined) {
      const _x$2 = _Array._2;
      if (_x$2 === undefined) {
      } else {
        const _Some = _x$2;
        const _len_expr = _Some;
        hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, _len_expr, dst, bag, undefined);
        hackwaly$tinycc$backend$codegen$$emit_sxtw(emitter, dst, dst);
        let tmp;
        let _try_err;
        _L: {
          _L$2: {
            const _bind$2 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
            if (_bind$2.$tag === 1) {
              const _ok = _bind$2;
              tmp = _ok._0;
            } else {
              const _err = _bind$2;
              const _tmp$27 = _err._0;
              _try_err = _tmp$27;
              break _L$2;
            }
            break _L;
          }
          hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
          return undefined;
        }
        hackwaly$tinycc$backend$codegen$$gen_type_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, _elem_ty, tmp, loc, bag);
        hackwaly$tinycc$backend$arm64$$emit32(emitter, -1694467072 | dst | dst << 5 | tmp << 16);
        hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
        return undefined;
      }
    }
  }
  const _bind$2 = hackwaly$tinycc$sem$$type_size_align(alloc.sem, ty, loc);
  if (_bind$2 === undefined) {
  } else {
    const _Some = _bind$2;
    const _x = _Some;
    const _size = _x._0;
    hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, dst, moonbitlang$core$int$$Int$to_uint64(_size));
    return undefined;
  }
  _L: {
    const _bind$3 = hackwaly$tinycc$sem$$strip_top_qualifiers(ty);
    if (_bind$3.$tag === 5) {
      const _Array = _bind$3;
      const _elem_ty = _Array._0;
      const _x = _Array._1;
      if (_x === undefined) {
        break _L;
      } else {
        const _Some = _x;
        const _n = _Some;
        hackwaly$tinycc$backend$codegen$$gen_type_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, _elem_ty, dst, loc, bag);
        if (_n !== 1) {
          let scale;
          let _try_err;
          _L$2: {
            _L$3: {
              const _bind$4 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                scale = _ok._0;
              } else {
                const _err = _bind$4;
                const _tmp$27 = _err._0;
                _try_err = _tmp$27;
                break _L$3;
              }
              break _L$2;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
            return undefined;
          }
          hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, scale, moonbitlang$core$int$$Int$to_uint64(_n));
          hackwaly$tinycc$backend$arm64$$emit32(emitter, -1694467072 | dst | dst << 5 | scale << 16);
          hackwaly$tinycc$backend$codegen$$give_reg(pool, scale);
          return;
        } else {
          return;
        }
      }
    } else {
      break _L;
    }
  }
  hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: unsupported dynamic sizeof for type");
}
function hackwaly$tinycc$backend$codegen$$gen_member_addr_with_info(emitter, alloc, syms, pool, cstrings, base, base_ty, is_arrow, info, dst, loc, bag) {
  if (is_arrow) {
    hackwaly$tinycc$backend$codegen$$gen_expr_ptr(emitter, alloc, syms, pool, cstrings, base, dst, bag);
  } else {
    if (!hackwaly$tinycc$frontend$ast$$expr_is_lvalue_simple(base)) {
      _L: {
        _L$2: {
          const _bind = hackwaly$tinycc$sem$$strip_top_qualifiers(base_ty);
          switch (_bind.$tag) {
            case 6: {
              break _L$2;
            }
            case 7: {
              break _L$2;
            }
            default: {
              hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, base, dst, bag);
            }
          }
          break _L;
        }
        const _bind = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(alloc.sem, base_ty, loc);
        if (_bind === undefined) {
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _size = _x._0;
          const _bind$2 = alloc.agg_temp_offset;
          if (_bind$2 === undefined) {
            hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: missing aggregate temp slot");
          } else {
            const _Some$2 = _bind$2;
            const _tmp_off = _Some$2;
            if (_size > alloc.agg_temp_size) {
              hackwaly$tinycc$support$diag$$add_error(bag, loc, "codegen: aggregate temp too small");
              return undefined;
            }
            hackwaly$tinycc$backend$codegen$$gen_agg_expr_to_addr(emitter, alloc, syms, pool, cstrings, base, 29, _tmp_off, base_ty, loc, bag);
            hackwaly$tinycc$backend$codegen$$emit_addr_local(emitter, dst, _tmp_off, loc, bag);
          }
        }
      }
    } else {
      hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, base, dst, bag);
    }
  }
  const off = info.offset;
  if (off !== 0) {
    if (off >= 0 && off <= 4095) {
      hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862270976 | dst | dst << 5 | off << 10);
      return;
    } else {
      let tmp;
      let _try_err;
      _L: {
        _L$2: {
          const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
          if (_bind.$tag === 1) {
            const _ok = _bind;
            tmp = _ok._0;
          } else {
            const _err = _bind;
            const _tmp$27 = _err._0;
            _try_err = _tmp$27;
            break _L$2;
          }
          break _L;
        }
        hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
        return undefined;
      }
      const imm = off < 0 ? -off | 0 : off;
      hackwaly$tinycc$backend$arm64$$arm64_movimm(emitter, tmp, moonbitlang$core$int$$Int$to_uint64(imm));
      const base_inst = off < 0 ? -889192448 : -1962934272;
      hackwaly$tinycc$backend$arm64$$emit32(emitter, base_inst | dst | dst << 5 | tmp << 16);
      hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
      return;
    }
  } else {
    return;
  }
}
function hackwaly$tinycc$backend$codegen$$gen_vla_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, elem_ty, size_expr, dst, loc, bag) {
  hackwaly$tinycc$backend$codegen$$gen_type_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(elem_ty, undefined, size_expr), dst, loc, bag);
}
function hackwaly$tinycc$backend$codegen$$gen_builtin_alloca(emitter, alloc, syms, pool, cstrings, args, loc, bag) {
  if (args.length !== 1) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "__builtin_alloca expects 1 argument");
    return undefined;
  }
  let size_reg;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        size_reg = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$gen_expr_int32(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 0), size_reg, bag, undefined);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862270976 | size_reg | size_reg << 5 | 15360);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1837306880 | size_reg | size_reg << 5);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -887069697 | size_reg << 16);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862269984);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, size_reg);
}
function hackwaly$tinycc$backend$codegen$$gen_builtin_va_copy(emitter, alloc, syms, pool, cstrings, args, loc, bag) {
  if (args.length < 2) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "__builtin_va_copy expects 2 arguments");
    return undefined;
  }
  let src_addr;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        src_addr = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 1), src_addr, bag);
  let tmp;
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        tmp = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$2 = _tmp$27;
        break _L$3;
      }
      break _L$2;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
    hackwaly$tinycc$backend$codegen$$give_reg(pool, src_addr);
    return undefined;
  }
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, src_addr, $0L);
  let dst_addr;
  let _try_err$3;
  _L$3: {
    _L$4: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        dst_addr = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$3 = _tmp$27;
        break _L$4;
      }
      break _L$3;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$3));
    hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
    hackwaly$tinycc$backend$codegen$$give_reg(pool, src_addr);
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 0), dst_addr, bag);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, dst_addr, $0L);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, dst_addr);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, src_addr);
}
function hackwaly$tinycc$backend$codegen$$gen_builtin_va_start(emitter, alloc, syms, pool, cstrings, args, loc, bag) {
  if (args.length < 1) {
    hackwaly$tinycc$support$diag$$add_error(bag, loc, "__builtin_va_start expects an ap argument");
    return undefined;
  }
  let ap_addr;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        ap_addr = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$gen_lvalue_addr(emitter, alloc, syms, pool, cstrings, moonbitlang$core$array$$Array$at$55$(args, 0), ap_addr, bag);
  let base;
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        base = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$2 = _tmp$27;
        break _L$3;
      }
      break _L$2;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err$2));
    hackwaly$tinycc$backend$codegen$$give_reg(pool, ap_addr);
    return undefined;
  }
  const stack_offset = 16 + alloc.varargs_stack_size | 0;
  hackwaly$tinycc$backend$codegen$$emit_addr_reg(emitter, base, 29, stack_offset, loc, bag);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, base, ap_addr, $0L);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, base);
  hackwaly$tinycc$backend$codegen$$give_reg(pool, ap_addr);
}
function hackwaly$tinycc$backend$codegen$$gen_call_direct$46$inner(emitter, alloc, syms, pool, cstrings, name, id, args, sret, loc, bag) {
  let sig;
  if (id > 0) {
    const _bind = hackwaly$tinycc$sem$$get_function_by_id(alloc.sem, id);
    if (_bind === undefined) {
      sig = moonbitlang$core$hashmap$$HashMap$get$160$(alloc.sem.functions, name);
    } else {
      const _Some = _bind;
      const _found = _Some;
      sig = _found;
    }
  } else {
    sig = moonbitlang$core$hashmap$$HashMap$get$160$(alloc.sem.functions, name);
  }
  let fixed_count = 0;
  let is_varargs = false;
  let ret_ty = hackwaly$tinycc$sem$$default_int_type();
  if (sig === undefined) {
    ret_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Call(new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Ident(name, id, 0, loc), args, 0, loc));
  } else {
    const _Some = sig;
    const _s = _Some;
    fixed_count = _s.params.length;
    is_varargs = _s.varargs;
    ret_ty = _s.return_type;
  }
  const is_varargs_call = is_varargs && args.length > fixed_count;
  const variadic_index = is_varargs_call ? fixed_count : 0;
  let arg_tys = [];
  let use_sig_params = false;
  if (sig === undefined) {
    const built = moonbitlang$core$array$$Array$new$46$inner$29$(args.length);
    let i = 0;
    while (true) {
      if (i < args.length) {
        const arg = moonbitlang$core$array$$Array$at$55$(args, i);
        const param_ty = hackwaly$tinycc$sem$$type_of_expr(alloc.sem, arg);
        const store_ty = is_varargs_call && i >= fixed_count ? hackwaly$tinycc$backend$codegen$$promote_vararg_type(param_ty) : param_ty;
        moonbitlang$core$array$$Array$push$29$(built, store_ty);
        i = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    arg_tys = built;
  } else {
    const _Some = sig;
    const _s = _Some;
    if (!_s.varargs && (!_s.is_old_style && args.length === _s.params.length)) {
      arg_tys = _s.params;
      use_sig_params = true;
    } else {
      const built = moonbitlang$core$array$$Array$new$46$inner$29$(args.length);
      let i = 0;
      while (true) {
        if (i < args.length) {
          const arg = moonbitlang$core$array$$Array$at$55$(args, i);
          const param_ty = i < _s.params.length ? moonbitlang$core$array$$Array$at$29$(_s.params, i) : hackwaly$tinycc$sem$$type_of_expr(alloc.sem, arg);
          const store_ty = is_varargs_call && i >= fixed_count ? hackwaly$tinycc$backend$codegen$$promote_vararg_type(param_ty) : param_ty;
          moonbitlang$core$array$$Array$push$29$(built, store_ty);
          i = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      arg_tys = built;
    }
  }
  const sym = hackwaly$tinycc$backend$codegen$$sym_for_ident$46$inner(syms, name, id);
  const emit_call_fn = () => {
    hackwaly$tinycc$backend$codegen$$emit_call(emitter, sym);
  };
  let cached_layout = undefined;
  if (use_sig_params && id > 0) {
    hackwaly$tinycc$backend$codegen$$ensure_call_layout_capacity(syms, id);
    const idx = id - 1 | 0;
    const _bind = moonbitlang$core$array$$Array$at$66$(syms.call_layout_cache, idx);
    if (_bind === undefined) {
      const layout = hackwaly$tinycc$backend$codegen$$arm64_pcs(alloc.sem, variadic_index, ret_ty, arg_tys, loc, bag);
      moonbitlang$core$array$$Array$set$66$(syms.call_layout_cache, idx, layout);
      cached_layout = layout;
    } else {
      const _Some = _bind;
      const _layout = _Some;
      cached_layout = _layout;
    }
  }
  hackwaly$tinycc$backend$codegen$$gen_call_with_layout(emitter, alloc, syms, pool, cstrings, args, arg_tys, ret_ty, variadic_index, sret, loc, bag, emit_call_fn, cached_layout);
  return ret_ty;
}
function hackwaly$tinycc$backend$codegen$$gen_call_expr_with_sret(emitter, alloc, syms, pool, cstrings, callee, args, sret_reg, sret_off, loc, bag) {
  hackwaly$tinycc$backend$codegen$$gen_call_expr_impl(emitter, alloc, syms, pool, cstrings, callee, args, { base_reg: sret_reg, off: sret_off }, loc, bag);
}
function hackwaly$tinycc$backend$codegen$$gen_switch_body(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, stmt, bag, return_chain, case_addrs, default_addr, next_case) {
  let _tmp$27 = stmt;
  let _tmp$28 = default_addr;
  let _tmp$29 = next_case;
  _L: while (true) {
    const stmt$2 = _tmp$27;
    const default_addr$2 = _tmp$28;
    const next_case$2 = _tmp$29;
    let default_addr0 = default_addr$2;
    let next_case0 = next_case$2;
    switch (stmt$2.$tag) {
      case 6: {
        const _Case = stmt$2;
        const _case_body = _Case._2;
        if (next_case0 < case_addrs.length) {
          moonbitlang$core$array$$Array$set$26$(case_addrs, next_case0, emitter.code_len << 2);
          next_case0 = next_case0 + 1 | 0;
        }
        const _bind = hackwaly$tinycc$backend$codegen$$gen_switch_body(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _case_body, bag, return_chain, case_addrs, default_addr0, next_case0);
        const _chain = _bind._0;
        const _new_default = _bind._1;
        const _new_next = _bind._2;
        return { _0: _chain, _1: _new_default, _2: _new_next };
      }
      case 7: {
        const _Default = stmt$2;
        const _def_body = _Default._0;
        default_addr0 = emitter.code_len << 2;
        const _bind$2 = hackwaly$tinycc$backend$codegen$$gen_switch_body(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, _def_body, bag, return_chain, case_addrs, default_addr0, next_case0);
        const _chain$2 = _bind$2._0;
        const _new_default$2 = _bind$2._1;
        const _new_next$2 = _bind$2._2;
        return { _0: _chain$2, _1: _new_default$2, _2: _new_next$2 };
      }
      case 0: {
        const _Compound = stmt$2;
        const _stmts = _Compound._0;
        let did_scope = false;
        let chain = return_chain;
        const _len = _stmts.length;
        let _tmp$30 = 0;
        while (true) {
          const _i = _tmp$30;
          if (_i < _len) {
            const s = _stmts[_i];
            if (!did_scope) {
              if (s.$tag === 16) {
                hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
                did_scope = true;
              }
            }
            const _bind$3 = hackwaly$tinycc$backend$codegen$$gen_switch_body(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, s, bag, chain, case_addrs, default_addr0, next_case0);
            const _new_chain = _bind$3._0;
            const _new_default$3 = _bind$3._1;
            const _new_next$3 = _bind$3._2;
            chain = _new_chain;
            default_addr0 = _new_default$3;
            next_case0 = _new_next$3;
            _tmp$30 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (did_scope) {
          hackwaly$tinycc$backend$codegen$$cg_pop_scope_codegen(emitter, alloc);
        }
        return { _0: chain, _1: default_addr0, _2: next_case0 };
      }
      case 5: {
        const chain$2 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, stmt$2, bag, return_chain);
        return { _0: chain$2, _1: default_addr0, _2: next_case0 };
      }
      case 8: {
        const _Label = stmt$2;
        const _name = _Label._0;
        const _body = _Label._1;
        const _loc = _Label._2;
        const addr = emitter.code_len << 2;
        const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$156$(labels.addrs, _name);
        if (_bind$3 === undefined) {
        } else {
          hackwaly$tinycc$support$diag$$add_error(bag, _loc, "codegen: duplicate label");
        }
        const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$156$(labels.chains, _name);
        if (_bind$4 === undefined) {
        } else {
          const _Some = _bind$4;
          const _chain$3 = _Some;
          if (_chain$3 !== 0) {
            let _try_err;
            _L$2: {
              _L$3: {
                const _bind$5 = hackwaly$tinycc$backend$arm64$$gsym_addr(emitter, _chain$3, addr);
                if (_bind$5.$tag === 1) {
                  const _ok = _bind$5;
                  _ok._0;
                } else {
                  const _err = _bind$5;
                  const _tmp$31 = _err._0;
                  _try_err = _tmp$31;
                  break _L$3;
                }
                break _L$2;
              }
              hackwaly$tinycc$support$diag$$add_error(bag, _loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
            }
          }
        }
        moonbitlang$core$hashmap$$HashMap$set$156$(labels.addrs, _name, addr);
        moonbitlang$core$hashmap$$HashMap$set$156$(labels.chains, _name, 0);
        const _bind$5 = hackwaly$tinycc$backend$codegen$$current_scope_vla_loc(alloc);
        if (_bind$5 === undefined) {
        } else {
          const _Some = _bind$5;
          const _off = _Some;
          hackwaly$tinycc$backend$codegen$$emit_vla_sp_restore(emitter, _off);
        }
        _tmp$27 = _body;
        _tmp$28 = default_addr0;
        _tmp$29 = next_case0;
        continue _L;
      }
      default: {
        const chain$3 = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, labels, cstrings, stmt$2, bag, return_chain);
        return { _0: chain$3, _1: default_addr0, _2: next_case0 };
      }
    }
  }
}
function hackwaly$tinycc$backend$codegen$$gen_vla_alloc_to_local_slot(emitter, alloc, syms, pool, cstrings, slot_offset, size_slot_offset, array_ty, loc, bag) {
  let bytes_reg;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$backend$codegen$$take_reg(pool);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        bytes_reg = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
    return undefined;
  }
  hackwaly$tinycc$backend$codegen$$gen_type_size_bytes_to_reg(emitter, alloc, syms, pool, cstrings, array_ty, bytes_reg, loc, bag);
  if (size_slot_offset === undefined) {
  } else {
    const _Some = size_slot_offset;
    const _off = _Some;
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, bytes_reg, 29, moonbitlang$core$int$$Int$to_int64(_off));
  }
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862270976 | bytes_reg | bytes_reg << 5 | 15360);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1837306880 | bytes_reg | bytes_reg << 5);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -887069697 | bytes_reg << 16);
  hackwaly$tinycc$backend$arm64$$emit32(emitter, -1862269984 | bytes_reg);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, bytes_reg, 29, moonbitlang$core$int$$Int$to_int64(slot_offset));
  hackwaly$tinycc$backend$codegen$$give_reg(pool, bytes_reg);
}
function hackwaly$tinycc$backend$codegen$$new_local_alloc_with_compound_slots(sem, ret_ty, func_name, static_locals, compound_literal_slots) {
  return { sem: sem, ret_ty: ret_ty, ret_loc: undefined, used_bytes: 0, varargs_stack_size: 0, scopes: [], vla_scopes: [], local_values: hackwaly$tinycc$backend$codegen$$fast_map_new$174$(undefined), local_overrides: [], local_id_values: hackwaly$tinycc$backend$codegen$$fast_map_new$175$(undefined), local_id_overrides: [], static_locals: static_locals, func_name: func_name, labels: hackwaly$tinycc$backend$codegen$$new_label_ctx(), compound_literal_slots: compound_literal_slots, agg_temp_offset: undefined, agg_temp_size: 0, agg_temp_align: 1, sret_offset: undefined };
}
function hackwaly$tinycc$backend$codegen$$new_reg_pool() {
  return { free: [9, 10, 11, 12, 13, 14, 15, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28] };
}
function hackwaly$tinycc$backend$codegen$$gen_func_def(emitter, sem, syms, func_offsets, label_addrs_by_func, cstrings, static_locals, func, bag) {
  const link = hackwaly$tinycc$backend$codegen$$link_name(func.name);
  hackwaly$tinycc$backend$codegen$$sym_for_name(syms, link);
  const start = emitter.code_len << 2;
  moonbitlang$core$hashmap$$HashMap$set$156$(func_offsets, link, start);
  const plan = hackwaly$tinycc$backend$codegen$$compute_frame_plan(sem, func, static_locals, bag);
  const frame_size = plan.frame_size;
  const alloc = hackwaly$tinycc$backend$codegen$$new_local_alloc_with_compound_slots(sem, func.return_type, func.name, static_locals, plan.compound_literal_slots);
  hackwaly$tinycc$backend$codegen$$cg_push_scope(alloc);
  const param_tys = plan.param_tys;
  alloc.ret_loc = plan.ret_loc;
  hackwaly$tinycc$backend$codegen$$reserve_sret_slot(alloc, func.loc, bag);
  hackwaly$tinycc$backend$codegen$$emit_prologue(emitter, frame_size);
  const pool = hackwaly$tinycc$backend$codegen$$new_reg_pool();
  const _bind = alloc.sret_offset;
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _off = _Some;
    hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, 8, 29, moonbitlang$core$int$$Int$to_int64(_off));
  }
  if (func.varargs) {
    alloc.varargs_stack_size = plan.stack_size;
  } else {
    alloc.varargs_stack_size = 0;
  }
  const arg_locs = plan.arg_locs;
  let i = 0;
  while (true) {
    if (i < func.params.length) {
      const p = moonbitlang$core$array$$Array$at$28$(func.params, i);
      const param_ty = moonbitlang$core$array$$Array$at$29$(param_tys, i);
      const _p$28 = moonbitlang$core$array$$Array$get$26$(arg_locs, i);
      const _p$29 = 0;
      let loc_i;
      if (_p$28 === undefined) {
        loc_i = _p$29;
      } else {
        const _p$30 = _p$28;
        loc_i = _p$30;
      }
      const byref = (loc_i & 1) !== 0;
      const slot = byref ? hackwaly$tinycc$backend$codegen$$alloc_local_byref(alloc, p.name, p.id, param_ty) : hackwaly$tinycc$backend$codegen$$alloc_local(alloc, p.name, p.id, param_ty, p.loc);
      if (slot === undefined) {
      } else {
        const _Some = slot;
        const _slot = _Some;
        if (byref) {
          if (loc_i < 16) {
            hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, loc_i >> 1, 29, moonbitlang$core$int$$Int$to_int64(_slot.offset));
          } else {
            if (loc_i >= 32) {
              const stack_off = (loc_i & -2) - 32 | 0;
              let tmp;
              let _try_err;
              _L: {
                _L$2: {
                  const _bind$2 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                  if (_bind$2.$tag === 1) {
                    const _ok = _bind$2;
                    tmp = _ok._0;
                  } else {
                    const _err = _bind$2;
                    const _tmp$27 = _err._0;
                    _try_err = _tmp$27;
                    break _L$2;
                  }
                  break _L;
                }
                hackwaly$tinycc$support$diag$$add_error(bag, p.loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                i = i + 1 | 0;
                continue;
              }
              hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 3, tmp, 29, moonbitlang$core$int$$Int$to_int64(16 + stack_off | 0));
              hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, 29, moonbitlang$core$int$$Int$to_int64(_slot.offset));
              hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
            }
          }
        } else {
          if (loc_i < 16) {
            const reg = loc_i >> 1;
            _L: {
              _L$2: {
                const _bind$2 = hackwaly$tinycc$sem$$strip_top_qualifiers(_slot.ty);
                switch (_bind$2.$tag) {
                  case 6: {
                    break _L$2;
                  }
                  case 7: {
                    break _L$2;
                  }
                  default: {
                    hackwaly$tinycc$backend$codegen$$emit_store_local_scalar(emitter, alloc.sem, _slot.ty, reg, _slot.offset, p.loc, bag);
                  }
                }
                break _L;
              }
              const _bind$2 = hackwaly$tinycc$backend$codegen$$slot_type_size_align(alloc, _slot, p.loc);
              if (_bind$2 === undefined) {
              } else {
                const _Some$2 = _bind$2;
                const _x = _Some$2;
                const _size = _x._0;
                hackwaly$tinycc$backend$codegen$$emit_store_gp_regs_to_addr(emitter, reg, reg + 1 | 0, _size, 29, _slot.offset, p.loc, bag);
              }
            }
          } else {
            if (loc_i < 32) {
              const fp_reg = (loc_i >> 1) - 8 | 0;
              const _bind$2 = hackwaly$tinycc$backend$codegen$$arm64_hfa(alloc.sem, _slot.ty, p.loc, bag);
              if (_bind$2 === undefined) {
                const _bind$3 = hackwaly$tinycc$backend$codegen$$float_kind_of_type(_slot.ty);
                if (_bind$3 === undefined) {
                } else {
                  const _Some$2 = _bind$3;
                  const _k = _Some$2;
                  if (moonbitlang$core$builtin$$Eq$equal$83$(_k, 1) || moonbitlang$core$builtin$$Eq$equal$83$(_k, 2)) {
                    hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, 16, fp_reg);
                  } else {
                    hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, 16, fp_reg);
                  }
                  hackwaly$tinycc$backend$codegen$$emit_store_local_scalar(emitter, alloc.sem, _slot.ty, 16, _slot.offset, p.loc, bag);
                }
              } else {
                const _Some$2 = _bind$2;
                const _x = _Some$2;
                const _count = _x._0;
                const _fsize = _x._1;
                let j = 0;
                while (true) {
                  if (j < _count) {
                    let tmp;
                    let _try_err;
                    _L: {
                      _L$2: {
                        const _bind$3 = hackwaly$tinycc$backend$codegen$$take_reg(pool);
                        if (_bind$3.$tag === 1) {
                          const _ok = _bind$3;
                          tmp = _ok._0;
                        } else {
                          const _err = _bind$3;
                          const _tmp$27 = _err._0;
                          _try_err = _tmp$27;
                          break _L$2;
                        }
                        break _L;
                      }
                      hackwaly$tinycc$support$diag$$add_error(bag, p.loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
                      j = _count;
                      continue;
                    }
                    if (_fsize === 8) {
                      hackwaly$tinycc$backend$codegen$$emit_fmov_d_to_x(emitter, tmp, fp_reg + j | 0);
                      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 3, tmp, 29, moonbitlang$core$int$$Int$to_int64(_slot.offset + (Math.imul(j, 8) | 0) | 0));
                    } else {
                      hackwaly$tinycc$backend$codegen$$emit_fmov_s_to_w(emitter, tmp, fp_reg + j | 0);
                      hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 2, tmp, 29, moonbitlang$core$int$$Int$to_int64(_slot.offset + (Math.imul(j, 4) | 0) | 0));
                    }
                    hackwaly$tinycc$backend$codegen$$give_reg(pool, tmp);
                    j = j + 1 | 0;
                    continue;
                  } else {
                    break;
                  }
                }
              }
            } else {
              if (loc_i >= 32) {
                const _bind$2 = hackwaly$tinycc$backend$codegen$$slot_type_size_align(alloc, _slot, p.loc);
                if (_bind$2 === undefined) {
                } else {
                  const _Some$2 = _bind$2;
                  const _x = _Some$2;
                  const _size = _x._0;
                  if (_size > 0) {
                    const stack_off = (loc_i & -2) - 32 | 0;
                    hackwaly$tinycc$backend$codegen$$emit_copy_bytes(emitter, pool, 29, 16 + stack_off | 0, 29, _slot.offset, _size, p.loc, bag);
                  }
                }
              }
            }
          }
        }
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  alloc.agg_temp_size = plan.agg_temp_size;
  alloc.agg_temp_align = plan.agg_temp_align;
  alloc.agg_temp_offset = plan.agg_temp_offset;
  if (plan.used_bytes_after_hidden > alloc.used_bytes) {
    alloc.used_bytes = plan.used_bytes_after_hidden;
  }
  const loops = [];
  const switches = [];
  const breakables = [];
  const return_chain = hackwaly$tinycc$backend$codegen$$gen_stmt(emitter, alloc, syms, pool, loops, switches, breakables, alloc.labels, cstrings, func.body, bag, 0);
  hackwaly$tinycc$backend$codegen$$cg_pop_scope(alloc);
  let _try_err;
  _L: {
    _L$2: {
      const _bind$2 = hackwaly$tinycc$backend$arm64$$gsym(emitter, return_chain);
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _ok._0;
      } else {
        const _err = _bind$2;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    hackwaly$tinycc$support$diag$$add_error(bag, func.loc, moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
  }
  hackwaly$tinycc$backend$codegen$$emit_restore_sp_to_frame_base(emitter, frame_size);
  hackwaly$tinycc$backend$codegen$$emit_epilogue(emitter, frame_size);
  moonbitlang$core$hashmap$$HashMap$set$157$(label_addrs_by_func, func.name, alloc.labels.addrs);
}
function hackwaly$tinycc$backend$codegen$$new_cstring_pool(capacity) {
  return { order: moonbitlang$core$array$$Array$new$46$inner$19$(capacity), syms: hackwaly$tinycc$backend$codegen$$fast_map_new$172$(capacity) };
}
function hackwaly$tinycc$backend$codegen$$new_symtab_with_capacity(capacity) {
  const cap = capacity > 0 ? capacity : 0;
  return { names: moonbitlang$core$array$$Array$new$46$inner$19$(cap), name_to_id: hackwaly$tinycc$backend$codegen$$fast_map_new$156$(cap), externals: hackwaly$tinycc$backend$codegen$$fast_map_new$170$(cap), link_cache: hackwaly$tinycc$backend$codegen$$fast_map_new$171$(cap), ident_syms: moonbitlang$core$array$$Array$new$46$inner$57$(cap), call_layout_cache: moonbitlang$core$array$$Array$new$46$inner$66$(cap) };
}
function hackwaly$tinycc$backend$codegen$$static_local_func_name(base_name) {
  if (!moonbitlang$core$string$$String$has_prefix(base_name, { str: hackwaly$tinycc$backend$codegen$$static_local_func_name$46$prefix$124$3500, start: 0, end: hackwaly$tinycc$backend$codegen$$static_local_func_name$46$prefix$124$3500.length })) {
    return undefined;
  }
  const start = hackwaly$tinycc$backend$codegen$$static_local_func_name$46$prefix$124$3500.length;
  const len = base_name.length;
  let i = start;
  while (true) {
    if (i < len) {
      const _tmp$27 = i;
      $bound_check(base_name, _tmp$27);
      const _p$28 = base_name.charCodeAt(_tmp$27);
      const _p$29 = 46;
      if (_p$28 === _p$29) {
        return moonbitlang$core$builtin$$Show$to_string$12$(moonbitlang$core$string$$String$view$46$inner(base_name, start, i));
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$backend$codegen$$string_has_nul(value) {
  const len = value.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      $bound_check(value, i);
      const _p$28 = value.charCodeAt(i);
      const _p$29 = 0;
      if (_p$28 === _p$29) {
        return true;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      return false;
    }
  }
}
function hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem(unit, sem, bag) {
  if (hackwaly$tinycc$support$diag$$has_errors(bag)) {
    return undefined;
  }
  const decl_count = unit.decls.length;
  let func_count = 0;
  let main_found = false;
  const func_defs = moonbitlang$core$array$$Array$new$46$inner$98$(decl_count);
  const var_decls = moonbitlang$core$array$$Array$new$46$inner$99$(decl_count);
  const external_symbols = moonbitlang$core$array$$Array$new$46$inner$100$(decl_count);
  const _arr = unit.decls;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const decl = _arr[_i];
      switch (decl.$tag) {
        case 0: {
          const _FuncDef = decl;
          const _func = _FuncDef._0;
          func_count = func_count + 1 | 0;
          if (_func.name === "main") {
            main_found = true;
          }
          moonbitlang$core$array$$Array$push$98$(func_defs, _func);
          break;
        }
        case 2: {
          const _Var = decl;
          const _var_decl = _Var._0;
          moonbitlang$core$array$$Array$push$99$(var_decls, _var_decl);
          const link = hackwaly$tinycc$backend$codegen$$link_name(_var_decl.name);
          moonbitlang$core$array$$Array$push$100$(external_symbols, { _0: link, _1: moonbitlang$core$builtin$$Eq$equal$79$(_var_decl.storage, 1) });
          break;
        }
        case 1: {
          const _FuncDecl = decl;
          const _func_decl = _FuncDecl._0;
          const link$2 = hackwaly$tinycc$backend$codegen$$link_name(_func_decl.name);
          moonbitlang$core$array$$Array$push$100$(external_symbols, { _0: link$2, _1: true });
          break;
        }
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const static_locals_by_func = hackwaly$tinycc$backend$codegen$$fast_map_new$154$(undefined);
  const static_local_init_maps = hackwaly$tinycc$backend$codegen$$fast_map_new$154$(undefined);
  const static_local_decls = moonbitlang$core$array$$Array$new$46$inner$99$(decl_count);
  const _len$2 = func_defs.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len$2) {
      const func = func_defs[_i];
      const func_id = func.id;
      let has_static_locals;
      if (func_id > 0) {
        const _p$28 = hackwaly$tinycc$backend$codegen$$get_opt_by_id$67$(sem.func_has_static_local_by_id, func_id);
        const _p$29 = false;
        has_static_locals = _p$28 === -1 ? _p$29 : _p$28;
      } else {
        const _p$28 = moonbitlang$core$hashmap$$HashMap$get$161$(sem.func_has_static_local, func.name);
        const _p$29 = false;
        has_static_locals = _p$28 === -1 ? _p$29 : _p$28;
      }
      if (has_static_locals) {
        const func_locals = hackwaly$tinycc$backend$codegen$$fast_map_new$155$(undefined);
        hackwaly$tinycc$backend$codegen$$collect_static_locals_in_stmt(func.name, func.body, func_locals, static_local_decls, static_local_init_maps);
        moonbitlang$core$hashmap$$HashMap$set$154$(static_locals_by_func, func.name, func_locals);
      }
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _len$3 = static_local_decls.length;
  let _tmp$29 = 0;
  while (true) {
    const _i = _tmp$29;
    if (_i < _len$3) {
      const decl = static_local_decls[_i];
      moonbitlang$core$array$$Array$push$99$(var_decls, decl);
      _tmp$29 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const empty_static_locals = hackwaly$tinycc$backend$codegen$$fast_map_new$155$(undefined);
  const total_decl_count = decl_count + static_local_decls.length | 0;
  const sym_capacity = total_decl_count > 0 ? Math.imul(total_decl_count, 2) | 0 : 0;
  const syms = hackwaly$tinycc$backend$codegen$$new_symtab_with_capacity(sym_capacity);
  const _len$4 = external_symbols.length;
  let _tmp$30 = 0;
  while (true) {
    const _i = _tmp$30;
    if (_i < _len$4) {
      const pair = external_symbols[_i];
      const _name = pair._0;
      const _is_ext = pair._1;
      const sym = hackwaly$tinycc$backend$codegen$$sym_for_name(syms, _name);
      moonbitlang$core$hashmap$$HashMap$set$170$(syms.externals, sym.id, _is_ext);
      _tmp$30 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const base_capacity = Math.imul(func_count, 256) | 0;
  const expr_capacity = Math.imul(sem.expr_type_cache.length, 2) | 0;
  const code_capacity = expr_capacity > base_capacity ? expr_capacity : base_capacity;
  const reloc_capacity = Math.imul(func_count, 16) | 0;
  const emitter = hackwaly$tinycc$backend$arm64$$new_arm64_emitter_with_capacity(code_capacity, reloc_capacity);
  const func_offsets = hackwaly$tinycc$backend$codegen$$fast_map_new$156$(func_count);
  const label_addrs_by_func = hackwaly$tinycc$backend$codegen$$fast_map_new$157$(func_count);
  const cstring_pool = hackwaly$tinycc$backend$codegen$$new_cstring_pool(total_decl_count);
  if (main_found) {
    const _len$5 = func_defs.length;
    let _tmp$31 = 0;
    while (true) {
      const _i = _tmp$31;
      if (_i < _len$5) {
        const func = func_defs[_i];
        if (func.name === "main") {
          const _bind = moonbitlang$core$hashmap$$HashMap$get$154$(static_locals_by_func, func.name);
          let func_statics;
          if (_bind === undefined) {
            func_statics = empty_static_locals;
          } else {
            const _Some = _bind;
            func_statics = _Some;
          }
          hackwaly$tinycc$backend$codegen$$gen_func_def(emitter, sem, syms, func_offsets, label_addrs_by_func, cstring_pool, func_statics, func, bag);
        }
        _tmp$31 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  const _len$5 = func_defs.length;
  let _tmp$31 = 0;
  while (true) {
    const _i = _tmp$31;
    if (_i < _len$5) {
      const func = func_defs[_i];
      let _tmp$32;
      if (!main_found) {
        _tmp$32 = true;
      } else {
        const _p$28 = func.name;
        const _p$29 = "main";
        _tmp$32 = !(_p$28 === _p$29);
      }
      if (_tmp$32) {
        const _bind = moonbitlang$core$hashmap$$HashMap$get$154$(static_locals_by_func, func.name);
        let func_statics;
        if (_bind === undefined) {
          func_statics = empty_static_locals;
        } else {
          const _Some = _bind;
          func_statics = _Some;
        }
        hackwaly$tinycc$backend$codegen$$gen_func_def(emitter, sem, syms, func_offsets, label_addrs_by_func, cstring_pool, func_statics, func, bag);
      }
      _tmp$31 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (hackwaly$tinycc$support$diag$$has_errors(bag)) {
    return undefined;
  }
  const data_words = [];
  const data_relocs = [];
  let data_align = 4;
  let bss_size = 0;
  let bss_align = 4;
  const def_symbols = hackwaly$tinycc$backend$codegen$$fast_map_new$158$(Math.imul(decl_count, 2) | 0);
  const _len$6 = var_decls.length;
  let _tmp$32 = 0;
  while (true) {
    const _i = _tmp$32;
    if (_i < _len$6) {
      _L: {
        const var_decl = var_decls[_i];
        const link = hackwaly$tinycc$backend$codegen$$link_name(var_decl.name);
        hackwaly$tinycc$backend$codegen$$sym_for_name(syms, link);
        let is_extern_decl;
        if (moonbitlang$core$builtin$$Eq$equal$79$(var_decl.storage, 1)) {
          const _bind = var_decl.init;
          is_extern_decl = _bind === undefined;
        } else {
          is_extern_decl = false;
        }
        if (is_extern_decl) {
          if (!moonbitlang$core$hashmap$$HashMap$contains$158$(def_symbols, link)) {
            const _p$28 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, link);
            const _p$29 = 0;
            let id;
            if (_p$28 === undefined) {
              id = _p$29;
            } else {
              const _p$30 = _p$28;
              id = _p$30;
            }
            moonbitlang$core$hashmap$$HashMap$set$158$(def_symbols, link, { id: id, name: link, section: undefined, value: 0, is_external: true });
            moonbitlang$core$hashmap$$HashMap$set$170$(syms.externals, id, true);
          }
        } else {
          const global_ty = var_decl.id > 0 ? hackwaly$tinycc$sem$$get_global_by_id(sem, var_decl.id) : undefined;
          let var_ty;
          if (global_ty === undefined) {
            const _bind = moonbitlang$core$hashmap$$HashMap$get$159$(sem.globals, var_decl.name);
            if (_bind === undefined) {
              var_ty = var_decl.ty;
            } else {
              const _Some = _bind;
              var_ty = _Some;
            }
          } else {
            const _Some = global_ty;
            var_ty = _Some;
          }
          const _bind = hackwaly$tinycc$backend$codegen$$type_size_align_or_error(sem, var_ty, var_decl.loc);
          let _bind$2;
          if (_bind === undefined) {
            break _L;
          } else {
            const _Some = _bind;
            _bind$2 = _Some;
          }
          const _size = _bind$2._0;
          const _align = _bind$2._1;
          const _bind$3 = var_decl.init;
          if (_bind$3 === undefined) {
            const aligned = hackwaly$tinycc$backend$codegen$$align_up(bss_size, _align);
            bss_size = aligned + _size | 0;
            if (_align > bss_align) {
              bss_align = _align;
            }
            const _p$28 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, link);
            const _p$29 = 0;
            let id;
            if (_p$28 === undefined) {
              id = _p$29;
            } else {
              const _p$30 = _p$28;
              id = _p$30;
            }
            const _p$30 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, link);
            const _p$31 = 0;
            let _tmp$33;
            if (_p$30 === undefined) {
              _tmp$33 = _p$31;
            } else {
              const _p$32 = _p$30;
              _tmp$33 = _p$32;
            }
            moonbitlang$core$hashmap$$HashMap$set$158$(def_symbols, link, { id: _tmp$33, name: link, section: hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14381, value: aligned, is_external: moonbitlang$core$builtin$$Eq$not_equal$78$(var_decl.storage, 2) });
            moonbitlang$core$hashmap$$HashMap$set$170$(syms.externals, id, false);
          } else {
            const _Some = _bind$3;
            const _init = _Some;
            const data_off = hackwaly$tinycc$backend$codegen$$align_up(data_words.length << 2, _align);
            const _bind$4 = moonbitlang$core$hashmap$$HashMap$get$154$(static_local_init_maps, var_decl.name);
            let init_locals;
            if (_bind$4 === undefined) {
              init_locals = empty_static_locals;
            } else {
              const _Some$2 = _bind$4;
              init_locals = _Some$2;
            }
            const _bind$5 = hackwaly$tinycc$backend$codegen$$static_local_func_name(var_decl.name);
            let label_ctx;
            if (_bind$5 === undefined) {
              label_ctx = undefined;
            } else {
              const _Some$2 = _bind$5;
              const _func_name = _Some$2;
              const _bind$6 = moonbitlang$core$hashmap$$HashMap$get$157$(label_addrs_by_func, _func_name);
              if (_bind$6 === undefined) {
                label_ctx = undefined;
              } else {
                const _Some$3 = _bind$6;
                const _labels = _Some$3;
                const _bind$7 = moonbitlang$core$hashmap$$HashMap$get$156$(func_offsets, hackwaly$tinycc$backend$codegen$$link_name(_func_name));
                if (_bind$7 === undefined) {
                  label_ctx = undefined;
                } else {
                  const _Some$4 = _bind$7;
                  const _func_start = _Some$4;
                  const func_sym = hackwaly$tinycc$backend$codegen$$sym_for_name(syms, hackwaly$tinycc$backend$codegen$$link_name(_func_name));
                  label_ctx = { func_sym: func_sym, func_start: _func_start, labels: _labels };
                }
              }
            }
            const _bind$6 = hackwaly$tinycc$backend$codegen$$build_global_initializer_bytes$46$inner(sem, syms, cstring_pool, init_locals, var_ty, _init, bag, label_ctx);
            if (_bind$6 === undefined) {
            } else {
              const _Some$2 = _bind$6;
              const _x = _Some$2;
              const _bytes = _x._0;
              const _rels = _x._1;
              while (true) {
                if (data_words.length << 2 < data_off) {
                  moonbitlang$core$array$$Array$push$24$(data_words, 0);
                  continue;
                } else {
                  break;
                }
              }
              let i = 0;
              while (true) {
                if (i < _bytes.length) {
                  let word = 0;
                  let j = 0;
                  while (true) {
                    if (j < 4 && (i + j | 0) < _bytes.length) {
                      word = word | (moonbitlang$core$array$$Array$at$26$(_bytes, i + j | 0) & 255) << ((j & 3) << 3);
                      j = j + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                  moonbitlang$core$array$$Array$push$24$(data_words, word);
                  i = i + 4 | 0;
                  continue;
                } else {
                  break;
                }
              }
              const _len$7 = _rels.length;
              let _tmp$33 = 0;
              while (true) {
                const _i$2 = _tmp$33;
                if (_i$2 < _len$7) {
                  const rel = _rels[_i$2];
                  moonbitlang$core$array$$Array$push$104$(data_relocs, { offset: data_off + rel.offset | 0, kind: rel.kind, sym: rel.sym, addend: rel.addend });
                  _tmp$33 = _i$2 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              const _p$28 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, link);
              const _p$29 = 0;
              let id;
              if (_p$28 === undefined) {
                id = _p$29;
              } else {
                const _p$30 = _p$28;
                id = _p$30;
              }
              moonbitlang$core$hashmap$$HashMap$set$158$(def_symbols, link, { id: id, name: link, section: hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14382, value: data_off, is_external: moonbitlang$core$builtin$$Eq$not_equal$78$(var_decl.storage, 2) });
              moonbitlang$core$hashmap$$HashMap$set$170$(syms.externals, id, false);
              if (_align > data_align) {
                data_align = _align;
              }
            }
          }
        }
        break _L;
      }
      _tmp$32 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const cstring_entries = moonbitlang$core$array$$Array$new$46$inner$101$(cstring_pool.order.length);
  const rodata_entries = moonbitlang$core$array$$Array$new$46$inner$101$(cstring_pool.order.length);
  let i = 0;
  while (true) {
    if (i < cstring_pool.order.length) {
      const value = moonbitlang$core$array$$Array$at$19$(cstring_pool.order, i);
      const entry = { index: i, value: value };
      if (hackwaly$tinycc$backend$codegen$$string_has_nul(value)) {
        moonbitlang$core$array$$Array$push$101$(rodata_entries, entry);
      } else {
        moonbitlang$core$array$$Array$push$101$(cstring_entries, entry);
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _bind = hackwaly$tinycc$backend$codegen$$build_string_section(cstring_entries, ".cstring", 1);
  const _cstring_offsets = _bind._0;
  const _cstring_section = _bind._1;
  const _bind$2 = hackwaly$tinycc$backend$codegen$$build_string_section(rodata_entries, ".rodata", 4);
  const _rodata_offsets = _bind$2._0;
  const _rodata_section = _bind$2._1;
  const _len$7 = cstring_entries.length;
  let _tmp$33 = 0;
  while (true) {
    const _i = _tmp$33;
    if (_i < _len$7) {
      const entry = cstring_entries[_i];
      const name = `_L_.str.${moonbitlang$core$builtin$$Show$to_string$90$(entry.index)}`;
      const _p$28 = moonbitlang$core$hashmap$$HashMap$get$156$(_cstring_offsets, entry.value);
      const _p$29 = 0;
      let off;
      if (_p$28 === undefined) {
        off = _p$29;
      } else {
        const _p$30 = _p$28;
        off = _p$30;
      }
      const _p$30 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, name);
      const _p$31 = 0;
      let id;
      if (_p$30 === undefined) {
        id = _p$31;
      } else {
        const _p$32 = _p$30;
        id = _p$32;
      }
      moonbitlang$core$hashmap$$HashMap$set$158$(def_symbols, name, { id: id, name: name, section: hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14383, value: off, is_external: false });
      moonbitlang$core$hashmap$$HashMap$set$170$(syms.externals, id, false);
      _tmp$33 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _len$8 = rodata_entries.length;
  let _tmp$34 = 0;
  while (true) {
    const _i = _tmp$34;
    if (_i < _len$8) {
      const entry = rodata_entries[_i];
      const name = `_L_.str.${moonbitlang$core$builtin$$Show$to_string$90$(entry.index)}`;
      const _p$28 = moonbitlang$core$hashmap$$HashMap$get$156$(_rodata_offsets, entry.value);
      const _p$29 = 0;
      let off;
      if (_p$28 === undefined) {
        off = _p$29;
      } else {
        const _p$30 = _p$28;
        off = _p$30;
      }
      const _p$30 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, name);
      const _p$31 = 0;
      let id;
      if (_p$30 === undefined) {
        id = _p$31;
      } else {
        const _p$32 = _p$30;
        id = _p$32;
      }
      moonbitlang$core$hashmap$$HashMap$set$158$(def_symbols, name, { id: id, name: name, section: hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14384, value: off, is_external: false });
      moonbitlang$core$hashmap$$HashMap$set$170$(syms.externals, id, false);
      _tmp$34 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$2 = unit.decls;
  const _len$9 = _arr$2.length;
  let _tmp$35 = 0;
  while (true) {
    const _i = _tmp$35;
    if (_i < _len$9) {
      const decl = _arr$2[_i];
      if (decl.$tag === 0) {
        const _FuncDef = decl;
        const _func = _FuncDef._0;
        const link = hackwaly$tinycc$backend$codegen$$link_name(_func.name);
        hackwaly$tinycc$backend$codegen$$sym_for_name(syms, link);
        const _p$28 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, link);
        const _p$29 = 0;
        let id;
        if (_p$28 === undefined) {
          id = _p$29;
        } else {
          const _p$30 = _p$28;
          id = _p$30;
        }
        const is_ext = moonbitlang$core$builtin$$Eq$not_equal$78$(_func.storage, 2);
        const _p$30 = moonbitlang$core$hashmap$$HashMap$get$156$(func_offsets, link);
        const _p$31 = 0;
        let _tmp$36;
        if (_p$30 === undefined) {
          _tmp$36 = _p$31;
        } else {
          const _p$32 = _p$30;
          _tmp$36 = _p$32;
        }
        moonbitlang$core$hashmap$$HashMap$set$158$(def_symbols, link, { id: id, name: link, section: hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem$46$constr$47$14385, value: _tmp$36, is_external: is_ext });
        moonbitlang$core$hashmap$$HashMap$set$170$(syms.externals, id, false);
      }
      _tmp$35 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const ordered_names = moonbitlang$core$array$$Array$new$46$inner$19$(syms.names.length);
  let i$2 = 0;
  while (true) {
    if (i$2 < syms.names.length) {
      const name = moonbitlang$core$array$$Array$at$19$(syms.names, i$2);
      const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$158$(def_symbols, name);
      if (_bind$3 === undefined) {
      } else {
        const _Some = _bind$3;
        const _sym = _Some;
        const _bind$4 = _sym.section;
        if (_bind$4 === undefined) {
        } else {
          const _Some$2 = _bind$4;
          const _sec = _Some$2;
          if (_sec === ".text") {
            moonbitlang$core$array$$Array$push$19$(ordered_names, name);
          }
        }
      }
      i$2 = i$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  i$2 = 0;
  while (true) {
    if (i$2 < syms.names.length) {
      const name = moonbitlang$core$array$$Array$at$19$(syms.names, i$2);
      let is_text = false;
      const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$158$(def_symbols, name);
      if (_bind$3 === undefined) {
      } else {
        const _Some = _bind$3;
        const _sym = _Some;
        const _bind$4 = _sym.section;
        if (_bind$4 === undefined) {
        } else {
          const _Some$2 = _bind$4;
          const _sec = _Some$2;
          if (_sec === ".text") {
            is_text = true;
          }
        }
      }
      if (!is_text) {
        moonbitlang$core$array$$Array$push$19$(ordered_names, name);
      }
      i$2 = i$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const symbols = moonbitlang$core$array$$Array$new$46$inner$31$(ordered_names.length);
  i$2 = 0;
  while (true) {
    if (i$2 < ordered_names.length) {
      const name = moonbitlang$core$array$$Array$at$19$(ordered_names, i$2);
      const _p$28 = moonbitlang$core$hashmap$$HashMap$get$156$(syms.name_to_id, name);
      const _p$29 = 0;
      let id;
      if (_p$28 === undefined) {
        id = _p$29;
      } else {
        const _p$30 = _p$28;
        id = _p$30;
      }
      const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$158$(def_symbols, name);
      if (_bind$3 === undefined) {
        moonbitlang$core$array$$Array$push$31$(symbols, { id: id, name: name, section: undefined, value: 0, is_external: true });
      } else {
        const _Some = _bind$3;
        const _sym = _Some;
        moonbitlang$core$array$$Array$push$31$(symbols, { id: id, name: name, section: _sym.section, value: _sym.value, is_external: _sym.is_external });
      }
      i$2 = i$2 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const text = hackwaly$tinycc$backend$arm64$$section_from_emitter_take(".text", emitter);
  const sections = [text];
  if (_rodata_section === undefined) {
  } else {
    const _Some = _rodata_section;
    const _sec = _Some;
    moonbitlang$core$array$$Array$push$107$(sections, _sec);
  }
  if (_cstring_section === undefined) {
  } else {
    const _Some = _cstring_section;
    const _sec = _Some;
    moonbitlang$core$array$$Array$push$107$(sections, _sec);
  }
  if (data_words.length > 0) {
    moonbitlang$core$array$$Array$push$107$(sections, { name: ".data", data: data_words, relocs: data_relocs, align: data_align, size_bytes: data_words.length << 2 });
  }
  if (bss_size > 0) {
    moonbitlang$core$array$$Array$push$107$(sections, { name: ".bss", data: [], relocs: [], align: bss_align, size_bytes: bss_size });
  }
  return hackwaly$tinycc$backend$macho$$encode_macho_object(sections, symbols);
}
function hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_from_ast(unit, bag) {
  const sem = hackwaly$tinycc$sem$$check_translation_unit(unit, bag);
  if (hackwaly$tinycc$support$diag$$has_errors(bag)) {
    return undefined;
  }
  return hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem(unit, sem, bag);
}
function hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes(unit, bag) {
  return hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_from_ast(unit, bag);
}
function hackwaly$tinycc$backend$codegen$$emit_load_local_int32(emitter, dst, off) {
  const off_u64 = moonbitlang$core$int$$Int$to_int64(off);
  hackwaly$tinycc$backend$arm64$$arm64_ldrx(emitter, false, 2, dst, 29, off_u64);
}
function hackwaly$tinycc$backend$codegen$$emit_store_local_int32(emitter, src, off) {
  const off_u64 = moonbitlang$core$int$$Int$to_int64(off);
  hackwaly$tinycc$backend$arm64$$arm64_strx(emitter, 2, src, 29, off_u64);
}
function hackwaly$tinycc$backend$codegen$$touch_unused_symbols() {
  ({ _0: 27, _1: hackwaly$tinycc$backend$arm64$$treg_r, _2: hackwaly$tinycc$backend$arm64$$treg_f, _3: hackwaly$tinycc$backend$arm64$$greloc, _4: hackwaly$tinycc$backend$arm64$$gind, _5: hackwaly$tinycc$backend$arm64$$gjmp_append, _6: hackwaly$tinycc$backend$arm64$$gen_fill_nops, _7: hackwaly$tinycc$backend$arm64$$arm64_vset_VT_CMP, _8: hackwaly$tinycc$backend$arm64$$gjmp_cond, _9: hackwaly$tinycc$backend$arm64$$arm64_ldrs, _10: hackwaly$tinycc$backend$arm64$$arm64_strv, _11: hackwaly$tinycc$backend$codegen$$emit_fcmp, _12: hackwaly$tinycc$backend$codegen$$emit_cset_from_fp_tok, _13: hackwaly$tinycc$backend$codegen$$emit_load_local_int32, _14: hackwaly$tinycc$backend$codegen$$emit_store_local_int32, _15: hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes, _16: 144, _17: 145, _18: 4, _19: 4194304, _20: hackwaly$tinycc$backend$arm64$$vdup, _21: hackwaly$tinycc$support$diag$$format_diag, _22: hackwaly$tinycc$backend$object$$new_section, _23: hackwaly$tinycc$backend$arm64$$section_from_emitter, _24: hackwaly$tinycc$backend$object$$reloc_addend, _25: hackwaly$tinycc$sem$$type_contains_vla, _26: hackwaly$tinycc$sem$$strip_qualifiers, _27: hackwaly$tinycc$sem$$strip_qual_attrs });
}
function hackwaly$tinycc$driver$cli$$print_usage() {
  moonbitlang$core$builtin$$println$19$("usage: tinycc.mbt [-c] [-run] [-bench] [-o OUT] [-I PATH]... [-isystem PATH]... [-L PATH]... [-l LIB]... [-D NAME[=VALUE]]... [-U NAME]... FILE...");
}
function hackwaly$tinycc$driver$cli$$split_define_spec(spec) {
  if (spec === "") {
    return undefined;
  }
  const len = spec.length;
  let i = 0;
  while (true) {
    if (i < len) {
      const _tmp$27 = i;
      $bound_check(spec, _tmp$27);
      const _p$28 = spec.charCodeAt(_tmp$27);
      const _p$29 = 61;
      if (_p$28 === _p$29) {
        const name = hackwaly$tinycc$support$util$$slice_string(spec, 0, i);
        const value = hackwaly$tinycc$support$util$$slice_string(spec, i + 1 | 0, len);
        return { _0: name, _1: value };
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: spec, _1: undefined };
}
function hackwaly$tinycc$driver$cli$$is_cli_whitespace(code) {
  return code === 32 || (code === 9 || (code === 10 || code === 13));
}
function hackwaly$tinycc$driver$cli$$split_listfile_args(contents) {
  const args = [];
  const len = contents.length;
  let i = 0;
  while (true) {
    if (i < len) {
      while (true) {
        let _tmp$27;
        if (i < len) {
          const _tmp$28 = i;
          $bound_check(contents, _tmp$28);
          _tmp$27 = hackwaly$tinycc$driver$cli$$is_cli_whitespace(contents.charCodeAt(_tmp$28));
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          i = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (i >= len) {
        break;
      }
      const start = i;
      while (true) {
        let _tmp$27;
        if (i < len) {
          const _tmp$28 = i;
          $bound_check(contents, _tmp$28);
          _tmp$27 = !hackwaly$tinycc$driver$cli$$is_cli_whitespace(contents.charCodeAt(_tmp$28));
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          i = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$array$$Array$push$19$(args, hackwaly$tinycc$support$util$$slice_string(contents, start, i));
      continue;
    } else {
      break;
    }
  }
  return args;
}
function hackwaly$tinycc$driver$cli$$expand_cli_args(host, args) {
  const expanded = [];
  let i = 0;
  while (true) {
    if (i < args.length) {
      const arg = moonbitlang$core$array$$Array$at$19$(args, i);
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$expand_cli_args$46$42$bind$124$125, start: 0, end: hackwaly$tinycc$driver$cli$$expand_cli_args$46$42$bind$124$125.length }) && arg.length > 1) {
        const path = hackwaly$tinycc$support$util$$slice_string(arg, 1, arg.length);
        let contents;
        let _try_err;
        _L: {
          _L$2: {
            const _bind = host.method_table.method_1(host.self, path);
            if (_bind.$tag === 1) {
              const _ok = _bind;
              contents = _ok._0;
            } else {
              const _err = _bind;
              const _tmp$27 = _err._0;
              _try_err = _tmp$27;
              break _L$2;
            }
            break _L;
          }
          moonbitlang$core$builtin$$println$19$(`error: failed to read argument file '${path}': ${moonbitlang$core$builtin$$Show$to_string$92$(_try_err)}`);
          return Option$None$29$;
        }
        const _arr = hackwaly$tinycc$driver$cli$$split_listfile_args(contents);
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const item = _arr[_i];
            moonbitlang$core$array$$Array$push$19$(expanded, item);
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      } else {
        moonbitlang$core$array$$Array$push$19$(expanded, arg);
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Option$Some$29$(expanded);
}
function hackwaly$tinycc$driver$cli$$is_c_source_path(path) {
  return moonbitlang$core$string$$String$has_suffix(path, { str: hackwaly$tinycc$driver$cli$$is_c_source_path$46$42$bind$124$131, start: 0, end: hackwaly$tinycc$driver$cli$$is_c_source_path$46$42$bind$124$131.length }) || moonbitlang$core$string$$String$has_suffix(path, { str: hackwaly$tinycc$driver$cli$$is_c_source_path$46$42$bind$124$132, start: 0, end: hackwaly$tinycc$driver$cli$$is_c_source_path$46$42$bind$124$132.length });
}
function hackwaly$tinycc$driver$cli$$parse_cli_args(host, args) {
  const _bind = hackwaly$tinycc$driver$cli$$expand_cli_args(host, args);
  let expanded;
  if (_bind.$tag === 0) {
    return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
  } else {
    const _Some = _bind;
    expanded = _Some._0;
  }
  const include_paths = [];
  const link_paths = [];
  const link_libs = [];
  const link_inputs = [];
  const inputs = [];
  const run_args = [];
  const macro_actions = [];
  let output = undefined;
  let compile_only = false;
  let run = false;
  let bench = false;
  let i = 1;
  let run_input = false;
  while (true) {
    if (i < expanded.length) {
      const arg = moonbitlang$core$array$$Array$at$19$(expanded, i);
      if (run && run_input) {
        moonbitlang$core$array$$Array$push$19$(run_args, arg);
        i = i + 1 | 0;
        continue;
      }
      if (run && !run_input) {
        if (arg === "--") {
          i = i + 1 | 0;
          while (true) {
            if (i < expanded.length) {
              moonbitlang$core$array$$Array$push$19$(run_args, moonbitlang$core$array$$Array$at$19$(expanded, i));
              i = i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          break;
        }
        let _tmp$27;
        if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$135, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$135.length })) {
          const _p$28 = "-";
          _tmp$27 = !(arg === _p$28);
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          moonbitlang$core$builtin$$println$19$(`error: unsupported option after -run '${arg}'`);
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        moonbitlang$core$array$$Array$push$19$(inputs, arg);
        run_input = true;
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-h" || arg === "--help") {
        hackwaly$tinycc$driver$cli$$print_usage();
        return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Help;
      }
      if (arg === "-c") {
        compile_only = true;
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-run") {
        run = true;
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-bench") {
        bench = true;
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-o") {
        if ((i + 1 | 0) >= expanded.length) {
          moonbitlang$core$builtin$$println$19$("error: missing argument for -o");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        output = moonbitlang$core$array$$Array$at$19$(expanded, i + 1 | 0);
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$136, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$136.length }) && arg.length > 2) {
        output = hackwaly$tinycc$support$util$$slice_string(arg, 2, arg.length);
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-I") {
        if ((i + 1 | 0) >= expanded.length) {
          moonbitlang$core$builtin$$println$19$("error: missing argument for -I");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        moonbitlang$core$array$$Array$push$19$(include_paths, moonbitlang$core$array$$Array$at$19$(expanded, i + 1 | 0));
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$137, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$137.length }) && arg.length > 2) {
        moonbitlang$core$array$$Array$push$19$(include_paths, hackwaly$tinycc$support$util$$slice_string(arg, 2, arg.length));
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-D") {
        if ((i + 1 | 0) >= expanded.length) {
          moonbitlang$core$builtin$$println$19$("error: missing argument for -D");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        const _bind$2 = hackwaly$tinycc$driver$cli$$split_define_spec(moonbitlang$core$array$$Array$at$19$(expanded, i + 1 | 0));
        if (_bind$2 === undefined) {
          moonbitlang$core$builtin$$println$19$("error: empty macro name in -D");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _name = _x._0;
          const _value = _x._1;
          if (_name === "") {
            moonbitlang$core$builtin$$println$19$("error: empty macro name in -D");
            hackwaly$tinycc$driver$cli$$print_usage();
            return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
          } else {
            moonbitlang$core$array$$Array$push$106$(macro_actions, new $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Define(_name, _value));
          }
        }
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$145, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$145.length }) && arg.length > 2) {
        const _bind$2 = hackwaly$tinycc$driver$cli$$split_define_spec(hackwaly$tinycc$support$util$$slice_string(arg, 2, arg.length));
        if (_bind$2 === undefined) {
          moonbitlang$core$builtin$$println$19$("error: empty macro name in -D");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _name = _x._0;
          const _value = _x._1;
          if (_name === "") {
            moonbitlang$core$builtin$$println$19$("error: empty macro name in -D");
            hackwaly$tinycc$driver$cli$$print_usage();
            return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
          } else {
            moonbitlang$core$array$$Array$push$106$(macro_actions, new $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Define(_name, _value));
          }
        }
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-U") {
        if ((i + 1 | 0) >= expanded.length) {
          moonbitlang$core$builtin$$println$19$("error: missing argument for -U");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        const name = moonbitlang$core$array$$Array$at$19$(expanded, i + 1 | 0);
        if (name === "") {
          moonbitlang$core$builtin$$println$19$("error: empty macro name in -U");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        moonbitlang$core$array$$Array$push$106$(macro_actions, new $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Undef(name));
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$153, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$153.length }) && arg.length > 2) {
        const name = hackwaly$tinycc$support$util$$slice_string(arg, 2, arg.length);
        if (name === "") {
          moonbitlang$core$builtin$$println$19$("error: empty macro name in -U");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        moonbitlang$core$array$$Array$push$106$(macro_actions, new $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliMacroAction$Undef(name));
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$154, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$154.length }) || moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$155, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$155.length })) {
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$156, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$156.length }) || moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$157, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$157.length })) {
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-fPIC" || arg === "-fpic") {
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$158, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$158.length })) {
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$159, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$159.length })) {
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-isystem") {
        if ((i + 1 | 0) >= expanded.length) {
          moonbitlang$core$builtin$$println$19$("error: missing argument for -isystem");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        moonbitlang$core$array$$Array$push$19$(include_paths, moonbitlang$core$array$$Array$at$19$(expanded, i + 1 | 0));
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$160, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$160.length }) && arg.length > 8) {
        moonbitlang$core$array$$Array$push$19$(include_paths, hackwaly$tinycc$support$util$$slice_string(arg, 8, arg.length));
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-L") {
        if ((i + 1 | 0) >= expanded.length) {
          moonbitlang$core$builtin$$println$19$("error: missing argument for -L");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        moonbitlang$core$array$$Array$push$19$(link_paths, moonbitlang$core$array$$Array$at$19$(expanded, i + 1 | 0));
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$161, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$161.length }) && arg.length > 2) {
        moonbitlang$core$array$$Array$push$19$(link_paths, hackwaly$tinycc$support$util$$slice_string(arg, 2, arg.length));
        i = i + 1 | 0;
        continue;
      }
      if (arg === "-l") {
        if ((i + 1 | 0) >= expanded.length) {
          moonbitlang$core$builtin$$println$19$("error: missing argument for -l");
          hackwaly$tinycc$driver$cli$$print_usage();
          return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
        }
        moonbitlang$core$array$$Array$push$19$(link_libs, moonbitlang$core$array$$Array$at$19$(expanded, i + 1 | 0));
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$162, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$162.length }) && arg.length > 2) {
        moonbitlang$core$array$$Array$push$19$(link_libs, hackwaly$tinycc$support$util$$slice_string(arg, 2, arg.length));
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$string$$String$has_prefix(arg, { str: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$163, start: 0, end: hackwaly$tinycc$driver$cli$$parse_cli_args$46$42$bind$124$163.length })) {
        moonbitlang$core$builtin$$println$19$(`error: unsupported option '${arg}'`);
        hackwaly$tinycc$driver$cli$$print_usage();
        return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
      }
      if (hackwaly$tinycc$driver$cli$$is_c_source_path(arg)) {
        moonbitlang$core$array$$Array$push$19$(inputs, arg);
      } else {
        moonbitlang$core$array$$Array$push$19$(link_inputs, arg);
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (run && compile_only) {
    moonbitlang$core$builtin$$println$19$("error: -run cannot be combined with -c");
    return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
  }
  if (run && !run_input) {
    moonbitlang$core$builtin$$println$19$("error: -run requires an input file");
    return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
  }
  if (inputs.length === 0) {
    moonbitlang$core$builtin$$println$19$("error: no input files");
    hackwaly$tinycc$driver$cli$$print_usage();
    return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
  }
  const _bind$2 = output;
  if (_bind$2 === undefined) {
  } else {
    if (inputs.length !== 1) {
      moonbitlang$core$builtin$$println$19$("error: -o requires exactly one input file");
      return $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Error;
    }
  }
  return new $64$hackwaly$47$tinycc$47$driver$47$cli$46$CliParse$Run({ include_paths: include_paths, link_paths: link_paths, link_libs: link_libs, link_inputs: link_inputs, inputs: inputs, output: output, compile_only: compile_only, run: run, run_args: run_args, bench: bench, macro_actions: macro_actions });
}
function hackwaly$tinycc$support$intern$intern_core$$tok_hash_step(h, code) {
  return (((((h >>> 0) + (h << 5 >>> 0) | 0) >>> 0) + ((h >>> 27 | 0) >>> 0) | 0) >>> 0) + (code >>> 0) | 0;
}
function hackwaly$tinycc$support$intern$intern_core$$tok_hash_view(view) {
  const len = view.end - view.start | 0;
  let h = 1;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < len) {
      const code = moonbitlang$core$string$$StringView$at(view, i);
      h = hackwaly$tinycc$support$intern$intern_core$$tok_hash_step(h, code);
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return h;
}
function hackwaly$tinycc$support$intern$intern_core$$new_string_interner_with_capacity(capacity) {
  if (capacity === undefined) {
    return { buckets: moonbitlang$core$array$$Array$make$26$(65536, 0), next_by_id: [], strings: [], views: [], hashes: [] };
  } else {
    const _Some = capacity;
    const _value = _Some;
    const cap = _value > 0 ? _value : 0;
    return { buckets: moonbitlang$core$array$$Array$make$26$(65536, 0), next_by_id: moonbitlang$core$array$$Array$new$46$inner$26$(cap), strings: moonbitlang$core$array$$Array$new$46$inner$19$(cap), views: moonbitlang$core$array$$Array$new$46$inner$12$(cap), hashes: moonbitlang$core$array$$Array$new$46$inner$24$(cap) };
  }
}
function hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id_hash(self, view, hash) {
  const bucket = hash & 65535;
  const len = view.end - view.start | 0;
  let id = moonbitlang$core$array$$Array$at$26$(self.buckets, bucket);
  while (true) {
    if (id !== 0) {
      if (moonbitlang$core$array$$Array$at$24$(self.hashes, id - 1 | 0) === hash) {
        const stored = moonbitlang$core$array$$Array$at$19$(self.strings, id - 1 | 0);
        if (stored.length === len && moonbitlang$core$builtin$$Eq$equal$12$(view, moonbitlang$core$array$$Array$at$12$(self.views, id - 1 | 0))) {
          return { _0: stored, _1: id };
        }
      }
      id = moonbitlang$core$array$$Array$at$26$(self.next_by_id, id - 1 | 0);
      continue;
    } else {
      break;
    }
  }
  const owned = moonbitlang$core$builtin$$Show$to_string$12$(view);
  const id$2 = self.strings.length + 1 | 0;
  moonbitlang$core$array$$Array$push$19$(self.strings, owned);
  moonbitlang$core$array$$Array$push$12$(self.views, moonbitlang$core$string$$String$view$46$inner(moonbitlang$core$array$$Array$at$19$(self.strings, id$2 - 1 | 0), 0, undefined));
  moonbitlang$core$array$$Array$push$24$(self.hashes, hash);
  moonbitlang$core$array$$Array$push$26$(self.next_by_id, moonbitlang$core$array$$Array$at$26$(self.buckets, bucket));
  moonbitlang$core$array$$Array$set$26$(self.buckets, bucket, id$2);
  const stored = moonbitlang$core$array$$Array$at$19$(self.strings, id$2 - 1 | 0);
  return { _0: stored, _1: id$2 };
}
function hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(self, view) {
  const hash = hackwaly$tinycc$support$intern$intern_core$$tok_hash_view(view);
  return hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id_hash(self, view, hash);
}
function hackwaly$tinycc$support$intern$intern_core$$StringInterner$get(self, id) {
  if (id <= 0 || id > self.strings.length) {
    return "";
  }
  return moonbitlang$core$array$$Array$at$19$(self.strings, id - 1 | 0);
}
function hackwaly$tinycc$support$intern$$tok_hash_step(h, code) {
  return hackwaly$tinycc$support$intern$intern_core$$tok_hash_step(h, code);
}
function hackwaly$tinycc$support$intern$$new_string_interner_with_capacity(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$support$intern$intern_core$$new_string_interner_with_capacity(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$support$intern$intern_core$$new_string_interner_with_capacity(_value);
  }
}
function moonbitlang$core$builtin$$Eq$equal$85$(_x_122, _x_123) {
  switch (_x_122) {
    case 0: {
      if (_x_123 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_123 === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_123 === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_123 === 3) {
        return true;
      } else {
        return false;
      }
    }
    case 4: {
      if (_x_123 === 4) {
        return true;
      } else {
        return false;
      }
    }
    case 5: {
      if (_x_123 === 5) {
        return true;
      } else {
        return false;
      }
    }
    case 6: {
      if (_x_123 === 6) {
        return true;
      } else {
        return false;
      }
    }
    case 7: {
      if (_x_123 === 7) {
        return true;
      } else {
        return false;
      }
    }
    case 8: {
      if (_x_123 === 8) {
        return true;
      } else {
        return false;
      }
    }
    case 9: {
      if (_x_123 === 9) {
        return true;
      } else {
        return false;
      }
    }
    case 10: {
      if (_x_123 === 10) {
        return true;
      } else {
        return false;
      }
    }
    case 11: {
      if (_x_123 === 11) {
        return true;
      } else {
        return false;
      }
    }
    case 12: {
      if (_x_123 === 12) {
        return true;
      } else {
        return false;
      }
    }
    case 13: {
      if (_x_123 === 13) {
        return true;
      } else {
        return false;
      }
    }
    case 14: {
      if (_x_123 === 14) {
        return true;
      } else {
        return false;
      }
    }
    case 15: {
      if (_x_123 === 15) {
        return true;
      } else {
        return false;
      }
    }
    case 16: {
      if (_x_123 === 16) {
        return true;
      } else {
        return false;
      }
    }
    case 17: {
      if (_x_123 === 17) {
        return true;
      } else {
        return false;
      }
    }
    case 18: {
      if (_x_123 === 18) {
        return true;
      } else {
        return false;
      }
    }
    case 19: {
      if (_x_123 === 19) {
        return true;
      } else {
        return false;
      }
    }
    case 20: {
      if (_x_123 === 20) {
        return true;
      } else {
        return false;
      }
    }
    case 21: {
      if (_x_123 === 21) {
        return true;
      } else {
        return false;
      }
    }
    case 22: {
      if (_x_123 === 22) {
        return true;
      } else {
        return false;
      }
    }
    case 23: {
      if (_x_123 === 23) {
        return true;
      } else {
        return false;
      }
    }
    case 24: {
      if (_x_123 === 24) {
        return true;
      } else {
        return false;
      }
    }
    case 25: {
      if (_x_123 === 25) {
        return true;
      } else {
        return false;
      }
    }
    case 26: {
      if (_x_123 === 26) {
        return true;
      } else {
        return false;
      }
    }
    case 27: {
      if (_x_123 === 27) {
        return true;
      } else {
        return false;
      }
    }
    case 28: {
      if (_x_123 === 28) {
        return true;
      } else {
        return false;
      }
    }
    case 29: {
      if (_x_123 === 29) {
        return true;
      } else {
        return false;
      }
    }
    case 30: {
      if (_x_123 === 30) {
        return true;
      } else {
        return false;
      }
    }
    case 31: {
      if (_x_123 === 31) {
        return true;
      } else {
        return false;
      }
    }
    case 32: {
      if (_x_123 === 32) {
        return true;
      } else {
        return false;
      }
    }
    case 33: {
      if (_x_123 === 33) {
        return true;
      } else {
        return false;
      }
    }
    case 34: {
      if (_x_123 === 34) {
        return true;
      } else {
        return false;
      }
    }
    case 35: {
      if (_x_123 === 35) {
        return true;
      } else {
        return false;
      }
    }
    case 36: {
      if (_x_123 === 36) {
        return true;
      } else {
        return false;
      }
    }
    case 37: {
      if (_x_123 === 37) {
        return true;
      } else {
        return false;
      }
    }
    case 38: {
      if (_x_123 === 38) {
        return true;
      } else {
        return false;
      }
    }
    case 39: {
      if (_x_123 === 39) {
        return true;
      } else {
        return false;
      }
    }
    case 40: {
      if (_x_123 === 40) {
        return true;
      } else {
        return false;
      }
    }
    case 41: {
      if (_x_123 === 41) {
        return true;
      } else {
        return false;
      }
    }
    case 42: {
      if (_x_123 === 42) {
        return true;
      } else {
        return false;
      }
    }
    case 43: {
      if (_x_123 === 43) {
        return true;
      } else {
        return false;
      }
    }
    case 44: {
      if (_x_123 === 44) {
        return true;
      } else {
        return false;
      }
    }
    case 45: {
      if (_x_123 === 45) {
        return true;
      } else {
        return false;
      }
    }
    case 46: {
      if (_x_123 === 46) {
        return true;
      } else {
        return false;
      }
    }
    case 47: {
      if (_x_123 === 47) {
        return true;
      } else {
        return false;
      }
    }
    case 48: {
      if (_x_123 === 48) {
        return true;
      } else {
        return false;
      }
    }
    case 49: {
      if (_x_123 === 49) {
        return true;
      } else {
        return false;
      }
    }
    case 50: {
      if (_x_123 === 50) {
        return true;
      } else {
        return false;
      }
    }
    case 51: {
      if (_x_123 === 51) {
        return true;
      } else {
        return false;
      }
    }
    case 52: {
      if (_x_123 === 52) {
        return true;
      } else {
        return false;
      }
    }
    case 53: {
      if (_x_123 === 53) {
        return true;
      } else {
        return false;
      }
    }
    case 54: {
      if (_x_123 === 54) {
        return true;
      } else {
        return false;
      }
    }
    case 55: {
      if (_x_123 === 55) {
        return true;
      } else {
        return false;
      }
    }
    case 56: {
      if (_x_123 === 56) {
        return true;
      } else {
        return false;
      }
    }
    case 57: {
      if (_x_123 === 57) {
        return true;
      } else {
        return false;
      }
    }
    case 58: {
      if (_x_123 === 58) {
        return true;
      } else {
        return false;
      }
    }
    case 59: {
      if (_x_123 === 59) {
        return true;
      } else {
        return false;
      }
    }
    case 60: {
      if (_x_123 === 60) {
        return true;
      } else {
        return false;
      }
    }
    case 61: {
      if (_x_123 === 61) {
        return true;
      } else {
        return false;
      }
    }
    case 62: {
      if (_x_123 === 62) {
        return true;
      } else {
        return false;
      }
    }
    case 63: {
      if (_x_123 === 63) {
        return true;
      } else {
        return false;
      }
    }
    case 64: {
      if (_x_123 === 64) {
        return true;
      } else {
        return false;
      }
    }
    case 65: {
      if (_x_123 === 65) {
        return true;
      } else {
        return false;
      }
    }
    case 66: {
      if (_x_123 === 66) {
        return true;
      } else {
        return false;
      }
    }
    case 67: {
      if (_x_123 === 67) {
        return true;
      } else {
        return false;
      }
    }
    case 68: {
      if (_x_123 === 68) {
        return true;
      } else {
        return false;
      }
    }
    case 69: {
      if (_x_123 === 69) {
        return true;
      } else {
        return false;
      }
    }
    case 70: {
      if (_x_123 === 70) {
        return true;
      } else {
        return false;
      }
    }
    case 71: {
      if (_x_123 === 71) {
        return true;
      } else {
        return false;
      }
    }
    case 72: {
      if (_x_123 === 72) {
        return true;
      } else {
        return false;
      }
    }
    case 73: {
      if (_x_123 === 73) {
        return true;
      } else {
        return false;
      }
    }
    case 74: {
      if (_x_123 === 74) {
        return true;
      } else {
        return false;
      }
    }
    case 75: {
      if (_x_123 === 75) {
        return true;
      } else {
        return false;
      }
    }
    case 76: {
      if (_x_123 === 76) {
        return true;
      } else {
        return false;
      }
    }
    case 77: {
      if (_x_123 === 77) {
        return true;
      } else {
        return false;
      }
    }
    case 78: {
      if (_x_123 === 78) {
        return true;
      } else {
        return false;
      }
    }
    case 79: {
      if (_x_123 === 79) {
        return true;
      } else {
        return false;
      }
    }
    case 80: {
      if (_x_123 === 80) {
        return true;
      } else {
        return false;
      }
    }
    case 81: {
      if (_x_123 === 81) {
        return true;
      } else {
        return false;
      }
    }
    case 82: {
      if (_x_123 === 82) {
        return true;
      } else {
        return false;
      }
    }
    case 83: {
      if (_x_123 === 83) {
        return true;
      } else {
        return false;
      }
    }
    case 84: {
      if (_x_123 === 84) {
        return true;
      } else {
        return false;
      }
    }
    case 85: {
      if (_x_123 === 85) {
        return true;
      } else {
        return false;
      }
    }
    case 86: {
      if (_x_123 === 86) {
        return true;
      } else {
        return false;
      }
    }
    case 87: {
      if (_x_123 === 87) {
        return true;
      } else {
        return false;
      }
    }
    case 88: {
      if (_x_123 === 88) {
        return true;
      } else {
        return false;
      }
    }
    case 89: {
      if (_x_123 === 89) {
        return true;
      } else {
        return false;
      }
    }
    case 90: {
      if (_x_123 === 90) {
        return true;
      } else {
        return false;
      }
    }
    case 91: {
      if (_x_123 === 91) {
        return true;
      } else {
        return false;
      }
    }
    case 92: {
      if (_x_123 === 92) {
        return true;
      } else {
        return false;
      }
    }
    case 93: {
      if (_x_123 === 93) {
        return true;
      } else {
        return false;
      }
    }
    case 94: {
      if (_x_123 === 94) {
        return true;
      } else {
        return false;
      }
    }
    case 95: {
      if (_x_123 === 95) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_123 === 96) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$token_value_from_parts(id, lexeme_id) {
  if (lexeme_id !== 0) {
    return -lexeme_id | 0;
  }
  if (id !== 0) {
    return id;
  }
  return 0;
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$new_lexeme_pool(capacity) {
  if (capacity === undefined) {
    return { entries: [] };
  } else {
    const _Some = capacity;
    const _value = _Some;
    const cap = _value > 0 ? _value : 0;
    return { entries: moonbitlang$core$array$$Array$new$46$inner$32$(cap) };
  }
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_intern(pool, text) {
  if (text.length === 0) {
    return 0;
  }
  moonbitlang$core$array$$Array$push$32$(pool.entries, new $64$hackwaly$47$tinycc$47$frontend$47$tokens$47$tokens_core$46$LexemeEntry$Owned(text));
  return pool.entries.length;
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_get(pool, id) {
  if (id <= 0) {
    return "";
  }
  const idx = id - 1 | 0;
  const _bind = moonbitlang$core$array$$Array$at$32$(pool.entries, idx);
  if (_bind.$tag === 0) {
    const _Owned = _bind;
    return _Owned._0;
  } else {
    const _Slice = _bind;
    const _text = _Slice._0;
    const _start = _Slice._1;
    const _len = _Slice._2;
    const value = hackwaly$tinycc$support$util$$slice_string(_text, _start, _start + _len | 0);
    moonbitlang$core$array$$Array$set$32$(pool.entries, idx, new $64$hackwaly$47$tinycc$47$frontend$47$tokens$47$tokens_core$46$LexemeEntry$Owned(value));
    return value;
  }
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_intern_slice(pool, text, start, end) {
  const len = end - start | 0;
  if (len <= 0) {
    return 0;
  }
  moonbitlang$core$array$$Array$push$32$(pool.entries, new $64$hackwaly$47$tinycc$47$frontend$47$tokens$47$tokens_core$46$LexemeEntry$Slice(text, start, len));
  return pool.entries.length;
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_len(pool, id) {
  if (id <= 0) {
    return 0;
  }
  const _bind = moonbitlang$core$array$$Array$at$32$(pool.entries, id - 1 | 0);
  if (_bind.$tag === 0) {
    const _Owned = _bind;
    const _value = _Owned._0;
    return _value.length;
  } else {
    const _Slice = _bind;
    return _Slice._2;
  }
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids(interner) {
  const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$749, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$749.length });
  const _kw_if = _bind._1;
  const _bind$2 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$744, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$744.length });
  const _kw_do = _bind$2._1;
  const _bind$3 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$739, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$739.length });
  const _kw_for = _bind$3._1;
  const _bind$4 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$734, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$734.length });
  const _kw_int = _bind$4._1;
  const _bind$5 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$729, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$729.length });
  const _kw_asm = _bind$5._1;
  const _bind$6 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$724, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$724.length });
  const _kw_else = _bind$6._1;
  const _bind$7 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$719, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$719.length });
  const _kw_goto = _bind$7._1;
  const _bind$8 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$714, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$714.length });
  const _kw_case = _bind$8._1;
  const _bind$9 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$709, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$709.length });
  const _kw_auto = _bind$9._1;
  const _bind$10 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$704, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$704.length });
  const _kw_void = _bind$10._1;
  const _bind$11 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$699, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$699.length });
  const _kw_char = _bind$11._1;
  const _bind$12 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$694, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$694.length });
  const _kw_long = _bind$12._1;
  const _bind$13 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$689, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$689.length });
  const _kw_enum = _bind$13._1;
  const _bind$14 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$684, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$684.length });
  const _kw_while = _bind$14._1;
  const _bind$15 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$679, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$679.length });
  const _kw_break = _bind$15._1;
  const _bind$16 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$674, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$674.length });
  const _kw_const = _bind$16._1;
  const _bind$17 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$669, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$669.length });
  const _kw_float = _bind$17._1;
  const _bind$18 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$664, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$664.length });
  const _kw_u_bool = _bind$18._1;
  const _bind$19 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$659, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$659.length });
  const _kw_short = _bind$19._1;
  const _bind$20 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$654, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$654.length });
  const _kw_union = _bind$20._1;
  const _bind$21 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$649, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$649.length });
  const _kw_du_asm = _bind$21._1;
  const _bind$22 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$644, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$644.length });
  const _kw_return = _bind$22._1;
  const _bind$23 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$639, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$639.length });
  const _kw_switch = _bind$23._1;
  const _bind$24 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$634, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$634.length });
  const _kw_extern = _bind$24._1;
  const _bind$25 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$629, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$629.length });
  const _kw_static = _bind$25._1;
  const _bind$26 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$624, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$624.length });
  const _kw_signed = _bind$26._1;
  const _bind$27 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$619, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$619.length });
  const _kw_inline = _bind$27._1;
  const _bind$28 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$614, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$614.length });
  const _kw_double = _bind$28._1;
  const _bind$29 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$609, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$609.length });
  const _kw_struct = _bind$29._1;
  const _bind$30 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$604, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$604.length });
  const _kw_sizeof = _bind$30._1;
  const _bind$31 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$599, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$599.length });
  const _kw_typeof = _bind$31._1;
  const _bind$32 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$594, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$594.length });
  const _kw_default = _bind$32._1;
  const _bind$33 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$589, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$589.length });
  const _kw_typedef = _bind$33._1;
  const _bind$34 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$584, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$584.length });
  const _kw_du_asm_du = _bind$34._1;
  const _bind$35 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$579, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$579.length });
  const _kw_du_const = _bind$35._1;
  const _bind$36 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$574, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$574.length });
  const _kw_continue = _bind$36._1;
  const _bind$37 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$569, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$569.length });
  const _kw_unsigned = _bind$37._1;
  const _bind$38 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$564, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$564.length });
  const _kw_volatile = _bind$38._1;
  const _bind$39 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$559, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$559.length });
  const _kw_register = _bind$39._1;
  const _bind$40 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$554, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$554.length });
  const _kw_restrict = _bind$40._1;
  const _bind$41 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$549, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$549.length });
  const _kw_u_alignof = _bind$41._1;
  const _bind$42 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$544, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$544.length });
  const _kw_du_typeof = _bind$42._1;
  const _bind$43 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$539, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$539.length });
  const _kw_du_inline = _bind$43._1;
  const _bind$44 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$534, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$534.length });
  const _kw_du_signed = _bind$44._1;
  const _bind$45 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$529, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$529.length });
  const _kw_u_float16 = _bind$45._1;
  const _bind$46 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$524, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$524.length });
  const _kw_u_noreturn = _bind$46._1;
  const _bind$47 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$519, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$519.length });
  const _kw_u_atomic = _bind$47._1;
  const _bind$48 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$514, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$514.length });
  const _kw_du_alignof = _bind$48._1;
  const _bind$49 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$509, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$509.length });
  const _kw_du_const_du = _bind$49._1;
  const _bind$50 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$504, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$504.length });
  const _kw_du_typeof_du = _bind$50._1;
  const _bind$51 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$499, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$499.length });
  const _kw_du_volatile = _bind$51._1;
  const _bind$52 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$494, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$494.length });
  const _kw_du_restrict = _bind$52._1;
  const _bind$53 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$489, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$489.length });
  const _kw_du_inline_du = _bind$53._1;
  const _bind$54 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$484, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$484.length });
  const _kw_du_signed_du = _bind$54._1;
  const _bind$55 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$479, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$479.length });
  const _kw_du_unsigned = _bind$55._1;
  const _bind$56 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$474, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$474.length });
  const _kw_du_alignof_du = _bind$56._1;
  const _bind$57 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$469, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$469.length });
  const _kw_du_attribute = _bind$57._1;
  const _bind$58 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$464, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$464.length });
  const _kw_du_volatile_du = _bind$58._1;
  const _bind$59 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$459, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$459.length });
  const _kw_du_restrict_du = _bind$59._1;
  const _bind$60 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$454, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$454.length });
  const _kw_du_unsigned_du = _bind$60._1;
  const _bind$61 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$449, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$449.length });
  const _kw_du_attribute_du = _bind$61._1;
  const _bind$62 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$444, start: 0, end: hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$42$bind$124$444.length });
  const _kw_u_static_assert = _bind$62._1;
  const kind_by_id = moonbitlang$core$array$$Array$make$61$(_kw_u_static_assert + 1 | 0, undefined);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_if, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14732);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_do, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14733);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_for, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14734);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_int, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14735);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_asm, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14736);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_else, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14737);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_goto, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14738);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_case, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14739);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_auto, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14740);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_void, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14741);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_char, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14742);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_long, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14743);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_enum, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14744);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_while, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14745);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_break, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14746);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_const, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14747);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_float, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14748);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_u_bool, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14749);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_short, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14750);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_union, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14751);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_asm, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14752);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_return, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14753);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_switch, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14754);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_extern, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14755);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_static, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14756);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_signed, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14757);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_inline, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14758);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_double, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14759);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_struct, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14760);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_sizeof, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14761);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_typeof, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14762);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_default, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14763);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_typedef, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14764);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_asm_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14765);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_const, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14766);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_continue, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14767);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_unsigned, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14768);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_volatile, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14769);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_register, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14770);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_restrict, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14771);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_u_alignof, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14772);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_typeof, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14773);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_inline, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14774);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_signed, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14775);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_u_float16, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14776);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_u_noreturn, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14777);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_u_atomic, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14778);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_alignof, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14779);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_const_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14780);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_typeof_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14781);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_volatile, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14782);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_restrict, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14783);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_inline_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14784);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_signed_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14785);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_unsigned, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14786);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_alignof_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14787);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_attribute, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14788);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_volatile_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14789);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_restrict_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14790);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_unsigned_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14791);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_du_attribute_du, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14792);
  moonbitlang$core$array$$Array$set$61$(kind_by_id, _kw_u_static_assert, hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids$46$constr$47$14793);
  return { kind_by_id: kind_by_id };
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$keyword_kind_from_id(id, ids) {
  if (id <= 0) {
    return undefined;
  }
  const kind_by_id = ids.kind_by_id;
  if (id >= kind_by_id.length) {
    return undefined;
  }
  return moonbitlang$core$array$$Array$at$61$(kind_by_id, id);
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$token_kind_text(kind) {
  switch (kind) {
    case 49: {
      return "(";
    }
    case 50: {
      return ")";
    }
    case 51: {
      return "{";
    }
    case 52: {
      return "}";
    }
    case 53: {
      return "[";
    }
    case 54: {
      return "]";
    }
    case 55: {
      return ",";
    }
    case 56: {
      return ";";
    }
    case 57: {
      return ":";
    }
    case 58: {
      return "?";
    }
    case 59: {
      return ".";
    }
    case 60: {
      return "...";
    }
    case 61: {
      return "->";
    }
    case 62: {
      return "=";
    }
    case 63: {
      return "+";
    }
    case 64: {
      return "-";
    }
    case 65: {
      return "*";
    }
    case 66: {
      return "/";
    }
    case 67: {
      return "%";
    }
    case 68: {
      return "++";
    }
    case 69: {
      return "--";
    }
    case 70: {
      return "+=";
    }
    case 71: {
      return "-=";
    }
    case 72: {
      return "*=";
    }
    case 73: {
      return "/=";
    }
    case 74: {
      return "%=";
    }
    case 75: {
      return "==";
    }
    case 76: {
      return "!=";
    }
    case 77: {
      return "<";
    }
    case 78: {
      return "<=";
    }
    case 79: {
      return ">";
    }
    case 80: {
      return ">=";
    }
    case 81: {
      return "<<";
    }
    case 82: {
      return ">>";
    }
    case 83: {
      return "<<=";
    }
    case 84: {
      return ">>=";
    }
    case 85: {
      return "&";
    }
    case 86: {
      return "|";
    }
    case 87: {
      return "^";
    }
    case 88: {
      return "~";
    }
    case 89: {
      return "!";
    }
    case 90: {
      return "&&";
    }
    case 91: {
      return "||";
    }
    case 92: {
      return "&=";
    }
    case 93: {
      return "|=";
    }
    case 94: {
      return "^=";
    }
    case 95: {
      return "#";
    }
    case 96: {
      return "##";
    }
    default: {
      return "";
    }
  }
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$token_kind_text_len(kind) {
  switch (kind) {
    case 49: {
      return 1;
    }
    case 50: {
      return 1;
    }
    case 51: {
      return 1;
    }
    case 52: {
      return 1;
    }
    case 53: {
      return 1;
    }
    case 54: {
      return 1;
    }
    case 55: {
      return 1;
    }
    case 56: {
      return 1;
    }
    case 57: {
      return 1;
    }
    case 58: {
      return 1;
    }
    case 59: {
      return 1;
    }
    case 62: {
      return 1;
    }
    case 63: {
      return 1;
    }
    case 64: {
      return 1;
    }
    case 65: {
      return 1;
    }
    case 66: {
      return 1;
    }
    case 67: {
      return 1;
    }
    case 77: {
      return 1;
    }
    case 79: {
      return 1;
    }
    case 85: {
      return 1;
    }
    case 86: {
      return 1;
    }
    case 87: {
      return 1;
    }
    case 88: {
      return 1;
    }
    case 89: {
      return 1;
    }
    case 95: {
      return 1;
    }
    case 60: {
      return 3;
    }
    case 61: {
      return 2;
    }
    case 68: {
      return 2;
    }
    case 69: {
      return 2;
    }
    case 70: {
      return 2;
    }
    case 71: {
      return 2;
    }
    case 72: {
      return 2;
    }
    case 73: {
      return 2;
    }
    case 74: {
      return 2;
    }
    case 75: {
      return 2;
    }
    case 76: {
      return 2;
    }
    case 78: {
      return 2;
    }
    case 80: {
      return 2;
    }
    case 81: {
      return 2;
    }
    case 82: {
      return 2;
    }
    case 90: {
      return 2;
    }
    case 91: {
      return 2;
    }
    case 92: {
      return 2;
    }
    case 93: {
      return 2;
    }
    case 94: {
      return 2;
    }
    case 96: {
      return 2;
    }
    case 83: {
      return 3;
    }
    case 84: {
      return 3;
    }
    default: {
      return 0;
    }
  }
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$token_text_with(interner, pool, tok) {
  const _p$28 = tok.value;
  const lexeme_id = _p$28 < 0 ? -_p$28 | 0 : 0;
  if (lexeme_id !== 0) {
    return hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_get(pool, lexeme_id);
  }
  const _p$29 = tok.value;
  const id = _p$29 > 0 ? _p$29 : 0;
  if (id !== 0) {
    return hackwaly$tinycc$support$intern$intern_core$$StringInterner$get(interner, id);
  }
  return hackwaly$tinycc$frontend$tokens$tokens_core$$token_kind_text(tok.kind);
}
function hackwaly$tinycc$frontend$tokens$tokens_core$$token_text_len_with(interner, pool, tok) {
  const _p$28 = tok.value;
  const lexeme_id = _p$28 < 0 ? -_p$28 | 0 : 0;
  if (lexeme_id !== 0) {
    return hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_len(pool, lexeme_id);
  }
  const _p$29 = tok.value;
  const id = _p$29 > 0 ? _p$29 : 0;
  if (id !== 0) {
    return hackwaly$tinycc$support$intern$intern_core$$StringInterner$get(interner, id).length;
  }
  return hackwaly$tinycc$frontend$tokens$tokens_core$$token_kind_text_len(tok.kind);
}
function hackwaly$tinycc$frontend$tokens$$token_value_from_parts(id, lexeme_id) {
  return hackwaly$tinycc$frontend$tokens$tokens_core$$token_value_from_parts(id, lexeme_id);
}
function hackwaly$tinycc$frontend$tokens$$token_id(tok) {
  const _p$28 = tok.value;
  return _p$28 > 0 ? _p$28 : 0;
}
function hackwaly$tinycc$frontend$tokens$$token_has_id(tok) {
  return tok.value > 0;
}
function hackwaly$tinycc$frontend$tokens$$new_lexeme_pool(capacity) {
  if (capacity === undefined) {
    return hackwaly$tinycc$frontend$tokens$tokens_core$$new_lexeme_pool(undefined);
  } else {
    const _Some = capacity;
    const _value = _Some;
    return hackwaly$tinycc$frontend$tokens$tokens_core$$new_lexeme_pool(_value);
  }
}
function hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pool, text) {
  return hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_intern(pool, text);
}
function hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern_slice(pool, text, start, end) {
  return hackwaly$tinycc$frontend$tokens$tokens_core$$lexeme_pool_intern_slice(pool, text, start, end);
}
function hackwaly$tinycc$frontend$tokens$$init_keyword_ids(interner) {
  return hackwaly$tinycc$frontend$tokens$tokens_core$$init_keyword_ids(interner);
}
function hackwaly$tinycc$frontend$tokens$$keyword_kind_from_id(id, ids) {
  return hackwaly$tinycc$frontend$tokens$tokens_core$$keyword_kind_from_id(id, ids);
}
function hackwaly$tinycc$frontend$tokens$$token_text_with(interner, pool, tok) {
  return hackwaly$tinycc$frontend$tokens$tokens_core$$token_text_with(interner, pool, tok);
}
function hackwaly$tinycc$frontend$tokens$$token_text_len_with(interner, pool, tok) {
  return hackwaly$tinycc$frontend$tokens$tokens_core$$token_text_len_with(interner, pool, tok);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$new_lexer(file, diags, interner, keyword_ids, lexeme_pool) {
  return { file_id: file.id, text: file.text, text_len: file.text.length, index: 0, line: 1, col: 1, line_start: true, diags: diags, interner: interner, keyword_ids: keyword_ids, lexeme_pool: lexeme_pool };
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$lexer_loc(lex) {
  return { file_id: lex.file_id, line: lex.line, col: lex.col, offset: lex.index };
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(code) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 57);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$is_ident_start(code) {
  if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 90)) {
    return true;
  } else {
    let _tmp$27;
    if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 122)) {
      _tmp$27 = true;
    } else {
      let _tmp$28;
      const _p$28 = 95;
      if (code === _p$28) {
        _tmp$28 = true;
      } else {
        let _tmp$29;
        const _p$29 = 36;
        if (code === _p$29) {
          _tmp$29 = true;
        } else {
          const _p$30 = 64;
          _tmp$29 = code === _p$30;
        }
        _tmp$28 = _tmp$29;
      }
      _tmp$27 = _tmp$28;
    }
    return _tmp$27;
  }
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$is_ident_continue(code) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$is_ident_start(code) || hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(code);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(kind, loc, line_start, id, lexeme_id) {
  const value = hackwaly$tinycc$frontend$tokens$$token_value_from_parts(id, lexeme_id);
  return { kind: kind, value: value, loc: loc, line_start: line_start, hidden: hackwaly$tinycc$frontend$tokens$$empty_hidden };
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$slice_to_view(text, start, end) {
  return moonbitlang$core$string$$String$view$46$inner(text, start, end);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$lex_ident(lex, loc, line_start) {
  const start = lex.index;
  const text = lex.text;
  const len = lex.text_len;
  let hash = hackwaly$tinycc$support$intern$$tok_hash_init;
  let idx = start + 1 | 0;
  const _tmp$27 = hash;
  $bound_check(text, start);
  hash = hackwaly$tinycc$support$intern$$tok_hash_step(_tmp$27, text.charCodeAt(start));
  while (true) {
    let _tmp$28;
    if (idx < len) {
      const _tmp$29 = idx;
      $bound_check(text, _tmp$29);
      _tmp$28 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_ident_continue(text.charCodeAt(_tmp$29));
    } else {
      _tmp$28 = false;
    }
    if (_tmp$28) {
      const _tmp$29 = hash;
      const _tmp$30 = idx;
      $bound_check(text, _tmp$30);
      hash = hackwaly$tinycc$support$intern$$tok_hash_step(_tmp$29, text.charCodeAt(_tmp$30));
      idx = idx + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  lex.index = idx;
  lex.col = lex.col + (idx - start | 0) | 0;
  lex.line_start = false;
  const name_view = hackwaly$tinycc$frontend$lexer$lexer_core$$slice_to_view(text, start, idx);
  const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id_hash(lex.interner, name_view, hash);
  const _id = _bind._1;
  const _bind$2 = hackwaly$tinycc$frontend$tokens$$keyword_kind_from_id(_id, lex.keyword_ids);
  if (_bind$2 === undefined) {
    return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(2, loc, line_start, _id, 0);
  } else {
    const _Some = _bind$2;
    const _kind = _Some;
    return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(_kind, loc, line_start, _id, 0);
  }
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$is_bin_digit(code) {
  const _p$28 = 48;
  if (code === _p$28) {
    return true;
  } else {
    const _p$29 = 49;
    return code === _p$29;
  }
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$is_hex_digit(code) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(code) || (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 70) || moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 102));
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$lex_number(lex, loc, line_start, started_with_dot) {
  const start = lex.index;
  const text = lex.text;
  const len = lex.text_len;
  let idx = start;
  let is_float = started_with_dot;
  let is_hex = false;
  if (started_with_dot) {
    idx = start + 1 | 0;
    while (true) {
      let _tmp$27;
      if (idx < len) {
        const _tmp$28 = idx;
        $bound_check(text, _tmp$28);
        _tmp$27 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(text.charCodeAt(_tmp$28));
      } else {
        _tmp$27 = false;
      }
      if (_tmp$27) {
        idx = idx + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  } else {
    let _tmp$27;
    if (idx < len) {
      const _tmp$28 = idx;
      $bound_check(text, _tmp$28);
      const _p$28 = text.charCodeAt(_tmp$28);
      const _p$29 = 48;
      _tmp$27 = _p$28 === _p$29;
    } else {
      _tmp$27 = false;
    }
    if (_tmp$27) {
      const next = idx + 1 | 0;
      if (next < len) {
        $bound_check(text, next);
        const next_code = text.charCodeAt(next);
        let _tmp$28;
        const _p$28 = 88;
        if (next_code === _p$28) {
          _tmp$28 = true;
        } else {
          const _p$29 = 120;
          _tmp$28 = next_code === _p$29;
        }
        if (_tmp$28) {
          is_hex = true;
          idx = idx + 2 | 0;
          while (true) {
            let _tmp$29;
            if (idx < len) {
              const _tmp$30 = idx;
              $bound_check(text, _tmp$30);
              _tmp$29 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_hex_digit(text.charCodeAt(_tmp$30));
            } else {
              _tmp$29 = false;
            }
            if (_tmp$29) {
              idx = idx + 1 | 0;
              continue;
            } else {
              break;
            }
          }
        } else {
          let _tmp$29;
          const _p$29 = 66;
          if (next_code === _p$29) {
            _tmp$29 = true;
          } else {
            const _p$30 = 98;
            _tmp$29 = next_code === _p$30;
          }
          if (_tmp$29) {
            idx = idx + 2 | 0;
            while (true) {
              let _tmp$30;
              if (idx < len) {
                const _tmp$31 = idx;
                $bound_check(text, _tmp$31);
                _tmp$30 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_bin_digit(text.charCodeAt(_tmp$31));
              } else {
                _tmp$30 = false;
              }
              if (_tmp$30) {
                idx = idx + 1 | 0;
                continue;
              } else {
                break;
              }
            }
          } else {
            idx = idx + 1 | 0;
            while (true) {
              let _tmp$30;
              if (idx < len) {
                const _tmp$31 = idx;
                $bound_check(text, _tmp$31);
                _tmp$30 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(text.charCodeAt(_tmp$31));
              } else {
                _tmp$30 = false;
              }
              if (_tmp$30) {
                idx = idx + 1 | 0;
                continue;
              } else {
                break;
              }
            }
          }
        }
      } else {
        idx = idx + 1 | 0;
      }
    } else {
      idx = idx + 1 | 0;
      while (true) {
        let _tmp$28;
        if (idx < len) {
          const _tmp$29 = idx;
          $bound_check(text, _tmp$29);
          _tmp$28 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(text.charCodeAt(_tmp$29));
        } else {
          _tmp$28 = false;
        }
        if (_tmp$28) {
          idx = idx + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
    let dot_ok = true;
    let _tmp$28;
    if ((idx + 1 | 0) < len) {
      const _tmp$29 = idx + 1 | 0;
      $bound_check(text, _tmp$29);
      const _p$28 = text.charCodeAt(_tmp$29);
      const _p$29 = 46;
      _tmp$28 = _p$28 === _p$29;
    } else {
      _tmp$28 = false;
    }
    if (_tmp$28) {
      dot_ok = false;
    }
    let _tmp$29;
    if (idx < len) {
      let _tmp$30;
      const _tmp$31 = idx;
      $bound_check(text, _tmp$31);
      const _p$28 = text.charCodeAt(_tmp$31);
      const _p$29 = 46;
      if (_p$28 === _p$29) {
        _tmp$30 = dot_ok;
      } else {
        _tmp$30 = false;
      }
      _tmp$29 = _tmp$30;
    } else {
      _tmp$29 = false;
    }
    if (_tmp$29) {
      is_float = true;
      idx = idx + 1 | 0;
      const accept_digit = is_hex ? hackwaly$tinycc$frontend$lexer$lexer_core$$is_hex_digit : hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit;
      while (true) {
        let _tmp$30;
        if (idx < len) {
          const _tmp$31 = idx;
          $bound_check(text, _tmp$31);
          _tmp$30 = accept_digit(text.charCodeAt(_tmp$31));
        } else {
          _tmp$30 = false;
        }
        if (_tmp$30) {
          idx = idx + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
  }
  const exp_char = is_hex ? 112 : 101;
  const exp_char_upper = is_hex ? 80 : 69;
  if (idx < len) {
    const _tmp$27 = idx;
    $bound_check(text, _tmp$27);
    const code = text.charCodeAt(_tmp$27);
    if (code === exp_char || code === exp_char_upper) {
      is_float = true;
      idx = idx + 1 | 0;
      if (idx < len) {
        const _tmp$28 = idx;
        $bound_check(text, _tmp$28);
        const sign = text.charCodeAt(_tmp$28);
        let _tmp$29;
        const _p$28 = 43;
        if (sign === _p$28) {
          _tmp$29 = true;
        } else {
          const _p$29 = 45;
          _tmp$29 = sign === _p$29;
        }
        if (_tmp$29) {
          idx = idx + 1 | 0;
        }
      }
      while (true) {
        let _tmp$28;
        if (idx < len) {
          const _tmp$29 = idx;
          $bound_check(text, _tmp$29);
          _tmp$28 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(text.charCodeAt(_tmp$29));
        } else {
          _tmp$28 = false;
        }
        if (_tmp$28) {
          idx = idx + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
  }
  while (true) {
    let _tmp$27;
    if (idx < len) {
      const _tmp$28 = idx;
      $bound_check(text, _tmp$28);
      _tmp$27 = hackwaly$tinycc$frontend$lexer$lexer_core$$is_ident_continue(text.charCodeAt(_tmp$28));
    } else {
      _tmp$27 = false;
    }
    if (_tmp$27) {
      idx = idx + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  lex.index = idx;
  lex.col = lex.col + (idx - start | 0) | 0;
  lex.line_start = false;
  const kind = is_float ? 4 : 3;
  const lexeme_id = hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern_slice(lex.lexeme_pool, text, start, idx);
  return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(kind, loc, line_start, 0, lexeme_id);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$add_lex_error(lex, loc, message) {
  hackwaly$tinycc$support$diag$$add_error(lex.diags, loc, message);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex) {
  lex.index = lex.index + 1 | 0;
  lex.col = lex.col + 1 | 0;
  lex.line_start = false;
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$lex_punct(lex, loc, line_start) {
  const idx = lex.index;
  if (idx >= lex.text_len) {
    return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(0, loc, line_start, 0, 0);
  }
  const text = lex.text;
  const len = lex.text_len;
  $bound_check(text, idx);
  const code = text.charCodeAt(idx);
  lex.index = idx + 1 | 0;
  const _p$28 = 10;
  if (code === _p$28) {
    lex.line = lex.line + 1 | 0;
    lex.col = 1;
    lex.line_start = true;
  } else {
    lex.col = lex.col + 1 | 0;
    lex.line_start = false;
  }
  switch (code) {
    case 40: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(49, loc, line_start, 0, 0);
    }
    case 41: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(50, loc, line_start, 0, 0);
    }
    case 123: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(51, loc, line_start, 0, 0);
    }
    case 125: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(52, loc, line_start, 0, 0);
    }
    case 91: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(53, loc, line_start, 0, 0);
    }
    case 93: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(54, loc, line_start, 0, 0);
    }
    case 59: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(56, loc, line_start, 0, 0);
    }
    case 44: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(55, loc, line_start, 0, 0);
    }
    case 58: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(57, loc, line_start, 0, 0);
    }
    case 63: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(58, loc, line_start, 0, 0);
    }
    case 35: {
      let _tmp$27;
      if (lex.index < len) {
        const _tmp$28 = lex.index;
        $bound_check(text, _tmp$28);
        const _p$29 = text.charCodeAt(_tmp$28);
        const _p$30 = 35;
        _tmp$27 = _p$29 === _p$30;
      } else {
        _tmp$27 = false;
      }
      if (_tmp$27) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(96, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(95, loc, line_start, 0, 0);
    }
    case 46: {
      let _tmp$28;
      if ((lex.index + 1 | 0) < len) {
        let _tmp$29;
        const _tmp$30 = lex.index;
        $bound_check(text, _tmp$30);
        const _p$29 = text.charCodeAt(_tmp$30);
        const _p$30 = 46;
        if (_p$29 === _p$30) {
          const _tmp$31 = lex.index + 1 | 0;
          $bound_check(text, _tmp$31);
          const _p$31 = text.charCodeAt(_tmp$31);
          const _p$32 = 46;
          _tmp$29 = _p$31 === _p$32;
        } else {
          _tmp$29 = false;
        }
        _tmp$28 = _tmp$29;
      } else {
        _tmp$28 = false;
      }
      if (_tmp$28) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(60, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(59, loc, line_start, 0, 0);
    }
    case 45: {
      if (lex.index < len) {
        const _tmp$29 = lex.index;
        $bound_check(text, _tmp$29);
        const next = text.charCodeAt(_tmp$29);
        const _p$29 = 62;
        if (next === _p$29) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(61, loc, line_start, 0, 0);
        }
        const _p$30 = 45;
        if (next === _p$30) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(69, loc, line_start, 0, 0);
        }
        const _p$31 = 61;
        if (next === _p$31) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(71, loc, line_start, 0, 0);
        }
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(64, loc, line_start, 0, 0);
    }
    case 43: {
      if (lex.index < len) {
        const _tmp$29 = lex.index;
        $bound_check(text, _tmp$29);
        const next = text.charCodeAt(_tmp$29);
        const _p$29 = 43;
        if (next === _p$29) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(68, loc, line_start, 0, 0);
        }
        const _p$30 = 61;
        if (next === _p$30) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(70, loc, line_start, 0, 0);
        }
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(63, loc, line_start, 0, 0);
    }
    case 42: {
      let _tmp$29;
      if (lex.index < len) {
        const _tmp$30 = lex.index;
        $bound_check(text, _tmp$30);
        const _p$29 = text.charCodeAt(_tmp$30);
        const _p$30 = 61;
        _tmp$29 = _p$29 === _p$30;
      } else {
        _tmp$29 = false;
      }
      if (_tmp$29) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(72, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(65, loc, line_start, 0, 0);
    }
    case 47: {
      let _tmp$30;
      if (lex.index < len) {
        const _tmp$31 = lex.index;
        $bound_check(text, _tmp$31);
        const _p$29 = text.charCodeAt(_tmp$31);
        const _p$30 = 61;
        _tmp$30 = _p$29 === _p$30;
      } else {
        _tmp$30 = false;
      }
      if (_tmp$30) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(73, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(66, loc, line_start, 0, 0);
    }
    case 37: {
      let _tmp$31;
      if (lex.index < len) {
        const _tmp$32 = lex.index;
        $bound_check(text, _tmp$32);
        const _p$29 = text.charCodeAt(_tmp$32);
        const _p$30 = 61;
        _tmp$31 = _p$29 === _p$30;
      } else {
        _tmp$31 = false;
      }
      if (_tmp$31) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(74, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(67, loc, line_start, 0, 0);
    }
    case 61: {
      let _tmp$32;
      if (lex.index < len) {
        const _tmp$33 = lex.index;
        $bound_check(text, _tmp$33);
        const _p$29 = text.charCodeAt(_tmp$33);
        const _p$30 = 61;
        _tmp$32 = _p$29 === _p$30;
      } else {
        _tmp$32 = false;
      }
      if (_tmp$32) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(75, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(62, loc, line_start, 0, 0);
    }
    case 33: {
      let _tmp$33;
      if (lex.index < len) {
        const _tmp$34 = lex.index;
        $bound_check(text, _tmp$34);
        const _p$29 = text.charCodeAt(_tmp$34);
        const _p$30 = 61;
        _tmp$33 = _p$29 === _p$30;
      } else {
        _tmp$33 = false;
      }
      if (_tmp$33) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(76, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(89, loc, line_start, 0, 0);
    }
    case 60: {
      let _tmp$34;
      if (lex.index < len) {
        const _tmp$35 = lex.index;
        $bound_check(text, _tmp$35);
        const _p$29 = text.charCodeAt(_tmp$35);
        const _p$30 = 60;
        _tmp$34 = _p$29 === _p$30;
      } else {
        _tmp$34 = false;
      }
      if (_tmp$34) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        let _tmp$35;
        if (lex.index < len) {
          const _tmp$36 = lex.index;
          $bound_check(text, _tmp$36);
          const _p$29 = text.charCodeAt(_tmp$36);
          const _p$30 = 61;
          _tmp$35 = _p$29 === _p$30;
        } else {
          _tmp$35 = false;
        }
        if (_tmp$35) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(83, loc, line_start, 0, 0);
        }
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(81, loc, line_start, 0, 0);
      }
      let _tmp$35;
      if (lex.index < len) {
        const _tmp$36 = lex.index;
        $bound_check(text, _tmp$36);
        const _p$29 = text.charCodeAt(_tmp$36);
        const _p$30 = 61;
        _tmp$35 = _p$29 === _p$30;
      } else {
        _tmp$35 = false;
      }
      if (_tmp$35) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(78, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(77, loc, line_start, 0, 0);
    }
    case 62: {
      let _tmp$36;
      if (lex.index < len) {
        const _tmp$37 = lex.index;
        $bound_check(text, _tmp$37);
        const _p$29 = text.charCodeAt(_tmp$37);
        const _p$30 = 62;
        _tmp$36 = _p$29 === _p$30;
      } else {
        _tmp$36 = false;
      }
      if (_tmp$36) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        let _tmp$37;
        if (lex.index < len) {
          const _tmp$38 = lex.index;
          $bound_check(text, _tmp$38);
          const _p$29 = text.charCodeAt(_tmp$38);
          const _p$30 = 61;
          _tmp$37 = _p$29 === _p$30;
        } else {
          _tmp$37 = false;
        }
        if (_tmp$37) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(84, loc, line_start, 0, 0);
        }
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(82, loc, line_start, 0, 0);
      }
      let _tmp$37;
      if (lex.index < len) {
        const _tmp$38 = lex.index;
        $bound_check(text, _tmp$38);
        const _p$29 = text.charCodeAt(_tmp$38);
        const _p$30 = 61;
        _tmp$37 = _p$29 === _p$30;
      } else {
        _tmp$37 = false;
      }
      if (_tmp$37) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(80, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(79, loc, line_start, 0, 0);
    }
    case 38: {
      if (lex.index < len) {
        const _tmp$38 = lex.index;
        $bound_check(text, _tmp$38);
        const next = text.charCodeAt(_tmp$38);
        const _p$29 = 38;
        if (next === _p$29) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(90, loc, line_start, 0, 0);
        }
        const _p$30 = 61;
        if (next === _p$30) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(92, loc, line_start, 0, 0);
        }
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(85, loc, line_start, 0, 0);
    }
    case 124: {
      if (lex.index < len) {
        const _tmp$38 = lex.index;
        $bound_check(text, _tmp$38);
        const next = text.charCodeAt(_tmp$38);
        const _p$29 = 124;
        if (next === _p$29) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(91, loc, line_start, 0, 0);
        }
        const _p$30 = 61;
        if (next === _p$30) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
          return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(93, loc, line_start, 0, 0);
        }
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(86, loc, line_start, 0, 0);
    }
    case 94: {
      let _tmp$38;
      if (lex.index < len) {
        const _tmp$39 = lex.index;
        $bound_check(text, _tmp$39);
        const _p$29 = text.charCodeAt(_tmp$39);
        const _p$30 = 61;
        _tmp$38 = _p$29 === _p$30;
      } else {
        _tmp$38 = false;
      }
      if (_tmp$38) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$advance_punct(lex);
        return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(94, loc, line_start, 0, 0);
      }
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(87, loc, line_start, 0, 0);
    }
    case 126: {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(88, loc, line_start, 0, 0);
    }
    default: {
      hackwaly$tinycc$frontend$lexer$lexer_core$$add_lex_error(lex, loc, "unexpected character");
      const lexeme_id = hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern_slice(lex.lexeme_pool, lex.text, loc.offset, lex.index);
      return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(1, loc, line_start, 0, lexeme_id);
    }
  }
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$is_ws_no_newline(code) {
  const _p$28 = 32;
  if (code === _p$28) {
    return true;
  } else {
    let _tmp$27;
    const _p$29 = 9;
    if (code === _p$29) {
      _tmp$27 = true;
    } else {
      let _tmp$28;
      const _p$30 = 13;
      if (code === _p$30) {
        _tmp$28 = true;
      } else {
        let _tmp$29;
        const _p$31 = 12;
        if (code === _p$31) {
          _tmp$29 = true;
        } else {
          const _p$32 = 11;
          _tmp$29 = code === _p$32;
        }
        _tmp$28 = _tmp$29;
      }
      _tmp$27 = _tmp$28;
    }
    return _tmp$27;
  }
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$advance(lex) {
  if (lex.index >= lex.text_len) {
    return -1;
  }
  const _tmp$27 = lex.text;
  const _tmp$28 = lex.index;
  $bound_check(_tmp$27, _tmp$28);
  const code = _tmp$27.charCodeAt(_tmp$28);
  lex.index = lex.index + 1 | 0;
  const _p$28 = 10;
  if (code === _p$28) {
    lex.line = lex.line + 1 | 0;
    lex.col = 1;
    lex.line_start = true;
  } else {
    lex.col = lex.col + 1 | 0;
    if (!hackwaly$tinycc$frontend$lexer$lexer_core$$is_ws_no_newline(code)) {
      lex.line_start = false;
    }
  }
  return code;
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$peek_char(lex) {
  if (lex.index >= lex.text_len) {
    return -1;
  }
  const _tmp$27 = lex.text;
  const _tmp$28 = lex.index;
  $bound_check(_tmp$27, _tmp$28);
  return _tmp$27.charCodeAt(_tmp$28);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$skip_string_literal(lex, loc, quote) {
  const text = lex.text;
  const len = lex.text_len;
  hackwaly$tinycc$frontend$lexer$lexer_core$$advance(lex);
  while (true) {
    let idx = lex.index;
    while (true) {
      if (idx < len) {
        const _tmp$27 = idx;
        $bound_check(text, _tmp$27);
        const code = text.charCodeAt(_tmp$27);
        let _tmp$28;
        if (code === quote) {
          _tmp$28 = true;
        } else {
          let _tmp$29;
          const _p$28 = 10;
          if (code === _p$28) {
            _tmp$29 = true;
          } else {
            const _p$29 = 92;
            _tmp$29 = code === _p$29;
          }
          _tmp$28 = _tmp$29;
        }
        if (_tmp$28) {
          break;
        }
        idx = idx + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    if (idx > lex.index) {
      lex.col = lex.col + (idx - lex.index | 0) | 0;
      lex.index = idx;
    }
    if (lex.index >= len) {
      hackwaly$tinycc$frontend$lexer$lexer_core$$add_lex_error(lex, loc, "unterminated string or char literal");
      break;
    }
    const _tmp$27 = lex.index;
    $bound_check(text, _tmp$27);
    const code = text.charCodeAt(_tmp$27);
    if (code === quote) {
      hackwaly$tinycc$frontend$lexer$lexer_core$$advance(lex);
      break;
    }
    const _p$28 = 10;
    if (code === _p$28) {
      hackwaly$tinycc$frontend$lexer$lexer_core$$add_lex_error(lex, loc, "unterminated string or char literal");
      break;
    }
    const _p$29 = 92;
    if (code === _p$29) {
      hackwaly$tinycc$frontend$lexer$lexer_core$$advance(lex);
      const _bind = hackwaly$tinycc$frontend$lexer$lexer_core$$peek_char(lex);
      if (_bind === -1) {
        hackwaly$tinycc$frontend$lexer$lexer_core$$add_lex_error(lex, loc, "unterminated escape sequence");
        break;
      } else {
        const _Some = _bind;
        const _x = _Some;
        if (_x === 10) {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance(lex);
          continue;
        } else {
          hackwaly$tinycc$frontend$lexer$lexer_core$$advance(lex);
          continue;
        }
      }
    }
    continue;
  }
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$lex_string_literal(lex, loc, line_start, quote) {
  const start = lex.index;
  hackwaly$tinycc$frontend$lexer$lexer_core$$skip_string_literal(lex, loc, quote);
  let kind;
  const _p$28 = 34;
  if (quote === _p$28) {
    kind = 6;
  } else {
    kind = 5;
  }
  const lexeme_id = hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern_slice(lex.lexeme_pool, lex.text, start, lex.index);
  return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(kind, loc, line_start, 0, lexeme_id);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$peek_char_offset(lex, offset) {
  const idx = lex.index + offset | 0;
  if (idx >= lex.text_len) {
    return -1;
  }
  const _tmp$27 = lex.text;
  $bound_check(_tmp$27, idx);
  return _tmp$27.charCodeAt(idx);
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$skip_block_comment(lex, start_loc) {
  const idx = lex.index;
  const len = lex.text_len;
  if (idx >= len) {
    hackwaly$tinycc$frontend$lexer$lexer_core$$add_lex_error(lex, start_loc, "unterminated block comment");
    return undefined;
  }
  const text = lex.text;
  let i = idx;
  let line = lex.line;
  let col = lex.col;
  let line_start = lex.line_start;
  while (true) {
    if (i < len) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      const _p$28 = 10;
      if (code === _p$28) {
        line = line + 1 | 0;
        col = 1;
        line_start = true;
        i = i + 1 | 0;
        continue;
      }
      let _tmp$28;
      const _p$29 = 42;
      if (code === _p$29) {
        let _tmp$29;
        if ((i + 1 | 0) < len) {
          const _tmp$30 = i + 1 | 0;
          $bound_check(text, _tmp$30);
          const _p$30 = text.charCodeAt(_tmp$30);
          const _p$31 = 47;
          _tmp$29 = _p$30 === _p$31;
        } else {
          _tmp$29 = false;
        }
        _tmp$28 = _tmp$29;
      } else {
        _tmp$28 = false;
      }
      if (_tmp$28) {
        col = col + 2 | 0;
        lex.index = i + 2 | 0;
        lex.line = line;
        lex.col = col;
        lex.line_start = line_start;
        return undefined;
      }
      col = col + 1 | 0;
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  lex.index = len;
  lex.line = line;
  lex.col = col;
  lex.line_start = line_start;
  hackwaly$tinycc$frontend$lexer$lexer_core$$add_lex_error(lex, start_loc, "unterminated block comment");
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$skip_line_comment(lex) {
  const idx = lex.index;
  const len = lex.text_len;
  if (idx >= len) {
    return undefined;
  }
  const text = lex.text;
  let i = idx;
  let col = lex.col;
  while (true) {
    if (i < len) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const _p$28 = text.charCodeAt(_tmp$27);
      const _p$29 = 10;
      if (_p$28 === _p$29) {
        lex.index = i + 1 | 0;
        lex.line = lex.line + 1 | 0;
        lex.col = 1;
        lex.line_start = true;
        return undefined;
      }
      i = i + 1 | 0;
      col = col + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  lex.index = len;
  lex.col = col;
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$skip_ws(lex) {
  const text = lex.text;
  const len = lex.text_len;
  while (true) {
    const idx = lex.index;
    if (idx >= len) {
      return undefined;
    }
    $bound_check(text, idx);
    const code = text.charCodeAt(idx);
    if (hackwaly$tinycc$frontend$lexer$lexer_core$$is_ws_no_newline(code)) {
      let next = idx + 1 | 0;
      while (true) {
        if (next < len) {
          const _tmp$27 = next;
          $bound_check(text, _tmp$27);
          const next_code = text.charCodeAt(_tmp$27);
          if (!hackwaly$tinycc$frontend$lexer$lexer_core$$is_ws_no_newline(next_code)) {
            break;
          }
          next = next + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const delta = next - idx | 0;
      lex.index = next;
      lex.col = lex.col + delta | 0;
      continue;
    }
    const _p$28 = 10;
    if (code === _p$28) {
      lex.index = idx + 1 | 0;
      lex.line = lex.line + 1 | 0;
      lex.col = 1;
      lex.line_start = true;
      continue;
    }
    const _p$29 = 92;
    if (code === _p$29) {
      const next = idx + 1 | 0;
      let _tmp$27;
      if (next < len) {
        $bound_check(text, next);
        const _p$30 = text.charCodeAt(next);
        const _p$31 = 10;
        _tmp$27 = _p$30 === _p$31;
      } else {
        _tmp$27 = false;
      }
      if (_tmp$27) {
        lex.index = idx + 2 | 0;
        lex.line = lex.line + 1 | 0;
        lex.col = 1;
        lex.line_start = false;
        continue;
      }
    }
    const _p$30 = 47;
    if (code === _p$30) {
      const next = idx + 1 | 0;
      if (next < len) {
        $bound_check(text, next);
        const next_code = text.charCodeAt(next);
        const _p$31 = 47;
        if (next_code === _p$31) {
          lex.index = idx + 2 | 0;
          lex.col = lex.col + 2 | 0;
          hackwaly$tinycc$frontend$lexer$lexer_core$$skip_line_comment(lex);
          continue;
        }
        const _p$32 = 42;
        if (next_code === _p$32) {
          const start_loc = hackwaly$tinycc$frontend$lexer$lexer_core$$lexer_loc(lex);
          lex.index = idx + 2 | 0;
          lex.col = lex.col + 2 | 0;
          hackwaly$tinycc$frontend$lexer$lexer_core$$skip_block_comment(lex, start_loc);
          continue;
        }
      }
    }
    return undefined;
  }
}
function hackwaly$tinycc$frontend$lexer$lexer_core$$next_token(lex) {
  hackwaly$tinycc$frontend$lexer$lexer_core$$skip_ws(lex);
  const loc = hackwaly$tinycc$frontend$lexer$lexer_core$$lexer_loc(lex);
  const line_start = lex.line_start;
  const _bind = hackwaly$tinycc$frontend$lexer$lexer_core$$peek_char(lex);
  if (_bind === -1) {
    return hackwaly$tinycc$frontend$lexer$lexer_core$$make_token$46$inner(0, loc, line_start, 0, 0);
  } else {
    const _Some = _bind;
    const _code = _Some;
    if (hackwaly$tinycc$frontend$lexer$lexer_core$$is_ident_start(_code)) {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$lex_ident(lex, loc, line_start);
    }
    if (hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(_code)) {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$lex_number(lex, loc, line_start, false);
    }
    const _p$28 = 46;
    if (_code === _p$28) {
      const _bind$2 = hackwaly$tinycc$frontend$lexer$lexer_core$$peek_char_offset(lex, 1);
      if (_bind$2 === -1) {
      } else {
        const _Some$2 = _bind$2;
        const _next_code = _Some$2;
        if (hackwaly$tinycc$frontend$lexer$lexer_core$$is_digit(_next_code)) {
          return hackwaly$tinycc$frontend$lexer$lexer_core$$lex_number(lex, loc, line_start, true);
        }
      }
    }
    let _tmp$27;
    const _p$29 = 34;
    if (_code === _p$29) {
      _tmp$27 = true;
    } else {
      const _p$30 = 39;
      _tmp$27 = _code === _p$30;
    }
    if (_tmp$27) {
      return hackwaly$tinycc$frontend$lexer$lexer_core$$lex_string_literal(lex, loc, line_start, _code);
    }
    return hackwaly$tinycc$frontend$lexer$lexer_core$$lex_punct(lex, loc, line_start);
  }
}
function hackwaly$tinycc$frontend$lexer$$new_lexer(file, diags, interner, keyword_ids, lexeme_pool) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$new_lexer(file, diags, interner, keyword_ids, lexeme_pool);
}
function hackwaly$tinycc$frontend$lexer$$lexer_loc(lex) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$lexer_loc(lex);
}
function hackwaly$tinycc$frontend$lexer$$next_token(lex) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$next_token(lex);
}
function hackwaly$tinycc$frontend$lexer$$peek_char(lex) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$peek_char(lex);
}
function hackwaly$tinycc$frontend$lexer$$peek_char_offset(lex, offset) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$peek_char_offset(lex, offset);
}
function hackwaly$tinycc$frontend$lexer$$advance(lex) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$advance(lex);
}
function hackwaly$tinycc$frontend$lexer$$skip_line_comment(lex) {
  hackwaly$tinycc$frontend$lexer$lexer_core$$skip_line_comment(lex);
}
function hackwaly$tinycc$frontend$lexer$$skip_block_comment(lex, loc) {
  hackwaly$tinycc$frontend$lexer$lexer_core$$skip_block_comment(lex, loc);
}
function hackwaly$tinycc$frontend$lexer$$skip_string_literal(lex, loc, quote) {
  hackwaly$tinycc$frontend$lexer$lexer_core$$skip_string_literal(lex, loc, quote);
}
function hackwaly$tinycc$frontend$lexer$$is_ws_no_newline(code) {
  return hackwaly$tinycc$frontend$lexer$lexer_core$$is_ws_no_newline(code);
}
function moonbitlang$x$time$$check_leap_year(year) {
  return (year % 4 | 0) === 0 && (year % 100 | 0) !== 0 || (year % 400 | 0) === 0;
}
function moonbitlang$x$time$$Zone$lookup_offset(self, secs) {
  if (self.offsets.length === 0) {
    return moonbitlang$x$time$$utc_offset;
  }
  if (self.offsets.length === 1) {
    return moonbitlang$core$array$$Array$at$59$(self.offsets, 0);
  }
  let last_offset = 0;
  const _end512 = self.transitions.length;
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < _end512) {
      const _bind = moonbitlang$core$array$$Array$at$60$(self.transitions, i);
      const _timestamp = _bind._0;
      const _offset_index = _bind._1;
      if (moonbitlang$core$builtin$$Compare$op_le$81$(_timestamp, secs)) {
        last_offset = _offset_index;
      } else {
        break;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$array$$Array$at$59$(self.offsets, last_offset);
}
function moonbitlang$x$time$$calc_days_in_month(year, month) {
  const leap = moonbitlang$x$time$$check_leap_year(year);
  switch (month) {
    case 2: {
      return leap ? 29 : 28;
    }
    case 1: {
      return 31;
    }
    case 3: {
      return 31;
    }
    case 5: {
      return 31;
    }
    case 7: {
      return 31;
    }
    case 8: {
      return 31;
    }
    case 10: {
      return 31;
    }
    case 12: {
      return 31;
    }
    default: {
      return 30;
    }
  }
}
function moonbitlang$x$time$$validate_time(h, m, s, ns) {
  const valid_hour = h >= 0 && h <= 23;
  const valid_minute = m >= 0 && m <= 59;
  const valid_second = s >= 0 && s <= 59;
  const valid_nano = ns >= 0 && ns <= 999999999;
  const zero = h === 24 && (m === 0 && (s === 0 && ns === 0));
  return valid_hour && (valid_minute && (valid_second && valid_nano)) || zero;
}
function moonbitlang$x$time$$PlainTime$of(hour, minute, second, nanosecond) {
  return moonbitlang$x$time$$validate_time(hour, minute, second, nanosecond) ? new Result$Ok$30$({ hour: hour, minute: minute, second: second, nanosecond: nanosecond }) : moonbitlang$core$builtin$$fail$96$(moonbitlang$x$time$$invalid_time_err, "@moonbitlang/x/time:plain_time.mbt:35:5-35:27");
}
function moonbitlang$x$time$$floor(x) {
  if (x > moonbitlang$core$double$$max_value || (x < moonbitlang$core$double$$min_value || x !== x)) {
    return x;
  }
  const n = moonbitlang$core$double$$Double$to_int64(x);
  const d = moonbitlang$core$int64$$Int64$to_double(n);
  return x >= 0 || x === d ? d : d - 1;
}
function moonbitlang$x$time$$floor_div_int64(x, y) {
  if (moonbitlang$core$builtin$$Eq$equal$7$(y, $0L)) {
    const _bind = moonbitlang$core$builtin$$fail$8$("division by zero", "@moonbitlang/x/time:util.mbt:329:5-329:29");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  const r = moonbitlang$core$int64$$Int64$to_double(x) / moonbitlang$core$int64$$Int64$to_double(y);
  return new Result$Ok$31$(moonbitlang$core$double$$Double$to_int64(moonbitlang$x$time$$floor(r)));
}
function moonbitlang$x$time$$floor_mod_int64(x, y) {
  const _bind = moonbitlang$x$time$$floor_div_int64(x, y);
  let _tmp$27;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    _tmp$27 = _ok._0;
  } else {
    return _bind;
  }
  return new Result$Ok$31$(moonbitlang$core$builtin$$Sub$sub$7$(x, moonbitlang$core$builtin$$Mul$mul$7$(_tmp$27, y)));
}
function moonbitlang$x$time$$cycle_to_year_ord(cycle) {
  let year = cycle / 365 | 0;
  let ordinal0 = cycle % 365 | 0;
  const _p$28 = year;
  $bound_check(moonbitlang$x$time$$year_deltas, _p$28);
  const delta = moonbitlang$x$time$$year_deltas[_p$28];
  if (ordinal0 < delta) {
    year = year - 1 | 0;
    const _tmp$27 = ordinal0;
    const _p$29 = year;
    $bound_check(moonbitlang$x$time$$year_deltas, _p$29);
    ordinal0 = _tmp$27 + (365 - moonbitlang$x$time$$year_deltas[_p$29] | 0) | 0;
  } else {
    ordinal0 = ordinal0 - delta | 0;
  }
  return { _0: year, _1: ordinal0 + 1 | 0 };
}
function moonbitlang$x$time$$fixed_days_to_year_ord(days) {
  let d0 = days;
  let year_offset = 0;
  if (moonbitlang$core$builtin$$Compare$op_lt$81$(d0, $0L)) {
    const cycles = moonbitlang$core$builtin$$Sub$sub$7$(moonbitlang$core$builtin$$Div$div$7$(days, moonbitlang$x$time$$days_per_400_years), $1L);
    year_offset = Math.imul(moonbitlang$core$int64$$Int64$to_int(cycles), 400) | 0;
    d0 = moonbitlang$core$builtin$$Sub$sub$7$(d0, moonbitlang$core$builtin$$Mul$mul$7$(cycles, moonbitlang$x$time$$days_per_400_years));
  }
  const n400 = moonbitlang$core$builtin$$Div$div$7$(d0, moonbitlang$x$time$$days_per_400_years);
  const cycle = moonbitlang$core$builtin$$Mod$mod$7$(d0, moonbitlang$x$time$$days_per_400_years);
  const _bind = moonbitlang$x$time$$cycle_to_year_ord(moonbitlang$core$int64$$Int64$to_int(cycle));
  const _y = _bind._0;
  const _ord = _bind._1;
  const year = (_y + (Math.imul(moonbitlang$core$int64$$Int64$to_int(n400), 400) | 0) | 0) + year_offset | 0;
  return { _0: year, _1: _ord };
}
function moonbitlang$x$time$$calc_days_in_year(year) {
  return moonbitlang$x$time$$check_leap_year(year) ? 366 : 365;
}
function moonbitlang$x$time$$validate_ordinal(year, ordinal) {
  return ordinal >= 1 && (ordinal <= 366 && ordinal <= moonbitlang$x$time$$calc_days_in_year(year));
}
function moonbitlang$x$time$$PlainDate$from_year_ord(year, ordinal) {
  const valid = year >= -9999 && year <= 9999 && moonbitlang$x$time$$validate_ordinal(year, ordinal);
  if (!valid) {
    const _bind = moonbitlang$core$builtin$$fail$8$(moonbitlang$x$time$$invalid_date_err, "@moonbitlang/x/time:plain_date.mbt:44:5-44:27");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  let month = 1;
  let day = ordinal;
  while (true) {
    if (moonbitlang$x$time$$calc_days_in_month(year, month) < day) {
      day = day - moonbitlang$x$time$$calc_days_in_month(year, month) | 0;
      month = month + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$32$({ year: year, month: month, day: day });
}
function moonbitlang$x$time$$PlainDate$from_unix_day(unix_day) {
  const _bind = moonbitlang$x$time$$fixed_days_to_year_ord(moonbitlang$core$builtin$$Add$add$7$(unix_day, moonbitlang$x$time$$days_zero_year_to_unix_epoch));
  const _year = _bind._0;
  const _ord = _bind._1;
  return moonbitlang$x$time$$PlainDate$from_year_ord(_year, _ord);
}
function moonbitlang$x$time$$PlainTime$from_nanosecond_of_day(nanosecond) {
  if (moonbitlang$core$builtin$$Compare$op_lt$81$(nanosecond, $0L) || moonbitlang$core$builtin$$Compare$op_gt$81$(nanosecond, moonbitlang$x$time$$nanoseconds_per_day)) {
    const _bind = moonbitlang$core$builtin$$fail$8$(moonbitlang$x$time$$invalid_time_err, "@moonbitlang/x/time:plain_time.mbt:158:5-158:27");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  let nanos = nanosecond;
  const hour = moonbitlang$core$builtin$$Div$div$7$(nanos, moonbitlang$x$time$$nanoseconds_per_hour);
  nanos = moonbitlang$core$builtin$$Sub$sub$7$(nanos, moonbitlang$core$builtin$$Mul$mul$7$(hour, moonbitlang$x$time$$nanoseconds_per_hour));
  const minute = moonbitlang$core$builtin$$Div$div$7$(nanos, moonbitlang$x$time$$nanoseconds_per_minute);
  nanos = moonbitlang$core$builtin$$Sub$sub$7$(nanos, moonbitlang$core$builtin$$Mul$mul$7$(minute, moonbitlang$x$time$$nanoseconds_per_minute));
  const second = moonbitlang$core$builtin$$Div$div$7$(nanos, moonbitlang$x$time$$nanoseconds_per_second);
  nanos = moonbitlang$core$builtin$$Sub$sub$7$(nanos, moonbitlang$core$builtin$$Mul$mul$7$(second, moonbitlang$x$time$$nanoseconds_per_second));
  return moonbitlang$x$time$$PlainTime$of(moonbitlang$core$int64$$Int64$to_int(hour), moonbitlang$core$int64$$Int64$to_int(minute), moonbitlang$core$int64$$Int64$to_int(second), moonbitlang$core$int64$$Int64$to_int(nanos));
}
function moonbitlang$x$time$$PlainDateTime$from_unix_second(second, nanosecond, offset) {
  if (!(nanosecond >= 0 && nanosecond <= 999999999)) {
    const _bind = moonbitlang$core$builtin$$fail$8$(moonbitlang$x$time$$invalid_date_time_err, "@moonbitlang/x/time:plain_date_time.mbt:47:5-47:32");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  const sec = moonbitlang$core$builtin$$Add$add$7$(second, moonbitlang$core$int$$Int$to_int64(offset.seconds));
  const _bind = moonbitlang$x$time$$floor_div_int64(sec, moonbitlang$x$time$$seconds_per_day);
  let unix_day;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    unix_day = _ok._0;
  } else {
    return _bind;
  }
  const _bind$2 = moonbitlang$x$time$$floor_mod_int64(sec, moonbitlang$x$time$$seconds_per_day);
  let seconds_of_day;
  if (_bind$2.$tag === 1) {
    const _ok = _bind$2;
    seconds_of_day = _ok._0;
  } else {
    return _bind$2;
  }
  const _bind$3 = moonbitlang$x$time$$PlainDate$from_unix_day(unix_day);
  let date;
  if (_bind$3.$tag === 1) {
    const _ok = _bind$3;
    date = _ok._0;
  } else {
    return _bind$3;
  }
  const _bind$4 = moonbitlang$x$time$$PlainTime$from_nanosecond_of_day(moonbitlang$core$builtin$$Add$add$7$(moonbitlang$core$builtin$$Mul$mul$7$(seconds_of_day, moonbitlang$x$time$$nanoseconds_per_second), moonbitlang$core$int$$Int$to_int64(nanosecond)));
  let time;
  if (_bind$4.$tag === 1) {
    const _ok = _bind$4;
    time = _ok._0;
  } else {
    return _bind$4;
  }
  return new Result$Ok$33$({ date: date, time: time });
}
function moonbitlang$x$time$$ZonedDateTime$from_unix_second$46$inner(second, nanosecond, zone) {
  const offset = moonbitlang$x$time$$Zone$lookup_offset(zone, second);
  const _bind = moonbitlang$x$time$$PlainDateTime$from_unix_second(second, nanosecond, offset);
  let datetime;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    datetime = _ok._0;
  } else {
    return _bind;
  }
  return new Result$Ok$34$({ datetime: datetime, zone: zone, offset: offset });
}
function moonbitlang$x$time$$unix$46$inner(second, nanosecond, zone) {
  return moonbitlang$x$time$$ZonedDateTime$from_unix_second$46$inner(second, nanosecond, zone);
}
function moonbitlang$x$time$$PlainDateTime$year(self) {
  const _p$28 = self.date;
  return _p$28.year;
}
function moonbitlang$x$time$$ZonedDateTime$year(self) {
  return moonbitlang$x$time$$PlainDateTime$year(self.datetime);
}
function moonbitlang$x$time$$PlainDateTime$month(self) {
  const _p$28 = self.date;
  return _p$28.month;
}
function moonbitlang$x$time$$ZonedDateTime$month(self) {
  return moonbitlang$x$time$$PlainDateTime$month(self.datetime);
}
function moonbitlang$x$time$$PlainDateTime$day(self) {
  const _p$28 = self.date;
  return _p$28.day;
}
function moonbitlang$x$time$$ZonedDateTime$day(self) {
  return moonbitlang$x$time$$PlainDateTime$day(self.datetime);
}
function moonbitlang$x$time$$PlainDateTime$hour(self) {
  const _p$28 = self.time;
  return _p$28.hour;
}
function moonbitlang$x$time$$ZonedDateTime$hour(self) {
  return moonbitlang$x$time$$PlainDateTime$hour(self.datetime);
}
function moonbitlang$x$time$$PlainDateTime$minute(self) {
  const _p$28 = self.time;
  return _p$28.minute;
}
function moonbitlang$x$time$$ZonedDateTime$minute(self) {
  return moonbitlang$x$time$$PlainDateTime$minute(self.datetime);
}
function moonbitlang$x$time$$PlainDateTime$second(self) {
  const _p$28 = self.time;
  return _p$28.second;
}
function moonbitlang$x$time$$ZonedDateTime$second(self) {
  return moonbitlang$x$time$$PlainDateTime$second(self.datetime);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$new_hidden_pool() {
  return { nodes: [], singleton_by_id: [] };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$clear_hidden_pool(pool) {
  moonbitlang$core$array$$Array$clear$42$(pool.nodes);
  moonbitlang$core$array$$Array$clear$26$(pool.singleton_by_id);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(kind, id, lexeme_id) {
  const value = hackwaly$tinycc$frontend$tokens$$token_value_from_parts(id, lexeme_id);
  return { kind: kind, value: value, loc: hackwaly$tinycc$support$source$$dummy_loc(0), line_start: false, hidden: hackwaly$tinycc$frontend$tokens$$empty_hidden };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_word_token(pp, word) {
  const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(pp.interner, { str: word, start: 0, end: word.length });
  const _id = _bind._1;
  const _bind$2 = hackwaly$tinycc$frontend$tokens$$keyword_kind_from_id(_id, pp.keyword_ids);
  if (_bind$2 === undefined) {
    return hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(2, _id, 0);
  } else {
    const _Some = _bind$2;
    const _kind = _Some;
    return hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(_kind, _id, 0);
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, tok) {
  return hackwaly$tinycc$frontend$tokens$$token_text_with(pp.interner, pp.lexeme_pool, tok);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme_len(pp, tok) {
  return hackwaly$tinycc$frontend$tokens$$token_text_len_with(pp.interner, pp.lexeme_pool, tok);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, name) {
  if (name === "") {
    return 0;
  }
  const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(pp.interner, { str: name, start: 0, end: name.length });
  return _bind._1;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$ensure_macro_capacity(pp, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = pp.macros.length;
  if (len >= id) {
    return undefined;
  }
  let i = len;
  while (true) {
    if (i < id) {
      moonbitlang$core$array$$Array$push$43$(pp.macros, undefined);
      i = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$set_macro(pp, id, macro_def) {
  hackwaly$tinycc$frontend$preproc$preproc_core$$ensure_macro_capacity(pp, id);
  if (id > 0) {
    moonbitlang$core$array$$Array$set$43$(pp.macros, id - 1 | 0, macro_def);
    pp.macro_epoch = pp.macro_epoch + 1 | 0;
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_have_id(tokens) {
  const _len = tokens.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const tok = tokens[_i];
      if (hackwaly$tinycc$frontend$tokens$$token_has_id(tok)) {
        return true;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return false;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, name, replacement) {
  const id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, name);
  if (id === 0) {
    return undefined;
  }
  const replacement_has_id = hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_have_id(replacement);
  hackwaly$tinycc$frontend$preproc$preproc_core$$set_macro(pp, id, { params: [], is_variadic: false, is_function: false, replacement: replacement, replacement_has_id: replacement_has_id, replacement_needs_expand: false, replacement_needs_epoch: -1 });
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, name, words) {
  const _p$28 = new Array(words.length);
  const _p$29 = words.length;
  let _tmp$27 = 0;
  while (true) {
    const _p$30 = _tmp$27;
    if (_p$30 < _p$29) {
      const _p$31 = words[_p$30];
      _p$28[_p$30] = hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_word_token(pp, _p$31);
      _tmp$27 = _p$30 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const tokens = _p$28;
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, name, tokens);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, name, value) {
  const lexeme_id = hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, moonbitlang$core$int$$Int$to_string$46$inner(value, 10));
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, name, [hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(3, 0, lexeme_id)]);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_zero(pp, name) {
  const id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, name);
  if (id === 0) {
    return undefined;
  }
  const param_id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, "x");
  const lexeme_id = hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, "0");
  const replacement = [hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(3, 0, lexeme_id)];
  hackwaly$tinycc$frontend$preproc$preproc_core$$set_macro(pp, id, { params: [param_id], is_variadic: true, is_function: true, replacement: replacement, replacement_has_id: hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_have_id(replacement), replacement_needs_expand: false, replacement_needs_epoch: -1 });
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, name) {
  const id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, name);
  if (id === 0) {
    return undefined;
  }
  const param_id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, "x");
  const replacement = [];
  hackwaly$tinycc$frontend$preproc$preproc_core$$set_macro(pp, id, { params: [param_id], is_variadic: true, is_function: true, replacement: replacement, replacement_has_id: false, replacement_needs_expand: false, replacement_needs_epoch: -1 });
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$init_builtin_macros(pp) {
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__APPLE__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__MACH__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__aarch64__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__arm64__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__LP64__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__TINYC__", 928);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, "__ORDER_LITTLE_ENDIAN__", [hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(3, 0, hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, "1234"))]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, "__ORDER_BIG_ENDIAN__", [hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(3, 0, hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, "4321"))]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, "__ORDER_PDP_ENDIAN__", [hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(3, 0, hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, "3412"))]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, "__BYTE_ORDER__", [hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_word_token(pp, "__ORDER_LITTLE_ENDIAN__")]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__LITTLE_ENDIAN__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__SIZE_TYPE__", ["unsigned", "long"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__PTRDIFF_TYPE__", ["long"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__INTMAX_TYPE__", ["long", "int"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__UINTMAX_TYPE__", ["long", "unsigned", "int"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__INTPTR_TYPE__", ["long"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__UINTPTR_TYPE__", ["unsigned", "long"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__INT8_TYPE__", ["signed", "char"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__UINT8_TYPE__", ["unsigned", "char"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__INT16_TYPE__", ["short"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__UINT16_TYPE__", ["unsigned", "short"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__INT32_TYPE__", ["int"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__UINT32_TYPE__", ["unsigned", "int"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__INT64_TYPE__", ["long", "long"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__UINT64_TYPE__", ["unsigned", "long", "long"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__int128_t", ["long", "double"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__uint128_t", ["long", "double"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__CHAR_BIT__", 8);
  if (hackwaly$tinycc$support$util$$char_is_unsigned) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__CHAR_UNSIGNED__", 1);
  }
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_POINTER__", 8);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_LONG__", 8);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_LONG_LONG__", 8);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_INT__", 4);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_SHORT__", 2);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_SIZE_T__", 8);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_PTRDIFF_T__", 8);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_WCHAR_T__", 4);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__SIZEOF_WINT_T__", 4);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__WCHAR_TYPE__", ["int"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "__WINT_TYPE__", ["int"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__STDC__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__STDC_HOSTED__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, "__STDC_VERSION__", [hackwaly$tinycc$frontend$preproc$preproc_core$$make_builtin_token$46$inner(3, 0, hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, "201112"))]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__GNUC__", 4);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__GNUC_MINOR__", 2);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__GNUC_PATCHLEVEL__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__GNUC_STDC_INLINE__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__APPLE_CC__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "__FINITE_MATH_ONLY__", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "_DONT_USE_CTYPE_INLINE_", 1);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, "_FORTIFY_SOURCE", 0);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_words_macro(pp, "_Float16", ["short", "unsigned", "int"]);
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_zero(pp, "__has_builtin");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_zero(pp, "__has_feature");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_zero(pp, "__has_extension");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_zero(pp, "__has_attribute");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_zero(pp, "__has_include");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_zero(pp, "__has_include_next");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_AVAILABLE");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_AVAILABLE_BEGIN");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_AVAILABLE_END");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_DEPRECATED");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_DEPRECATED_WITH_REPLACEMENT");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_UNAVAILABLE");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_UNAVAILABLE_BEGIN");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "__API_UNAVAILABLE_END");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "API_AVAILABLE");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "API_AVAILABLE_BEGIN");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "API_AVAILABLE_END");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "API_UNAVAILABLE");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "API_UNAVAILABLE_BEGIN");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "API_UNAVAILABLE_END");
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_func_macro_empty(pp, "API_DEPRECATED");
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$dir_name(path) {
  const _bind = moonbitlang$core$string$$String$rev_find(path, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$dir_name$46$42$bind$124$782, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$dir_name$46$42$bind$124$782.length });
  if (_bind === undefined) {
    return "";
  } else {
    const _Some = _bind;
    const _idx = _Some;
    return hackwaly$tinycc$support$util$$slice_string(path, 0, _idx);
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$month_name(month) {
  switch (month) {
    case 1: {
      return "Jan";
    }
    case 2: {
      return "Feb";
    }
    case 3: {
      return "Mar";
    }
    case 4: {
      return "Apr";
    }
    case 5: {
      return "May";
    }
    case 6: {
      return "Jun";
    }
    case 7: {
      return "Jul";
    }
    case 8: {
      return "Aug";
    }
    case 9: {
      return "Sep";
    }
    case 10: {
      return "Oct";
    }
    case 11: {
      return "Nov";
    }
    case 12: {
      return "Dec";
    }
    default: {
      return "Jan";
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pad2_space(value) {
  return value < 10 ? ` ${moonbitlang$core$int$$Int$to_string$46$inner(value, 10)}` : moonbitlang$core$int$$Int$to_string$46$inner(value, 10);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$format_date(dt) {
  const month = hackwaly$tinycc$frontend$preproc$preproc_core$$month_name(moonbitlang$x$time$$ZonedDateTime$month(dt));
  const day = hackwaly$tinycc$frontend$preproc$preproc_core$$pad2_space(moonbitlang$x$time$$ZonedDateTime$day(dt));
  const year = moonbitlang$core$int$$Int$to_string$46$inner(moonbitlang$x$time$$ZonedDateTime$year(dt), 10);
  return `${month} ${day} ${year}`;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pad2(value) {
  return value < 10 ? `0${moonbitlang$core$int$$Int$to_string$46$inner(value, 10)}` : moonbitlang$core$int$$Int$to_string$46$inner(value, 10);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$format_time(dt) {
  const hour = hackwaly$tinycc$frontend$preproc$preproc_core$$pad2(moonbitlang$x$time$$ZonedDateTime$hour(dt));
  const minute = hackwaly$tinycc$frontend$preproc$preproc_core$$pad2(moonbitlang$x$time$$ZonedDateTime$minute(dt));
  const second = hackwaly$tinycc$frontend$preproc$preproc_core$$pad2(moonbitlang$x$time$$ZonedDateTime$second(dt));
  return `${hour}:${minute}:${second}`;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$init_datetime_literals() {
  const now_ms = moonbitlang$core$env$$now();
  const now_sec = moonbitlang$core$int$$Int$to_int64(moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$Div$div$6$(now_ms, $1000L)));
  let _try_err;
  _L: {
    const _bind = moonbitlang$x$time$$unix$46$inner(now_sec, 0, moonbitlang$x$time$$utc_zone);
    let _bind$2;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _bind$2 = _ok._0;
    } else {
      const _err = _bind;
      const _tmp$27 = _err._0;
      _try_err = _tmp$27;
      break _L;
    }
    return { _0: hackwaly$tinycc$frontend$preproc$preproc_core$$format_date(_bind$2), _1: hackwaly$tinycc$frontend$preproc$preproc_core$$format_time(_bind$2) };
  }
  return hackwaly$tinycc$frontend$preproc$preproc_core$$init_datetime_literals$46$tuple$47$15302;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor(map, file, diags, host) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$init_datetime_literals();
  const _date_literal = _bind._0;
  const _time_literal = _bind._1;
  const text_len = file.text.length;
  let interner_capacity = text_len / 128 | 0;
  if (interner_capacity < 4096) {
    interner_capacity = 4096;
  } else {
    if (interner_capacity > 65536) {
      interner_capacity = 65536;
    }
  }
  const lexeme_capacity = interner_capacity;
  let pending_capacity = text_len / 64 | 0;
  if (pending_capacity < 256) {
    pending_capacity = 256;
  } else {
    if (pending_capacity > 8192) {
      pending_capacity = 8192;
    }
  }
  const interner = hackwaly$tinycc$support$intern$$new_string_interner_with_capacity(interner_capacity);
  const keyword_ids = hackwaly$tinycc$frontend$tokens$$init_keyword_ids(interner);
  const _bind$2 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$906, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$906.length });
  const _line_macro_id = _bind$2._1;
  const _bind$3 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$901, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$901.length });
  const _file_macro_id = _bind$3._1;
  const _bind$4 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$896, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$896.length });
  const _date_macro_id = _bind$4._1;
  const _bind$5 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$891, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$891.length });
  const _time_macro_id = _bind$5._1;
  const _bind$6 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$886, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$886.length });
  const _defined_id = _bind$6._1;
  const _bind$7 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$881, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$881.length });
  const _has_include_id = _bind$7._1;
  const _bind$8 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$876, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$876.length });
  const _has_include_next_id = _bind$8._1;
  const _bind$9 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$871, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$871.length });
  const _dir_define_id = _bind$9._1;
  const _bind$10 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$866, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$866.length });
  const _dir_undef_id = _bind$10._1;
  const _bind$11 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$861, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$861.length });
  const _dir_if_id = _bind$11._1;
  const _bind$12 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$856, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$856.length });
  const _dir_ifdef_id = _bind$12._1;
  const _bind$13 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$851, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$851.length });
  const _dir_ifndef_id = _bind$13._1;
  const _bind$14 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$846, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$846.length });
  const _dir_elif_id = _bind$14._1;
  const _bind$15 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$841, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$841.length });
  const _dir_else_id = _bind$15._1;
  const _bind$16 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$836, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$836.length });
  const _dir_endif_id = _bind$16._1;
  const _bind$17 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$831, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$831.length });
  const _dir_include_id = _bind$17._1;
  const _bind$18 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$826, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$826.length });
  const _dir_include_next_id = _bind$18._1;
  const _bind$19 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$821, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$821.length });
  const _dir_line_id = _bind$19._1;
  const _bind$20 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$816, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$816.length });
  const _dir_error_id = _bind$20._1;
  const _bind$21 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$811, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$811.length });
  const _dir_warning_id = _bind$21._1;
  const _bind$22 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(interner, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$806, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor$46$42$bind$124$806.length });
  const _dir_pragma_id = _bind$22._1;
  const lexeme_pool = hackwaly$tinycc$frontend$tokens$$new_lexeme_pool(lexeme_capacity);
  const pp = { host: host, lexer: hackwaly$tinycc$frontend$lexer$$new_lexer(file, diags, interner, keyword_ids, lexeme_pool), lexer_stack: moonbitlang$core$array$$Array$new$46$inner$102$(16), held_stack: moonbitlang$core$array$$Array$new$46$inner$103$(16), path_stack: moonbitlang$core$array$$Array$new$46$inner$19$(16), dir_stack: moonbitlang$core$array$$Array$new$46$inner$19$(16), current_path: file.path, current_dir: hackwaly$tinycc$frontend$preproc$preproc_core$$dir_name(file.path), logical_path: file.path, logical_path_stack: moonbitlang$core$array$$Array$new$46$inner$19$(16), line_adjust: 0, line_adjust_stack: moonbitlang$core$array$$Array$new$46$inner$26$(16), include_paths: moonbitlang$core$array$$Array$new$46$inner$19$(16), diags: diags, map: map, macros: [], macro_epoch: 0, pending: moonbitlang$core$array$$Array$new$46$inner$15$(pending_capacity), held: undefined, cond_stack: moonbitlang$core$array$$Array$new$46$inner$41$(64), active: true, expanding: moonbitlang$core$array$$Array$new$46$inner$26$(64), expanding_guards: moonbitlang$core$array$$Array$new$46$inner$40$(64), date_literal: _date_literal, time_literal: _time_literal, interner: interner, keyword_ids: keyword_ids, lexeme_pool: lexeme_pool, hidden_pool: hackwaly$tinycc$frontend$preproc$preproc_core$$new_hidden_pool(), builtin_ids: { line_macro: _line_macro_id, file_macro: _file_macro_id, date_macro: _date_macro_id, time_macro: _time_macro_id, defined: _defined_id, has_include: _has_include_id, has_include_next: _has_include_next_id, dir_define: _dir_define_id, dir_undef: _dir_undef_id, dir_if: _dir_if_id, dir_ifdef: _dir_ifdef_id, dir_ifndef: _dir_ifndef_id, dir_elif: _dir_elif_id, dir_else: _dir_else_id, dir_endif: _dir_endif_id, dir_include: _dir_include_id, dir_include_next: _dir_include_next_id, dir_line: _dir_line_id, dir_error: _dir_error_id, dir_warning: _dir_warning_id, dir_pragma: _dir_pragma_id } };
  hackwaly$tinycc$frontend$preproc$preproc_core$$init_builtin_macros(pp);
  return pp;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$finalize_preprocessor(pp) {
  const dummy_file = { id: pp.lexer.file_id, path: pp.current_path, text: "" };
  pp.lexer = hackwaly$tinycc$frontend$lexer$$new_lexer(dummy_file, pp.diags, pp.interner, pp.keyword_ids, pp.lexeme_pool);
  moonbitlang$core$array$$Array$clear$102$(pp.lexer_stack);
  moonbitlang$core$array$$Array$clear$103$(pp.held_stack);
  moonbitlang$core$array$$Array$clear$19$(pp.path_stack);
  moonbitlang$core$array$$Array$clear$19$(pp.dir_stack);
  moonbitlang$core$array$$Array$clear$19$(pp.logical_path_stack);
  moonbitlang$core$array$$Array$clear$26$(pp.line_adjust_stack);
  moonbitlang$core$array$$Array$clear$19$(pp.include_paths);
  moonbitlang$core$array$$Array$clear$43$(pp.macros);
  pp.macro_epoch = 0;
  moonbitlang$core$array$$Array$clear$15$(pp.pending);
  moonbitlang$core$array$$Array$clear$41$(pp.cond_stack);
  moonbitlang$core$array$$Array$clear$26$(pp.expanding);
  moonbitlang$core$array$$Array$clear$40$(pp.expanding_guards);
  hackwaly$tinycc$frontend$preproc$preproc_core$$clear_hidden_pool(pp.hidden_pool);
  let i = 0;
  while (true) {
    if (i < pp.map.files.length) {
      const file = moonbitlang$core$array$$Array$at$27$(pp.map.files, i);
      if (file.text.length > 0) {
        moonbitlang$core$array$$Array$set$27$(pp.map.files, i, { id: file.id, path: file.path, text: "" });
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$Array$clear$32$(pp.lexeme_pool.entries);
  moonbitlang$core$array$$Array$clear$26$(pp.interner.buckets);
  moonbitlang$core$array$$Array$clear$26$(pp.interner.next_by_id);
  moonbitlang$core$array$$Array$clear$19$(pp.interner.strings);
  moonbitlang$core$array$$Array$clear$12$(pp.interner.views);
  moonbitlang$core$array$$Array$clear$24$(pp.interner.hashes);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, message) {
  hackwaly$tinycc$support$diag$$add_error(pp.diags, loc, message);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$is_macro_name_token(tok) {
  return hackwaly$tinycc$frontend$tokens$$token_id(tok) > 0;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(_pp, tok) {
  return hackwaly$tinycc$frontend$tokens$$token_id(tok);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$get_macro(pp, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = pp.macros.length;
  return id <= len ? moonbitlang$core$array$$Array$at$43$(pp.macros, id - 1 | 0) : undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$has_macro(pp, id) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$get_macro(pp, id);
  return !(_bind === undefined);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$remove_macro(pp, id) {
  if (id <= 0) {
    return undefined;
  }
  const len = pp.macros.length;
  if (id <= len) {
    moonbitlang$core$array$$Array$set$43$(pp.macros, id - 1 | 0, undefined);
    pp.macro_epoch = pp.macro_epoch + 1 | 0;
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$next_input_token(pp) {
  while (true) {
    const _bind = pp.held;
    if (_bind === undefined) {
      const tok = hackwaly$tinycc$frontend$lexer$$next_token(pp.lexer);
      _L: {
        const _bind$2 = tok.kind;
        if (_bind$2 === 0) {
          if (pp.lexer_stack.length > 0) {
            const _bind$3 = moonbitlang$core$array$$Array$pop$102$(pp.lexer_stack);
            if (_bind$3 === undefined) {
            } else {
              const _Some = _bind$3;
              const _prev = _Some;
              pp.lexer = _prev;
            }
            const _bind$4 = moonbitlang$core$array$$Array$pop$103$(pp.held_stack);
            if (_bind$4.$tag === 1) {
              const _Some = _bind$4;
              const _prev_held = _Some._0;
              pp.held = _prev_held;
            }
            const _bind$5 = moonbitlang$core$array$$Array$pop$19$(pp.path_stack);
            if (_bind$5 === undefined) {
            } else {
              const _Some = _bind$5;
              const _prev_path = _Some;
              pp.current_path = _prev_path;
            }
            const _bind$6 = moonbitlang$core$array$$Array$pop$19$(pp.dir_stack);
            if (_bind$6 === undefined) {
            } else {
              const _Some = _bind$6;
              const _prev_dir = _Some;
              pp.current_dir = _prev_dir;
            }
            const _bind$7 = moonbitlang$core$array$$Array$pop$19$(pp.logical_path_stack);
            if (_bind$7 === undefined) {
            } else {
              const _Some = _bind$7;
              const _prev_path = _Some;
              pp.logical_path = _prev_path;
            }
            const _bind$8 = moonbitlang$core$array$$Array$pop$26$(pp.line_adjust_stack);
            if (_bind$8 === undefined) {
            } else {
              const _Some = _bind$8;
              const _prev_adjust = _Some;
              pp.line_adjust = _prev_adjust;
            }
            continue;
          } else {
            break _L;
          }
        } else {
          break _L;
        }
      }
      return tok;
    } else {
      const _Some = _bind;
      const _tok = _Some;
      pp.held = undefined;
      return _tok;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_tokens(pp) {
  const out = [];
  while (true) {
    const tok = hackwaly$tinycc$frontend$preproc$preproc_core$$next_input_token(pp);
    const _bind = tok.kind;
    if (_bind === 0) {
      pp.held = tok;
      break;
    } else {
      if (tok.line_start) {
        pp.held = tok;
        break;
      }
      moonbitlang$core$array$$Array$push$15$(out, tok);
    }
    continue;
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_head_token(pp) {
  const tok = hackwaly$tinycc$frontend$preproc$preproc_core$$next_input_token(pp);
  const _bind = tok.kind;
  if (_bind === 0) {
    pp.held = tok;
    return undefined;
  } else {
    if (tok.line_start) {
      pp.held = tok;
      return undefined;
    } else {
      return tok;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp) {
  while (true) {
    const _bind = hackwaly$tinycc$frontend$lexer$$peek_char(pp.lexer);
    if (_bind === -1) {
      return undefined;
    } else {
      const _Some = _bind;
      const _code = _Some;
      const _p$28 = 92;
      if (_code === _p$28) {
        _L: {
          const _bind$2 = hackwaly$tinycc$frontend$lexer$$peek_char_offset(pp.lexer, 1);
          if (_bind$2 === -1) {
            break _L;
          } else {
            const _Some$2 = _bind$2;
            const _x = _Some$2;
            if (_x === 10) {
              hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
              hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
              continue;
            } else {
              break _L;
            }
          }
        }
      }
      hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
      const _p$29 = 10;
      if (_code === _p$29) {
        return undefined;
      }
    }
    continue;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$skip_inactive(pp) {
  const lex = pp.lexer;
  const text = lex.text;
  const len = lex.text_len;
  while (true) {
    if (lex.index < len) {
      const idx = lex.index;
      $bound_check(text, idx);
      const code = text.charCodeAt(idx);
      if (lex.line_start) {
        if (hackwaly$tinycc$frontend$lexer$$is_ws_no_newline(code)) {
          lex.index = idx + 1 | 0;
          lex.col = lex.col + 1 | 0;
          continue;
        }
        const _p$28 = 10;
        if (code === _p$28) {
          lex.index = idx + 1 | 0;
          lex.line = lex.line + 1 | 0;
          lex.col = 1;
          lex.line_start = true;
          continue;
        }
        let _tmp$27;
        const _p$29 = 92;
        if (code === _p$29) {
          let _tmp$28;
          if ((idx + 1 | 0) < len) {
            const _tmp$29 = idx + 1 | 0;
            $bound_check(text, _tmp$29);
            const _p$30 = text.charCodeAt(_tmp$29);
            const _p$31 = 10;
            _tmp$28 = _p$30 === _p$31;
          } else {
            _tmp$28 = false;
          }
          _tmp$27 = _tmp$28;
        } else {
          _tmp$27 = false;
        }
        if (_tmp$27) {
          lex.index = idx + 2 | 0;
          lex.line = lex.line + 1 | 0;
          lex.col = 1;
          lex.line_start = false;
          continue;
        }
        let _tmp$28;
        const _p$30 = 47;
        if (code === _p$30) {
          _tmp$28 = (idx + 1 | 0) < len;
        } else {
          _tmp$28 = false;
        }
        if (_tmp$28) {
          const _tmp$29 = idx + 1 | 0;
          $bound_check(text, _tmp$29);
          const next_code = text.charCodeAt(_tmp$29);
          const _p$31 = 47;
          if (next_code === _p$31) {
            lex.index = idx + 2 | 0;
            lex.col = lex.col + 2 | 0;
            hackwaly$tinycc$frontend$lexer$$skip_line_comment(lex);
            continue;
          }
          const _p$32 = 42;
          if (next_code === _p$32) {
            const start_loc = hackwaly$tinycc$frontend$lexer$$lexer_loc(lex);
            lex.index = idx + 2 | 0;
            lex.col = lex.col + 2 | 0;
            hackwaly$tinycc$frontend$lexer$$skip_block_comment(lex, start_loc);
            continue;
          }
        }
        const _p$31 = 35;
        if (code === _p$31) {
          return undefined;
        }
      }
      const _p$28 = 10;
      if (code === _p$28) {
        lex.index = idx + 1 | 0;
        lex.line = lex.line + 1 | 0;
        lex.col = 1;
        lex.line_start = true;
        continue;
      }
      let _tmp$27;
      const _p$29 = 92;
      if (code === _p$29) {
        let _tmp$28;
        if ((idx + 1 | 0) < len) {
          const _tmp$29 = idx + 1 | 0;
          $bound_check(text, _tmp$29);
          const _p$30 = text.charCodeAt(_tmp$29);
          const _p$31 = 10;
          _tmp$28 = _p$30 === _p$31;
        } else {
          _tmp$28 = false;
        }
        _tmp$27 = _tmp$28;
      } else {
        _tmp$27 = false;
      }
      if (_tmp$27) {
        lex.index = idx + 2 | 0;
        lex.line = lex.line + 1 | 0;
        lex.col = 1;
        lex.line_start = false;
        continue;
      }
      let _tmp$28;
      const _p$30 = 47;
      if (code === _p$30) {
        _tmp$28 = (idx + 1 | 0) < len;
      } else {
        _tmp$28 = false;
      }
      if (_tmp$28) {
        const _tmp$29 = idx + 1 | 0;
        $bound_check(text, _tmp$29);
        const next_code = text.charCodeAt(_tmp$29);
        const _p$31 = 47;
        if (next_code === _p$31) {
          lex.index = idx + 2 | 0;
          lex.col = lex.col + 2 | 0;
          hackwaly$tinycc$frontend$lexer$$skip_line_comment(lex);
          continue;
        }
        const _p$32 = 42;
        if (next_code === _p$32) {
          const start_loc = hackwaly$tinycc$frontend$lexer$$lexer_loc(lex);
          lex.index = idx + 2 | 0;
          lex.col = lex.col + 2 | 0;
          hackwaly$tinycc$frontend$lexer$$skip_block_comment(lex, start_loc);
          continue;
        }
      }
      let _tmp$29;
      const _p$31 = 34;
      if (code === _p$31) {
        _tmp$29 = true;
      } else {
        const _p$32 = 39;
        _tmp$29 = code === _p$32;
      }
      if (_tmp$29) {
        const start_loc = hackwaly$tinycc$frontend$lexer$$lexer_loc(lex);
        hackwaly$tinycc$frontend$lexer$$skip_string_literal(lex, start_loc, code);
        continue;
      }
      lex.index = idx + 1 | 0;
      lex.col = lex.col + 1 | 0;
      lex.line_start = false;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_text(pp) {
  const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  let saw_non_ws = false;
  while (true) {
    const _bind = hackwaly$tinycc$frontend$lexer$$peek_char(pp.lexer);
    if (_bind === -1) {
      return sb.val;
    } else {
      const _Some = _bind;
      const _code = _Some;
      const _p$28 = 92;
      if (_code === _p$28) {
        _L: {
          const _bind$2 = hackwaly$tinycc$frontend$lexer$$peek_char_offset(pp.lexer, 1);
          if (_bind$2 === -1) {
            break _L;
          } else {
            const _Some$2 = _bind$2;
            const _x = _Some$2;
            if (_x === 10) {
              hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
              hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
              continue;
            } else {
              break _L;
            }
          }
        }
      }
      const _p$29 = 10;
      if (_code === _p$29) {
        hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
        return sb.val;
      }
      if (!saw_non_ws && hackwaly$tinycc$frontend$lexer$$is_ws_no_newline(_code)) {
        hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
        continue;
      }
      saw_non_ws = true;
      moonbitlang$core$builtin$$Logger$write_char$1$(sb, _code);
      hackwaly$tinycc$frontend$lexer$$advance(pp.lexer);
    }
    continue;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$slice_tokens(tokens, start) {
  if (start <= 0) {
    return tokens;
  }
  if (start >= tokens.length) {
    return [];
  }
  return moonbitlang$core$array$$ArrayView$to_array$15$(moonbitlang$core$array$$Array$sub$46$inner$15$(tokens, start, tokens.length));
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$prefix_tokens(tokens, end) {
  if (end <= 0) {
    return [];
  }
  const total_len = tokens.length;
  const capacity = total_len > end ? total_len : end;
  const out = moonbitlang$core$array$$Array$new$46$inner$15$(capacity);
  let i = 0;
  while (true) {
    if (i < end) {
      moonbitlang$core$array$$Array$push$15$(out, moonbitlang$core$array$$Array$at$15$(tokens, i));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$join_path(base, name) {
  if (base === "") {
    return name;
  }
  return moonbitlang$core$string$$String$has_suffix(base, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$join_path$46$42$bind$124$993, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$join_path$46$42$bind$124$993.length }) ? `${base}${name}` : `${base}/${name}`;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$add_include_path(pp, path) {
  moonbitlang$core$array$$Array$push$19$(pp.include_paths, path);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$strip_quotes(lexeme) {
  const len = lexeme.length;
  let _tmp$27;
  if (len >= 2) {
    let _tmp$28;
    $bound_check(lexeme, 0);
    const _p$28 = lexeme.charCodeAt(0);
    const _p$29 = 34;
    if (_p$28 === _p$29) {
      const _tmp$29 = len - 1 | 0;
      $bound_check(lexeme, _tmp$29);
      const _p$30 = lexeme.charCodeAt(_tmp$29);
      const _p$31 = 34;
      _tmp$28 = _p$30 === _p$31;
    } else {
      _tmp$28 = false;
    }
    _tmp$27 = _tmp$28;
  } else {
    _tmp$27 = false;
  }
  if (_tmp$27) {
    return hackwaly$tinycc$support$util$$slice_string(lexeme, 1, len - 1 | 0);
  }
  return lexeme;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_include_path(pp, args, loc) {
  if (args.length === 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "missing include path");
    return undefined;
  }
  if (moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(args, 0).kind, 6)) {
    return { path: hackwaly$tinycc$frontend$preproc$preproc_core$$strip_quotes(hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(args, 0))), is_angle: false };
  }
  if (moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(args, 0).kind, 77)) {
    const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
    let i = 1;
    while (true) {
      if (i < args.length) {
        if (moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(args, i).kind, 79)) {
          return { path: sb.val, is_angle: true };
        }
        moonbitlang$core$builtin$$Logger$write_string$1$(sb, hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(args, i)));
        i = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unterminated include path");
    return undefined;
  }
  hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid include path");
  return undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_has_include_path(pp, args) {
  if (args.length === 0) {
    return undefined;
  }
  if (moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(args, 0).kind, 6)) {
    return { path: hackwaly$tinycc$frontend$preproc$preproc_core$$strip_quotes(hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(args, 0))), is_angle: false };
  }
  if (moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(args, 0).kind, 77)) {
    const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
    let i = 1;
    while (true) {
      if (i < args.length) {
        if (moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(args, i).kind, 79)) {
          return { path: sb.val, is_angle: true };
        }
        moonbitlang$core$builtin$$Logger$write_string$1$(sb, hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(args, i)));
        i = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  return undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$resolve_include_path(pp, path, is_angle, include_next) {
  if (moonbitlang$core$string$$String$has_prefix(path, { str: hackwaly$tinycc$frontend$preproc$preproc_core$$resolve_include_path$46$42$bind$124$996, start: 0, end: hackwaly$tinycc$frontend$preproc$preproc_core$$resolve_include_path$46$42$bind$124$996.length })) {
    return path;
  }
  let skip_first = include_next;
  if (!is_angle) {
    if (skip_first) {
      skip_first = false;
    } else {
      const candidate = hackwaly$tinycc$frontend$preproc$preproc_core$$join_path(pp.current_dir, path);
      const _tmp$27 = pp.host;
      if (_tmp$27.method_table.method_0(_tmp$27.self, candidate)) {
        return candidate;
      }
    }
  }
  const _arr = pp.include_paths;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      _L: {
        const p = _arr[_i];
        if (skip_first) {
          skip_first = false;
          break _L;
        }
        const candidate = hackwaly$tinycc$frontend$preproc$preproc_core$$join_path(p, path);
        const _tmp$28 = pp.host;
        if (_tmp$28.method_table.method_0(_tmp$28.self, candidate)) {
          return candidate;
        }
        break _L;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$eval_has_include(pp, args, include_next) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_has_include_path(pp, args);
  if (_bind === undefined) {
    return 0;
  } else {
    const _Some = _bind;
    const _spec = _Some;
    const _bind$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$resolve_include_path(pp, _spec.path, _spec.is_angle, include_next);
    return _bind$2 === undefined ? 0 : 1;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$include_file(pp, spec, loc, include_next) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$resolve_include_path(pp, spec.path, spec.is_angle, include_next);
  if (_bind === undefined) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, `include not found: ${spec.path}`);
    return;
  } else {
    const _Some = _bind;
    const _resolved = _Some;
    let _try_err;
    _L: {
      const _tmp$27 = pp.host;
      const _bind$2 = _tmp$27.method_table.method_1(_tmp$27.self, _resolved);
      let _bind$3;
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _bind$3 = _ok._0;
      } else {
        const _err = _bind$2;
        const _tmp$28 = _err._0;
        _try_err = _tmp$28;
        break _L;
      }
      const file = hackwaly$tinycc$support$source$$add_file(pp.map, _resolved, _bind$3);
      moonbitlang$core$array$$Array$push$102$(pp.lexer_stack, pp.lexer);
      moonbitlang$core$array$$Array$push$103$(pp.held_stack, pp.held);
      pp.held = undefined;
      moonbitlang$core$array$$Array$push$19$(pp.path_stack, pp.current_path);
      moonbitlang$core$array$$Array$push$19$(pp.dir_stack, pp.current_dir);
      moonbitlang$core$array$$Array$push$19$(pp.logical_path_stack, pp.logical_path);
      moonbitlang$core$array$$Array$push$26$(pp.line_adjust_stack, pp.line_adjust);
      pp.lexer = hackwaly$tinycc$frontend$lexer$$new_lexer(file, pp.diags, pp.interner, pp.keyword_ids, pp.lexeme_pool);
      pp.current_path = _resolved;
      pp.current_dir = hackwaly$tinycc$frontend$preproc$preproc_core$$dir_name(_resolved);
      pp.logical_path = _resolved;
      pp.line_adjust = 0;
      return;
    }
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, `failed to read include: ${moonbitlang$core$builtin$$Show$to_string$92$(_try_err)}`);
    return;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$is_adjacent(pp, left, right) {
  return left.loc.file_id === right.loc.file_id && right.loc.offset === (left.loc.offset + hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme_len(pp, left) | 0);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$normalize_macro_tokens(tokens) {
  let needs_copy = false;
  const _len = tokens.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const tok = tokens[_i];
      if (tok.line_start) {
        needs_copy = true;
        break;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (!needs_copy) {
    return tokens;
  }
  const out = moonbitlang$core$array$$Array$new$46$inner$15$(tokens.length);
  const _len$2 = tokens.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len$2) {
      const tok = tokens[_i];
      moonbitlang$core$array$$Array$push$15$(out, { kind: tok.kind, value: tok.value, loc: tok.loc, line_start: false, hidden: tok.hidden });
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_macro_params(pp, args, loc) {
  const params = [];
  let i = 1;
  let is_variadic = false;
  _L: while (true) {
    if (i < args.length) {
      const tok = moonbitlang$core$array$$Array$at$15$(args, i);
      const _bind = tok.kind;
      switch (_bind) {
        case 50: {
          i = i + 1 | 0;
          const replacement = hackwaly$tinycc$frontend$preproc$preproc_core$$slice_tokens(args, i);
          return { _0: params, _1: is_variadic, _2: replacement };
        }
        case 60: {
          is_variadic = true;
          const varargs_id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, "__VA_ARGS__");
          moonbitlang$core$array$$Array$push$26$(params, varargs_id);
          i = i + 1 | 0;
          continue _L;
        }
        case 2: {
          const param_id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(pp, tok);
          if (param_id === 0) {
            hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid macro parameter");
            return undefined;
          }
          moonbitlang$core$array$$Array$push$26$(params, param_id);
          i = i + 1 | 0;
          if (i < args.length) {
            const _bind$2 = moonbitlang$core$array$$Array$at$15$(args, i).kind;
            if (_bind$2 === 55) {
              i = i + 1 | 0;
              if (i < args.length) {
                const _bind$3 = moonbitlang$core$array$$Array$at$15$(args, i).kind;
                if (_bind$3 === 60) {
                  is_variadic = true;
                  const varargs_id$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, "__VA_ARGS__");
                  moonbitlang$core$array$$Array$push$26$(params, varargs_id$2);
                  i = i + 1 | 0;
                }
              }
              continue _L;
            }
          }
          break;
        }
        default: {
          hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid macro parameter");
          return undefined;
        }
      }
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unterminated macro parameter list");
  return undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_define_macro(pp, name_tok, args, loc) {
  const is_function_like = args.length > 0 && (moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(args, 0).kind, 49) && hackwaly$tinycc$frontend$preproc$preproc_core$$is_adjacent(pp, name_tok, moonbitlang$core$array$$Array$at$15$(args, 0)));
  if (is_function_like) {
    const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_macro_params(pp, args, loc);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _params = _x._0;
      const _is_variadic = _x._1;
      const _replacement = _x._2;
      const normalized = hackwaly$tinycc$frontend$preproc$preproc_core$$normalize_macro_tokens(_replacement);
      return { params: _params, is_variadic: _is_variadic, is_function: true, replacement: normalized, replacement_has_id: hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_have_id(normalized), replacement_needs_expand: false, replacement_needs_epoch: -1 };
    }
  } else {
    const normalized = hackwaly$tinycc$frontend$preproc$preproc_core$$normalize_macro_tokens(args);
    return { params: [], is_variadic: false, is_function: false, replacement: normalized, replacement_has_id: hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_have_id(normalized), replacement_needs_expand: false, replacement_needs_epoch: -1 };
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp) {
  moonbitlang$core$array$$Array$pop$26$(pp.expanding);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$release_expanding_guards(pp) {
  while (true) {
    if (pp.expanding_guards.length > 0) {
      const guard_restore = moonbitlang$core$array$$Array$at$40$(pp.expanding_guards, pp.expanding_guards.length - 1 | 0).restore_len;
      if (pp.pending.length <= guard_restore) {
        hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp);
        moonbitlang$core$array$$Array$pop$40$(pp.expanding_guards);
      } else {
        break;
      }
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$next_raw_token(pp) {
  if (pp.pending.length > 0) {
    const _bind = moonbitlang$core$array$$Array$pop$15$(pp.pending);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _tok = _Some;
      hackwaly$tinycc$frontend$preproc$preproc_core$$release_expanding_guards(pp);
      return _tok;
    }
  }
  return hackwaly$tinycc$frontend$preproc$preproc_core$$next_input_token(pp);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$push_back(pp, tok) {
  moonbitlang$core$array$$Array$push$15$(pp.pending, tok);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$read_macro_args(pp, loc) {
  const args = [];
  let current = [];
  let depth_paren = 0;
  let depth_brace = 0;
  let depth_bracket = 0;
  _L: while (true) {
    const tok = hackwaly$tinycc$frontend$preproc$preproc_core$$next_raw_token(pp);
    const _bind = tok.kind;
    switch (_bind) {
      case 0: {
        hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unterminated macro invocation");
        return Option$None$35$;
      }
      case 49: {
        depth_paren = depth_paren + 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        continue _L;
      }
      case 50: {
        if (depth_paren === 0 && (depth_brace === 0 && depth_bracket === 0)) {
          if (current.length > 0 || args.length > 0) {
            moonbitlang$core$array$$Array$push$44$(args, current);
          }
          return new Option$Some$35$(args);
        }
        depth_paren = depth_paren - 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        continue _L;
      }
      case 51: {
        depth_brace = depth_brace + 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        continue _L;
      }
      case 52: {
        if (depth_brace > 0) {
          depth_brace = depth_brace - 1 | 0;
        }
        moonbitlang$core$array$$Array$push$15$(current, tok);
        continue _L;
      }
      case 53: {
        depth_bracket = depth_bracket + 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        continue _L;
      }
      case 54: {
        if (depth_bracket > 0) {
          depth_bracket = depth_bracket - 1 | 0;
        }
        moonbitlang$core$array$$Array$push$15$(current, tok);
        continue _L;
      }
      case 55: {
        if (depth_paren === 0 && (depth_brace === 0 && depth_bracket === 0)) {
          moonbitlang$core$array$$Array$push$44$(args, current);
          current = [];
          continue _L;
        } else {
          moonbitlang$core$array$$Array$push$15$(current, tok);
        }
        break;
      }
      default: {
        moonbitlang$core$array$$Array$push$15$(current, tok);
      }
    }
    continue;
  }
  return Option$None$35$;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$normalize_macro_args(macro_def, args, loc) {
  if (!macro_def.is_function) {
    return new Option$Some$35$(args);
  }
  const param_count = macro_def.params.length;
  if (macro_def.is_variadic) {
    if (args.length < (param_count - 1 | 0)) {
      return Option$None$35$;
    }
    const out = [];
    let _tmp$27 = 0;
    while (true) {
      const i = _tmp$27;
      if (i < (param_count - 1 | 0)) {
        moonbitlang$core$array$$Array$push$44$(out, moonbitlang$core$array$$Array$at$44$(args, i));
        _tmp$27 = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const var_tokens = [];
    let _tmp$28 = param_count - 1 | 0;
    while (true) {
      const i = _tmp$28;
      if (i < args.length) {
        if (var_tokens.length > 0) {
          moonbitlang$core$array$$Array$push$15$(var_tokens, { kind: 55, value: 0, loc: loc, line_start: false, hidden: hackwaly$tinycc$frontend$tokens$$empty_hidden });
        }
        const _arr = moonbitlang$core$array$$Array$at$44$(args, i);
        const _len = _arr.length;
        let _tmp$29 = 0;
        while (true) {
          const _i = _tmp$29;
          if (_i < _len) {
            const t = _arr[_i];
            moonbitlang$core$array$$Array$push$15$(var_tokens, t);
            _tmp$29 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        _tmp$28 = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$push$44$(out, var_tokens);
    return new Option$Some$35$(out);
  }
  if (args.length !== param_count) {
    return Option$None$35$;
  }
  return new Option$Some$35$(args);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$is_expanding(pp, id) {
  const _arr = pp.expanding;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const n = _arr[_i];
      if (n === id) {
        return true;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return false;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$push_expanding(pp, id) {
  moonbitlang$core$array$$Array$push$26$(pp.expanding, id);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$stringize_tokens(pp, tokens) {
  if (tokens.length === 0) {
    return "";
  }
  if (tokens.length === 1) {
    return hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(tokens, 0));
  }
  let size_hint = 0;
  const _len = tokens.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const tok = tokens[_i];
      size_hint = (size_hint + hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme_len(pp, tok) | 0) + 1 | 0;
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (size_hint > 0) {
    size_hint = size_hint - 1 | 0;
  }
  const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(size_hint);
  let first = true;
  let prev = undefined;
  const _len$2 = tokens.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len$2) {
      const tok = tokens[_i];
      if (first) {
        first = false;
      } else {
        const _bind = prev;
        if (_bind === undefined) {
          moonbitlang$core$builtin$$Logger$write_char$1$(sb, 32);
        } else {
          const _Some = _bind;
          const _prev_tok = _Some;
          if (!hackwaly$tinycc$frontend$preproc$preproc_core$$is_adjacent(pp, _prev_tok, tok)) {
            moonbitlang$core$builtin$$Logger$write_char$1$(sb, 32);
          }
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$1$(sb, hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, tok));
      prev = tok;
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return sb.val;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$escape_string(text) {
  const len = text.length;
  let i = 0;
  while (true) {
    if (i < len) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      let _tmp$28;
      const _p$28 = 92;
      if (code === _p$28) {
        _tmp$28 = true;
      } else {
        const _p$29 = 34;
        _tmp$28 = code === _p$29;
      }
      if (_tmp$28) {
        break;
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (i === len) {
    return text;
  }
  const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(len);
  let j = 0;
  while (true) {
    if (j < len) {
      const _tmp$27 = j;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      const _p$28 = 92;
      if (code === _p$28) {
        moonbitlang$core$builtin$$Logger$write_string$1$(sb, "\\\\");
      } else {
        const _p$29 = 34;
        if (code === _p$29) {
          moonbitlang$core$builtin$$Logger$write_string$1$(sb, "\\\"");
        } else {
          moonbitlang$core$builtin$$Logger$write_char$1$(sb, code);
        }
      }
      j = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return sb.val;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$make_string_literal(pp, text, loc) {
  const escaped = hackwaly$tinycc$frontend$preproc$preproc_core$$escape_string(text);
  const lexeme_id = hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, `\"${escaped}\"`);
  const token_value = hackwaly$tinycc$frontend$tokens$$token_value_from_parts(0, lexeme_id);
  return { kind: 6, value: token_value, loc: loc, line_start: false, hidden: hackwaly$tinycc$frontend$tokens$$empty_hidden };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$make_int_literal_token(pp, value, loc) {
  const lexeme_id = hackwaly$tinycc$frontend$tokens$$lexeme_pool_intern(pp.lexeme_pool, moonbitlang$core$int$$Int$to_string$46$inner(value, 10));
  const token_value = hackwaly$tinycc$frontend$tokens$$token_value_from_parts(0, lexeme_id);
  return { kind: 3, value: token_value, loc: loc, line_start: false, hidden: hackwaly$tinycc$frontend$tokens$$empty_hidden };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$builtin_macro_tokens(pp, tok) {
  const id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
  if (id === pp.builtin_ids.line_macro) {
    const _p$28 = tok.loc;
    const _tmp$27 = _p$28.line + pp.line_adjust | 0;
    return new Option$Some$36$([hackwaly$tinycc$frontend$preproc$preproc_core$$make_int_literal_token(pp, _tmp$27, tok.loc)]);
  }
  if (id === pp.builtin_ids.file_macro) {
    const path = pp.logical_path === "" ? pp.current_path : pp.logical_path;
    return new Option$Some$36$([hackwaly$tinycc$frontend$preproc$preproc_core$$make_string_literal(pp, path, tok.loc)]);
  }
  if (id === pp.builtin_ids.date_macro) {
    return new Option$Some$36$([hackwaly$tinycc$frontend$preproc$preproc_core$$make_string_literal(pp, pp.date_literal, tok.loc)]);
  }
  if (id === pp.builtin_ids.time_macro) {
    return new Option$Some$36$([hackwaly$tinycc$frontend$preproc$preproc_core$$make_string_literal(pp, pp.time_literal, tok.loc)]);
  }
  return Option$None$36$;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$is_builtin_macro_id(pp, id) {
  return id === pp.builtin_ids.line_macro || (id === pp.builtin_ids.file_macro || (id === pp.builtin_ids.date_macro || id === pp.builtin_ids.time_macro));
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$token_needs_expansion(pp, tok) {
  const id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
  if (id > 0) {
    let _tmp$27;
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$is_builtin_macro_id(pp, id)) {
      _tmp$27 = true;
    } else {
      const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$get_macro(pp, id);
      _tmp$27 = !(_bind === undefined);
    }
    return _tmp$27;
  } else {
    return false;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_need_expansion(pp, tokens) {
  const _len = tokens.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const tok = tokens[_i];
      if (hackwaly$tinycc$frontend$preproc$preproc_core$$token_needs_expansion(pp, tok)) {
        return true;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return false;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$macro_replacement_needs_expand(pp, macro_id, macro_def) {
  if (!macro_def.replacement_has_id) {
    return false;
  }
  if (macro_def.replacement_needs_epoch === pp.macro_epoch) {
    return macro_def.replacement_needs_expand;
  }
  const needs = hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_need_expansion(pp, macro_def.replacement);
  if (macro_id > 0 && macro_id <= pp.macros.length) {
    moonbitlang$core$array$$Array$set$43$(pp.macros, macro_id - 1 | 0, { params: macro_def.params, is_variadic: macro_def.is_variadic, is_function: macro_def.is_function, replacement: macro_def.replacement, replacement_has_id: macro_def.replacement_has_id, replacement_needs_expand: needs, replacement_needs_epoch: pp.macro_epoch });
  }
  return needs;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$lookup_param_index(params, id) {
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < params.length) {
      if (moonbitlang$core$array$$Array$at$26$(params, i) === id) {
        return i;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$lex_paste_tokens(pp, text, left, right, loc, hidden) {
  const file = { id: loc.file_id, path: ":paste:", text: text };
  const lex = hackwaly$tinycc$frontend$lexer$$new_lexer(file, pp.diags, pp.interner, pp.keyword_ids, pp.lexeme_pool);
  const out = [];
  while (true) {
    const tok = hackwaly$tinycc$frontend$lexer$$next_token(lex);
    const _bind = tok.kind;
    if (_bind === 0) {
      break;
    } else {
      moonbitlang$core$array$$Array$push$15$(out, { kind: tok.kind, value: tok.value, loc: loc, line_start: false, hidden: hidden });
    }
    continue;
  }
  if (out.length > 1) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, `warning: pasting \"${left}\" and \"${right}\" does not give a valid preprocessing token`);
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$ensure_hidden_singleton_slot(pool, id) {
  while (true) {
    if (pool.singleton_by_id.length < id) {
      moonbitlang$core$array$$Array$push$26$(pool.singleton_by_id, 0);
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$hidden_contains(pool, hidden, id) {
  let cur = hidden;
  while (true) {
    if (cur !== 0) {
      const node = moonbitlang$core$array$$Array$at$42$(pool.nodes, cur - 1 | 0);
      if (node.id === id) {
        return true;
      }
      cur = node.next;
      continue;
    } else {
      break;
    }
  }
  return false;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$hidden_add(pool, hidden, id) {
  if (hackwaly$tinycc$frontend$preproc$preproc_core$$hidden_contains(pool, hidden, id)) {
    return hidden;
  }
  if (hidden === 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$ensure_hidden_singleton_slot(pool, id);
    const existing = moonbitlang$core$array$$Array$at$26$(pool.singleton_by_id, id - 1 | 0);
    if (existing !== 0) {
      return existing;
    }
  }
  const node_id = pool.nodes.length + 1 | 0;
  moonbitlang$core$array$$Array$push$42$(pool.nodes, { id: id, next: hidden });
  if (hidden === 0) {
    moonbitlang$core$array$$Array$set$26$(pool.singleton_by_id, id - 1 | 0, node_id);
  }
  return node_id;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$add_hidden(pp, tok, id) {
  const new_hidden = hackwaly$tinycc$frontend$preproc$preproc_core$$hidden_add(pp.hidden_pool, tok.hidden, id);
  return new_hidden === tok.hidden ? tok : { kind: tok.kind, value: tok.value, loc: tok.loc, line_start: tok.line_start, hidden: new_hidden };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$add_hidden_tokens(pp, tokens, id) {
  const out = moonbitlang$core$array$$Array$new$46$inner$15$(tokens.length);
  const _len = tokens.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const tok = tokens[_i];
      moonbitlang$core$array$$Array$push$15$(out, hackwaly$tinycc$frontend$preproc$preproc_core$$add_hidden(pp, tok, id));
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$read_macro_args_from_tokens(pp, tokens, start, loc) {
  const len = tokens.length;
  const args = [];
  let current = [];
  let depth_paren = 0;
  let depth_brace = 0;
  let depth_bracket = 0;
  let i = start;
  while (true) {
    if (i < len) {
      const tok = moonbitlang$core$array$$Array$at$15$(tokens, i);
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 49)) {
        depth_paren = depth_paren + 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 50)) {
        if (depth_paren === 0 && (depth_brace === 0 && depth_bracket === 0)) {
          if (current.length > 0 || args.length > 0) {
            moonbitlang$core$array$$Array$push$44$(args, current);
          }
          return { _0: args, _1: i + 1 | 0 };
        }
        depth_paren = depth_paren - 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 51)) {
        depth_brace = depth_brace + 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 52)) {
        if (depth_brace > 0) {
          depth_brace = depth_brace - 1 | 0;
        }
        moonbitlang$core$array$$Array$push$15$(current, tok);
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 53)) {
        depth_bracket = depth_bracket + 1 | 0;
        moonbitlang$core$array$$Array$push$15$(current, tok);
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 54)) {
        if (depth_bracket > 0) {
          depth_bracket = depth_bracket - 1 | 0;
        }
        moonbitlang$core$array$$Array$push$15$(current, tok);
        i = i + 1 | 0;
        continue;
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 55) && (depth_paren === 0 && (depth_brace === 0 && depth_bracket === 0))) {
        moonbitlang$core$array$$Array$push$44$(args, current);
        current = [];
        i = i + 1 | 0;
        continue;
      }
      moonbitlang$core$array$$Array$push$15$(current, tok);
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unterminated macro invocation");
  return undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$merge_hidden(pool, a, b) {
  if (a === 0) {
    return b;
  }
  if (b === 0) {
    return a;
  }
  let out = a;
  let cur = b;
  while (true) {
    if (cur !== 0) {
      const node = moonbitlang$core$array$$Array$at$42$(pool.nodes, cur - 1 | 0);
      out = hackwaly$tinycc$frontend$preproc$preproc_core$$hidden_add(pool, out, node.id);
      cur = node.next;
      continue;
    } else {
      break;
    }
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$substitute_macro(pp, macro_def, raw_args, loc) {
  if (!macro_def.is_function) {
    return { _0: macro_def.replacement, _1: hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_need_expansion(pp, macro_def.replacement) };
  }
  const out = moonbitlang$core$array$$Array$new$46$inner$15$(macro_def.replacement.length);
  let needs_expand = false;
  const params = macro_def.params;
  const expanded_cache = moonbitlang$core$array$$Array$make$51$(raw_args.length, Option$None$36$);
  let i = 0;
  while (true) {
    if (i < macro_def.replacement.length) {
      const tok = moonbitlang$core$array$$Array$at$15$(macro_def.replacement, i);
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 95) && (i + 1 | 0) < macro_def.replacement.length) {
        const next_tok = moonbitlang$core$array$$Array$at$15$(macro_def.replacement, i + 1 | 0);
        if (moonbitlang$core$builtin$$Eq$equal$85$(next_tok.kind, 2)) {
          const param_id = hackwaly$tinycc$frontend$tokens$$token_id(next_tok);
          if (param_id > 0) {
            const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$lookup_param_index(params, param_id);
            if (_bind === undefined) {
            } else {
              const _Some = _bind;
              const _idx = _Some;
              const arg_tokens = _idx < raw_args.length ? moonbitlang$core$array$$Array$at$44$(raw_args, _idx) : [];
              const string_tok = hackwaly$tinycc$frontend$preproc$preproc_core$$make_string_literal(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$stringize_tokens(pp, arg_tokens), loc);
              moonbitlang$core$array$$Array$push$15$(out, string_tok);
              if (!needs_expand && hackwaly$tinycc$frontend$preproc$preproc_core$$token_needs_expansion(pp, string_tok)) {
                needs_expand = true;
              }
              i = i + 2 | 0;
              continue;
            }
          }
        }
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 96) && (out.length > 0 && (i + 1 | 0) < macro_def.replacement.length)) {
        const _bind = moonbitlang$core$array$$Array$pop$15$(out);
        let last;
        if (_bind === undefined) {
          i = i + 1 | 0;
          continue;
        } else {
          const _Some = _bind;
          last = _Some;
        }
        let next_tokens = [];
        let next_from_param = false;
        const next_tok = moonbitlang$core$array$$Array$at$15$(macro_def.replacement, i + 1 | 0);
        if (moonbitlang$core$builtin$$Eq$equal$85$(next_tok.kind, 2)) {
          const param_id = hackwaly$tinycc$frontend$tokens$$token_id(next_tok);
          if (param_id > 0) {
            const _bind$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$lookup_param_index(params, param_id);
            if (_bind$2 === undefined) {
              next_tokens = [next_tok];
            } else {
              const _Some = _bind$2;
              const _idx = _Some;
              next_tokens = _idx < raw_args.length ? moonbitlang$core$array$$Array$at$44$(raw_args, _idx) : [];
              next_from_param = true;
            }
          } else {
            next_tokens = [next_tok];
          }
        } else {
          next_tokens = [next_tok];
        }
        if (next_tokens.length === 0) {
          moonbitlang$core$array$$Array$push$15$(out, last);
          i = i + 2 | 0;
          continue;
        }
        const last_text = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, last);
        const next_text = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(next_tokens, 0));
        const merged_lexeme = `${last_text}${next_text}`;
        const merged_hidden = hackwaly$tinycc$frontend$preproc$preproc_core$$merge_hidden(pp.hidden_pool, last.hidden, moonbitlang$core$array$$Array$at$15$(next_tokens, 0).hidden);
        const merged_tokens = hackwaly$tinycc$frontend$preproc$preproc_core$$lex_paste_tokens(pp, merged_lexeme, last_text, next_text, loc, merged_hidden);
        const _len = merged_tokens.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const t = merged_tokens[_i];
            moonbitlang$core$array$$Array$push$15$(out, t);
            if (!needs_expand && hackwaly$tinycc$frontend$preproc$preproc_core$$token_needs_expansion(pp, t)) {
              needs_expand = true;
            }
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (next_tokens.length > 1) {
          let _tmp$28 = 1;
          while (true) {
            const j = _tmp$28;
            if (j < next_tokens.length) {
              const t = moonbitlang$core$array$$Array$at$15$(next_tokens, j);
              if (next_from_param) {
                moonbitlang$core$array$$Array$push$15$(out, t);
              } else {
                moonbitlang$core$array$$Array$push$15$(out, { kind: t.kind, value: t.value, loc: loc, line_start: false, hidden: t.hidden });
              }
              if (!needs_expand && hackwaly$tinycc$frontend$preproc$preproc_core$$token_needs_expansion(pp, t)) {
                needs_expand = true;
              }
              _tmp$28 = j + 1 | 0;
              continue;
            } else {
              break;
            }
          }
        }
        i = i + 2 | 0;
        continue;
      }
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 2)) {
        const param_id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
        if (param_id > 0) {
          const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$lookup_param_index(params, param_id);
          if (_bind === undefined) {
          } else {
            const _Some = _bind;
            const _idx = _Some;
            const arg_tokens = hackwaly$tinycc$frontend$preproc$preproc_core$$ensure_expanded_arg(pp, raw_args, expanded_cache, _idx);
            const _len = arg_tokens.length;
            let _tmp$27 = 0;
            while (true) {
              const _i = _tmp$27;
              if (_i < _len) {
                const t = arg_tokens[_i];
                const out_tok = { kind: t.kind, value: t.value, loc: t.loc, line_start: false, hidden: t.hidden };
                moonbitlang$core$array$$Array$push$15$(out, out_tok);
                if (!needs_expand && hackwaly$tinycc$frontend$preproc$preproc_core$$token_needs_expansion(pp, out_tok)) {
                  needs_expand = true;
                }
                _tmp$27 = _i + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            i = i + 1 | 0;
            continue;
          }
        }
      }
      const out_tok = { kind: tok.kind, value: tok.value, loc: loc, line_start: false, hidden: tok.hidden };
      moonbitlang$core$array$$Array$push$15$(out, out_tok);
      if (!needs_expand && hackwaly$tinycc$frontend$preproc$preproc_core$$token_needs_expansion(pp, out_tok)) {
        needs_expand = true;
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: out, _1: needs_expand };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$ensure_expanded_arg(pp, raw_args, expanded_cache, idx) {
  if (idx < 0 || idx >= raw_args.length) {
    return [];
  }
  const _bind = moonbitlang$core$array$$Array$at$51$(expanded_cache, idx);
  if (_bind.$tag === 1) {
    const _Some = _bind;
    return _Some._0;
  } else {
    const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, moonbitlang$core$array$$Array$at$44$(raw_args, idx));
    moonbitlang$core$array$$Array$set$51$(expanded_cache, idx, new Option$Some$36$(expanded));
    return expanded;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, tokens) {
  let _tmp$27 = tokens;
  while (true) {
    const tokens$2 = _tmp$27;
    let out_opt = Option$None$36$;
    let changed = false;
    const len = tokens$2.length;
    let i = 0;
    while (true) {
      if (i < len) {
        const tok = moonbitlang$core$array$$Array$at$15$(tokens$2, i);
        const macro_id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
        const is_macro_name = macro_id > 0;
        if (is_macro_name) {
          const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$builtin_macro_tokens(pp, tok);
          if (_bind.$tag === 1) {
            const _Some = _bind;
            const _replacement = _Some._0;
            const _bind$2 = out_opt;
            let out;
            if (_bind$2.$tag === 1) {
              const _Some$2 = _bind$2;
              out = _Some$2._0;
            } else {
              const arr = hackwaly$tinycc$frontend$preproc$preproc_core$$prefix_tokens(tokens$2, i);
              out_opt = new Option$Some$36$(arr);
              out = arr;
            }
            const _len = _replacement.length;
            let _tmp$28 = 0;
            while (true) {
              const _i = _tmp$28;
              if (_i < _len) {
                const t = _replacement[_i];
                moonbitlang$core$array$$Array$push$15$(out, t);
                _tmp$28 = _i + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            changed = true;
            i = i + 1 | 0;
            continue;
          }
        }
        let hidden_ok;
        if (!is_macro_name) {
          hidden_ok = true;
        } else {
          let _tmp$28;
          const _p$28 = tok.hidden;
          if (_p$28 === 0) {
            _tmp$28 = true;
          } else {
            _tmp$28 = macro_id !== 0 && !hackwaly$tinycc$frontend$preproc$preproc_core$$hidden_contains(pp.hidden_pool, tok.hidden, macro_id);
          }
          hidden_ok = _tmp$28;
        }
        if (is_macro_name && (macro_id !== 0 && hidden_ok)) {
          const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$get_macro(pp, macro_id);
          if (_bind === undefined) {
          } else {
            const _Some = _bind;
            const _macro_def = _Some;
            if (hackwaly$tinycc$frontend$preproc$preproc_core$$is_expanding(pp, macro_id)) {
              const _bind$2 = out_opt;
              if (_bind$2.$tag === 1) {
                const _Some$2 = _bind$2;
                const _arr = _Some$2._0;
                moonbitlang$core$array$$Array$push$15$(_arr, tok);
              }
              i = i + 1 | 0;
              continue;
            }
            if (_macro_def.is_function) {
              if ((i + 1 | 0) < len && moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(tokens$2, i + 1 | 0).kind, 49)) {
                const _bind$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$read_macro_args_from_tokens(pp, tokens$2, i + 2 | 0, tok.loc);
                if (_bind$2 === undefined) {
                  const _bind$3 = out_opt;
                  if (_bind$3.$tag === 1) {
                    const _Some$2 = _bind$3;
                    const _arr = _Some$2._0;
                    moonbitlang$core$array$$Array$push$15$(_arr, tok);
                  }
                  i = i + 1 | 0;
                  continue;
                } else {
                  const _Some$2 = _bind$2;
                  const _x = _Some$2;
                  const _raw_args = _x._0;
                  const _next_i = _x._1;
                  const _bind$3 = hackwaly$tinycc$frontend$preproc$preproc_core$$normalize_macro_args(_macro_def, _raw_args, tok.loc);
                  if (_bind$3.$tag === 0) {
                    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, tok.loc, "macro argument count mismatch");
                    const _bind$4 = out_opt;
                    if (_bind$4.$tag === 1) {
                      const _Some$3 = _bind$4;
                      const _arr = _Some$3._0;
                      moonbitlang$core$array$$Array$push$15$(_arr, tok);
                    }
                    i = _next_i;
                    continue;
                  } else {
                    const _Some$3 = _bind$3;
                    const _norm_raw = _Some$3._0;
                    if (hackwaly$tinycc$frontend$tokens$$token_id(tok) === pp.builtin_ids.has_include || hackwaly$tinycc$frontend$tokens$$token_id(tok) === pp.builtin_ids.has_include_next) {
                      const include_next = hackwaly$tinycc$frontend$tokens$$token_id(tok) === pp.builtin_ids.has_include_next;
                      const arg_tokens = _norm_raw.length > 0 ? hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, moonbitlang$core$array$$Array$at$44$(_norm_raw, 0)) : [];
                      const value = hackwaly$tinycc$frontend$preproc$preproc_core$$eval_has_include(pp, arg_tokens, include_next);
                      const _bind$4 = out_opt;
                      let out;
                      if (_bind$4.$tag === 1) {
                        const _Some$4 = _bind$4;
                        out = _Some$4._0;
                      } else {
                        const arr = hackwaly$tinycc$frontend$preproc$preproc_core$$prefix_tokens(tokens$2, i);
                        out_opt = new Option$Some$36$(arr);
                        out = arr;
                      }
                      moonbitlang$core$array$$Array$push$15$(out, hackwaly$tinycc$frontend$preproc$preproc_core$$make_int_literal_token(pp, value, tok.loc));
                      changed = true;
                      i = _next_i;
                      continue;
                    }
                    const _bind$4 = hackwaly$tinycc$frontend$preproc$preproc_core$$substitute_macro(pp, _macro_def, _norm_raw, tok.loc);
                    const _replaced = _bind$4._0;
                    const _needs_expand = _bind$4._1;
                    let expanded;
                    if (_needs_expand) {
                      hackwaly$tinycc$frontend$preproc$preproc_core$$push_expanding(pp, macro_id);
                      const expanded$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$add_hidden_tokens(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, _replaced), macro_id);
                      hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp);
                      expanded = expanded$2;
                    } else {
                      expanded = _replaced;
                    }
                    const _bind$5 = out_opt;
                    let out;
                    if (_bind$5.$tag === 1) {
                      const _Some$4 = _bind$5;
                      out = _Some$4._0;
                    } else {
                      const arr = hackwaly$tinycc$frontend$preproc$preproc_core$$prefix_tokens(tokens$2, i);
                      out_opt = new Option$Some$36$(arr);
                      out = arr;
                    }
                    const _len = expanded.length;
                    let _tmp$28 = 0;
                    while (true) {
                      const _i = _tmp$28;
                      if (_i < _len) {
                        const t = expanded[_i];
                        moonbitlang$core$array$$Array$push$15$(out, t);
                        _tmp$28 = _i + 1 | 0;
                        continue;
                      } else {
                        break;
                      }
                    }
                    changed = true;
                    i = _next_i;
                    continue;
                  }
                }
              }
              const _bind$2 = out_opt;
              if (_bind$2.$tag === 1) {
                const _Some$2 = _bind$2;
                const _arr = _Some$2._0;
                moonbitlang$core$array$$Array$push$15$(_arr, tok);
              }
              i = i + 1 | 0;
              continue;
            } else {
              let expanded;
              if (hackwaly$tinycc$frontend$preproc$preproc_core$$macro_replacement_needs_expand(pp, macro_id, _macro_def)) {
                hackwaly$tinycc$frontend$preproc$preproc_core$$push_expanding(pp, macro_id);
                const expanded$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$add_hidden_tokens(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, _macro_def.replacement), macro_id);
                hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp);
                expanded = expanded$2;
              } else {
                expanded = _macro_def.replacement;
              }
              const _bind$2 = out_opt;
              let out;
              if (_bind$2.$tag === 1) {
                const _Some$2 = _bind$2;
                out = _Some$2._0;
              } else {
                const arr = hackwaly$tinycc$frontend$preproc$preproc_core$$prefix_tokens(tokens$2, i);
                out_opt = new Option$Some$36$(arr);
                out = arr;
              }
              const _len = expanded.length;
              let _tmp$28 = 0;
              while (true) {
                const _i = _tmp$28;
                if (_i < _len) {
                  const t = expanded[_i];
                  moonbitlang$core$array$$Array$push$15$(out, t);
                  _tmp$28 = _i + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              changed = true;
              i = i + 1 | 0;
              continue;
            }
          }
        }
        const _bind = out_opt;
        if (_bind.$tag === 1) {
          const _Some = _bind;
          const _arr = _Some._0;
          moonbitlang$core$array$$Array$push$15$(_arr, tok);
        }
        i = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _bind = out_opt;
    if (_bind.$tag === 0) {
      return tokens$2;
    } else {
      const _Some = _bind;
      const _out = _Some._0;
      if (changed && hackwaly$tinycc$frontend$preproc$preproc_core$$tokens_need_expansion(pp, _out)) {
        _tmp$27 = _out;
        continue;
      } else {
        return _out;
      }
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$push_cond(pp, cond) {
  const parent = pp.active;
  const active = parent && cond;
  moonbitlang$core$array$$Array$push$41$(pp.cond_stack, { parent_active: parent, taken: active, active: active });
  pp.active = active;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$update_elif(pp, cond, loc) {
  if (pp.cond_stack.length === 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unexpected #elif without #if");
    return undefined;
  }
  const idx = pp.cond_stack.length - 1 | 0;
  const state = moonbitlang$core$array$$Array$at$41$(pp.cond_stack, idx);
  if (!state.parent_active) {
    state.active = false;
  } else {
    if (state.taken) {
      state.active = false;
    } else {
      state.active = cond;
      if (cond) {
        state.taken = true;
      }
    }
  }
  moonbitlang$core$array$$Array$set$41$(pp.cond_stack, idx, state);
  pp.active = state.active;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$update_else(pp, loc) {
  if (pp.cond_stack.length === 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unexpected #else without #if");
    return undefined;
  }
  const idx = pp.cond_stack.length - 1 | 0;
  const state = moonbitlang$core$array$$Array$at$41$(pp.cond_stack, idx);
  if (!state.parent_active) {
    state.active = false;
  } else {
    if (state.taken) {
      state.active = false;
    } else {
      state.active = true;
      state.taken = true;
    }
  }
  moonbitlang$core$array$$Array$set$41$(pp.cond_stack, idx, state);
  pp.active = state.active;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pop_cond(pp, loc) {
  if (pp.cond_stack.length === 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unexpected #endif without #if");
    return undefined;
  }
  moonbitlang$core$array$$Array$pop$41$(pp.cond_stack);
  if (pp.cond_stack.length === 0) {
    pp.active = true;
    return;
  } else {
    const idx = pp.cond_stack.length - 1 | 0;
    pp.active = moonbitlang$core$array$$Array$at$41$(pp.cond_stack, idx).active;
    return;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$expand_if_tokens(pp, tokens) {
  let has_defined = false;
  const _len = tokens.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const tok = tokens[_i];
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 2) && hackwaly$tinycc$frontend$tokens$$token_id(tok) === pp.builtin_ids.defined) {
        has_defined = true;
        break;
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (!has_defined) {
    return hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, tokens);
  }
  const len = tokens.length;
  const out = moonbitlang$core$array$$Array$new$46$inner$15$(len);
  const segment = [];
  let i = 0;
  while (true) {
    if (i < len) {
      const tok = moonbitlang$core$array$$Array$at$15$(tokens, i);
      if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 2) && hackwaly$tinycc$frontend$tokens$$token_id(tok) === pp.builtin_ids.defined) {
        if (segment.length > 0) {
          const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, segment);
          const _len$2 = expanded.length;
          let _tmp$28 = 0;
          while (true) {
            const _i = _tmp$28;
            if (_i < _len$2) {
              const t = expanded[_i];
              moonbitlang$core$array$$Array$push$15$(out, t);
              _tmp$28 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$array$$Array$clear$15$(segment);
        }
        moonbitlang$core$array$$Array$push$15$(out, tok);
        i = i + 1 | 0;
        if (i < len && moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(tokens, i).kind, 49)) {
          moonbitlang$core$array$$Array$push$15$(out, moonbitlang$core$array$$Array$at$15$(tokens, i));
          i = i + 1 | 0;
          if (i < len) {
            moonbitlang$core$array$$Array$push$15$(out, moonbitlang$core$array$$Array$at$15$(tokens, i));
            i = i + 1 | 0;
          }
          if (i < len && moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(tokens, i).kind, 50)) {
            moonbitlang$core$array$$Array$push$15$(out, moonbitlang$core$array$$Array$at$15$(tokens, i));
            i = i + 1 | 0;
          }
        } else {
          if (i < len) {
            moonbitlang$core$array$$Array$push$15$(out, moonbitlang$core$array$$Array$at$15$(tokens, i));
            i = i + 1 | 0;
          }
        }
        continue;
      }
      moonbitlang$core$array$$Array$push$15$(segment, tok);
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (segment.length > 0) {
    const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, segment);
    const _len$2 = expanded.length;
    let _tmp$28 = 0;
    while (true) {
      const _i = _tmp$28;
      if (_i < _len$2) {
        const t = expanded[_i];
        moonbitlang$core$array$$Array$push$15$(out, t);
        _tmp$28 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$push_tokens(pp, tokens) {
  let i = tokens.length;
  while (true) {
    if (i > 0) {
      i = i - 1 | 0;
      moonbitlang$core$array$$Array$push$15$(pp.pending, moonbitlang$core$array$$Array$at$15$(tokens, i));
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_line_int_literal(pp, lexeme, loc) {
  const end = hackwaly$tinycc$support$util$$int_literal_end(lexeme);
  if (end <= 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid integer in #line");
    return 0;
  }
  if (end < lexeme.length) {
    const suffix = hackwaly$tinycc$support$util$$slice_string(lexeme, end, lexeme.length);
    const _it = moonbitlang$core$string$$String$iter(suffix);
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$115$(_it);
      if (_bind === -1) {
        break;
      } else {
        const _Some = _bind;
        const _ch = _Some;
        if (_ch !== 117 && (_ch !== 85 && (_ch !== 108 && _ch !== 76))) {
          hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid integer in #line");
          return 0;
        }
        continue;
      }
    }
  }
  const trimmed = hackwaly$tinycc$support$util$$slice_string(lexeme, 0, end);
  const base = hackwaly$tinycc$support$util$$int_literal_base(lexeme);
  const value = hackwaly$tinycc$support$util$$parse_uint64_literal(trimmed, base);
  return moonbitlang$core$int64$$Int64$to_int(value);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$handle_line_directive(pp, tokens, loc) {
  if (tokens.length === 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "missing line number in #line");
    return undefined;
  }
  const line_tok = moonbitlang$core$array$$Array$at$15$(tokens, 0);
  if (moonbitlang$core$builtin$$Eq$not_equal$84$(line_tok.kind, 3)) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid line number in #line");
    return undefined;
  }
  const line_val = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_line_int_literal(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, line_tok), line_tok.loc);
  if (line_val <= 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid line number in #line");
    return undefined;
  }
  pp.line_adjust = line_val - (loc.line + 1 | 0) | 0;
  if (tokens.length > 1 && moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(tokens, 1).kind, 6)) {
    pp.logical_path = hackwaly$tinycc$frontend$preproc$preproc_core$$strip_quotes(hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(tokens, 1)));
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$peek_if(p) {
  if (p.index >= p.tokens.length) {
    return undefined;
  }
  return moonbitlang$core$array$$Array$at$15$(p.tokens, p.index);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, kind) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$peek_if(p);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _tok = _Some;
    if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, kind)) {
      p.index = p.index + 1 | 0;
      return true;
    } else {
      return false;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$advance_if(p) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$peek_if(p);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _tok = _Some;
    p.index = p.index + 1 | 0;
    return _tok;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal(pp, lexeme, loc) {
  const end = hackwaly$tinycc$support$util$$int_literal_end(lexeme);
  if (end <= 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid integer in #if");
    return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal$46$record$47$15929;
  }
  const suffix = end < lexeme.length ? hackwaly$tinycc$support$util$$slice_string(lexeme, end, lexeme.length) : "";
  const _it = moonbitlang$core$string$$String$iter(suffix);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$115$(_it);
    if (_bind === -1) {
      break;
    } else {
      const _Some = _bind;
      const _ch = _Some;
      if (_ch !== 117 && (_ch !== 85 && (_ch !== 108 && _ch !== 76))) {
        hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid integer in #if");
        return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal$46$record$47$15930;
      }
      continue;
    }
  }
  const trimmed = hackwaly$tinycc$support$util$$slice_string(lexeme, 0, end);
  const base = hackwaly$tinycc$support$util$$int_literal_base(lexeme);
  const value = hackwaly$tinycc$support$util$$parse_uint64_literal(trimmed, base);
  const _bind = hackwaly$tinycc$support$util$$parse_int_suffix(suffix);
  const _unsigned_suffix = _bind._1;
  const is_unsigned = _unsigned_suffix || moonbitlang$core$builtin$$Compare$op_gt$80$(value, hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal$46$max_signed$124$199);
  return { value: value, is_unsigned: is_unsigned };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$macro_int_value(pp, tok, loc) {
  const id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(pp, tok);
  if (id === 0) {
    return undefined;
  }
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$get_macro(pp, id);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _macro_def = _Some;
    if (_macro_def.is_function) {
      return undefined;
    }
    if (_macro_def.replacement.length === 1 && moonbitlang$core$builtin$$Eq$equal$85$(moonbitlang$core$array$$Array$at$15$(_macro_def.replacement, 0).kind, 3)) {
      return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, moonbitlang$core$array$$Array$at$15$(_macro_def.replacement, 0)), loc);
    }
    return undefined;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(cond) {
  return { value: cond ? $1L : $0L, is_unsigned: false };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_defined(p, loc) {
  if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 49)) {
    _L: {
      const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$advance_if(p);
      if (_bind === undefined) {
        break _L;
      } else {
        const _Some = _bind;
        const _tok = _Some;
        if (hackwaly$tinycc$frontend$preproc$preproc_core$$is_macro_name_token(_tok)) {
          if (!hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 50)) {
            hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "missing ')' after defined");
          }
          return hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(hackwaly$tinycc$frontend$preproc$preproc_core$$has_macro(p.pp, hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(p.pp, _tok)));
        } else {
          break _L;
        }
      }
    }
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "expected identifier after defined(");
    return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_defined$46$record$47$15955;
  }
  _L: {
    const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$advance_if(p);
    if (_bind === undefined) {
      break _L;
    } else {
      const _Some = _bind;
      const _tok = _Some;
      if (hackwaly$tinycc$frontend$preproc$preproc_core$$is_macro_name_token(_tok)) {
        return hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(hackwaly$tinycc$frontend$preproc$preproc_core$$has_macro(p.pp, hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(p.pp, _tok)));
      } else {
        break _L;
      }
    }
  }
  hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "expected identifier after defined");
  return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_defined$46$record$47$15956;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pp_hex_digit_value(code) {
  if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 57)) {
    return code - 48 | 0;
  }
  if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 65) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 70)) {
    return (code - 65 | 0) + 10 | 0;
  }
  if (moonbitlang$core$builtin$$Compare$op_ge$23$(code, 97) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 102)) {
    return (code - 97 | 0) + 10 | 0;
  }
  return undefined;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_hex_escape(pp, text, start, loc) {
  let i = start;
  let value = 0;
  let saw = false;
  while (true) {
    if (i < text.length) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      const digit = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_hex_digit_value(code);
      if (digit === undefined) {
        break;
      } else {
        const _Some = digit;
        const _v = _Some;
        value = (Math.imul(value, 16) | 0) + _v | 0;
        saw = true;
        i = i + 1 | 0;
      }
      continue;
    } else {
      break;
    }
  }
  if (!saw) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "invalid hex escape in #if");
  }
  return { _0: value, _1: i };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_oct_digit(code) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 55);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_octal_escape(text, start) {
  let i = start;
  let value = 0;
  let count = 0;
  while (true) {
    if (i < text.length && count < 3) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      if (!hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_oct_digit(code)) {
        break;
      }
      value = (Math.imul(value, 8) | 0) + (code - 48 | 0) | 0;
      i = i + 1 | 0;
      count = count + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: value, _1: i };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$decode_pp_escape_value(pp, text, start, loc) {
  if (start >= text.length) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "unterminated escape sequence in #if");
    return { _0: 0, _1: start };
  }
  $bound_check(text, start);
  const code = text.charCodeAt(start);
  _L: {
    switch (code) {
      case 97: {
        return { _0: 7, _1: start + 1 | 0 };
      }
      case 98: {
        return { _0: 8, _1: start + 1 | 0 };
      }
      case 102: {
        return { _0: 12, _1: start + 1 | 0 };
      }
      case 110: {
        return { _0: 10, _1: start + 1 | 0 };
      }
      case 114: {
        return { _0: 13, _1: start + 1 | 0 };
      }
      case 116: {
        return { _0: 9, _1: start + 1 | 0 };
      }
      case 118: {
        return { _0: 11, _1: start + 1 | 0 };
      }
      case 92: {
        return { _0: 92, _1: start + 1 | 0 };
      }
      case 39: {
        return { _0: 39, _1: start + 1 | 0 };
      }
      case 34: {
        return { _0: 34, _1: start + 1 | 0 };
      }
      case 63: {
        return { _0: 63, _1: start + 1 | 0 };
      }
      case 120: {
        break _L;
      }
      case 88: {
        break _L;
      }
      default: {
        return hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_oct_digit(code) ? hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_octal_escape(text, start) : { _0: code, _1: start + 1 | 0 };
      }
    }
  }
  return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_hex_escape(pp, text, start + 1 | 0, loc);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_char_literal(pp, tok) {
  const lexeme = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(pp, tok);
  if (lexeme.length < 3) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, tok.loc, "invalid character literal in #if");
    return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_char_literal$46$record$47$15994;
  }
  const len = lexeme.length;
  let value = 0;
  let i = 1;
  if ((i + 1 | 0) >= len) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, tok.loc, "invalid character literal in #if");
    return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_char_literal$46$record$47$15995;
  }
  const _tmp$27 = i;
  $bound_check(lexeme, _tmp$27);
  const code = lexeme.charCodeAt(_tmp$27);
  const _p$28 = 92;
  if (code === _p$28) {
    const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$decode_pp_escape_value(pp, lexeme, i + 1 | 0, tok.loc);
    const _esc = _bind._0;
    const _next_index = _bind._1;
    value = _esc;
    i = _next_index;
  } else {
    value = code;
    i = i + 1 | 0;
  }
  if ((i + 1 | 0) < len) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, tok.loc, "multi-character literal in #if");
  }
  return { value: moonbitlang$core$int$$Int$to_uint64(value), is_unsigned: false };
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$skip_paren_expr(p, loc) {
  let depth = 1;
  while (true) {
    if (depth > 0) {
      const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$advance_if(p);
      if (_bind === undefined) {
        hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "missing ')' in #if expression");
        return undefined;
      } else {
        const _Some = _bind;
        const _tok = _Some;
        if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 49)) {
          depth = depth + 1 | 0;
        } else {
          if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 50)) {
            depth = depth - 1 | 0;
          }
        }
      }
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(v) {
  return moonbitlang$core$builtin$$Eq$equal$6$(v.value, $0L);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$peek_if(p);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _tok = _Some;
    return moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 50);
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$pp_shift_count(v) {
  return moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$BitAnd$land$6$(v.value, $63L));
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_logical_or(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_logical_and(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 91)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_logical_and(p, loc);
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(!hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(value) || !hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(rhs));
      continue;
    } else {
      break;
    }
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_logical_and(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_or(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 90)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_or(p, loc);
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(!hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(value) && !hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(rhs));
      continue;
    } else {
      break;
    }
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_or(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_xor(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 86)) {
      if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
        break;
      }
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_xor(p, loc);
      const _p$28 = value;
      const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
      value = { value: moonbitlang$core$builtin$$BitOr$lor$6$(value.value, rhs.value), is_unsigned: unsigned };
      continue;
    } else {
      break;
    }
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_xor(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_and(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 87)) {
      if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
        break;
      }
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_and(p, loc);
      const _p$28 = value;
      const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
      value = { value: moonbitlang$core$builtin$$BitXOr$lxor$6$(value.value, rhs.value), is_unsigned: unsigned };
      continue;
    } else {
      break;
    }
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_bit_and(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_eq(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 85)) {
      if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
        break;
      }
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_eq(p, loc);
      const _p$28 = value;
      const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
      value = { value: moonbitlang$core$builtin$$BitAnd$land$6$(value.value, rhs.value), is_unsigned: unsigned };
      continue;
    } else {
      break;
    }
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_eq(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_rel(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
      break;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 75)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_rel(p, loc);
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(moonbitlang$core$builtin$$Eq$equal$6$(value.value, rhs.value));
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 76)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_rel(p, loc);
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(moonbitlang$core$builtin$$Eq$not_equal$80$(value.value, rhs.value));
      continue;
    }
    break;
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_rel(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_shift(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
      break;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 77)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_shift(p, loc);
      let cond;
      const _p$28 = value;
      if (_p$28.is_unsigned || rhs.is_unsigned) {
        cond = moonbitlang$core$builtin$$Compare$op_lt$80$(value.value, rhs.value);
      } else {
        cond = moonbitlang$core$builtin$$Compare$op_lt$81$(value.value, rhs.value);
      }
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(cond);
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 78)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_shift(p, loc);
      let cond;
      const _p$28 = value;
      if (_p$28.is_unsigned || rhs.is_unsigned) {
        cond = moonbitlang$core$builtin$$Compare$op_le$80$(value.value, rhs.value);
      } else {
        cond = moonbitlang$core$builtin$$Compare$op_le$81$(value.value, rhs.value);
      }
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(cond);
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 79)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_shift(p, loc);
      let cond;
      const _p$28 = value;
      if (_p$28.is_unsigned || rhs.is_unsigned) {
        cond = moonbitlang$core$builtin$$Compare$op_gt$80$(value.value, rhs.value);
      } else {
        cond = moonbitlang$core$builtin$$Compare$op_gt$81$(value.value, rhs.value);
      }
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(cond);
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 80)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_shift(p, loc);
      let cond;
      const _p$28 = value;
      if (_p$28.is_unsigned || rhs.is_unsigned) {
        cond = moonbitlang$core$builtin$$Compare$op_ge$80$(value.value, rhs.value);
      } else {
        cond = moonbitlang$core$builtin$$Compare$op_ge$81$(value.value, rhs.value);
      }
      value = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(cond);
      continue;
    }
    break;
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_shift(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_add(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
      break;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 81)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_add(p, loc);
      const shift = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_shift_count(rhs);
      value = { value: moonbitlang$core$builtin$$Shl$shl$6$(value.value, shift), is_unsigned: value.is_unsigned };
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 82)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_add(p, loc);
      const shift = hackwaly$tinycc$frontend$preproc$preproc_core$$pp_shift_count(rhs);
      let new_value;
      if (value.is_unsigned) {
        new_value = moonbitlang$core$builtin$$Shr$shr$6$(value.value, shift);
      } else {
        const lhs = value.value;
        new_value = moonbitlang$core$builtin$$Shr$shr$7$(lhs, shift);
      }
      value = { value: new_value, is_unsigned: value.is_unsigned };
      continue;
    }
    break;
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_add(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
      break;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 63)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul(p, loc);
      const _p$28 = value;
      const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
      value = { value: moonbitlang$core$builtin$$Add$add$6$(value.value, rhs.value), is_unsigned: unsigned };
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 64)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul(p, loc);
      const _p$28 = value;
      const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
      value = { value: moonbitlang$core$builtin$$Sub$sub$6$(value.value, rhs.value), is_unsigned: unsigned };
      continue;
    }
    break;
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul(p, loc) {
  let value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc);
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$peek_is_rparen(p)) {
      break;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 65)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc);
      const _p$28 = value;
      const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
      value = { value: moonbitlang$core$builtin$$Mul$mul$6$(value.value, rhs.value), is_unsigned: unsigned };
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 66)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc);
      if (hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(rhs)) {
        hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "division by zero in #if");
        value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul$46$record$47$16085;
      } else {
        const _p$28 = value;
        const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
        let new_value;
        if (unsigned) {
          new_value = moonbitlang$core$builtin$$Div$div$6$(value.value, rhs.value);
        } else {
          const lhs = value.value;
          const rhs_val = rhs.value;
          new_value = moonbitlang$core$builtin$$Div$div$7$(lhs, rhs_val);
        }
        value = { value: new_value, is_unsigned: unsigned };
      }
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 67)) {
      const rhs = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc);
      if (hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(rhs)) {
        hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "modulo by zero in #if");
        value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_mul$46$record$47$16086;
      } else {
        const _p$28 = value;
        const unsigned = _p$28.is_unsigned || rhs.is_unsigned;
        let new_value;
        if (unsigned) {
          new_value = moonbitlang$core$builtin$$Mod$mod$6$(value.value, rhs.value);
        } else {
          const lhs = value.value;
          const rhs_val = rhs.value;
          new_value = moonbitlang$core$builtin$$Mod$mod$7$(lhs, rhs_val);
        }
        value = { value: new_value, is_unsigned: unsigned };
      }
      continue;
    }
    break;
  }
  return value;
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc) {
  while (true) {
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 89)) {
      return hackwaly$tinycc$frontend$preproc$preproc_core$$pp_bool_value(hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc)));
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 88)) {
      const v = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc);
      return { value: moonbitlang$core$uint64$$UInt64$lnot(v.value), is_unsigned: v.is_unsigned };
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 63)) {
      continue;
    }
    if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 64)) {
      const v = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_unary(p, loc);
      const value = moonbitlang$core$builtin$$Sub$sub$6$($0L, v.value);
      return { value: value, is_unsigned: v.is_unsigned };
    }
    return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary(p, loc);
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary(p, loc) {
  const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$advance_if(p);
  if (_bind === undefined) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "unexpected end of #if expression");
    return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16109;
  } else {
    const _Some = _bind;
    const _tok = _Some;
    if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 50)) {
      p.index = p.index - 1 | 0;
      return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16110;
    }
    if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 3)) {
      return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_int_literal(p.pp, hackwaly$tinycc$frontend$preproc$preproc_core$$pp_token_lexeme(p.pp, _tok), _tok.loc);
    }
    if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 5)) {
      return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_pp_char_literal(p.pp, _tok);
    }
    if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 2)) {
      if (hackwaly$tinycc$frontend$tokens$$token_id(_tok) === p.pp.builtin_ids.defined) {
        return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_defined(p, loc);
      }
      const _bind$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_int_value(p.pp, _tok, _tok.loc);
      if (_bind$2 === undefined) {
        if (hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 49)) {
          hackwaly$tinycc$frontend$preproc$preproc_core$$skip_paren_expr(p, _tok.loc);
          return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16111;
        }
        return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16112;
      } else {
        const _Some$2 = _bind$2;
        const _v = _Some$2;
        return _v;
      }
    }
    if (moonbitlang$core$builtin$$Eq$equal$85$(_tok.kind, 49)) {
      const value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_logical_or(p, loc);
      if (!hackwaly$tinycc$frontend$preproc$preproc_core$$match_kind(p, 50)) {
        let idx = p.index;
        while (true) {
          if (idx < p.tokens.length) {
            const _bind$2 = moonbitlang$core$array$$Array$at$15$(p.tokens, idx);
            const _x = _bind$2.kind;
            if (_x === 50) {
              idx = idx + 1 | 0;
              break;
            } else {
              idx = idx + 1 | 0;
            }
            continue;
          } else {
            break;
          }
        }
        p.index = idx;
      }
      return value;
    }
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(p.pp, loc, "unexpected token in #if expression");
    return hackwaly$tinycc$frontend$preproc$preproc_core$$parse_primary$46$record$47$16113;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$eval_if_expr(pp, tokens, loc) {
  if (tokens.length === 0) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, loc, "empty #if expression");
    return false;
  }
  const parser = { tokens: tokens, index: 0, pp: pp };
  const value = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_logical_or(parser, loc);
  return !hackwaly$tinycc$frontend$preproc$preproc_core$$pp_is_zero(value);
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$handle_directive(pp, _hash_tok) {
  const name_tok = hackwaly$tinycc$frontend$preproc$preproc_core$$next_input_token(pp);
  if (moonbitlang$core$builtin$$Eq$equal$85$(name_tok.kind, 0)) {
    return undefined;
  }
  if (name_tok.line_start) {
    pp.held = name_tok;
    return undefined;
  }
  const name_id = hackwaly$tinycc$frontend$tokens$$token_id(name_tok);
  const ids = pp.builtin_ids;
  const is_conditional = name_id === ids.dir_if || (name_id === ids.dir_ifdef || (name_id === ids.dir_ifndef || (name_id === ids.dir_elif || (name_id === ids.dir_else || name_id === ids.dir_endif))));
  if (!pp.active && !is_conditional) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    return undefined;
  }
  if (name_id === ids.dir_define) {
    const args = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_tokens(pp);
    if (args.length === 0 || !hackwaly$tinycc$frontend$preproc$preproc_core$$is_macro_name_token(moonbitlang$core$array$$Array$at$15$(args, 0))) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, name_tok.loc, "missing macro name in #define");
      return undefined;
    }
    const macro_id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(pp, moonbitlang$core$array$$Array$at$15$(args, 0));
    if (macro_id === 0) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, name_tok.loc, "invalid macro name in #define");
      return undefined;
    }
    const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_define_macro(pp, moonbitlang$core$array$$Array$at$15$(args, 0), hackwaly$tinycc$frontend$preproc$preproc_core$$slice_tokens(args, 1), name_tok.loc);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _macro_def = _Some;
      hackwaly$tinycc$frontend$preproc$preproc_core$$set_macro(pp, macro_id, _macro_def);
    }
    return undefined;
  }
  if (name_id === ids.dir_undef) {
    const macro_name_tok = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_head_token(pp);
    const _bind = pp.held;
    if (_bind === undefined) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    }
    if (macro_name_tok === undefined) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, name_tok.loc, "missing macro name in #undef");
      return undefined;
    } else {
      const _Some = macro_name_tok;
      const _tok = _Some;
      if (!hackwaly$tinycc$frontend$preproc$preproc_core$$is_macro_name_token(_tok)) {
        hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, name_tok.loc, "missing macro name in #undef");
        return undefined;
      } else {
        const macro_id = hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(pp, _tok);
        if (macro_id !== 0) {
          hackwaly$tinycc$frontend$preproc$preproc_core$$remove_macro(pp, macro_id);
        }
        return undefined;
      }
    }
  }
  if (name_id === ids.dir_ifdef) {
    if (!pp.active) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
      hackwaly$tinycc$frontend$preproc$preproc_core$$push_cond(pp, false);
      return undefined;
    }
    const macro_name_tok = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_head_token(pp);
    const _bind = pp.held;
    if (_bind === undefined) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    }
    let cond;
    if (macro_name_tok === undefined) {
      cond = false;
    } else {
      const _Some = macro_name_tok;
      const _tok = _Some;
      cond = hackwaly$tinycc$frontend$preproc$preproc_core$$is_macro_name_token(_tok) && hackwaly$tinycc$frontend$preproc$preproc_core$$has_macro(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(pp, _tok));
    }
    hackwaly$tinycc$frontend$preproc$preproc_core$$push_cond(pp, cond);
    return undefined;
  }
  if (name_id === ids.dir_ifndef) {
    if (!pp.active) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
      hackwaly$tinycc$frontend$preproc$preproc_core$$push_cond(pp, false);
      return undefined;
    }
    const macro_name_tok = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_head_token(pp);
    const _bind = pp.held;
    if (_bind === undefined) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    }
    let cond;
    if (macro_name_tok === undefined) {
      cond = false;
    } else {
      const _Some = macro_name_tok;
      const _tok = _Some;
      cond = hackwaly$tinycc$frontend$preproc$preproc_core$$is_macro_name_token(_tok) && !hackwaly$tinycc$frontend$preproc$preproc_core$$has_macro(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_token(pp, _tok));
    }
    hackwaly$tinycc$frontend$preproc$preproc_core$$push_cond(pp, cond);
    return undefined;
  }
  if (name_id === ids.dir_if) {
    if (!pp.active) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
      hackwaly$tinycc$frontend$preproc$preproc_core$$push_cond(pp, false);
      return undefined;
    }
    const args = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_tokens(pp);
    const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_if_tokens(pp, args);
    const cond = hackwaly$tinycc$frontend$preproc$preproc_core$$eval_if_expr(pp, expanded, name_tok.loc);
    hackwaly$tinycc$frontend$preproc$preproc_core$$push_cond(pp, cond);
    return undefined;
  }
  if (name_id === ids.dir_elif) {
    if (pp.cond_stack.length === 0) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
      hackwaly$tinycc$frontend$preproc$preproc_core$$update_elif(pp, false, name_tok.loc);
      return undefined;
    }
    const idx = pp.cond_stack.length - 1 | 0;
    const state = moonbitlang$core$array$$Array$at$41$(pp.cond_stack, idx);
    if (!state.parent_active || state.taken) {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
      hackwaly$tinycc$frontend$preproc$preproc_core$$update_elif(pp, false, name_tok.loc);
      return undefined;
    }
    const args = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_tokens(pp);
    const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_if_tokens(pp, args);
    const cond = hackwaly$tinycc$frontend$preproc$preproc_core$$eval_if_expr(pp, expanded, name_tok.loc);
    hackwaly$tinycc$frontend$preproc$preproc_core$$update_elif(pp, cond, name_tok.loc);
    return undefined;
  }
  if (name_id === ids.dir_else) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    hackwaly$tinycc$frontend$preproc$preproc_core$$update_else(pp, name_tok.loc);
    return undefined;
  }
  if (name_id === ids.dir_endif) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    hackwaly$tinycc$frontend$preproc$preproc_core$$pop_cond(pp, name_tok.loc);
    return undefined;
  }
  if (name_id === ids.dir_include) {
    const args = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_tokens(pp);
    if (pp.active) {
      const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, args);
      const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_include_path(pp, expanded, name_tok.loc);
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _spec = _Some;
        hackwaly$tinycc$frontend$preproc$preproc_core$$include_file(pp, _spec, name_tok.loc, false);
      }
    }
    return undefined;
  }
  if (name_id === ids.dir_include_next) {
    const args = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_tokens(pp);
    if (pp.active) {
      const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, args);
      const _bind = hackwaly$tinycc$frontend$preproc$preproc_core$$parse_include_path(pp, expanded, name_tok.loc);
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _spec = _Some;
        hackwaly$tinycc$frontend$preproc$preproc_core$$include_file(pp, _spec, name_tok.loc, true);
      }
    }
    return undefined;
  }
  if (name_id === ids.dir_line) {
    const args = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_tokens(pp);
    if (!pp.active) {
      return undefined;
    }
    const expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, args);
    hackwaly$tinycc$frontend$preproc$preproc_core$$handle_line_directive(pp, expanded, name_tok.loc);
    return undefined;
  }
  if (name_id === ids.dir_error) {
    if (pp.active) {
      const text = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_text(pp);
      hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, name_tok.loc, `error: ${text}`);
    } else {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    }
    return undefined;
  }
  if (name_id === ids.dir_warning) {
    if (pp.active) {
      const text = hackwaly$tinycc$frontend$preproc$preproc_core$$read_directive_text(pp);
      hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, name_tok.loc, `warning: ${text}`);
    } else {
      hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    }
    return undefined;
  }
  if (name_id === ids.dir_pragma) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    return undefined;
  }
  if (pp.active) {
    hackwaly$tinycc$frontend$preproc$preproc_core$$skip_directive_line(pp);
    hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, name_tok.loc, "unknown preprocessor directive");
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$next_pp_token(pp) {
  _L: while (true) {
    if (!pp.active) {
      const _bind = pp.held;
      if (_bind === undefined) {
        if (pp.pending.length === 0) {
          hackwaly$tinycc$frontend$preproc$preproc_core$$skip_inactive(pp);
        }
      }
    }
    let from_pending = false;
    let tok;
    if (pp.pending.length > 0) {
      const _bind = moonbitlang$core$array$$Array$pop$15$(pp.pending);
      if (_bind === undefined) {
        continue;
      } else {
        const _Some = _bind;
        const _t = _Some;
        from_pending = true;
        hackwaly$tinycc$frontend$preproc$preproc_core$$release_expanding_guards(pp);
        tok = _t;
      }
    } else {
      tok = hackwaly$tinycc$frontend$preproc$preproc_core$$next_input_token(pp);
    }
    const _bind = tok.kind;
    switch (_bind) {
      case 0: {
        return tok;
      }
      case 95: {
        if (tok.line_start && !from_pending) {
          hackwaly$tinycc$frontend$preproc$preproc_core$$handle_directive(pp, tok);
          continue _L;
        }
        break;
      }
    }
    if (!pp.active) {
      continue;
    }
    if (hackwaly$tinycc$frontend$tokens$$token_id(tok) === 0) {
      return tok;
    }
    const macro_id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
    const is_macro_name = macro_id > 0;
    if (is_macro_name) {
      const _bind$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$builtin_macro_tokens(pp, tok);
      if (_bind$2.$tag === 1) {
        const _Some = _bind$2;
        const _tokens = _Some._0;
        hackwaly$tinycc$frontend$preproc$preproc_core$$push_tokens(pp, _tokens);
        continue;
      }
    }
    let hidden_ok;
    if (!is_macro_name) {
      hidden_ok = true;
    } else {
      let _tmp$27;
      const _p$28 = tok.hidden;
      if (_p$28 === 0) {
        _tmp$27 = true;
      } else {
        _tmp$27 = macro_id !== 0 && !hackwaly$tinycc$frontend$preproc$preproc_core$$hidden_contains(pp.hidden_pool, tok.hidden, macro_id);
      }
      hidden_ok = _tmp$27;
    }
    if (is_macro_name && (macro_id !== 0 && hidden_ok)) {
      const _bind$2 = hackwaly$tinycc$frontend$preproc$preproc_core$$get_macro(pp, macro_id);
      if (_bind$2 === undefined) {
      } else {
        const _Some = _bind$2;
        const _macro_def = _Some;
        if (hackwaly$tinycc$frontend$preproc$preproc_core$$is_expanding(pp, macro_id)) {
          return tok;
        }
        if (_macro_def.is_function) {
          const next_tok = hackwaly$tinycc$frontend$preproc$preproc_core$$next_raw_token(pp);
          const _bind$3 = next_tok.kind;
          if (_bind$3 === 49) {
          } else {
            hackwaly$tinycc$frontend$preproc$preproc_core$$push_back(pp, next_tok);
            return tok;
          }
          const _bind$4 = hackwaly$tinycc$frontend$preproc$preproc_core$$read_macro_args(pp, tok.loc);
          if (_bind$4.$tag === 0) {
            return tok;
          } else {
            const _Some$2 = _bind$4;
            const _args = _Some$2._0;
            const _bind$5 = hackwaly$tinycc$frontend$preproc$preproc_core$$normalize_macro_args(_macro_def, _args, tok.loc);
            if (_bind$5.$tag === 0) {
              hackwaly$tinycc$frontend$preproc$preproc_core$$add_pp_error(pp, tok.loc, "macro argument count mismatch");
              return tok;
            } else {
              const _Some$3 = _bind$5;
              const _norm_args = _Some$3._0;
              const restore_len = pp.pending.length;
              const _bind$6 = hackwaly$tinycc$frontend$preproc$preproc_core$$substitute_macro(pp, _macro_def, _norm_args, tok.loc);
              const _replaced = _bind$6._0;
              const _needs_expand = _bind$6._1;
              let did_push = false;
              let expanded;
              if (_needs_expand) {
                hackwaly$tinycc$frontend$preproc$preproc_core$$push_expanding(pp, macro_id);
                did_push = true;
                expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$add_hidden_tokens(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, _replaced), macro_id);
              } else {
                expanded = _replaced;
              }
              if (expanded.length > 0) {
                if (did_push) {
                  moonbitlang$core$array$$Array$push$40$(pp.expanding_guards, { restore_len: restore_len });
                }
                hackwaly$tinycc$frontend$preproc$preproc_core$$push_tokens(pp, expanded);
                if (did_push) {
                  hackwaly$tinycc$frontend$preproc$preproc_core$$release_expanding_guards(pp);
                }
                if (did_push && hackwaly$tinycc$frontend$preproc$preproc_core$$is_expanding(pp, macro_id)) {
                  hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp);
                }
              } else {
                if (did_push) {
                  hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp);
                }
              }
              continue;
            }
          }
        } else {
          const restore_len = pp.pending.length;
          let did_push = false;
          let expanded;
          if (hackwaly$tinycc$frontend$preproc$preproc_core$$macro_replacement_needs_expand(pp, macro_id, _macro_def)) {
            hackwaly$tinycc$frontend$preproc$preproc_core$$push_expanding(pp, macro_id);
            did_push = true;
            expanded = hackwaly$tinycc$frontend$preproc$preproc_core$$add_hidden_tokens(pp, hackwaly$tinycc$frontend$preproc$preproc_core$$expand_tokens(pp, _macro_def.replacement), macro_id);
          } else {
            expanded = _macro_def.replacement;
          }
          if (expanded.length > 0) {
            if (did_push) {
              moonbitlang$core$array$$Array$push$40$(pp.expanding_guards, { restore_len: restore_len });
            }
            hackwaly$tinycc$frontend$preproc$preproc_core$$push_tokens(pp, expanded);
            if (did_push) {
              hackwaly$tinycc$frontend$preproc$preproc_core$$release_expanding_guards(pp);
            }
            if (did_push && hackwaly$tinycc$frontend$preproc$preproc_core$$is_expanding(pp, macro_id)) {
              hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp);
            }
          } else {
            if (did_push) {
              hackwaly$tinycc$frontend$preproc$preproc_core$$pop_expanding(pp);
            }
          }
          continue;
        }
      }
    }
    return tok;
  }
}
function hackwaly$tinycc$frontend$preproc$preproc_core$$dump_tokens(pp, max_count) {
  const out = [];
  while (true) {
    if (out.length < max_count) {
      const tok = hackwaly$tinycc$frontend$preproc$preproc_core$$next_pp_token(pp);
      moonbitlang$core$array$$Array$push$15$(out, tok);
      const _bind = tok.kind;
      if (_bind === 0) {
        break;
      }
      continue;
    } else {
      break;
    }
  }
  return out;
}
function hackwaly$tinycc$frontend$preproc$$define_macro(pp, name, replacement) {
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_macro(pp, name, replacement);
}
function hackwaly$tinycc$frontend$preproc$$define_int_macro(pp, name, value) {
  hackwaly$tinycc$frontend$preproc$preproc_core$$define_int_macro(pp, name, value);
}
function hackwaly$tinycc$frontend$preproc$$new_preprocessor(map, file, diags, host) {
  return hackwaly$tinycc$frontend$preproc$preproc_core$$new_preprocessor(map, file, diags, host);
}
function hackwaly$tinycc$frontend$preproc$$finalize_preprocessor(pp) {
  hackwaly$tinycc$frontend$preproc$preproc_core$$finalize_preprocessor(pp);
}
function hackwaly$tinycc$frontend$preproc$$macro_id_from_name(pp, name) {
  return hackwaly$tinycc$frontend$preproc$preproc_core$$macro_id_from_name(pp, name);
}
function hackwaly$tinycc$frontend$preproc$$remove_macro(pp, id) {
  hackwaly$tinycc$frontend$preproc$preproc_core$$remove_macro(pp, id);
}
function hackwaly$tinycc$frontend$preproc$$add_include_path(pp, path) {
  hackwaly$tinycc$frontend$preproc$preproc_core$$add_include_path(pp, path);
}
function hackwaly$tinycc$frontend$preproc$$normalize_macro_tokens(tokens) {
  return hackwaly$tinycc$frontend$preproc$preproc_core$$normalize_macro_tokens(tokens);
}
function hackwaly$tinycc$frontend$preproc$$next_pp_token(pp) {
  return hackwaly$tinycc$frontend$preproc$preproc_core$$next_pp_token(pp);
}
function hackwaly$tinycc$frontend$preproc$$dump_tokens(pp, max_count) {
  return hackwaly$tinycc$frontend$preproc$preproc_core$$dump_tokens(pp, max_count);
}
function hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_capacity_with(counts, values, scope_levels, id) {
  if (id <= 0) {
    return undefined;
  }
  let idx = counts.length;
  while (true) {
    if (idx < id) {
      moonbitlang$core$array$$Array$push$26$(counts, 0);
      moonbitlang$core$array$$Array$push$50$(values, undefined);
      moonbitlang$core$array$$Array$push$26$(scope_levels, 0);
      idx = idx + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$new_parser(pp) {
  const text_len = pp.lexer.text_len;
  let id_capacity = text_len / 64 | 0;
  if (id_capacity < 512) {
    id_capacity = 512;
  } else {
    if (id_capacity > 65536) {
      id_capacity = 65536;
    }
  }
  const typedef_counts = moonbitlang$core$array$$Array$new$46$inner$26$(id_capacity);
  const typedef_values = moonbitlang$core$array$$Array$new$46$inner$50$(id_capacity);
  const typedef_scope_levels = moonbitlang$core$array$$Array$new$46$inner$26$(id_capacity);
  const typedef_scope_stack = moonbitlang$core$array$$Array$new$46$inner$26$(128);
  moonbitlang$core$array$$Array$push$26$(typedef_scope_stack, 1);
  const typedef_overrides = moonbitlang$core$array$$Array$new$46$inner$52$(128);
  moonbitlang$core$array$$Array$push$52$(typedef_overrides, []);
  const pending_typedef_scopes = moonbitlang$core$array$$Array$new$46$inner$67$(128);
  const buffer = moonbitlang$core$array$$Array$new$46$inner$15$(64);
  const builtin_defs = [{ _0: "__builtin_va_list", _1: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void) }, hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$tuple$47$16249];
  const _len = builtin_defs.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const def = builtin_defs[_i];
      const _name = def._0;
      const _ty = def._1;
      const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(pp.interner, { str: _name, start: 0, end: _name.length });
      const _id = _bind._1;
      hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_capacity_with(typedef_counts, typedef_values, typedef_scope_levels, _id);
      moonbitlang$core$array$$Array$set$26$(typedef_counts, _id - 1 | 0, 1);
      moonbitlang$core$array$$Array$set$50$(typedef_values, _id - 1 | 0, _ty);
      moonbitlang$core$array$$Array$set$26$(typedef_scope_levels, _id - 1 | 0, 1);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const current = hackwaly$tinycc$frontend$preproc$$next_pp_token(pp);
  const lookahead = hackwaly$tinycc$frontend$preproc$$next_pp_token(pp);
  const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(pp.interner, { str: hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$892, start: 0, end: hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$892.length });
  const _builtin_types_compatible_p = _bind._1;
  const _bind$2 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(pp.interner, { str: hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$887, start: 0, end: hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$887.length });
  const _builtin_offsetof = _bind$2._1;
  const _bind$3 = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(pp.interner, { str: hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$882, start: 0, end: hackwaly$tinycc$frontend$parser$parser_core$$new_parser$46$42$bind$124$882.length });
  const _builtin_va_arg = _bind$3._1;
  return { pp: pp, current: current, lookahead: lookahead, buffer: buffer, buffer_pos: 0, diags: pp.diags, typedef_counts: typedef_counts, typedef_values: typedef_values, typedef_scope_levels: typedef_scope_levels, typedef_scope_stack: typedef_scope_stack, next_typedef_scope_id: 2, typedef_overrides: typedef_overrides, pending_typedef_scopes: pending_typedef_scopes, anon_tag_id: 0, next_expr_id: 0, builtin_ids: { types_compatible_p: _builtin_types_compatible_p, offsetof: _builtin_offsetof, va_arg: _builtin_va_arg } };
}
function hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p) {
  const id = p.next_expr_id + 1 | 0;
  p.next_expr_id = id;
  return id;
}
function hackwaly$tinycc$frontend$parser$parser_core$$special_ident_kind(tok, ids) {
  const _bind = hackwaly$tinycc$frontend$tokens$$keyword_kind_from_id(hackwaly$tinycc$frontend$tokens$$token_id(tok), ids);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _kind = _Some;
    _L: {
      switch (_kind) {
        case 31: {
          break _L;
        }
        case 36: {
          break _L;
        }
        case 32: {
          break _L;
        }
        case 37: {
          break _L;
        }
        case 33: {
          break _L;
        }
        case 38: {
          break _L;
        }
        case 34: {
          break _L;
        }
        case 35: {
          break _L;
        }
        case 22: {
          break _L;
        }
        case 21: {
          break _L;
        }
        case 23: {
          break _L;
        }
        case 24: {
          break _L;
        }
        case 29: {
          break _L;
        }
        case 30: {
          break _L;
        }
        case 27: {
          break _L;
        }
        case 28: {
          break _L;
        }
        default: {
          return undefined;
        }
      }
    }
    return _kind;
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$is_at_end(p) {
  const _bind = p.current.kind;
  if (_bind === 0) {
    return true;
  } else {
    return false;
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, message) {
  hackwaly$tinycc$support$diag$$add_error(p.diags, loc, message);
}
function hackwaly$tinycc$frontend$parser$parser_core$$current_typedef_scope_id(p) {
  const len = p.typedef_scope_stack.length;
  return len === 0 ? 0 : moonbitlang$core$array$$Array$at$26$(p.typedef_scope_stack, len - 1 | 0);
}
function hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_scope_level(p, id) {
  return id <= 0 || id > p.typedef_scope_levels.length ? 0 : moonbitlang$core$array$$Array$at$26$(p.typedef_scope_levels, id - 1 | 0);
}
function hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_value(p, id) {
  return id <= 0 || id > p.typedef_values.length ? undefined : moonbitlang$core$array$$Array$at$50$(p.typedef_values, id - 1 | 0);
}
function hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_count(p, id) {
  return id <= 0 || id > p.typedef_counts.length ? 0 : moonbitlang$core$array$$Array$at$26$(p.typedef_counts, id - 1 | 0);
}
function hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_capacity(p, id) {
  hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_capacity_with(p.typedef_counts, p.typedef_values, p.typedef_scope_levels, id);
}
function hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_count(p, id, count) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_capacity(p, id);
  moonbitlang$core$array$$Array$set$26$(p.typedef_counts, id - 1 | 0, count);
}
function hackwaly$tinycc$frontend$parser$parser_core$$inc_typedef_count(p, id) {
  if (id === 0) {
    return undefined;
  }
  const count = hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_count(p, id);
  hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_count(p, id, count + 1 | 0);
}
function hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_scope_level(p, id, level) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_capacity(p, id);
  moonbitlang$core$array$$Array$set$26$(p.typedef_scope_levels, id - 1 | 0, level);
}
function hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_value(p, id, value) {
  if (id <= 0) {
    return undefined;
  }
  hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_capacity(p, id);
  moonbitlang$core$array$$Array$set$50$(p.typedef_values, id - 1 | 0, value);
}
function hackwaly$tinycc$frontend$parser$parser_core$$typedef_id_from_name(p, name) {
  if (name === "") {
    return 0;
  }
  const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(p.pp.interner, { str: name, start: 0, end: name.length });
  return _bind._1;
}
function hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(ty) {
  _L: {
    switch (ty.$tag) {
      case 12: {
        const _Qualified = ty;
        const _qual = _Qualified._0;
        const _base = _Qualified._1;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Qualified(_qual, hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(_base));
      }
      case 11: {
        const _Attributed = ty;
        const _attrs = _Attributed._0;
        const _base$2 = _Attributed._1;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Attributed(_attrs, hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(_base$2));
      }
      case 4: {
        const _Pointer = ty;
        const _inner = _Pointer._0;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(_inner));
      }
      case 5: {
        const _Array = ty;
        const _elem = _Array._0;
        const _size = _Array._1;
        const _size_expr = _Array._2;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(_elem), _size, _size_expr);
      }
      case 10: {
        const _Function = ty;
        const _return_type = _Function._0;
        const _params = _Function._1;
        const _varargs = _Function._2;
        const _is_old_style = _Function._3;
        const _call_conv = _Function._4;
        const _p$28 = new Array(_params.length);
        const _p$29 = _params.length;
        let _tmp$27 = 0;
        while (true) {
          const _p$30 = _tmp$27;
          if (_p$30 < _p$29) {
            const _p$31 = _params[_p$30];
            _p$28[_p$30] = hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(_p$31);
            _tmp$27 = _p$30 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(_return_type), _p$28, _varargs, _is_old_style, _call_conv);
      }
      case 6: {
        const _Struct = ty;
        const _name = _Struct._0;
        const _id = _Struct._1;
        const _x = _Struct._2;
        if (_x.$tag === 1) {
          const _attrs$2 = _Struct._3;
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Struct(_name, _id, Option$None$37$, _attrs$2);
        } else {
          break _L;
        }
      }
      case 7: {
        const _Union = ty;
        const _name$2 = _Union._0;
        const _id$2 = _Union._1;
        const _x$2 = _Union._2;
        if (_x$2.$tag === 1) {
          const _attrs$2 = _Union._3;
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Union(_name$2, _id$2, Option$None$37$, _attrs$2);
        } else {
          break _L;
        }
      }
      case 8: {
        const _Enum = ty;
        const _name$3 = _Enum._0;
        const _id$3 = _Enum._1;
        const _x$3 = _Enum._2;
        if (_x$3.$tag === 1) {
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Enum(_name$3, _id$3, Option$None$22$);
        } else {
          break _L;
        }
      }
      default: {
        break _L;
      }
    }
  }
  return ty;
}
function hackwaly$tinycc$frontend$parser$parser_core$$define_typedef(p, name, ty) {
  const id = hackwaly$tinycc$frontend$parser$parser_core$$typedef_id_from_name(p, name);
  if (id === 0) {
    return undefined;
  }
  const scope_id = hackwaly$tinycc$frontend$parser$parser_core$$current_typedef_scope_id(p);
  const prev_scope = hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_scope_level(p, id);
  const already = prev_scope === scope_id;
  const resolved = hackwaly$tinycc$frontend$parser$parser_core$$typedef_ref_type(ty);
  const idx = p.typedef_overrides.length - 1 | 0;
  if (!already) {
    const overrides = moonbitlang$core$array$$Array$at$52$(p.typedef_overrides, idx);
    moonbitlang$core$array$$Array$push$62$(overrides, { _0: id, _1: hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_value(p, id), _2: prev_scope });
    moonbitlang$core$array$$Array$set$52$(p.typedef_overrides, idx, overrides);
    hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_value(p, id, resolved);
    hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_scope_level(p, id, scope_id);
    hackwaly$tinycc$frontend$parser$parser_core$$inc_typedef_count(p, id);
    return;
  } else {
    hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_value(p, id, resolved);
    return;
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p) {
  const tok = p.current;
  p.current = p.lookahead;
  if (p.buffer_pos < p.buffer.length) {
    p.lookahead = moonbitlang$core$array$$Array$at$15$(p.buffer, p.buffer_pos);
    p.buffer_pos = p.buffer_pos + 1 | 0;
    if (p.buffer_pos === p.buffer.length) {
      moonbitlang$core$array$$Array$clear$15$(p.buffer);
      p.buffer_pos = 0;
    }
  } else {
    p.lookahead = hackwaly$tinycc$frontend$preproc$$next_pp_token(p.pp);
  }
  return tok;
}
function hackwaly$tinycc$frontend$parser$parser_core$$expect(p, kind, message) {
  const tok = p.current;
  if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, kind)) {
    return hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  }
  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, message);
  return tok;
}
function hackwaly$tinycc$frontend$parser$parser_core$$typedef_id_from_token(_p$28, tok) {
  if (moonbitlang$core$builtin$$Eq$not_equal$84$(tok.kind, 2)) {
    return 0;
  }
  return hackwaly$tinycc$frontend$tokens$$token_id(tok);
}
function hackwaly$tinycc$frontend$parser$parser_core$$has_typedef(p, tok) {
  const id = hackwaly$tinycc$frontend$parser$parser_core$$typedef_id_from_token(p, tok);
  if (id === 0) {
    return false;
  }
  return hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_count(p, id) > 0;
}
function hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, tok) {
  const _bind = tok.kind;
  switch (_bind) {
    case 31: {
      return true;
    }
    case 36: {
      return true;
    }
    case 32: {
      return true;
    }
    case 37: {
      return true;
    }
    case 33: {
      return true;
    }
    case 38: {
      return true;
    }
    case 34: {
      return true;
    }
    case 35: {
      return true;
    }
    case 22: {
      return true;
    }
    case 21: {
      return true;
    }
    case 23: {
      return true;
    }
    case 24: {
      return true;
    }
    case 29: {
      return true;
    }
    case 30: {
      return true;
    }
    case 19: {
      return true;
    }
    case 20: {
      return true;
    }
    case 26: {
      return true;
    }
    case 25: {
      return true;
    }
    case 27: {
      return true;
    }
    case 39: {
      return true;
    }
    case 40: {
      return true;
    }
    case 42: {
      return true;
    }
    case 45: {
      return true;
    }
    case 41: {
      return true;
    }
    case 2: {
      return hackwaly$tinycc$frontend$parser$parser_core$$has_typedef(p, tok);
    }
    default: {
      return false;
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, kind) {
  return moonbitlang$core$builtin$$Eq$equal$85$(p.current.kind, kind) ? hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p) : undefined;
}
function hackwaly$tinycc$frontend$parser$parser_core$$is_oct_digit(code) {
  return moonbitlang$core$builtin$$Compare$op_ge$23$(code, 48) && moonbitlang$core$builtin$$Compare$op_le$23$(code, 55);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_hex_escape(p, text, start, loc) {
  let i = start;
  let value = 0;
  let saw = false;
  while (true) {
    if (i < text.length) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      const digit = hackwaly$tinycc$support$util$$hex_digit_value(code);
      if (digit === undefined) {
        break;
      } else {
        const _Some = digit;
        const _v = _Some;
        value = (Math.imul(value, 16) | 0) + _v | 0;
        saw = true;
        i = i + 1 | 0;
      }
      continue;
    } else {
      break;
    }
  }
  if (!saw) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "invalid hex escape");
  }
  return { _0: value, _1: i };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_octal_escape(text, start) {
  let i = start;
  let value = 0;
  let count = 0;
  while (true) {
    if (i < text.length && count < 3) {
      const _tmp$27 = i;
      $bound_check(text, _tmp$27);
      const code = text.charCodeAt(_tmp$27);
      if (!hackwaly$tinycc$frontend$parser$parser_core$$is_oct_digit(code)) {
        break;
      }
      value = (Math.imul(value, 8) | 0) + (code - 48 | 0) | 0;
      i = i + 1 | 0;
      count = count + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: value, _1: i };
}
function hackwaly$tinycc$frontend$parser$parser_core$$decode_escape_value(p, text, start, loc) {
  if (start >= text.length) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "unterminated escape sequence");
    return { _0: 0, _1: start };
  }
  $bound_check(text, start);
  const code = text.charCodeAt(start);
  _L: {
    switch (code) {
      case 97: {
        return { _0: 7, _1: start + 1 | 0 };
      }
      case 98: {
        return { _0: 8, _1: start + 1 | 0 };
      }
      case 102: {
        return { _0: 12, _1: start + 1 | 0 };
      }
      case 110: {
        return { _0: 10, _1: start + 1 | 0 };
      }
      case 114: {
        return { _0: 13, _1: start + 1 | 0 };
      }
      case 116: {
        return { _0: 9, _1: start + 1 | 0 };
      }
      case 118: {
        return { _0: 11, _1: start + 1 | 0 };
      }
      case 92: {
        return { _0: 92, _1: start + 1 | 0 };
      }
      case 39: {
        return { _0: 39, _1: start + 1 | 0 };
      }
      case 34: {
        return { _0: 34, _1: start + 1 | 0 };
      }
      case 63: {
        return { _0: 63, _1: start + 1 | 0 };
      }
      case 120: {
        break _L;
      }
      case 88: {
        break _L;
      }
      default: {
        return hackwaly$tinycc$frontend$parser$parser_core$$is_oct_digit(code) ? hackwaly$tinycc$frontend$parser$parser_core$$parse_octal_escape(text, start) : { _0: code, _1: start + 1 | 0 };
      }
    }
  }
  return hackwaly$tinycc$frontend$parser$parser_core$$parse_hex_escape(p, text, start + 1 | 0, loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$decode_string_literal(p, lexeme, loc) {
  const len = lexeme.length;
  const size_hint = len > 2 ? len - 2 | 0 : 0;
  const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(size_hint);
  let i = 1;
  let count = 0;
  while (true) {
    if ((i + 1 | 0) < len) {
      const _tmp$27 = i;
      $bound_check(lexeme, _tmp$27);
      const code = lexeme.charCodeAt(_tmp$27);
      const _p$28 = 92;
      if (code === _p$28) {
        if ((i + 1 | 0) >= len) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "unterminated escape sequence");
          break;
        }
        const _tmp$28 = i + 1 | 0;
        $bound_check(lexeme, _tmp$28);
        const next = lexeme.charCodeAt(_tmp$28);
        const _p$29 = 10;
        if (next === _p$29) {
          i = i + 2 | 0;
          continue;
        }
        const _bind = hackwaly$tinycc$frontend$parser$parser_core$$decode_escape_value(p, lexeme, i + 1 | 0, loc);
        const _value = _bind._0;
        const _next_index = _bind._1;
        if (_value >= 0) {
          const _p$30 = _value & 65535;
          moonbitlang$core$builtin$$Logger$write_char$1$(sb, _p$30);
          count = count + 1 | 0;
        }
        i = _next_index;
        continue;
      }
      moonbitlang$core$builtin$$Logger$write_char$1$(sb, code);
      count = count + 1 | 0;
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: sb.val, _1: count };
}
function hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok) {
  return hackwaly$tinycc$frontend$tokens$$token_text_with(p.pp.interner, p.pp.lexeme_pool, tok);
}
function hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme_len(p, tok) {
  return hackwaly$tinycc$frontend$tokens$$token_text_len_with(p.pp.interner, p.pp.lexeme_pool, tok);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, loc) {
  if (moonbitlang$core$builtin$$Eq$not_equal$84$(p.current.kind, 6)) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected string literal in attribute");
    return undefined;
  }
  const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$decode_string_literal(p, hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok), tok.loc);
  const _part = _bind._0;
  if (moonbitlang$core$builtin$$Eq$not_equal$84$(p.current.kind, 6)) {
    return _part;
  }
  const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme_len(p, tok));
  moonbitlang$core$builtin$$Logger$write_string$1$(sb, _part);
  while (true) {
    const _bind$2 = p.current.kind;
    if (_bind$2 === 6) {
      const next_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$decode_string_literal(p, hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, next_tok), next_tok.loc);
      const _next_part = _bind$3._0;
      moonbitlang$core$builtin$$Logger$write_string$1$(sb, _next_part);
      continue;
    } else {
      break;
    }
  }
  return sb.val;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_clobbers(p) {
  const clobbers = [];
  const kind = p.current.kind;
  _L: {
    _L$2: {
      if (kind === 57) {
        break _L$2;
      } else {
        if (kind === 50) {
          break _L$2;
        }
      }
      break _L;
    }
    return clobbers;
  }
  while (true) {
    const loc = p.current.loc;
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, loc);
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _value = _Some;
      moonbitlang$core$array$$Array$push$19$(clobbers, _value);
    }
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
    if (_bind$2 === undefined) {
    } else {
      continue;
    }
    break;
  }
  return clobbers;
}
function hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, message) {
  const tok = p.current;
  const _bind = tok.kind;
  if (_bind === 2) {
    return hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  }
  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, message);
  return undefined;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_labels(p) {
  const labels = [];
  const kind = p.current.kind;
  _L: {
    _L$2: {
      if (kind === 57) {
        break _L$2;
      } else {
        if (kind === 50) {
          break _L$2;
        }
      }
      break _L;
    }
    return labels;
  }
  while (true) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected label identifier");
    let name;
    if (_bind === undefined) {
      name = "";
    } else {
      const _Some = _bind;
      const _tok = _Some;
      name = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok);
    }
    const _p$28 = "";
    if (!(name === _p$28)) {
      moonbitlang$core$array$$Array$push$19$(labels, name);
    }
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
    if (_bind$2 === undefined) {
    } else {
      continue;
    }
    break;
  }
  return labels;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_char_literal_value(p, tok) {
  const lexeme = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok);
  if (lexeme.length < 3) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "invalid character literal");
    return 0;
  }
  const len = lexeme.length;
  let value = 0;
  let i = 1;
  if ((i + 1 | 0) >= len) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "invalid character literal");
    return 0;
  }
  const _tmp$27 = i;
  $bound_check(lexeme, _tmp$27);
  const code = lexeme.charCodeAt(_tmp$27);
  const _p$28 = 92;
  if (code === _p$28) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$decode_escape_value(p, lexeme, i + 1 | 0, tok.loc);
    const _esc = _bind._0;
    const _next_index = _bind._1;
    value = _esc;
    i = _next_index;
  } else {
    value = code;
    i = i + 1 | 0;
  }
  if ((i + 1 | 0) < len) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multi-character literal");
  }
  return value;
}
function hackwaly$tinycc$frontend$parser$parser_core$$push_typedef_scope(p) {
  const scope_id = p.next_typedef_scope_id;
  p.next_typedef_scope_id = scope_id + 1 | 0;
  moonbitlang$core$array$$Array$push$26$(p.typedef_scope_stack, scope_id);
  moonbitlang$core$array$$Array$push$52$(p.typedef_overrides, []);
}
function hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_scope(p) {
  const len = p.pending_typedef_scopes.length;
  if (len === 0) {
    return undefined;
  }
  const idx = len - 1 | 0;
  if (!moonbitlang$core$array$$Array$at$67$(p.pending_typedef_scopes, idx)) {
    hackwaly$tinycc$frontend$parser$parser_core$$push_typedef_scope(p);
    moonbitlang$core$array$$Array$set$67$(p.pending_typedef_scopes, idx, true);
    return;
  } else {
    return;
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$is_attr_name_token(kind) {
  switch (kind) {
    case 2: {
      return true;
    }
    case 23: {
      return true;
    }
    case 24: {
      return true;
    }
    case 29: {
      return true;
    }
    case 27: {
      return true;
    }
    case 22: {
      return true;
    }
    default: {
      return false;
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$normalize_attr_name(name) {
  return moonbitlang$core$string$$String$to_lower(moonbitlang$core$builtin$$Show$to_string$12$(moonbitlang$core$string$$String$trim$46$inner(name, { str: hackwaly$tinycc$frontend$parser$parser_core$$normalize_attr_name$46$42$bind$124$1061, start: 0, end: hackwaly$tinycc$frontend$parser$parser_core$$normalize_attr_name$46$42$bind$124$1061.length })));
}
function hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p) {
  let depth = 1;
  while (true) {
    if (depth > 0 && !hackwaly$tinycc$frontend$parser$parser_core$$is_at_end(p)) {
      const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _bind = tok.kind;
      switch (_bind) {
        case 49: {
          depth = depth + 1 | 0;
          break;
        }
        case 50: {
          depth = depth - 1 | 0;
          break;
        }
      }
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$lookup_typedef(p, tok) {
  const id = hackwaly$tinycc$frontend$parser$parser_core$$typedef_id_from_token(p, tok);
  if (id === 0) {
    return undefined;
  }
  return hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_value(p, id);
}
function hackwaly$tinycc$frontend$parser$parser_core$$next_anon_tag(p) {
  p.anon_tag_id = p.anon_tag_id + 1 | 0;
  const name = `__anon_tag_${moonbitlang$core$builtin$$Show$to_string$90$(p.anon_tag_id)}`;
  const _bind = hackwaly$tinycc$support$intern$intern_core$$StringInterner$intern_view_with_id(p.pp.interner, { str: name, start: 0, end: name.length });
  const _id = _bind._1;
  return { _0: name, _1: _id };
}
function hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, offset) {
  if (offset <= 0) {
    return p.current;
  }
  if (offset === 1) {
    return p.lookahead;
  }
  const target = p.buffer_pos + (offset - 2 | 0) | 0;
  while (true) {
    if (p.buffer.length <= target) {
      moonbitlang$core$array$$Array$push$15$(p.buffer, hackwaly$tinycc$frontend$preproc$$next_pp_token(p.pp));
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$array$$Array$at$15$(p.buffer, target);
}
function hackwaly$tinycc$frontend$parser$parser_core$$apply_decl_wrappers(base, wrappers) {
  let ty = base;
  let i = wrappers.length;
  while (true) {
    if (i > 0) {
      i = i - 1 | 0;
      const _bind = moonbitlang$core$array$$Array$at$76$(wrappers, i);
      switch (_bind.$tag) {
        case 0: {
          const _Pointer = _bind;
          const _qual = _Pointer._0;
          ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(ty);
          ty = hackwaly$tinycc$frontend$ast$$apply_qualifiers(ty, _qual);
          break;
        }
        case 1: {
          const _Array = _bind;
          const _size = _Array._0;
          const _size_expr = _Array._1;
          ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(ty, _size, _size_expr);
          break;
        }
        default: {
          const _Function = _bind;
          const _params = _Function._0;
          const _varargs = _Function._1;
          const _is_old_style = _Function._2;
          const _p$28 = new Array(_params.length);
          const _p$29 = _params.length;
          let _tmp$27 = 0;
          while (true) {
            const _p$30 = _tmp$27;
            if (_p$30 < _p$29) {
              const _p$31 = _params[_p$30];
              _p$28[_p$30] = _p$31.ty;
              _tmp$27 = _p$30 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          const param_types = _p$28;
          ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(ty, param_types, _varargs, _is_old_style, $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default);
        }
      }
      continue;
    } else {
      break;
    }
  }
  return ty;
}
function hackwaly$tinycc$frontend$parser$parser_core$$is_paren_pointer_declarator(p) {
  const _p$28 = 0;
  if (moonbitlang$core$builtin$$Eq$not_equal$84$(hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind, 49)) {
    return false;
  }
  let depth = 0;
  let i = 1;
  while (true) {
    const _p$29 = i;
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$29).kind;
    switch (_bind) {
      case 0: {
        return false;
      }
      case 49: {
        depth = depth + 1 | 0;
        break;
      }
      case 50: {
        if (depth === 0) {
          return false;
        }
        depth = depth - 1 | 0;
        break;
      }
      case 65: {
        if (depth === 0) {
          return true;
        }
        break;
      }
    }
    i = i + 1 | 0;
    continue;
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_type_qualifiers(p) {
  let qual = hackwaly$tinycc$frontend$ast$$empty_qual();
  _L: while (true) {
    const tok = p.current;
    let kind = tok.kind;
    const _bind = kind;
    if (_bind === 2) {
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$special_ident_kind(tok, p.pp.keyword_ids);
      if (_bind$2 === undefined) {
      } else {
        const _Some = _bind$2;
        const _mapped = _Some;
        kind = _mapped;
      }
    }
    const _bind$2 = kind;
    switch (_bind$2) {
      case 23: {
        qual = hackwaly$tinycc$frontend$ast$$with_const(qual);
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        continue _L;
      }
      case 24: {
        qual = hackwaly$tinycc$frontend$ast$$with_volatile(qual);
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        continue _L;
      }
      case 29: {
        qual = hackwaly$tinycc$frontend$ast$$with_restrict(qual);
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        continue _L;
      }
      case 30: {
        qual = hackwaly$tinycc$frontend$ast$$with_atomic(qual);
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        continue _L;
      }
    }
    break;
  }
  return qual;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_label(p, loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after asm");
  const label = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, loc);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after asm label");
  return label;
}
function hackwaly$tinycc$frontend$parser$parser_core$$strip_type_qualifiers(ty) {
  let _tmp$27 = ty;
  _L: while (true) {
    const ty$2 = _tmp$27;
    switch (ty$2.$tag) {
      case 12: {
        const _Qualified = ty$2;
        const _base = _Qualified._1;
        _tmp$27 = _base;
        continue _L;
      }
      case 11: {
        const _Attributed = ty$2;
        const _base$2 = _Attributed._1;
        _tmp$27 = _base$2;
        continue _L;
      }
      default: {
        return ty$2;
      }
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p) {
  while (true) {
    if (!hackwaly$tinycc$frontend$parser$parser_core$$is_at_end(p)) {
      const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      _L: {
        _L$2: {
          const _bind = tok.kind;
          switch (_bind) {
            case 56: {
              break _L$2;
            }
            case 52: {
              break _L$2;
            }
          }
          break _L;
        }
        return undefined;
      }
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$is_type_spec_start(p) {
  const tok = p.current;
  let kind = tok.kind;
  const _bind = kind;
  if (_bind === 2) {
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$special_ident_kind(tok, p.pp.keyword_ids);
    if (_bind$2 === undefined) {
    } else {
      const _Some = _bind$2;
      const _mapped = _Some;
      kind = _mapped;
    }
  }
  const _bind$2 = kind;
  switch (_bind$2) {
    case 31: {
      return true;
    }
    case 36: {
      return true;
    }
    case 32: {
      return true;
    }
    case 33: {
      return true;
    }
    case 34: {
      return true;
    }
    case 35: {
      return true;
    }
    case 37: {
      return true;
    }
    case 38: {
      return true;
    }
    case 39: {
      return true;
    }
    case 40: {
      return true;
    }
    case 42: {
      return true;
    }
    case 23: {
      return true;
    }
    case 24: {
      return true;
    }
    case 29: {
      return true;
    }
    case 30: {
      return true;
    }
    case 22: {
      return true;
    }
    case 21: {
      return true;
    }
    case 46: {
      return true;
    }
    case 45: {
      return true;
    }
    case 2: {
      return hackwaly$tinycc$frontend$parser$parser_core$$has_typedef(p, p.current);
    }
    default: {
      return false;
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$dec_typedef_count(p, id) {
  if (id === 0) {
    return undefined;
  }
  const count = hackwaly$tinycc$frontend$parser$parser_core$$get_typedef_count(p, id);
  if (count <= 1) {
    hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_count(p, id, 0);
    return;
  } else {
    hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_count(p, id, count - 1 | 0);
    return;
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$pop_typedef_scope(p) {
  const _bind = moonbitlang$core$array$$Array$pop$52$(p.typedef_overrides);
  if (_bind.$tag === 1) {
    const _Some = _bind;
    const _overrides = _Some._0;
    let i = _overrides.length;
    while (true) {
      if (i > 0) {
        i = i - 1 | 0;
        const _bind$2 = moonbitlang$core$array$$Array$at$62$(_overrides, i);
        const _id = _bind$2._0;
        const _prev = _bind$2._1;
        const _prev_scope = _bind$2._2;
        hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_value(p, _id, _prev);
        hackwaly$tinycc$frontend$parser$parser_core$$set_typedef_scope_level(p, _id, _prev_scope);
        hackwaly$tinycc$frontend$parser$parser_core$$dec_typedef_count(p, _id);
        continue;
      } else {
        break;
      }
    }
  }
  moonbitlang$core$array$$Array$pop$26$(p.typedef_scope_stack);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_string_literal_expr(p, first) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$decode_string_literal(p, hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, first), first.loc);
  const _value = _bind._0;
  const _len = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$84$(p.current.kind, 6)) {
    return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StringLit(_value, _len + 1 | 0, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), first.loc);
  }
  const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme_len(p, first));
  let byte_len = _len;
  moonbitlang$core$builtin$$Logger$write_string$1$(sb, _value);
  while (true) {
    const _bind$2 = p.current.kind;
    if (_bind$2 === 6) {
      const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$decode_string_literal(p, hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok), tok.loc);
      const _part = _bind$3._0;
      const _part_len = _bind$3._1;
      moonbitlang$core$builtin$$Logger$write_string$1$(sb, _part);
      byte_len = byte_len + _part_len | 0;
      continue;
    } else {
      break;
    }
  }
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StringLit(sb.val, byte_len + 1 | 0, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), first.loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_stmt(p, loc) {
  let is_volatile = false;
  let is_goto = false;
  while (true) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 24);
    if (_bind === undefined) {
    } else {
      is_volatile = true;
      continue;
    }
    const _bind$2 = p.current.kind;
    if (_bind$2 === 2) {
      const tok = p.current;
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$special_ident_kind(tok, p.pp.keyword_ids);
      if (_bind$3 === undefined) {
      } else {
        const _Some = _bind$3;
        const _x = _Some;
        if (_x === 24) {
          hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
          is_volatile = true;
          continue;
        }
      }
    }
    const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 15);
    if (_bind$3 === undefined) {
    } else {
      is_goto = true;
      continue;
    }
    break;
  }
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after asm");
  const _p$28 = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, loc);
  const _p$29 = "";
  let template;
  if (_p$28 === undefined) {
    template = _p$29;
  } else {
    const _p$30 = _p$28;
    template = _p$30;
  }
  let outputs = [];
  let inputs = [];
  let clobbers = [];
  let labels = [];
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 57);
  if (_bind === undefined) {
  } else {
    outputs = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_operands(p);
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 57);
    if (_bind$2 === undefined) {
    } else {
      inputs = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_operands(p);
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 57);
      if (_bind$3 === undefined) {
      } else {
        clobbers = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_clobbers(p);
        const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 57);
        if (_bind$4 === undefined) {
        } else {
          labels = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_labels(p);
        }
      }
    }
  }
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after asm");
  return { template: template, outputs: outputs, inputs: inputs, clobbers: clobbers, labels: labels, is_volatile: is_volatile, is_goto: is_goto, loc: loc };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_operands(p) {
  const operands = [];
  const kind = p.current.kind;
  _L: {
    _L$2: {
      if (kind === 57) {
        break _L$2;
      } else {
        if (kind === 50) {
          break _L$2;
        }
      }
      break _L;
    }
    return operands;
  }
  while (true) {
    const start_loc = p.current.loc;
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 53);
    let name;
    if (_bind === undefined) {
      name = undefined;
    } else {
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected asm operand name");
      let id;
      if (_bind$2 === undefined) {
        id = "";
      } else {
        const _Some = _bind$2;
        const _tok = _Some;
        id = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok);
      }
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 54, "expected ']' after asm operand name");
      name = id === "" ? undefined : id;
    }
    const _p$28 = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, start_loc);
    const _p$29 = "";
    let constraint;
    if (_p$28 === undefined) {
      constraint = _p$29;
    } else {
      const _p$30 = _p$28;
      constraint = _p$30;
    }
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after asm constraint");
    const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after asm operand");
    moonbitlang$core$array$$Array$push$112$(operands, { name: name, constraint: constraint, expr: expr, loc: start_loc });
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
    if (_bind$2 === undefined) {
    } else {
      continue;
    }
    break;
  }
  return operands;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p) {
  return hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_comma(p);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_comma(p) {
  let expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq(p);
  while (true) {
    const _bind = p.current.kind;
    if (_bind === 55) {
      const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const right = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq(p);
      expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Binary(11, expr, right, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
    } else {
      break;
    }
    continue;
  }
  return expr;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq(p) {
  const left = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
  const _bind = p.current.kind;
  let op;
  switch (_bind) {
    case 62: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16615;
      break;
    }
    case 70: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16616;
      break;
    }
    case 71: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16617;
      break;
    }
    case 72: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16618;
      break;
    }
    case 73: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16619;
      break;
    }
    case 74: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16620;
      break;
    }
    case 83: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16621;
      break;
    }
    case 84: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16622;
      break;
    }
    case 92: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16623;
      break;
    }
    case 93: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16624;
      break;
    }
    case 94: {
      op = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq$46$constr$47$16625;
      break;
    }
    default: {
      op = undefined;
    }
  }
  if (op === undefined) {
    return left;
  } else {
    const _Some = op;
    const _op = _Some;
    const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    const right = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq(p);
    return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Binary(_op, left, right, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p) {
  const cond = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_binary(p, 1);
  const _bind = p.current.kind;
  if (_bind === 58) {
    const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    const then_expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 57, "expected ':' in conditional expression");
    const else_expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
    return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Conditional(cond, then_expr, else_expr, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
  } else {
    return cond;
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_binary(p, min_prec) {
  let expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
  while (true) {
    let prec = 0;
    let op = 12;
    const _bind = p.current.kind;
    switch (_bind) {
      case 91: {
        op = 29;
        prec = 1;
        break;
      }
      case 90: {
        op = 28;
        prec = 2;
        break;
      }
      case 86: {
        op = 27;
        prec = 3;
        break;
      }
      case 87: {
        op = 26;
        prec = 4;
        break;
      }
      case 85: {
        op = 25;
        prec = 5;
        break;
      }
      case 75: {
        op = 19;
        prec = 6;
        break;
      }
      case 76: {
        op = 20;
        prec = 6;
        break;
      }
      case 77: {
        op = 21;
        prec = 7;
        break;
      }
      case 78: {
        op = 22;
        prec = 7;
        break;
      }
      case 79: {
        op = 23;
        prec = 7;
        break;
      }
      case 80: {
        op = 24;
        prec = 7;
        break;
      }
      case 81: {
        op = 17;
        prec = 8;
        break;
      }
      case 82: {
        op = 18;
        prec = 8;
        break;
      }
      case 63: {
        op = 12;
        prec = 9;
        break;
      }
      case 64: {
        op = 13;
        prec = 9;
        break;
      }
      case 65: {
        op = 14;
        prec = 10;
        break;
      }
      case 66: {
        op = 15;
        prec = 10;
        break;
      }
      case 67: {
        op = 16;
        prec = 10;
        break;
      }
    }
    if (prec === 0 || prec < min_prec) {
      break;
    }
    const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    const right = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_binary(p, prec + 1 | 0);
    expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Binary(op, expr, right, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
    continue;
  }
  return expr;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p) {
  const _bind = p.current.kind;
  switch (_bind) {
    case 43: {
      const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _p$28 = 0;
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind;
      if (_bind$2 === 49) {
        if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, 1))) {
          hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after sizeof");
          const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
          if (_bind$3 === undefined) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "expected type name after sizeof");
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit("0", hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
          } else {
            const _Some = _bind$3;
            const _ty = _Some;
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after sizeof type");
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$SizeofType(_ty, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
          }
        }
      }
      const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$SizeofExpr(expr, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
    }
    case 44: {
      const tok$2 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _p$29 = 0;
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$29).kind;
      if (_bind$3 === 49) {
        if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, 1))) {
          hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after alignof");
          const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
          if (_bind$4 === undefined) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok$2.loc, "expected type name after alignof");
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit("0", hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$2.loc);
          } else {
            const _Some = _bind$4;
            const _ty = _Some;
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after alignof type");
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$AlignofType(_ty, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$2.loc);
          }
        }
      }
      const expr$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$AlignofExpr(expr$2, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$2.loc);
    }
  }
  const _p$30 = 0;
  const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$30).kind;
  if (_bind$4 === 49) {
    if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, 1))) {
      const lparen = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
      if (_bind$5 === undefined) {
        hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, lparen.loc, "expected type name in cast");
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit("0", hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), lparen.loc);
      } else {
        const _Some = _bind$5;
        const _ty = _Some;
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after cast type");
        const _p$31 = 0;
        const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$31).kind;
        if (_bind$6 === 51) {
          const init = hackwaly$tinycc$frontend$parser$parser_core$$parse_initializer(p);
          const literal = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$CompoundLiteral(_ty, init, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), lparen.loc);
          return hackwaly$tinycc$frontend$parser$parser_core$$parse_postfix_tail(p, literal);
        }
        const expr$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Cast(_ty, expr$3, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), lparen.loc);
      }
    }
  }
  const _bind$5 = p.current.kind;
  switch (_bind$5) {
    case 90: {
      const tok$3 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const name_tok = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected label identifier after &&");
      if (name_tok === undefined) {
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit("0", hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$3.loc);
      } else {
        const _Some = name_tok;
        const _label_tok = _Some;
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$LabelAddr(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _label_tok), hackwaly$tinycc$frontend$tokens$$token_id(_label_tok), hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$3.loc);
      }
    }
    case 68: {
      const tok$4 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(6, expr$3, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$4.loc);
    }
    case 69: {
      const tok$5 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$4 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(7, expr$4, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$5.loc);
    }
    case 63: {
      const tok$6 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$5 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(0, expr$5, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$6.loc);
    }
    case 64: {
      const tok$7 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$6 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(1, expr$6, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$7.loc);
    }
    case 89: {
      const tok$8 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$7 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(2, expr$7, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$8.loc);
    }
    case 88: {
      const tok$9 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$8 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(3, expr$8, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$9.loc);
    }
    case 85: {
      const tok$10 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$9 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(4, expr$9, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$10.loc);
    }
    case 65: {
      const tok$11 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr$10 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_unary(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(5, expr$10, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$11.loc);
    }
    default: {
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_postfix(p);
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_postfix(p) {
  const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_primary(p);
  return hackwaly$tinycc$frontend$parser$parser_core$$parse_postfix_tail(p, expr);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_primary(p) {
  const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  const _bind = tok.kind;
  switch (_bind) {
    case 3: {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok), hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
    }
    case 4: {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$FloatLit(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok), hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
    }
    case 5: {
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$CharLit(hackwaly$tinycc$frontend$parser$parser_core$$parse_char_literal_value(p, tok), hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
    }
    case 6: {
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_string_literal_expr(p, tok);
    }
    case 2: {
      const _bind$2 = p.current.kind;
      if (_bind$2 === 49) {
        const id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
        if (id === p.builtin_ids.types_compatible_p) {
          hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after __builtin_types_compatible_p");
          const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
          let a;
          if (_bind$3 === undefined) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "expected type name in builtin");
            a = hackwaly$tinycc$frontend$ast$$default_int_type();
          } else {
            const _Some = _bind$3;
            a = _Some;
          }
          hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 55, "expected ',' in __builtin_types_compatible_p");
          const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
          let b;
          if (_bind$4 === undefined) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "expected type name in builtin");
            b = hackwaly$tinycc$frontend$ast$$default_int_type();
          } else {
            const _Some = _bind$4;
            b = _Some;
          }
          hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after __builtin_types_compatible_p");
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinTypesCompatibleP(a, b, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
        } else {
          if (id === p.builtin_ids.offsetof) {
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after __builtin_offsetof");
            const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
            let ty;
            if (_bind$3 === undefined) {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "expected type name in __builtin_offsetof");
              ty = hackwaly$tinycc$frontend$ast$$default_int_type();
            } else {
              const _Some = _bind$3;
              ty = _Some;
            }
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 55, "expected ',' in __builtin_offsetof");
            const path = [];
            const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected member name in __builtin_offsetof");
            if (_bind$4 === undefined) {
            } else {
              const _Some = _bind$4;
              const _id = _Some;
              moonbitlang$core$array$$Array$push$19$(path, hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _id));
            }
            while (true) {
              const _bind$5 = p.current.kind;
              if (_bind$5 === 59) {
                hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
                const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected member name in __builtin_offsetof");
                if (_bind$6 === undefined) {
                  break;
                } else {
                  const _Some = _bind$6;
                  const _id = _Some;
                  moonbitlang$core$array$$Array$push$19$(path, hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _id));
                }
              } else {
                break;
              }
              continue;
            }
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after __builtin_offsetof");
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinOffsetof(ty, path, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
          } else {
            if (id === p.builtin_ids.va_arg) {
              hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after __builtin_va_arg");
              const list = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq(p);
              hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 55, "expected ',' in __builtin_va_arg");
              const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
              let ty;
              if (_bind$3 === undefined) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "expected type name in builtin");
                ty = hackwaly$tinycc$frontend$ast$$default_int_type();
              } else {
                const _Some = _bind$3;
                ty = _Some;
              }
              hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after __builtin_va_arg");
              return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$BuiltinVaArg(list, ty, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
            } else {
              return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Ident(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok), hackwaly$tinycc$frontend$tokens$$token_id(tok), hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
            }
          }
        }
      } else {
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Ident(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok), hackwaly$tinycc$frontend$tokens$$token_id(tok), hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
      }
    }
    case 49: {
      const _bind$3 = p.current.kind;
      if (_bind$3 === 51) {
        const lbrace = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const block = hackwaly$tinycc$frontend$parser$parser_core$$parse_compound_stmt(p, lbrace.loc);
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after statement expression");
        if (block.$tag === 0) {
          const _Compound = block;
          const _stmts = _Compound._0;
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StmtExpr(_stmts, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
        } else {
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$StmtExpr([], hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
        }
      } else {
        const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')'");
        return expr;
      }
    }
    default: {
      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "unexpected token in expression");
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit("0", hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_compound_stmt(p, loc) {
  moonbitlang$core$array$$Array$push$67$(p.pending_typedef_scopes, false);
  const stmts = moonbitlang$core$array$$Array$new$46$inner$49$(8);
  while (true) {
    _L: {
      _L$2: {
        const _bind = p.current.kind;
        switch (_bind) {
          case 0: {
            break _L$2;
          }
          case 52: {
            break _L$2;
          }
          default: {
            moonbitlang$core$array$$Array$push$49$(stmts, hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p));
          }
        }
        break _L;
      }
      break;
    }
    continue;
  }
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 52, "expected '}'");
  const _p$28 = moonbitlang$core$array$$Array$pop$67$(p.pending_typedef_scopes);
  const _p$29 = false;
  const did_scope = _p$28 === -1 ? _p$29 : _p$28;
  if (did_scope) {
    hackwaly$tinycc$frontend$parser$parser_core$$pop_typedef_scope(p);
  }
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Compound(stmts, loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p) {
  const tok = p.current;
  const _bind = tok.kind;
  switch (_bind) {
    case 51: {
      const lbrace = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_compound_stmt(p, lbrace.loc);
    }
    case 47: {
      const assert_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const static_assert = hackwaly$tinycc$frontend$parser$parser_core$$parse_static_assert(p, assert_tok.loc);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after _Static_assert");
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$StaticAssert(static_assert);
    }
    case 48: {
      const asm_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const asm_stmt = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_stmt(p, asm_tok.loc);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after asm");
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Asm(asm_stmt);
    }
    case 17: {
      const case_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 60);
      const end_expr = _bind$2 === undefined ? undefined : hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 57, "expected ':' after case");
      const body = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Case(expr, end_expr, body, case_tok.loc);
    }
    case 18: {
      const def_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 57, "expected ':' after default");
      const body$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Default(body$2, def_tok.loc);
    }
    case 7: {
      const if_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_if_stmt(p, if_tok.loc);
    }
    case 9: {
      const while_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_while_stmt(p, while_tok.loc);
    }
    case 11: {
      const do_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_do_while_stmt(p, do_tok.loc);
    }
    case 10: {
      const for_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_for_stmt(p, for_tok.loc);
    }
    case 16: {
      const sw_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return hackwaly$tinycc$frontend$parser$parser_core$$parse_switch_stmt(p, sw_tok.loc);
    }
    case 13: {
      const break_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after break");
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Break(break_tok.loc);
    }
    case 12: {
      const cont_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after continue");
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Continue(cont_tok.loc);
    }
    case 15: {
      const goto_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _bind$3 = p.current.kind;
      if (_bind$3 === 65) {
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const expr$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after goto");
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$GotoExpr(expr$2, goto_tok.loc);
      } else {
        const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected label after goto");
        let name;
        if (_bind$4 === undefined) {
          name = "";
        } else {
          const _Some = _bind$4;
          const _tok = _Some;
          name = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok);
        }
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after goto");
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Goto(name, goto_tok.loc);
      }
    }
    case 14: {
      const ret_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 56);
      if (_bind$4 === undefined) {
      } else {
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Return(undefined, ret_tok.loc);
      }
      const value = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after return");
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Return(value, ret_tok.loc);
    }
    case 56: {
      const semi = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty(semi.loc);
    }
  }
  const _bind$5 = tok.kind;
  if (_bind$5 === 2) {
    const _p$28 = 1;
    const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind;
    if (_bind$6 === 57) {
      const label_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 57, "expected ':' after label");
      hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p);
      const body$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Label(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, label_tok), body$3, label_tok.loc);
    }
  }
  if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, tok)) {
    hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_scope(p);
    const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$parse_decl_specs$46$inner(p, true);
    if (_bind$6 === undefined) {
      hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty(tok.loc);
    } else {
      const _Some = _bind$6;
      const _specs = _Some;
      const base = _specs.ty;
      const is_typedef = _specs.is_typedef;
      const storage = _specs.storage;
      const is_inline = _specs.is_inline;
      const base_attrs = _specs.attrs;
      const _bind$7 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 56);
      if (_bind$7 === undefined) {
        const decls = moonbitlang$core$array$$Array$new$46$inner$99$(4);
        let decl_loc = tok.loc;
        let saw_decl = false;
        while (true) {
          const _bind$8 = hackwaly$tinycc$frontend$parser$parser_core$$parse_init_declarator(p, base);
          if (_bind$8 === undefined) {
            hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p);
            return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty(tok.loc);
          } else {
            const _Some$2 = _bind$8;
            const _x = _Some$2;
            const _decl = _x._0;
            const _init = _x._1;
            if (!saw_decl) {
              decl_loc = _decl.loc;
              saw_decl = true;
            }
            const combined_attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(base_attrs, _decl.attrs);
            const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_decl.ty, hackwaly$tinycc$frontend$ast$$normalize_call_conv(combined_attrs.call_conv));
            if (is_typedef) {
              if (_init === undefined) {
              } else {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "typedef cannot have initializer");
              }
              const typedef_ty = hackwaly$tinycc$frontend$ast$$apply_type_attrs(adjusted_ty, hackwaly$tinycc$frontend$ast$$type_attrs_from(combined_attrs));
              hackwaly$tinycc$frontend$parser$parser_core$$define_typedef(p, _decl.name, typedef_ty);
            } else {
              let actual_init = _init;
              if (adjusted_ty.$tag === 10) {
                const _bind$9 = actual_init;
                if (_bind$9 === undefined) {
                } else {
                  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "function declaration cannot have initializer");
                  actual_init = undefined;
                }
              }
              if (is_inline) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "inline can only apply to functions");
              }
              moonbitlang$core$array$$Array$push$99$(decls, { name: _decl.name, id: _decl.id, ty: adjusted_ty, init: actual_init, storage: storage, attrs: combined_attrs, loc: _decl.loc });
            }
          }
          const _bind$9 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
          if (_bind$9 === undefined) {
          } else {
            continue;
          }
          break;
        }
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after declaration");
        if (is_typedef) {
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty(decl_loc);
        }
        if (saw_decl) {
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$DeclStmt(decls, decl_loc);
        }
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty(tok.loc);
      } else {
        const _Some$2 = _bind$7;
        const _semi = _Some$2;
        if (is_typedef) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _semi.loc, "typedef requires a declarator");
          return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Empty(_semi.loc);
        }
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$TagDef(base, _semi.loc);
      }
    }
  }
  const expr$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after expression");
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$ExprStmt(expr$2, hackwaly$tinycc$frontend$ast$$expr_loc(expr$2));
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p) {
  let attrs = hackwaly$tinycc$frontend$ast$$empty_attrs();
  while (true) {
    const _bind = p.current.kind;
    if (_bind === 46) {
      const clause = hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause(p, p.current.loc);
      attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, clause);
      continue;
    } else {
      break;
    }
  }
  return attrs;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause(p, loc) {
  let attrs = hackwaly$tinycc$frontend$ast$$empty_attrs();
  hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
  if (_bind === undefined) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected '(' after attribute");
    return attrs;
  }
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
  if (_bind$2 === undefined) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected '(' after attribute");
    return attrs;
  }
  while (true) {
    if (!hackwaly$tinycc$frontend$parser$parser_core$$is_at_end(p) && moonbitlang$core$builtin$$Eq$not_equal$84$(p.current.kind, 50)) {
      const name_tok = p.current;
      if (!hackwaly$tinycc$frontend$parser$parser_core$$is_attr_name_token(name_tok.kind)) {
        hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, name_tok.loc, "expected attribute name");
        break;
      }
      hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const name = hackwaly$tinycc$frontend$parser$parser_core$$normalize_attr_name(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, name_tok));
      let has_args = false;
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
      if (_bind$3 === undefined) {
      } else {
        has_args = true;
      }
      switch (name) {
        case "aligned": {
          let spec;
          if (has_args) {
            const _bind$4 = p.current.kind;
            if (_bind$4 === 50) {
              spec = $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$AlignSpec$Default;
            } else {
              const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
              spec = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$AlignSpec$Expr(expr);
            }
          } else {
            spec = $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$AlignSpec$Default;
          }
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(new Option$Some$38$(spec), -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after aligned attribute");
          }
          break;
        }
        case "packed": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16804, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "weak": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16805, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "noreturn": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16806, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "constructor": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16807, -1, -1, Option$None$41$, -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "destructor": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16808, -1, Option$None$41$, -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "always_inline": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16809, Option$None$41$, -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "section": {
          if (!has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, name_tok.loc, "expected '(' after section");
          } else {
            const section = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, name_tok.loc);
            attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, new Option$Some$40$(section), Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after section");
          }
          break;
        }
        case "alias": {
          if (!has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, name_tok.loc, "expected '(' after alias");
          } else {
            const alias_name = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, name_tok.loc);
            attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, new Option$Some$40$(alias_name), Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after alias");
          }
          break;
        }
        case "visibility": {
          if (!has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, name_tok.loc, "expected '(' after visibility");
          } else {
            const vis = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, name_tok.loc);
            let value;
            if (vis === undefined) {
              value = undefined;
            } else {
              const _Some = vis;
              const _x = _Some;
              switch (_x) {
                case "default": {
                  value = hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16810;
                  break;
                }
                case "hidden": {
                  value = hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16811;
                  break;
                }
                case "internal": {
                  value = hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16812;
                  break;
                }
                case "protected": {
                  value = hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16813;
                  break;
                }
                default: {
                  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, name_tok.loc, "expected visibility(\"default|hidden|internal|protected\")");
                  value = undefined;
                }
              }
            }
            attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, new Option$Some$39$(value), Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after visibility");
          }
          break;
        }
        case "cleanup": {
          if (!has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, name_tok.loc, "expected '(' after cleanup");
          } else {
            const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected cleanup function name");
            if (_bind$4 === undefined) {
            } else {
              const _Some = _bind$4;
              const _id = _Some;
              attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, new Option$Some$40$(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _id)), -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
            }
            hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after cleanup");
          }
          break;
        }
        case "cdecl": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, new Option$Some$41$($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Cdecl), -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "stdcall": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, new Option$Some$41$($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Stdcall), -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "fastcall": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, new Option$Some$41$($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Fastcall), -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "thiscall": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, new Option$Some$41$($64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Thiscall), -1, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "regparm": {
          if (!has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, name_tok.loc, "expected '(' after regparm");
          } else {
            const _bind$4 = p.current.kind;
            let raw;
            if (_bind$4 === 3) {
              const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
              let parsed;
              let _try_err;
              _L: {
                _L$2: {
                  const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok);
                  const _bind$6 = moonbitlang$core$strconv$$parse_int$46$inner({ str: _bind$5, start: 0, end: _bind$5.length }, 0);
                  if (_bind$6.$tag === 1) {
                    const _ok = _bind$6;
                    parsed = _ok._0;
                  } else {
                    const _err = _bind$6;
                    const _tmp$27 = _err._0;
                    _try_err = _tmp$27;
                    break _L$2;
                  }
                  break _L;
                }
                parsed = 0;
              }
              hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after regparm");
              raw = parsed;
            } else {
              hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
              raw = 0;
            }
            let count = raw;
            if (count < 0) {
              count = 0;
            } else {
              if (count > 3) {
                count = 3;
              }
            }
            if (count > 0) {
              attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, new Option$Some$41$(new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Regparm(count)), -1, -1, -1, -1));
            }
          }
          break;
        }
        case "dllimport": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16814, -1, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "dllexport": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16815, -1, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "nodecorate": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16816, -1));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        case "nodebug": {
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause$46$constr$47$16817));
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
          break;
        }
        default: {
          if (has_args) {
            hackwaly$tinycc$frontend$parser$parser_core$$skip_paren_group(p);
          }
        }
      }
      const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
      if (_bind$4 === undefined) {
      } else {
        continue;
      }
      break;
    } else {
      break;
    }
  }
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after attribute list");
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after attribute");
  return attrs;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_decl_specs$46$inner(p, allow_storage) {
  return hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers(p, allow_storage, true);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers(p, allow_storage, allow_typedef) {
  let is_typedef = false;
  let storage = 0;
  let is_inline = false;
  let saw_any = false;
  let start_loc = p.current.loc;
  let qual = hackwaly$tinycc$frontend$ast$$empty_qual();
  let attrs = hackwaly$tinycc$frontend$ast$$empty_attrs();
  let signedness = 0;
  let short_seen = false;
  let long_count = 0;
  let saw_char = false;
  let saw_int = false;
  let saw_bool = false;
  let saw_float = false;
  let saw_double = false;
  let saw_void = false;
  let base = undefined;
  _L: while (true) {
    const tok = p.current;
    let kind = tok.kind;
    const _bind = kind;
    if (_bind === 2) {
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$special_ident_kind(tok, p.pp.keyword_ids);
      if (_bind$2 === undefined) {
      } else {
        const _Some = _bind$2;
        const _mapped = _Some;
        kind = _mapped;
      }
    }
    _L$2: {
      _L$3: {
        const _bind$2 = kind;
        switch (_bind$2) {
          case 41: {
            if (allow_typedef) {
              if (is_typedef || moonbitlang$core$builtin$$Eq$not_equal$78$(storage, 0)) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple storage classes");
              }
              is_typedef = true;
            } else {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "unexpected typedef");
            }
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 19: {
            break _L$3;
          }
          case 20: {
            break _L$3;
          }
          case 26: {
            break _L$3;
          }
          case 25: {
            break _L$3;
          }
          case 27: {
            break _L$3;
          }
          case 28: {
            attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, Option$None$40$, Option$None$40$, hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16851, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 30: {
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
            if (_bind$3 === undefined) {
              qual = hackwaly$tinycc$frontend$ast$$with_atomic(qual);
            } else {
              const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
              if (_bind$4 === undefined) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "expected type name in _Atomic");
                return undefined;
              } else {
                const _Some = _bind$4;
                const _ty = _Some;
                hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after _Atomic type");
                const _bind$5 = base;
                if (_bind$5 === undefined) {
                  base = _ty;
                  start_loc = tok.loc;
                } else {
                  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple type specifiers");
                }
                qual = hackwaly$tinycc$frontend$ast$$with_atomic(qual);
              }
            }
            continue _L;
          }
          case 23: {
            qual = hackwaly$tinycc$frontend$ast$$with_const(qual);
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 24: {
            qual = hackwaly$tinycc$frontend$ast$$with_volatile(qual);
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 29: {
            qual = hackwaly$tinycc$frontend$ast$$with_restrict(qual);
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 46: {
            const clause = hackwaly$tinycc$frontend$parser$parser_core$$parse_attribute_clause(p, tok.loc);
            attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, clause);
            continue _L;
          }
          case 22: {
            if (signedness === 2) {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "signed/unsigned conflict");
            } else {
              signedness = 1;
            }
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 21: {
            if (signedness === 1) {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "signed/unsigned conflict");
            } else {
              signedness = 2;
            }
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 37: {
            short_seen = true;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 38: {
            long_count = long_count + 1 | 0;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 33: {
            saw_int = true;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 32: {
            saw_char = true;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 36: {
            saw_bool = true;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 34: {
            saw_float = true;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 35: {
            saw_double = true;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 31: {
            saw_void = true;
            hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
            saw_any = true;
            continue _L;
          }
          case 39: {
            const _bind$4 = base;
            if (_bind$4 === undefined) {
              const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$parse_struct_type(p, false);
              if (_bind$5 === undefined) {
                return undefined;
              } else {
                const _Some = _bind$5;
                const _x = _Some;
                const _ty = _x._0;
                const _loc = _x._1;
                base = _ty;
                start_loc = _loc;
                saw_any = true;
                continue _L;
              }
            } else {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple type specifiers");
              break _L;
            }
          }
          case 40: {
            const _bind$5 = base;
            if (_bind$5 === undefined) {
              const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$parse_struct_type(p, true);
              if (_bind$6 === undefined) {
                return undefined;
              } else {
                const _Some = _bind$6;
                const _x = _Some;
                const _ty = _x._0;
                const _loc = _x._1;
                base = _ty;
                start_loc = _loc;
                saw_any = true;
                continue _L;
              }
            } else {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple type specifiers");
              break _L;
            }
          }
          case 42: {
            const _bind$6 = base;
            if (_bind$6 === undefined) {
              const _bind$7 = hackwaly$tinycc$frontend$parser$parser_core$$parse_enum_type(p);
              if (_bind$7 === undefined) {
                return undefined;
              } else {
                const _Some = _bind$7;
                const _x = _Some;
                const _ty = _x._0;
                const _loc = _x._1;
                base = _ty;
                start_loc = _loc;
                saw_any = true;
                continue _L;
              }
            } else {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple type specifiers");
              break _L;
            }
          }
          case 45: {
            const _bind$7 = base;
            if (_bind$7 === undefined) {
              const _bind$8 = hackwaly$tinycc$frontend$parser$parser_core$$parse_typeof_spec(p, tok.loc);
              if (_bind$8 === undefined) {
                return undefined;
              } else {
                const _Some = _bind$8;
                const _ty = _Some;
                base = _ty;
                start_loc = tok.loc;
                saw_any = true;
                continue _L;
              }
            } else {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple type specifiers");
              hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
              continue _L;
            }
          }
          case 2: {
            const _bind$8 = hackwaly$tinycc$frontend$parser$parser_core$$lookup_typedef(p, tok);
            if (_bind$8 === undefined) {
            } else {
              const _Some = _bind$8;
              const _aliased = _Some;
              _L$4: {
                const _bind$9 = base;
                if (_bind$9 === undefined) {
                  if (saw_void) {
                    break _L$4;
                  } else {
                    if (saw_bool) {
                      break _L$4;
                    } else {
                      if (saw_float) {
                        break _L$4;
                      } else {
                        if (saw_double) {
                          break _L$4;
                        } else {
                          if (saw_char) {
                            break _L$4;
                          } else {
                            if (saw_int) {
                              break _L$4;
                            } else {
                              if (short_seen) {
                                break _L$4;
                              } else {
                                if (long_count > 0) {
                                  break _L$4;
                                } else {
                                  if (signedness !== 0) {
                                    break _L$4;
                                  } else {
                                    hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
                                    base = _aliased;
                                    start_loc = tok.loc;
                                    saw_any = true;
                                    continue _L;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  break _L$4;
                }
              }
              break _L;
            }
            break;
          }
        }
        break _L$2;
      }
      if (allow_storage) {
        const _bind$2 = kind;
        switch (_bind$2) {
          case 27: {
            is_inline = true;
            break;
          }
          case 19: {
            if (moonbitlang$core$builtin$$Eq$not_equal$78$(storage, 0) || is_typedef) {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple storage classes");
            }
            storage = 1;
            break;
          }
          case 20: {
            if (moonbitlang$core$builtin$$Eq$not_equal$78$(storage, 0) || is_typedef) {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple storage classes");
            }
            storage = 2;
            break;
          }
          case 26: {
            if (moonbitlang$core$builtin$$Eq$not_equal$78$(storage, 0) || is_typedef) {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple storage classes");
            }
            storage = 3;
            break;
          }
          case 25: {
            if (moonbitlang$core$builtin$$Eq$not_equal$78$(storage, 0) || is_typedef) {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "multiple storage classes");
            }
            storage = 4;
            break;
          }
        }
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        saw_any = true;
        continue;
      } else {
        hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, tok.loc, "storage class not allowed here");
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        saw_any = true;
        continue;
      }
    }
    break;
  }
  if (!saw_any) {
    return undefined;
  }
  const invalid_combo = saw_void || (saw_bool || (saw_float || (saw_double || (saw_char || (saw_int || (short_seen || (long_count > 0 || signedness !== 0)))))));
  const _bind = base;
  if (_bind === undefined) {
  } else {
    if (invalid_combo) {
      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, start_loc, "invalid type specifier combination");
    }
  }
  const _bind$2 = base;
  let ty;
  if (_bind$2 === undefined) {
    if (saw_void) {
      ty = $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void;
    } else {
      if (saw_bool) {
        ty = $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Bool;
      } else {
        if (saw_float || saw_double) {
          if (long_count > 0 && saw_double) {
            ty = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16852;
          } else {
            if (saw_double) {
              ty = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16853;
            } else {
              if (long_count > 0) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, start_loc, "invalid long float");
                ty = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16854;
              } else {
                ty = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers$46$constr$47$16855;
              }
            }
          }
        } else {
          const kind = saw_char ? 0 : short_seen ? 1 : long_count >= 2 ? 4 : long_count === 1 ? 3 : 2;
          const unsigned = moonbitlang$core$builtin$$Eq$equal$180$(kind, 0) && signedness === 0 ? hackwaly$tinycc$support$util$$char_is_unsigned : signedness === 2;
          ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Int(kind, unsigned);
        }
      }
    }
  } else {
    const _Some = _bind$2;
    ty = _Some;
  }
  if (ty.$tag === 0) {
    _L$2: {
      _L$3: {
        if (signedness !== 0) {
          break _L$3;
        } else {
          if (short_seen) {
            break _L$3;
          } else {
            if (long_count > 0) {
              break _L$3;
            }
          }
        }
        break _L$2;
      }
      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, start_loc, "invalid modifiers for void");
    }
  }
  if (ty.$tag === 1) {
    if (signedness !== 0) {
      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, start_loc, "invalid modifiers for _Bool");
    }
  }
  const qualified = hackwaly$tinycc$frontend$ast$$apply_qualifiers(ty, qual);
  const final_ty = hackwaly$tinycc$frontend$ast$$apply_type_attrs(qualified, hackwaly$tinycc$frontend$ast$$type_attrs_from(attrs));
  return { ty: final_ty, loc: start_loc, is_typedef: is_typedef, storage: storage, is_inline: is_inline, attrs: attrs };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_enum_type(p) {
  const kw = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  let name = "";
  let id = 0;
  const _bind = p.current.kind;
  if (_bind === 2) {
    const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    name = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok);
    id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
  }
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 51);
  if (_bind$2 === undefined) {
  } else {
    const items = hackwaly$tinycc$frontend$parser$parser_core$$parse_enum_items(p);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 52, "expected '}' after enum");
    if (name === "") {
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$next_anon_tag(p);
      const _anon_name = _bind$3._0;
      const _anon_id = _bind$3._1;
      name = _anon_name;
      id = _anon_id;
    }
    return { _0: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Enum(name, id, new Option$Some$22$(items)), _1: kw.loc };
  }
  if (name === "") {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, kw.loc, "expected enum name or '{'");
    return undefined;
  }
  return { _0: new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Enum(name, id, Option$None$22$), _1: kw.loc };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_enum_items(p) {
  const items = [];
  const _bind = p.current.kind;
  if (_bind === 52) {
    return items;
  }
  while (true) {
    const name_tok = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected enumerator name");
    if (name_tok === undefined) {
    } else {
      const _Some = name_tok;
      const _tok = _Some;
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 62);
      const value = _bind$2 === undefined ? undefined : hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
      moonbitlang$core$array$$Array$push$114$(items, { name: hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok), id: hackwaly$tinycc$frontend$tokens$$token_id(_tok), value: value, loc: _tok.loc });
    }
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
    if (_bind$2 === undefined) {
    } else {
      const _bind$3 = p.current.kind;
      if (_bind$3 === 52) {
        break;
      }
      continue;
    }
    break;
  }
  return items;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_struct_type(p, is_union) {
  const kw = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  let attrs = hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p);
  let name = "";
  let id = 0;
  const _bind = p.current.kind;
  if (_bind === 2) {
    const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    name = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok);
    id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
  }
  attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 51);
  if (_bind$2 === undefined) {
  } else {
    const fields = hackwaly$tinycc$frontend$parser$parser_core$$parse_struct_fields(p);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 52, "expected '}' after fields");
    attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
    if (name === "") {
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$next_anon_tag(p);
      const _anon_name = _bind$3._0;
      const _anon_id = _bind$3._1;
      name = _anon_name;
      id = _anon_id;
    }
    const ty = is_union ? new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Union(name, id, new Option$Some$37$(fields), attrs) : new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Struct(name, id, new Option$Some$37$(fields), attrs);
    return { _0: ty, _1: kw.loc };
  }
  if (name === "") {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, kw.loc, "expected tag name or '{'");
    return undefined;
  }
  const ty = is_union ? new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Union(name, id, Option$None$37$, attrs) : new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Struct(name, id, Option$None$37$, attrs);
  return { _0: ty, _1: kw.loc };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_struct_fields(p) {
  const items = [];
  while (true) {
    if (!hackwaly$tinycc$frontend$parser$parser_core$$is_at_end(p) && moonbitlang$core$builtin$$Eq$not_equal$84$(p.current.kind, 52)) {
      const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 47);
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _assert_tok = _Some;
        const static_assert = hackwaly$tinycc$frontend$parser$parser_core$$parse_static_assert(p, _assert_tok.loc);
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after _Static_assert");
        moonbitlang$core$array$$Array$push$113$(items, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$RecordItem$StaticAssert(static_assert));
        continue;
      }
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_decl_specs$46$inner(p, false);
      if (_bind$2 === undefined) {
        hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p);
        break;
      } else {
        const _Some = _bind$2;
        const _specs = _Some;
        const base = hackwaly$tinycc$frontend$ast$$apply_type_attrs(_specs.ty, hackwaly$tinycc$frontend$ast$$type_attrs_from(_specs.attrs));
        const loc = _specs.loc;
        const is_typedef = _specs.is_typedef;
        if (is_typedef) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "typedef not allowed in struct field");
        }
        let any_field = false;
        while (true) {
          const _bind$3 = p.current.kind;
          let decl;
          if (_bind$3 === 57) {
            decl = { name: "", id: 0, ty: base, params: Option$None$42$, varargs: false, is_old_style: false, attrs: hackwaly$tinycc$frontend$ast$$empty_attrs(), loc: loc };
          } else {
            decl = hackwaly$tinycc$frontend$parser$parser_core$$parse_field_declarator(p, base, loc);
          }
          const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 57);
          const bit_width = _bind$4 === undefined ? undefined : hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
          if (decl === undefined) {
          } else {
            const _Some$2 = decl;
            const _field_decl = _Some$2;
            const stripped = hackwaly$tinycc$frontend$parser$parser_core$$strip_type_qualifiers(_field_decl.ty);
            let allow_anon;
            if (_field_decl.name === "") {
              let _tmp$27;
              if (bit_width === undefined) {
                if (stripped.$tag === 6) {
                  _tmp$27 = true;
                } else {
                  if (stripped.$tag === 7) {
                    _tmp$27 = true;
                  } else {
                    _tmp$27 = false;
                  }
                }
              } else {
                _tmp$27 = false;
              }
              allow_anon = _tmp$27;
            } else {
              allow_anon = false;
            }
            _L: {
              _L$2: {
                const _p$28 = _field_decl.name;
                const _p$29 = "";
                if (!(_p$28 === _p$29)) {
                  break _L$2;
                } else {
                  if (bit_width === undefined) {
                    if (allow_anon) {
                      break _L$2;
                    } else {
                      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected field declarator");
                    }
                  } else {
                    break _L$2;
                  }
                }
                break _L;
              }
              any_field = true;
              const combined_attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(_specs.attrs, _field_decl.attrs);
              const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_field_decl.ty, hackwaly$tinycc$frontend$ast$$normalize_call_conv(combined_attrs.call_conv));
              moonbitlang$core$array$$Array$push$113$(items, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$RecordItem$Field({ name: _field_decl.name, id: _field_decl.id, ty: adjusted_ty, bit_width: bit_width, attrs: combined_attrs, loc: _field_decl.loc }));
            }
          }
          const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
          if (_bind$5 === undefined) {
          } else {
            continue;
          }
          break;
        }
        if (!any_field) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected field declarator");
        }
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after struct field");
      }
      continue;
    } else {
      break;
    }
  }
  return items;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_field_declarator(p, base, fallback_loc) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_pointer_chain(p, base);
  const _ty0 = _bind._0;
  const _pointer_attrs = _bind._1;
  let attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(_pointer_attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  const _p$28 = 0;
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind;
  if (_bind$2 === 49) {
    const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_declarator(p, _ty0);
    if (_bind$3 === undefined) {
      return undefined;
    } else {
      const _Some = _bind$3;
      const _decl = _Some;
      return { name: _decl.name, id: _decl.id, ty: _decl.ty, params: _decl.params, varargs: _decl.varargs, is_old_style: _decl.is_old_style, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _decl.attrs), loc: _decl.loc };
    }
  } else {
    let name;
    let id;
    let loc;
    _L: {
      const _bind$3 = p.current.kind;
      if (_bind$3 === 2) {
        const name_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const _tmp$27 = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, name_tok);
        const _tmp$28 = hackwaly$tinycc$frontend$tokens$$token_id(name_tok);
        const _tmp$29 = name_tok.loc;
        name = _tmp$27;
        id = _tmp$28;
        loc = _tmp$29;
        break _L;
      } else {
        name = "";
        id = 0;
        loc = fallback_loc;
        break _L;
      }
    }
    const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator_suffix(p, _ty0);
    const _ty = _bind$3._0;
    const _params = _bind$3._1;
    const _varargs = _bind$3._2;
    const _is_old_style = _bind$3._3;
    const _suffix_attrs = _bind$3._4;
    attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _suffix_attrs);
    return { name: name, id: id, ty: _ty, params: _params, varargs: _varargs, is_old_style: _is_old_style, attrs: attrs, loc: loc };
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator_suffix(p, ty_in) {
  let ty = ty_in;
  let varargs = false;
  let old_style = false;
  let attrs = hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p);
  const array_sizes = [];
  while (true) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 53);
    if (_bind === undefined) {
      break;
    } else {
      const size = hackwaly$tinycc$frontend$parser$parser_core$$parse_array_size(p);
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 54, "expected ']' after array size");
      moonbitlang$core$array$$Array$push$70$(array_sizes, size);
      continue;
    }
  }
  let i = array_sizes.length;
  while (true) {
    if (i > 0) {
      i = i - 1 | 0;
      const _bind = moonbitlang$core$array$$Array$at$70$(array_sizes, i);
      const _size = _bind._0;
      const _size_expr = _bind._1;
      ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Array(ty, _size, _size_expr);
      continue;
    } else {
      break;
    }
  }
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
  let params;
  if (_bind === undefined) {
    params = Option$None$42$;
  } else {
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_param_list(p);
    const _params = _bind$2._0;
    const _has_varargs = _bind$2._1;
    const _is_old_style = _bind$2._2;
    varargs = _has_varargs;
    old_style = _is_old_style;
    const _p$28 = new Array(_params.length);
    const _p$29 = _params.length;
    let _tmp$27 = 0;
    while (true) {
      const _p$30 = _tmp$27;
      if (_p$30 < _p$29) {
        const _p$31 = _params[_p$30];
        _p$28[_p$30] = _p$31.ty;
        _tmp$27 = _p$30 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const param_types = _p$28;
    ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Function(ty, param_types, varargs, old_style, $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CallConv$Default);
    params = new Option$Some$42$(_params);
  }
  attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
  ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(ty, call_conv);
  return { _0: ty, _1: params, _2: varargs, _3: old_style, _4: attrs };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_array_size(p) {
  const _bind = p.current.kind;
  if (_bind === 54) {
    return { _0: undefined, _1: undefined };
  }
  const _bind$2 = p.current.kind;
  if (_bind$2 === 20) {
    hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  }
  const loc = p.current.loc;
  const _bind$3 = p.current.kind;
  if (_bind$3 === 3) {
    const _p$28 = 1;
    const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind;
    if (_bind$4 === 54) {
      const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      const text = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok);
      const _bind$5 = hackwaly$tinycc$frontend$ast$$parse_int64_literal(text);
      if (_bind$5 === undefined) {
        const expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit(text, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
        return { _0: undefined, _1: expr };
      } else {
        const _Some = _bind$5;
        const _v = _Some;
        if (moonbitlang$core$builtin$$Compare$op_lt$81$(_v, $0L)) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "invalid array size");
          const expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$IntLit(text, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
          return { _0: undefined, _1: expr };
        } else {
          return { _0: moonbitlang$core$int64$$Int64$to_int(_v), _1: undefined };
        }
      }
    }
  }
  const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
  const _bind$4 = hackwaly$tinycc$frontend$ast$$const_i64_from_expr(expr);
  let size;
  if (_bind$4 === undefined) {
    size = undefined;
  } else {
    const _Some = _bind$4;
    const _v = _Some;
    if (moonbitlang$core$builtin$$Compare$op_lt$81$(_v, $0L)) {
      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "invalid array size");
      size = undefined;
    } else {
      size = moonbitlang$core$int64$$Int64$to_int(_v);
    }
  }
  return { _0: size, _1: expr };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_param_list(p) {
  const params = [];
  let varargs = false;
  let old_style = false;
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 50);
  if (_bind === undefined) {
  } else {
    old_style = true;
    return { _0: params, _1: varargs, _2: old_style };
  }
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 60);
  if (_bind$2 === undefined) {
  } else {
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after '...'");
    return { _0: params, _1: true, _2: false };
  }
  const first = p.current;
  const _bind$3 = first.kind;
  let first_mapped;
  if (_bind$3 === 2) {
    first_mapped = hackwaly$tinycc$frontend$parser$parser_core$$special_ident_kind(first, p.pp.keyword_ids);
  } else {
    first_mapped = undefined;
  }
  const _bind$4 = first.kind;
  if (_bind$4 === 2) {
    if (first_mapped === undefined) {
      if (!hackwaly$tinycc$frontend$parser$parser_core$$has_typedef(p, first)) {
        old_style = true;
        while (true) {
          const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected parameter name");
          if (_bind$5 === undefined) {
            break;
          } else {
            const _Some = _bind$5;
            const _tok = _Some;
            moonbitlang$core$array$$Array$push$28$(params, { name: hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok), id: hackwaly$tinycc$frontend$tokens$$token_id(_tok), ty: hackwaly$tinycc$frontend$parser$parser_core$$parse_param_list$46$constr$47$17058, loc: _tok.loc });
          }
          const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
          if (_bind$6 === undefined) {
          } else {
            continue;
          }
          break;
        }
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after parameter list");
        return { _0: params, _1: varargs, _2: old_style };
      }
    }
  }
  const _bind$5 = p.current.kind;
  if (_bind$5 === 31) {
    const void_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 50);
    if (_bind$6 === undefined) {
    } else {
      return { _0: params, _1: varargs, _2: false };
    }
    const _bind$7 = hackwaly$tinycc$frontend$parser$parser_core$$parse_param_after_base(p, $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Void, hackwaly$tinycc$frontend$ast$$empty_attrs(), void_tok.loc);
    if (_bind$7 === undefined) {
    } else {
      const _Some = _bind$7;
      const _param = _Some;
      moonbitlang$core$array$$Array$push$28$(params, _param);
    }
  } else {
    const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers(p, false, false);
    if (_bind$6 === undefined) {
    } else {
      const _Some = _bind$6;
      const _specs = _Some;
      const _bind$7 = hackwaly$tinycc$frontend$parser$parser_core$$parse_param_after_base(p, _specs.ty, _specs.attrs, _specs.loc);
      if (_bind$7 === undefined) {
      } else {
        const _Some$2 = _bind$7;
        const _param = _Some$2;
        moonbitlang$core$array$$Array$push$28$(params, _param);
      }
    }
  }
  while (true) {
    const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
    if (_bind$6 === undefined) {
    } else {
      const _bind$7 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 60);
      if (_bind$7 === undefined) {
      } else {
        varargs = true;
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after '...'");
        break;
      }
      const _bind$8 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers(p, false, false);
      if (_bind$8 === undefined) {
      } else {
        const _Some = _bind$8;
        const _specs = _Some;
        const _bind$9 = hackwaly$tinycc$frontend$parser$parser_core$$parse_param_after_base(p, _specs.ty, _specs.attrs, _specs.loc);
        if (_bind$9 === undefined) {
        } else {
          const _Some$2 = _bind$9;
          const _param = _Some$2;
          moonbitlang$core$array$$Array$push$28$(params, _param);
        }
      }
      continue;
    }
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after parameter list");
    break;
  }
  return { _0: params, _1: varargs, _2: old_style };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_param_after_base(p, base, attrs, loc) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_param_declarator(p, base, loc);
  if (_bind === undefined) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected parameter declarator");
    return undefined;
  } else {
    const _Some = _bind;
    const _param = _Some;
    const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
    const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_param.ty, call_conv);
    return { name: _param.name, id: _param.id, ty: adjusted_ty, loc: _param.loc };
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_param_declarator(p, base, fallback_loc) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_pointer_chain(p, base);
  const _ty0 = _bind._0;
  const _pointer_attrs = _bind._1;
  let attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(_pointer_attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  if (hackwaly$tinycc$frontend$parser$parser_core$$is_paren_pointer_declarator(p)) {
    const parts = hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_parts(p, true, fallback_loc);
    let parts$2;
    if (parts === undefined) {
      return undefined;
    } else {
      const _Some = parts;
      parts$2 = _Some;
    }
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_suffix_wrappers(p);
    const _outer_wrappers = _bind$2._0;
    const _suffix_attrs = _bind$2._4;
    const wrappers = parts$2.wrappers;
    const _len = _outer_wrappers.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const wrap = _outer_wrappers[_i];
        moonbitlang$core$array$$Array$push$76$(wrappers, wrap);
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, parts$2.attrs);
    attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _suffix_attrs);
    let ty = hackwaly$tinycc$frontend$parser$parser_core$$apply_decl_wrappers(_ty0, wrappers);
    const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
    ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(ty, call_conv);
    return { name: parts$2.name, id: parts$2.id, ty: ty, loc: parts$2.loc };
  }
  const _bind$2 = p.current.kind;
  if (_bind$2 === 2) {
    const name_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator_suffix(p, _ty0);
    const _ty = _bind$3._0;
    const _suffix_attrs = _bind$3._4;
    attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _suffix_attrs);
    const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
    const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_ty, call_conv);
    return { name: hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, name_tok), id: hackwaly$tinycc$frontend$tokens$$token_id(name_tok), ty: adjusted_ty, loc: name_tok.loc };
  }
  const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator_suffix(p, _ty0);
  const _ty = _bind$3._0;
  const _suffix_attrs = _bind$3._4;
  attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _suffix_attrs);
  const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
  const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_ty, call_conv);
  return { name: "", id: 0, ty: adjusted_ty, loc: fallback_loc };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_parts(p, allow_missing_name, fallback_loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' in declarator");
  const quals = [];
  let attrs = hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p);
  while (true) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 65);
    if (_bind === undefined) {
      break;
    } else {
      moonbitlang$core$array$$Array$push$75$(quals, hackwaly$tinycc$frontend$parser$parser_core$$parse_type_qualifiers(p));
      attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
      continue;
    }
  }
  attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  let name = "";
  let id = 0;
  let loc = fallback_loc;
  let nested_wrappers = [];
  let nested_attrs = hackwaly$tinycc$frontend$ast$$empty_attrs();
  const _p$28 = 0;
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind;
  if (_bind === 49) {
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_parts(p, allow_missing_name, fallback_loc);
    if (_bind$2 === undefined) {
      return undefined;
    } else {
      const _Some = _bind$2;
      const _parts = _Some;
      name = _parts.name;
      id = _parts.id;
      loc = _parts.loc;
      nested_wrappers = _parts.wrappers;
      nested_attrs = _parts.attrs;
    }
  } else {
    const _bind$2 = p.current.kind;
    if (_bind$2 === 2) {
      const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      name = hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, tok);
      id = hackwaly$tinycc$frontend$tokens$$token_id(tok);
      loc = tok.loc;
    } else {
      if (allow_missing_name) {
        name = "";
        id = 0;
        loc = fallback_loc;
      } else {
        hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected identifier");
        return undefined;
      }
    }
  }
  attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_inner_suffix_wrappers(p);
  const _inner_wrappers = _bind$2._0;
  const _params = _bind$2._1;
  const _varargs = _bind$2._2;
  const _is_old_style = _bind$2._3;
  attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' in declarator");
  const wrappers = nested_wrappers;
  const _len = _inner_wrappers.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const wrap = _inner_wrappers[_i];
      moonbitlang$core$array$$Array$push$76$(wrappers, wrap);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let i = quals.length;
  while (true) {
    if (i > 0) {
      i = i - 1 | 0;
      moonbitlang$core$array$$Array$push$76$(wrappers, new $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Pointer(moonbitlang$core$array$$Array$at$75$(quals, i)));
      continue;
    } else {
      break;
    }
  }
  const combined_attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, nested_attrs);
  return { name: name, id: id, loc: loc, wrappers: wrappers, params: _params, varargs: _varargs, is_old_style: _is_old_style, attrs: combined_attrs };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_inner_suffix_wrappers(p) {
  const wrappers = [];
  while (true) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 53);
    if (_bind === undefined) {
      break;
    } else {
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_array_size(p);
      const _size = _bind$2._0;
      const _size_expr = _bind$2._1;
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 54, "expected ']' after array size");
      moonbitlang$core$array$$Array$push$76$(wrappers, new $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Array(_size, _size_expr));
      continue;
    }
  }
  let params = Option$None$42$;
  let varargs = false;
  let old_style = false;
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
  if (_bind === undefined) {
  } else {
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_param_list(p);
    const _list = _bind$2._0;
    const _has_varargs = _bind$2._1;
    const _is_old_style = _bind$2._2;
    params = new Option$Some$42$(_list);
    varargs = _has_varargs;
    old_style = _is_old_style;
    moonbitlang$core$array$$Array$push$76$(wrappers, new $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Function(_list, varargs, old_style));
  }
  return { _0: wrappers, _1: params, _2: varargs, _3: old_style };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_pointer_chain(p, ty_in) {
  let ty = ty_in;
  let attrs = hackwaly$tinycc$frontend$ast$$empty_attrs();
  while (true) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 65);
    if (_bind === undefined) {
      break;
    } else {
      const qual = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_qualifiers(p);
      const pointer_attrs = hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p);
      attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, pointer_attrs);
      ty = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$Pointer(ty);
      ty = hackwaly$tinycc$frontend$ast$$apply_qualifiers(ty, qual);
      continue;
    }
  }
  return { _0: ty, _1: attrs };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_suffix_wrappers(p) {
  let attrs = hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p);
  const wrappers = [];
  while (true) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 53);
    if (_bind === undefined) {
      break;
    } else {
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_array_size(p);
      const _size = _bind$2._0;
      const _size_expr = _bind$2._1;
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 54, "expected ']' after array size");
      moonbitlang$core$array$$Array$push$76$(wrappers, new $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Array(_size, _size_expr));
      continue;
    }
  }
  let params = Option$None$42$;
  let varargs = false;
  let old_style = false;
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
  if (_bind === undefined) {
  } else {
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_param_list(p);
    const _list = _bind$2._0;
    const _has_varargs = _bind$2._1;
    const _is_old_style = _bind$2._2;
    params = new Option$Some$42$(_list);
    varargs = _has_varargs;
    old_style = _is_old_style;
    moonbitlang$core$array$$Array$push$76$(wrappers, new $64$hackwaly$47$tinycc$47$frontend$47$parser$47$parser_core$46$DeclWrapper$Function(_list, varargs, old_style));
  }
  attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  return { _0: wrappers, _1: params, _2: varargs, _3: old_style, _4: attrs };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_declarator(p, base) {
  const fallback_loc = p.current.loc;
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_parts(p, false, fallback_loc);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _parts = _Some;
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_suffix_wrappers(p);
    const _outer_wrappers = _bind$2._0;
    const _suffix_attrs = _bind$2._4;
    const wrappers = _parts.wrappers;
    const _len = _outer_wrappers.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const wrap = _outer_wrappers[_i];
        moonbitlang$core$array$$Array$push$76$(wrappers, wrap);
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    let attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(_parts.attrs, _suffix_attrs);
    const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 48);
    if (_bind$3 === undefined) {
    } else {
      const _Some$2 = _bind$3;
      const _asm_tok = _Some$2;
      const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_label(p, _asm_tok.loc);
      if (_bind$4 === undefined) {
      } else {
        const _Some$3 = _bind$4;
        const _label = _Some$3;
        attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, new Option$Some$40$(_label), Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
      }
      attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
    }
    let ty = hackwaly$tinycc$frontend$parser$parser_core$$apply_decl_wrappers(base, wrappers);
    const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
    ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(ty, call_conv);
    return { name: _parts.name, id: _parts.id, ty: ty, params: _parts.params, varargs: _parts.varargs, is_old_style: _parts.is_old_style, attrs: attrs, loc: _parts.loc };
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_static_assert(p, loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after _Static_assert");
  const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
  let message = undefined;
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
  if (_bind === undefined) {
  } else {
    message = hackwaly$tinycc$frontend$parser$parser_core$$parse_attr_string(p, loc);
  }
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after _Static_assert");
  return { expr: expr, message: message, loc: loc };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_specifiers(p, false, false);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _specs = _Some;
    const base = _specs.ty;
    const base_attrs = _specs.attrs;
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_pointer_chain(p, base);
    const _ty0 = _bind$2._0;
    const _pointer_attrs = _bind$2._1;
    let attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(base_attrs, _pointer_attrs);
    attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
    if (hackwaly$tinycc$frontend$parser$parser_core$$is_paren_pointer_declarator(p)) {
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_abstract(p, _ty0);
      const _ty = _bind$3._0;
      const _paren_attrs = _bind$3._1;
      attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _paren_attrs);
      const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
      return hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_ty, call_conv);
    } else {
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator_suffix(p, _ty0);
      const _full = _bind$3._0;
      const _suffix_attrs = _bind$3._4;
      attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _suffix_attrs);
      const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
      return hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_full, call_conv);
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_abstract(p, base) {
  const fallback_loc = p.current.loc;
  const parts = hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_parts(p, true, fallback_loc);
  let parts$2;
  if (parts === undefined) {
    return { _0: base, _1: hackwaly$tinycc$frontend$ast$$empty_attrs() };
  } else {
    const _Some = parts;
    parts$2 = _Some;
  }
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_suffix_wrappers(p);
  const _outer_wrappers = _bind._0;
  const _suffix_attrs = _bind._4;
  const wrappers = parts$2.wrappers;
  const _len = _outer_wrappers.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const wrap = _outer_wrappers[_i];
      moonbitlang$core$array$$Array$push$76$(wrappers, wrap);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(parts$2.attrs, _suffix_attrs);
  let ty = hackwaly$tinycc$frontend$parser$parser_core$$apply_decl_wrappers(base, wrappers);
  const call_conv = hackwaly$tinycc$frontend$ast$$normalize_call_conv(attrs.call_conv);
  ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(ty, call_conv);
  return { _0: ty, _1: attrs };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_typeof_spec(p, loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 49);
  if (_bind === undefined) {
    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected '(' after typeof");
    return undefined;
  }
  if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_spec_start(p)) {
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_type_name(p);
    if (_bind$2 === undefined) {
      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, loc, "expected type name in typeof");
      return undefined;
    } else {
      const _Some = _bind$2;
      const _ty = _Some;
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after typeof type");
      return _ty;
    }
  }
  const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after typeof expression");
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$CType$TypeofExpr(expr);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_do_while_stmt(p, loc) {
  const body = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 9, "expected while after do");
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after while");
  const cond = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after do-while condition");
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after do-while");
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$DoWhile(cond, body, loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_for_stmt(p, loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after for");
  moonbitlang$core$array$$Array$push$67$(p.pending_typedef_scopes, false);
  const init = hackwaly$tinycc$frontend$parser$parser_core$$parse_for_init(p);
  let did_scope = false;
  const scope_idx = p.pending_typedef_scopes.length - 1 | 0;
  if (moonbitlang$core$array$$Array$at$67$(p.pending_typedef_scopes, scope_idx)) {
    did_scope = true;
  } else {
    moonbitlang$core$array$$Array$pop$67$(p.pending_typedef_scopes);
  }
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 56);
  let cond;
  if (_bind === undefined) {
    const cond_expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after for condition");
    cond = cond_expr;
  } else {
    cond = undefined;
  }
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 50);
  let step;
  if (_bind$2 === undefined) {
    const step_expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after for step");
    step = step_expr;
  } else {
    step = undefined;
  }
  const body = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
  if (did_scope) {
    const _p$28 = moonbitlang$core$array$$Array$pop$67$(p.pending_typedef_scopes);
    const _p$29 = false;
    const opened = _p$28 === -1 ? _p$29 : _p$28;
    if (opened) {
      hackwaly$tinycc$frontend$parser$parser_core$$pop_typedef_scope(p);
    }
  }
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$For(init, cond, step, body, loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_for_init(p) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 56);
  if (_bind === undefined) {
  } else {
    return undefined;
  }
  if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, p.current)) {
    hackwaly$tinycc$frontend$parser$parser_core$$ensure_typedef_scope(p);
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_decl_specs$46$inner(p, true);
    if (_bind$2 === undefined) {
      hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p);
      return undefined;
    } else {
      const _Some = _bind$2;
      const _specs = _Some;
      const base = _specs.ty;
      const is_typedef = _specs.is_typedef;
      const storage = _specs.storage;
      const is_inline = _specs.is_inline;
      const base_attrs = _specs.attrs;
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 56);
      if (_bind$3 === undefined) {
        const decls = moonbitlang$core$array$$Array$new$46$inner$99$(4);
        let decl_loc = p.current.loc;
        let saw_decl = false;
        while (true) {
          const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$parse_init_declarator(p, base);
          if (_bind$4 === undefined) {
            hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p);
            return undefined;
          } else {
            const _Some$2 = _bind$4;
            const _x = _Some$2;
            const _decl = _x._0;
            const _init = _x._1;
            if (!saw_decl) {
              decl_loc = _decl.loc;
              saw_decl = true;
            }
            const combined_attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(base_attrs, _decl.attrs);
            const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_decl.ty, hackwaly$tinycc$frontend$ast$$normalize_call_conv(combined_attrs.call_conv));
            if (is_typedef) {
              if (_init === undefined) {
              } else {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "typedef cannot have initializer");
              }
              const typedef_ty = hackwaly$tinycc$frontend$ast$$apply_type_attrs(adjusted_ty, hackwaly$tinycc$frontend$ast$$type_attrs_from(combined_attrs));
              hackwaly$tinycc$frontend$parser$parser_core$$define_typedef(p, _decl.name, typedef_ty);
            } else {
              let actual_init = _init;
              if (adjusted_ty.$tag === 10) {
                const _bind$5 = actual_init;
                if (_bind$5 === undefined) {
                } else {
                  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "function declaration cannot have initializer");
                  actual_init = undefined;
                }
              }
              if (is_inline) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "inline can only apply to functions");
              }
              moonbitlang$core$array$$Array$push$99$(decls, { name: _decl.name, id: _decl.id, ty: adjusted_ty, init: actual_init, storage: storage, attrs: combined_attrs, loc: _decl.loc });
            }
          }
          const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
          if (_bind$5 === undefined) {
          } else {
            continue;
          }
          break;
        }
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after for declaration");
        if (is_typedef || !saw_decl) {
          return undefined;
        }
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$DeclStmt(decls, decl_loc);
      } else {
        const _Some$2 = _bind$3;
        const _semi = _Some$2;
        if (is_typedef) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _semi.loc, "typedef requires a declarator");
          return undefined;
        }
        return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$TagDef(base, _semi.loc);
      }
    }
  }
  const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after for init");
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$ExprStmt(expr, hackwaly$tinycc$frontend$ast$$expr_loc(expr));
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_init_declarator(p, base) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator(p, base);
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _decl = _Some;
    const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 62);
    const init = _bind$2 === undefined ? undefined : hackwaly$tinycc$frontend$parser$parser_core$$parse_initializer(p);
    return { _0: _decl, _1: init };
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator(p, base) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_pointer_chain(p, base);
  const _ty0 = _bind._0;
  const _pointer_attrs = _bind._1;
  let attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(_pointer_attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
  const _p$28 = 0;
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind;
  if (_bind$2 === 49) {
    const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_paren_pointer_declarator(p, _ty0);
    if (_bind$3 === undefined) {
      return undefined;
    } else {
      const _Some = _bind$3;
      const _decl = _Some;
      return { name: _decl.name, id: _decl.id, ty: _decl.ty, params: _decl.params, varargs: _decl.varargs, is_old_style: _decl.is_old_style, attrs: hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _decl.attrs), loc: _decl.loc };
    }
  } else {
    const name_tok = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected identifier");
    if (name_tok === undefined) {
      return undefined;
    } else {
      const _Some = name_tok;
      const _tok = _Some;
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator_suffix(p, _ty0);
      const _ty = _bind$3._0;
      const _params = _bind$3._1;
      const _varargs = _bind$3._2;
      const _is_old_style = _bind$3._3;
      const _suffix_attrs = _bind$3._4;
      attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, _suffix_attrs);
      const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 48);
      if (_bind$4 === undefined) {
      } else {
        const _Some$2 = _bind$4;
        const _asm_tok = _Some$2;
        const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_label(p, _asm_tok.loc);
        if (_bind$5 === undefined) {
        } else {
          const _Some$3 = _bind$5;
          const _label = _Some$3;
          attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$ast$$attrs_with(Option$None$38$, -1, -1, Option$None$39$, Option$None$40$, Option$None$40$, new Option$Some$40$(_label), Option$None$40$, -1, -1, -1, -1, Option$None$41$, -1, -1, -1, -1));
        }
        attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(attrs, hackwaly$tinycc$frontend$parser$parser_core$$parse_attributes(p));
      }
      return { name: hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok), id: hackwaly$tinycc$frontend$tokens$$token_id(_tok), ty: _ty, params: _params, varargs: _varargs, is_old_style: _is_old_style, attrs: attrs, loc: _tok.loc };
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_initializer(p) {
  const _bind = p.current.kind;
  if (_bind === 51) {
    const lbrace = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    const items = moonbitlang$core$array$$Array$new$46$inner$38$(4);
    const _bind$2 = p.current.kind;
    if (_bind$2 === 52) {
      hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List(items, lbrace.loc);
    }
    while (true) {
      const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_designator_list(p);
      const _designators = _bind$3._0;
      const _item_loc = _bind$3._1;
      const value = hackwaly$tinycc$frontend$parser$parser_core$$parse_initializer(p);
      moonbitlang$core$array$$Array$push$38$(items, { designators: _designators, value: value, loc: _item_loc });
      const _bind$4 = p.current.kind;
      if (_bind$4 === 55) {
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const _bind$5 = p.current.kind;
        if (_bind$5 === 52) {
          hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
          break;
        }
        continue;
      }
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 52, "expected '}' after initializer list");
      break;
    }
    return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$List(items, lbrace.loc);
  }
  const expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq(p);
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Initializer$Expr(expr, hackwaly$tinycc$frontend$ast$$expr_loc(expr));
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_designator_list(p) {
  const designators = moonbitlang$core$array$$Array$new$46$inner$37$(2);
  let start_loc = p.current.loc;
  while (true) {
    const _bind = p.current.kind;
    if (_bind === 59) {
      const dot_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      start_loc = dot_tok.loc;
      const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected field name");
      let _bind$3;
      if (_bind$2 === undefined) {
        _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_designator_list$46$tuple$47$17367;
      } else {
        const _Some = _bind$2;
        const _tok = _Some;
        _bind$3 = { _0: hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok), _1: hackwaly$tinycc$frontend$tokens$$token_id(_tok) };
      }
      const _name = _bind$3._0;
      const _id = _bind$3._1;
      moonbitlang$core$array$$Array$push$37$(designators, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Field(_name, _id, dot_tok.loc));
      continue;
    }
    const _bind$2 = p.current.kind;
    if (_bind$2 === 53) {
      const lbrack = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      start_loc = lbrack.loc;
      const start = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
      const _bind$3 = p.current.kind;
      let end_expr;
      if (_bind$3 === 60) {
        hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        end_expr = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_cond(p);
      } else {
        end_expr = undefined;
      }
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 54, "expected ']' after designator");
      if (end_expr === undefined) {
        moonbitlang$core$array$$Array$push$37$(designators, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Index(start, lbrack.loc));
      } else {
        const _Some = end_expr;
        const _end = _Some;
        moonbitlang$core$array$$Array$push$37$(designators, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$IndexRange(start, _end, lbrack.loc));
      }
      continue;
    }
    const _bind$3 = p.current.kind;
    if (_bind$3 === 2) {
      const _p$28 = 1;
      const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$peek_token_at(p, _p$28).kind;
      if (_bind$4 === 57) {
        const name_tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        start_loc = name_tok.loc;
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 57, "expected ':' after designator");
        moonbitlang$core$array$$Array$push$37$(designators, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$InitDesignator$Field(hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, name_tok), hackwaly$tinycc$frontend$tokens$$token_id(name_tok), name_tok.loc));
        continue;
      }
    }
    break;
  }
  if (designators.length > 0) {
    const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 62);
    if (_bind === undefined) {
      hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, p.current.loc, "expected '=' after designator");
    }
  }
  return { _0: designators, _1: start_loc };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_if_stmt(p, loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after if");
  const cond = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after if condition");
  const then_branch = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
  const _bind = p.current.kind;
  let else_branch;
  if (_bind === 8) {
    hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    else_branch = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
  } else {
    else_branch = undefined;
  }
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$If(cond, then_branch, else_branch, loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_switch_stmt(p, loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after switch");
  const cond = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after switch condition");
  const body = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$Switch(cond, body, loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_while_stmt(p, loc) {
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 49, "expected '(' after while");
  const cond = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
  hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after while condition");
  const body = hackwaly$tinycc$frontend$parser$parser_core$$parse_stmt(p);
  return new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Stmt$While(cond, body, loc);
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_postfix_tail(p, base) {
  let expr = base;
  _L: while (true) {
    const _bind = p.current.kind;
    switch (_bind) {
      case 49: {
        const tok = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const args = hackwaly$tinycc$frontend$parser$parser_core$$parse_call_args(p);
        expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Call(expr, args, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok.loc);
        continue _L;
      }
      case 53: {
        const tok$2 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const index = hackwaly$tinycc$frontend$parser$parser_core$$parse_expr(p);
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 54, "expected ']' after index");
        expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Index(expr, index, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$2.loc);
        continue _L;
      }
      case 59: {
        const tok$3 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected field name");
        let _bind$3;
        if (_bind$2 === undefined) {
          _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_postfix_tail$46$tuple$47$17405;
        } else {
          const _Some = _bind$2;
          const _tok = _Some;
          _bind$3 = { _0: hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok), _1: hackwaly$tinycc$frontend$tokens$$token_id(_tok) };
        }
        const _name = _bind$3._0;
        const _id = _bind$3._1;
        expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Member(expr, _name, _id, false, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$3.loc);
        continue _L;
      }
      case 61: {
        const tok$4 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$expect_ident(p, "expected field name");
        let _bind$5;
        if (_bind$4 === undefined) {
          _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$parse_postfix_tail$46$tuple$47$17406;
        } else {
          const _Some = _bind$4;
          const _tok = _Some;
          _bind$5 = { _0: hackwaly$tinycc$frontend$parser$parser_core$$token_lexeme(p, _tok), _1: hackwaly$tinycc$frontend$tokens$$token_id(_tok) };
        }
        const _name$2 = _bind$5._0;
        const _id$2 = _bind$5._1;
        expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Member(expr, _name$2, _id$2, true, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$4.loc);
        continue _L;
      }
      case 68: {
        const tok$5 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(8, expr, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$5.loc);
        continue _L;
      }
      case 69: {
        const tok$6 = hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
        expr = new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Expr$Unary(9, expr, hackwaly$tinycc$frontend$parser$parser_core$$new_expr_id(p), tok$6.loc);
        continue _L;
      }
      default: {
        break _L;
      }
    }
  }
  return expr;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_call_args(p) {
  const args = moonbitlang$core$array$$Array$new$46$inner$55$(4);
  const _bind = p.current.kind;
  if (_bind === 50) {
    hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
    return args;
  }
  while (true) {
    moonbitlang$core$array$$Array$push$55$(args, hackwaly$tinycc$frontend$parser$parser_core$$parse_expr_eq(p));
    const _bind$2 = p.current.kind;
    if (_bind$2 === 55) {
      hackwaly$tinycc$frontend$parser$parser_core$$advance_token(p);
      continue;
    }
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 50, "expected ')' after arguments");
    break;
  }
  return args;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_old_style_param_decls(p, params) {
  const param_map = hackwaly$tinycc$support$util$$fast_map_new$156$(undefined);
  let _tmp$27 = 0;
  while (true) {
    const i = _tmp$27;
    if (i < params.length) {
      _L: {
        const name = moonbitlang$core$array$$Array$at$28$(params, i).name;
        if (name === "") {
          break _L;
        }
        if (moonbitlang$core$hashmap$$HashMap$contains$156$(param_map, name)) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, moonbitlang$core$array$$Array$at$28$(params, i).loc, "duplicate parameter name");
        } else {
          moonbitlang$core$hashmap$$HashMap$set$156$(param_map, name, i);
        }
        break _L;
      }
      _tmp$27 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const seen = hackwaly$tinycc$support$util$$fast_map_new$161$(undefined);
  while (true) {
    if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, p.current)) {
      const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_decl_specs$46$inner(p, true);
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _specs = _Some;
        const base = _specs.ty;
        if (_specs.is_typedef) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _specs.loc, "typedef not allowed in parameter list");
        }
        if (_specs.is_inline) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _specs.loc, "inline not allowed in parameter list");
        }
        if (moonbitlang$core$builtin$$Eq$not_equal$78$(_specs.storage, 0) && moonbitlang$core$builtin$$Eq$not_equal$78$(_specs.storage, 4)) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _specs.loc, "invalid storage class for parameter");
        }
        let any_decl = false;
        while (true) {
          const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$parse_declarator(p, base);
          if (_bind$2 === undefined) {
            hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _specs.loc, "expected parameter declarator");
            break;
          } else {
            const _Some$2 = _bind$2;
            const _decl = _Some$2;
            any_decl = true;
            const combined_attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(_specs.attrs, _decl.attrs);
            const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_decl.ty, hackwaly$tinycc$frontend$ast$$normalize_call_conv(combined_attrs.call_conv));
            if (_decl.name === "") {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "parameter name missing");
            } else {
              const _bind$3 = moonbitlang$core$hashmap$$HashMap$get$156$(param_map, _decl.name);
              if (_bind$3 === undefined) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "unknown parameter name");
              } else {
                const _Some$3 = _bind$3;
                const _idx = _Some$3;
                if (moonbitlang$core$hashmap$$HashMap$contains$161$(seen, _decl.name)) {
                  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "duplicate parameter declaration");
                } else {
                  moonbitlang$core$hashmap$$HashMap$set$161$(seen, _decl.name, true);
                  moonbitlang$core$array$$Array$set$28$(params, _idx, { name: _decl.name, id: _decl.id, ty: adjusted_ty, loc: _decl.loc });
                }
              }
            }
          }
          const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
          if (_bind$3 === undefined) {
          } else {
            continue;
          }
          break;
        }
        if (!any_decl) {
          hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _specs.loc, "expected parameter declarator");
        }
        hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after parameter declaration");
      }
      continue;
    } else {
      break;
    }
  }
  return params;
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_decl(p) {
  const _bind = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 47);
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _assert_tok = _Some;
    const static_assert = hackwaly$tinycc$frontend$parser$parser_core$$parse_static_assert(p, _assert_tok.loc);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after _Static_assert");
    return new Option$Some$43$([new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$StaticAssert(static_assert)]);
  }
  const _bind$2 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 48);
  if (_bind$2 === undefined) {
  } else {
    const _Some = _bind$2;
    const _asm_tok = _Some;
    const asm_stmt = hackwaly$tinycc$frontend$parser$parser_core$$parse_asm_stmt(p, _asm_tok.loc);
    hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after asm");
    return new Option$Some$43$([new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Asm(asm_stmt)]);
  }
  const _bind$3 = hackwaly$tinycc$frontend$parser$parser_core$$parse_decl_specs$46$inner(p, true);
  let specs;
  if (_bind$3 === undefined) {
    const head = p.current;
    _L: {
      _L$2: {
        const _bind$4 = head.kind;
        if (_bind$4 === 2) {
          if (!hackwaly$tinycc$frontend$parser$parser_core$$has_typedef(p, head)) {
            specs = { ty: hackwaly$tinycc$frontend$parser$parser_core$$parse_decl$46$constr$47$17461, loc: head.loc, is_typedef: false, storage: 0, is_inline: false, attrs: hackwaly$tinycc$frontend$ast$$empty_attrs() };
          } else {
            break _L$2;
          }
        } else {
          break _L$2;
        }
        break _L;
      }
      specs = undefined;
    }
  } else {
    const _Some = _bind$3;
    const _val = _Some;
    specs = _val;
  }
  if (specs === undefined) {
    return Option$None$43$;
  } else {
    const _Some = specs;
    const _specs = _Some;
    const base_type = _specs.ty;
    const is_typedef = _specs.is_typedef;
    const storage = _specs.storage;
    const is_inline = _specs.is_inline;
    const base_attrs = _specs.attrs;
    const _bind$4 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 56);
    if (_bind$4 === undefined) {
      const decls = [];
      while (true) {
        const _bind$5 = hackwaly$tinycc$frontend$parser$parser_core$$parse_init_declarator(p, base_type);
        if (_bind$5 === undefined) {
          hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p);
          return Option$None$43$;
        } else {
          const _Some$2 = _bind$5;
          const _x = _Some$2;
          const _decl = _x._0;
          const _init = _x._1;
          const combined_attrs = hackwaly$tinycc$frontend$ast$$merge_attrs(base_attrs, _decl.attrs);
          const adjusted_ty = hackwaly$tinycc$frontend$ast$$apply_call_conv_to_type(_decl.ty, hackwaly$tinycc$frontend$ast$$normalize_call_conv(combined_attrs.call_conv));
          if (is_typedef) {
            if (_init === undefined) {
            } else {
              hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "typedef cannot have initializer");
            }
            const typedef_ty = hackwaly$tinycc$frontend$ast$$apply_type_attrs(adjusted_ty, hackwaly$tinycc$frontend$ast$$type_attrs_from(combined_attrs));
            hackwaly$tinycc$frontend$parser$parser_core$$define_typedef(p, _decl.name, typedef_ty);
            moonbitlang$core$array$$Array$push$105$(decls, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Typedef(_decl.name, typedef_ty, combined_attrs, _decl.loc));
          } else {
            const _bind$6 = _decl.params;
            if (_bind$6.$tag === 1) {
              const _Some$3 = _bind$6;
              const _params = _Some$3._0;
              if (adjusted_ty.$tag === 10) {
                const _Function = adjusted_ty;
                const _return_type = _Function._0;
                let final_params = _params;
                let lbrace = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 51);
                const _bind$7 = lbrace;
                if (_bind$7 === undefined) {
                  if (_decl.is_old_style) {
                    if (hackwaly$tinycc$frontend$parser$parser_core$$is_type_start(p, p.current)) {
                      final_params = hackwaly$tinycc$frontend$parser$parser_core$$parse_old_style_param_decls(p, final_params);
                      lbrace = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 51);
                      const _bind$8 = lbrace;
                      if (_bind$8 === undefined) {
                        hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "expected '{' after parameter declarations");
                      }
                    }
                  }
                }
                const _bind$8 = lbrace;
                if (_bind$8 === undefined) {
                  if (_init === undefined) {
                  } else {
                    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "function declaration cannot have initializer");
                  }
                  moonbitlang$core$array$$Array$push$105$(decls, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$FuncDecl({ name: _decl.name, id: _decl.id, return_type: _return_type, params: final_params, varargs: _decl.varargs, is_old_style: _decl.is_old_style, storage: storage, is_inline: is_inline, attrs: combined_attrs, loc: _decl.loc }));
                } else {
                  const _Some$4 = _bind$8;
                  const _lbrace_tok = _Some$4;
                  if (_init === undefined) {
                  } else {
                    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "function cannot have initializer");
                  }
                  if (decls.length > 0) {
                    hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "function definition cannot be mixed with other declarators");
                  }
                  const body = hackwaly$tinycc$frontend$parser$parser_core$$parse_compound_stmt(p, _lbrace_tok.loc);
                  moonbitlang$core$array$$Array$push$105$(decls, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$FuncDef({ name: _decl.name, id: _decl.id, return_type: _return_type, params: final_params, varargs: _decl.varargs, is_old_style: _decl.is_old_style, storage: storage, is_inline: is_inline, attrs: combined_attrs, body: body, loc: _decl.loc }));
                  return new Option$Some$43$(decls);
                }
              } else {
                if (is_inline) {
                  hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "inline can only apply to functions");
                }
                moonbitlang$core$array$$Array$push$105$(decls, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Var({ name: _decl.name, id: _decl.id, ty: adjusted_ty, init: _init, storage: storage, attrs: combined_attrs, loc: _decl.loc }));
              }
            } else {
              if (is_inline) {
                hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _decl.loc, "inline can only apply to functions");
              }
              moonbitlang$core$array$$Array$push$105$(decls, new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$Var({ name: _decl.name, id: _decl.id, ty: adjusted_ty, init: _init, storage: storage, attrs: combined_attrs, loc: _decl.loc }));
            }
          }
        }
        const _bind$6 = hackwaly$tinycc$frontend$parser$parser_core$$match_token(p, 55);
        if (_bind$6 === undefined) {
        } else {
          continue;
        }
        break;
      }
      hackwaly$tinycc$frontend$parser$parser_core$$expect(p, 56, "expected ';' after declaration");
      return new Option$Some$43$(decls);
    } else {
      const _Some$2 = _bind$4;
      const _semi = _Some$2;
      if (is_typedef) {
        hackwaly$tinycc$frontend$parser$parser_core$$add_parse_error(p, _semi.loc, "typedef requires a declarator");
        return Option$None$43$;
      } else {
        return new Option$Some$43$([new $64$hackwaly$47$tinycc$47$frontend$47$ast$47$ast_core$46$Decl$TagDef(base_type, _semi.loc)]);
      }
    }
  }
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_translation_unit_with(p) {
  let decl_capacity = p.pp.lexer.text_len / 256 | 0;
  if (decl_capacity < 256) {
    decl_capacity = 256;
  } else {
    if (decl_capacity > 16384) {
      decl_capacity = 16384;
    }
  }
  const decls = moonbitlang$core$array$$Array$new$46$inner$105$(decl_capacity);
  while (true) {
    if (!hackwaly$tinycc$frontend$parser$parser_core$$is_at_end(p)) {
      const _bind = hackwaly$tinycc$frontend$parser$parser_core$$parse_decl(p);
      if (_bind.$tag === 1) {
        const _Some = _bind;
        const _items = _Some._0;
        const _len = _items.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const item = _items[_i];
            moonbitlang$core$array$$Array$push$105$(decls, item);
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      } else {
        hackwaly$tinycc$frontend$parser$parser_core$$synchronize(p);
      }
      continue;
    } else {
      break;
    }
  }
  const expr_id_max = p.next_expr_id;
  return { decls: decls, expr_id_max: expr_id_max };
}
function hackwaly$tinycc$frontend$parser$parser_core$$parse_translation_unit(pp) {
  const parser = hackwaly$tinycc$frontend$parser$parser_core$$new_parser(pp);
  return hackwaly$tinycc$frontend$parser$parser_core$$parse_translation_unit_with(parser);
}
function hackwaly$tinycc$frontend$parser$$parse_translation_unit(pp) {
  return hackwaly$tinycc$frontend$parser$parser_core$$parse_translation_unit(pp);
}
function moonbitlang$x$sys$internal$ffi$$get_env_var(key) {
  return moonbitlang$x$sys$internal$ffi$$is_env_var_exists_internal(key) ? moonbitlang$x$sys$internal$ffi$$get_env_var_internal(key) : undefined;
}
function moonbitlang$x$sys$$get_env_var(key) {
  return moonbitlang$x$sys$internal$ffi$$get_env_var(key);
}
function hackwaly$tinycc$driver$$parse_cli_args(host, args) {
  return hackwaly$tinycc$driver$cli$$parse_cli_args(host, args);
}
function hackwaly$tinycc$driver$$bench_stats_new() {
  return { parse_ns: $0L, sem_ns: $0L, codegen_ns: $0L, total_ns: $0L, files: 0 };
}
function hackwaly$tinycc$driver$$bench_delta_ns(start_ns, end_ns) {
  return moonbitlang$core$builtin$$Sub$sub$6$(end_ns, start_ns);
}
function hackwaly$tinycc$driver$$bench_ms(delta_ns) {
  return moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$Div$div$6$(delta_ns, $1000000L));
}
function hackwaly$tinycc$driver$$bench_us(delta_ns) {
  return moonbitlang$core$uint64$$UInt64$to_int(moonbitlang$core$builtin$$Div$div$6$(moonbitlang$core$builtin$$Add$add$6$(delta_ns, $999L), $1000L));
}
function hackwaly$tinycc$driver$$lex_cli_macro_tokens(pp, value) {
  if (value === "") {
    return [];
  }
  const file = hackwaly$tinycc$support$source$$add_file(pp.map, "<cmdline>", value);
  const lex = hackwaly$tinycc$frontend$lexer$$new_lexer(file, pp.diags, pp.interner, pp.keyword_ids, pp.lexeme_pool);
  const tokens = [];
  while (true) {
    const tok = hackwaly$tinycc$frontend$lexer$$next_token(lex);
    if (moonbitlang$core$builtin$$Eq$equal$85$(tok.kind, 0)) {
      break;
    }
    moonbitlang$core$array$$Array$push$15$(tokens, tok);
    continue;
  }
  return hackwaly$tinycc$frontend$preproc$$normalize_macro_tokens(tokens);
}
function hackwaly$tinycc$driver$$apply_cli_macros(pp, actions) {
  const _len = actions.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const action = actions[_i];
      if (action.$tag === 0) {
        const _Define = action;
        const _name = _Define._0;
        const _value = _Define._1;
        if (_value === undefined) {
          hackwaly$tinycc$frontend$preproc$$define_int_macro(pp, _name, 1);
        } else {
          const _Some = _value;
          const _v = _Some;
          hackwaly$tinycc$frontend$preproc$$define_macro(pp, _name, hackwaly$tinycc$driver$$lex_cli_macro_tokens(pp, _v));
        }
      } else {
        const _Undef = action;
        const _name = _Undef._0;
        hackwaly$tinycc$frontend$preproc$$remove_macro(pp, hackwaly$tinycc$frontend$preproc$$macro_id_from_name(pp, _name));
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function hackwaly$tinycc$driver$$bench_summary_line(stats) {
  const parse_ms = hackwaly$tinycc$driver$$bench_ms(stats.parse_ns);
  const sem_ms = hackwaly$tinycc$driver$$bench_ms(stats.sem_ns);
  const codegen_ms = hackwaly$tinycc$driver$$bench_ms(stats.codegen_ns);
  const total_ms = hackwaly$tinycc$driver$$bench_ms(stats.total_ns);
  const parse_us = hackwaly$tinycc$driver$$bench_us(stats.parse_ns);
  const sem_us = hackwaly$tinycc$driver$$bench_us(stats.sem_ns);
  const codegen_us = hackwaly$tinycc$driver$$bench_us(stats.codegen_ns);
  const total_us = hackwaly$tinycc$driver$$bench_us(stats.total_ns);
  return `bench: files=${moonbitlang$core$builtin$$Show$to_string$90$(stats.files)} parse_ms=${moonbitlang$core$builtin$$Show$to_string$90$(parse_ms)} sem_ms=${moonbitlang$core$builtin$$Show$to_string$90$(sem_ms)} codegen_ms=${moonbitlang$core$builtin$$Show$to_string$90$(codegen_ms)} total_ms=${moonbitlang$core$builtin$$Show$to_string$90$(total_ms)} parse_us=${moonbitlang$core$builtin$$Show$to_string$90$(parse_us)} sem_us=${moonbitlang$core$builtin$$Show$to_string$90$(sem_us)} codegen_us=${moonbitlang$core$builtin$$Show$to_string$90$(codegen_us)} total_us=${moonbitlang$core$builtin$$Show$to_string$90$(total_us)}`;
}
function hackwaly$tinycc$driver$$build_clang_link_args(obj_path, exe_path, cfg) {
  const args = [];
  moonbitlang$core$array$$Array$push$19$(args, "clang");
  moonbitlang$core$array$$Array$push$19$(args, "-w");
  moonbitlang$core$array$$Array$push$19$(args, obj_path);
  moonbitlang$core$array$$Array$push$19$(args, "-o");
  moonbitlang$core$array$$Array$push$19$(args, exe_path);
  const _arr = cfg.link_inputs;
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const input = _arr[_i];
      moonbitlang$core$array$$Array$push$19$(args, input);
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$2 = cfg.link_paths;
  const _len$2 = _arr$2.length;
  let _tmp$28 = 0;
  while (true) {
    const _i = _tmp$28;
    if (_i < _len$2) {
      const path = _arr$2[_i];
      moonbitlang$core$array$$Array$push$19$(args, `-L${path}`);
      _tmp$28 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$3 = cfg.link_libs;
  const _len$3 = _arr$3.length;
  let _tmp$29 = 0;
  while (true) {
    const _i = _tmp$29;
    if (_i < _len$3) {
      const lib = _arr$3[_i];
      moonbitlang$core$array$$Array$push$19$(args, `-l${lib}`);
      _tmp$29 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return args;
}
function hackwaly$tinycc$driver$$bench_file_line(path, parse_ns, sem_ns, codegen_ns, total_ns) {
  const parse_ms = hackwaly$tinycc$driver$$bench_ms(parse_ns);
  const sem_ms = hackwaly$tinycc$driver$$bench_ms(sem_ns);
  const codegen_ms = hackwaly$tinycc$driver$$bench_ms(codegen_ns);
  const total_ms = hackwaly$tinycc$driver$$bench_ms(total_ns);
  const parse_us = hackwaly$tinycc$driver$$bench_us(parse_ns);
  const sem_us = hackwaly$tinycc$driver$$bench_us(sem_ns);
  const codegen_us = hackwaly$tinycc$driver$$bench_us(codegen_ns);
  const total_us = hackwaly$tinycc$driver$$bench_us(total_ns);
  return `bench: file=${path} parse_ms=${moonbitlang$core$builtin$$Show$to_string$90$(parse_ms)} sem_ms=${moonbitlang$core$builtin$$Show$to_string$90$(sem_ms)} codegen_ms=${moonbitlang$core$builtin$$Show$to_string$90$(codegen_ms)} total_ms=${moonbitlang$core$builtin$$Show$to_string$90$(total_ms)} parse_us=${moonbitlang$core$builtin$$Show$to_string$90$(parse_us)} sem_us=${moonbitlang$core$builtin$$Show$to_string$90$(sem_us)} codegen_us=${moonbitlang$core$builtin$$Show$to_string$90$(codegen_us)} total_us=${moonbitlang$core$builtin$$Show$to_string$90$(total_us)}`;
}
function hackwaly$tinycc$driver$$bench_stats_add(stats, parse_ns, sem_ns, codegen_ns, total_ns) {
  stats.parse_ns = moonbitlang$core$builtin$$Add$add$6$(stats.parse_ns, parse_ns);
  stats.sem_ns = moonbitlang$core$builtin$$Add$add$6$(stats.sem_ns, sem_ns);
  stats.codegen_ns = moonbitlang$core$builtin$$Add$add$6$(stats.codegen_ns, codegen_ns);
  stats.total_ns = moonbitlang$core$builtin$$Add$add$6$(stats.total_ns, total_ns);
  stats.files = stats.files + 1 | 0;
}
function hackwaly$tinycc$driver$$format_diag_for_cli(map, d) {
  const loc = d.loc;
  const _bind = moonbitlang$core$array$$Array$get$27$(map.files, loc.file_id);
  if (_bind === undefined) {
    return d.message;
  } else {
    const _Some = _bind;
    const _file = _Some;
    return `${_file.path}:${moonbitlang$core$builtin$$Show$to_string$90$(loc.line)}:${moonbitlang$core$builtin$$Show$to_string$90$(loc.col)}: ${d.message}`;
  }
}
function hackwaly$tinycc$driver$$load_input(host, path) {
  let _try_err;
  _L: {
    const _bind = host.method_table.method_1(host.self, path);
    let _bind$2;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _bind$2 = _ok._0;
    } else {
      const _err = _bind;
      const _tmp$27 = _err._0;
      _try_err = _tmp$27;
      break _L;
    }
    return { _0: path, _1: _bind$2 };
  }
  moonbitlang$core$builtin$$println$19$(`failed to read input: ${moonbitlang$core$builtin$$Show$to_string$92$(_try_err)}`);
  return undefined;
}
function hackwaly$tinycc$driver$$compile_to_object_path(host, cfg, input_path, output_path, bench_stats) {
  const _bind = hackwaly$tinycc$driver$$load_input(host, input_path);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _path = _x._0;
    const _text = _x._1;
    const bag = hackwaly$tinycc$support$diag$$new_diag_bag();
    const map = hackwaly$tinycc$support$source$$new_source_map();
    const file = hackwaly$tinycc$support$source$$add_file(map, _path, _text);
    const pp = hackwaly$tinycc$frontend$preproc$$new_preprocessor(map, file, bag, host);
    hackwaly$tinycc$frontend$preproc$$add_include_path(pp, "compat/include");
    const _arr = cfg.include_paths;
    const _len = _arr.length;
    let _tmp$27 = 0;
    while (true) {
      const _i = _tmp$27;
      if (_i < _len) {
        const p = _arr[_i];
        hackwaly$tinycc$frontend$preproc$$add_include_path(pp, p);
        _tmp$27 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    hackwaly$tinycc$driver$$apply_cli_macros(pp, cfg.macro_actions);
    let parse_ns = $0L;
    let sem_ns = $0L;
    let codegen_ns = $0L;
    let total_ns = $0L;
    let sem_ctx = undefined;
    const bench_enabled = cfg.bench;
    const total_start = bench_enabled ? $0L : $0L;
    const unit = hackwaly$tinycc$frontend$parser$$parse_translation_unit(pp);
    hackwaly$tinycc$frontend$preproc$$finalize_preprocessor(pp);
    if (bench_enabled) {
      const parse_end = $0L;
      parse_ns = hackwaly$tinycc$driver$$bench_delta_ns(total_start, parse_end);
    }
    if (!hackwaly$tinycc$support$diag$$has_errors(bag)) {
      if (bench_enabled) {
        const sem_start = $0L;
        sem_ctx = hackwaly$tinycc$sem$$check_translation_unit(unit, bag);
        const sem_end = $0L;
        sem_ns = hackwaly$tinycc$driver$$bench_delta_ns(sem_start, sem_end);
      } else {
        sem_ctx = hackwaly$tinycc$sem$$check_translation_unit(unit, bag);
      }
    }
    if (!hackwaly$tinycc$support$diag$$has_errors(bag)) {
      const codegen_start = bench_enabled ? $0L : $0L;
      const _bind$2 = sem_ctx;
      if (_bind$2 === undefined) {
      } else {
        const _Some$2 = _bind$2;
        const _ctx = _Some$2;
        const _bind$3 = hackwaly$tinycc$backend$codegen$$codegen_arm64_object_bytes_with_sem(unit, _ctx, bag);
        if (_bind$3 === undefined) {
        } else {
          const _Some$3 = _bind$3;
          const _bytes = _Some$3;
          let _try_err;
          _L: {
            _L$2: {
              const _bind$4 = host.method_table.method_3(host.self, output_path, _bytes);
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _ok._0;
              } else {
                const _err = _bind$4;
                const _tmp$28 = _err._0;
                _try_err = _tmp$28;
                break _L$2;
              }
              break _L;
            }
            hackwaly$tinycc$support$diag$$add_error(bag, hackwaly$tinycc$support$source$$dummy_loc(0), moonbitlang$core$builtin$$Show$to_string$92$(_try_err));
          }
        }
      }
      if (bench_enabled) {
        const codegen_end = $0L;
        codegen_ns = hackwaly$tinycc$driver$$bench_delta_ns(codegen_start, codegen_end);
      }
    }
    if (bench_enabled) {
      const total_end = $0L;
      total_ns = hackwaly$tinycc$driver$$bench_delta_ns(total_start, total_end);
      if (bench_stats === undefined) {
      } else {
        const _Some$2 = bench_stats;
        const _stats = _Some$2;
        hackwaly$tinycc$driver$$bench_stats_add(_stats, parse_ns, sem_ns, codegen_ns, total_ns);
      }
      moonbitlang$core$builtin$$println$19$(hackwaly$tinycc$driver$$bench_file_line(_path, parse_ns, sem_ns, codegen_ns, total_ns));
    }
    if (hackwaly$tinycc$support$diag$$has_errors(bag)) {
      const _arr$2 = bag.diags;
      const _len$2 = _arr$2.length;
      let _tmp$28 = 0;
      while (true) {
        const _i = _tmp$28;
        if (_i < _len$2) {
          const d = _arr$2[_i];
          moonbitlang$core$builtin$$println$19$(hackwaly$tinycc$driver$$format_diag_for_cli(pp.map, d));
          _tmp$28 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return false;
    } else {
      return true;
    }
  }
}
function hackwaly$tinycc$driver$$default_output_path(input_path) {
  const _bind = moonbitlang$core$string$$String$rev_find(input_path, { str: hackwaly$tinycc$driver$$default_output_path$46$42$bind$124$238, start: 0, end: hackwaly$tinycc$driver$$default_output_path$46$42$bind$124$238.length });
  let slash;
  if (_bind === undefined) {
    slash = -1;
  } else {
    const _Some = _bind;
    slash = _Some;
  }
  const _bind$2 = moonbitlang$core$string$$String$rev_find(input_path, { str: hackwaly$tinycc$driver$$default_output_path$46$42$bind$124$232, start: 0, end: hackwaly$tinycc$driver$$default_output_path$46$42$bind$124$232.length });
  if (_bind$2 === undefined) {
    return `${input_path}.o`;
  } else {
    const _Some = _bind$2;
    const _dot = _Some;
    return _dot > slash ? `${hackwaly$tinycc$support$util$$slice_string(input_path, 0, _dot)}.o` : `${input_path}.o`;
  }
}
function hackwaly$tinycc$driver$$write_shell_quoted_arg(buf, arg) {
  moonbitlang$core$buffer$$Buffer$write_byte(buf, 39);
  const _arr = moonbitlang$core$encoding$utf8$$encode$46$inner({ str: arg, start: 0, end: arg.length }, false);
  const _len = _arr.length;
  let _tmp$27 = 0;
  while (true) {
    const _i = _tmp$27;
    if (_i < _len) {
      const b = _arr[_i];
      const _p$28 = 39;
      if (b === _p$28) {
        moonbitlang$core$buffer$$Buffer$write_byte(buf, 39);
        moonbitlang$core$buffer$$Buffer$write_byte(buf, 92);
        moonbitlang$core$buffer$$Buffer$write_byte(buf, 39);
        moonbitlang$core$buffer$$Buffer$write_byte(buf, 39);
      } else {
        moonbitlang$core$buffer$$Buffer$write_byte(buf, b);
      }
      _tmp$27 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$buffer$$Buffer$write_byte(buf, 39);
}
function hackwaly$tinycc$driver$$build_shell_command_bytes(args) {
  const buf = moonbitlang$core$buffer$$new$46$inner(Math.imul(args.length, 16) | 0);
  let i = 0;
  while (true) {
    if (i < args.length) {
      if (i > 0) {
        moonbitlang$core$buffer$$Buffer$write_byte(buf, 32);
      }
      hackwaly$tinycc$driver$$write_shell_quoted_arg(buf, moonbitlang$core$array$$Array$at$19$(args, i));
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$buffer$$Buffer$write_byte(buf, 0);
  return moonbitlang$core$buffer$$Buffer$to_bytes(buf);
}
function hackwaly$tinycc$driver$$run_shell_command(args) {
  hackwaly$tinycc$driver$$build_shell_command_bytes(args);
  return 1;
}
function hackwaly$tinycc$driver$$join_temp_path(dir, name) {
  return dir === "" ? name : moonbitlang$core$string$$String$has_suffix(dir, { str: hackwaly$tinycc$driver$$join_temp_path$46$42$bind$124$247, start: 0, end: hackwaly$tinycc$driver$$join_temp_path$46$42$bind$124$247.length }) ? `${dir}${name}` : `${dir}/${name}`;
}
function hackwaly$tinycc$driver$$temp_dir() {
  const _bind = moonbitlang$x$sys$$get_env_var("TMPDIR");
  if (_bind === undefined) {
    return "/tmp";
  } else {
    const _Some = _bind;
    return _Some;
  }
}
function hackwaly$tinycc$driver$$run_temp_base() {
  const stamp = $0L;
  return hackwaly$tinycc$driver$$join_temp_path(hackwaly$tinycc$driver$$temp_dir(), `tinycc.mbt.run.${moonbitlang$core$builtin$$Show$to_string$80$(stamp)}`);
}
function hackwaly$tinycc$driver$$run_with_args(host, args) {
  hackwaly$tinycc$backend$codegen$$touch_unused_symbols();
  const _bind = hackwaly$tinycc$driver$$parse_cli_args(host, args);
  switch (_bind.$tag) {
    case 1: {
      return 0;
    }
    case 2: {
      return 1;
    }
    default: {
      const _Run = _bind;
      const _cfg = _Run._0;
      if (_cfg.run) {
        const _bind$2 = _cfg.output;
        if (_bind$2 === undefined) {
        } else {
          moonbitlang$core$builtin$$println$19$("error: -o is not supported with -run");
          return 1;
        }
        if (_cfg.inputs.length !== 1) {
          moonbitlang$core$builtin$$println$19$("error: -run requires exactly one input file");
          return 1;
        }
        const base = hackwaly$tinycc$driver$$run_temp_base();
        const obj_path = `${base}.o`;
        const exe_path = `${base}.out`;
        if (!hackwaly$tinycc$driver$$compile_to_object_path(host, _cfg, moonbitlang$core$array$$Array$at$19$(_cfg.inputs, 0), obj_path, undefined)) {
          return 1;
        }
        const link_status = hackwaly$tinycc$driver$$run_shell_command(hackwaly$tinycc$driver$$build_clang_link_args(obj_path, exe_path, _cfg));
        if (link_status !== 0) {
          moonbitlang$core$builtin$$println$19$("error: clang link failed");
          return 1;
        }
        const run_args = [];
        moonbitlang$core$array$$Array$push$19$(run_args, exe_path);
        const _arr = _cfg.run_args;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            const arg = _arr[_i];
            moonbitlang$core$array$$Array$push$19$(run_args, arg);
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const run_status = hackwaly$tinycc$driver$$run_shell_command(run_args);
        let _try_err;
        _L: {
          _L$2: {
            const _bind$3 = host.method_table.method_4(host.self, obj_path);
            if (_bind$3.$tag === 1) {
              const _ok = _bind$3;
              _ok._0;
            } else {
              const _err = _bind$3;
              const _tmp$28 = _err._0;
              _try_err = _tmp$28;
              break _L$2;
            }
            break _L;
          }
        }
        let _try_err$2;
        _L$2: {
          _L$3: {
            const _bind$3 = host.method_table.method_4(host.self, exe_path);
            if (_bind$3.$tag === 1) {
              const _ok = _bind$3;
              _ok._0;
            } else {
              const _err = _bind$3;
              const _tmp$28 = _err._0;
              _try_err$2 = _tmp$28;
              break _L$3;
            }
            break _L$2;
          }
        }
        if (run_status !== 0) {
          return run_status;
        }
        return 0;
      } else {
        let any_errors = false;
        const bench_enabled = _cfg.bench;
        const bench_stats = hackwaly$tinycc$driver$$bench_stats_new();
        const _arr = _cfg.inputs;
        const _len = _arr.length;
        let _tmp$27 = 0;
        while (true) {
          const _i = _tmp$27;
          if (_i < _len) {
            _L: {
              const input_path = _arr[_i];
              if (!_cfg.compile_only) {
                const _bind$2 = hackwaly$tinycc$driver$$load_input(host, input_path);
                if (_bind$2 === undefined) {
                  any_errors = true;
                  break _L;
                } else {
                  const _Some = _bind$2;
                  const _x = _Some;
                  const _path = _x._0;
                  const _text = _x._1;
                  const bag = hackwaly$tinycc$support$diag$$new_diag_bag();
                  const map = hackwaly$tinycc$support$source$$new_source_map();
                  const file = hackwaly$tinycc$support$source$$add_file(map, _path, _text);
                  const pp = hackwaly$tinycc$frontend$preproc$$new_preprocessor(map, file, bag, host);
                  hackwaly$tinycc$frontend$preproc$$add_include_path(pp, "compat/include");
                  const _arr$2 = _cfg.include_paths;
                  const _len$2 = _arr$2.length;
                  let _tmp$28 = 0;
                  while (true) {
                    const _i$2 = _tmp$28;
                    if (_i$2 < _len$2) {
                      const p = _arr$2[_i$2];
                      hackwaly$tinycc$frontend$preproc$$add_include_path(pp, p);
                      _tmp$28 = _i$2 + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                  hackwaly$tinycc$driver$$apply_cli_macros(pp, _cfg.macro_actions);
                  const toks = hackwaly$tinycc$frontend$preproc$$dump_tokens(pp, 32);
                  const _len$3 = toks.length;
                  let _tmp$29 = 0;
                  while (true) {
                    const _i$2 = _tmp$29;
                    if (_i$2 < _len$3) {
                      const t = toks[_i$2];
                      moonbitlang$core$builtin$$println$19$(hackwaly$tinycc$frontend$tokens$$token_text_with(pp.interner, pp.lexeme_pool, t));
                      _tmp$29 = _i$2 + 1 | 0;
                      continue;
                    } else {
                      break;
                    }
                  }
                  if (hackwaly$tinycc$support$diag$$has_errors(bag)) {
                    any_errors = true;
                    const _arr$3 = bag.diags;
                    const _len$4 = _arr$3.length;
                    let _tmp$30 = 0;
                    while (true) {
                      const _i$2 = _tmp$30;
                      if (_i$2 < _len$4) {
                        const d = _arr$3[_i$2];
                        moonbitlang$core$builtin$$println$19$(hackwaly$tinycc$driver$$format_diag_for_cli(pp.map, d));
                        _tmp$30 = _i$2 + 1 | 0;
                        continue;
                      } else {
                        break;
                      }
                    }
                  }
                }
              } else {
                const _bind$2 = _cfg.output;
                let out_path;
                if (_bind$2 === undefined) {
                  out_path = hackwaly$tinycc$driver$$default_output_path(input_path);
                } else {
                  const _Some = _bind$2;
                  out_path = _Some;
                }
                if (!hackwaly$tinycc$driver$$compile_to_object_path(host, _cfg, input_path, out_path, bench_stats)) {
                  any_errors = true;
                }
              }
              break _L;
            }
            _tmp$27 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (bench_enabled && _cfg.compile_only) {
          moonbitlang$core$builtin$$println$19$(hackwaly$tinycc$driver$$bench_summary_line(bench_stats));
        }
        if (any_errors) {
          return 1;
        }
        return 0;
      }
    }
  }
}
function hackwaly$tinycc$driver$$run_args(host, args) {
  return hackwaly$tinycc$driver$$run_with_args(host, args);
}
function hackwaly$tinycc$host$$Host$path_exists$0$(self, path) {
  return moonbitlang$core$builtin$$Map$contains$135$(self.files, path);
}
function hackwaly$tinycc$host$$Host$read_file_to_bytes$0$(self, path) {
  const _bind = moonbitlang$core$builtin$$Map$get$135$(self.files, path);
  if (_bind === undefined) {
    return moonbitlang$core$builtin$$fail$95$(`File not found in InMemoryHost: ${path}`, "@hackwaly/tinycc/host/mem_host:in_memory_host.mbt:14:13-14:60");
  } else {
    const _Some = _bind;
    const _bytes = _Some;
    return new Result$Ok$44$(_bytes);
  }
}
function hackwaly$tinycc$host$$Host$read_file_to_string$0$(self, path) {
  const _bind = moonbitlang$core$builtin$$Map$get$135$(self.files, path);
  if (_bind === undefined) {
    return moonbitlang$core$builtin$$fail$19$(`File not found in InMemoryHost: ${path}`, "@hackwaly/tinycc/host/mem_host:in_memory_host.mbt:22:13-22:60");
  } else {
    const _Some = _bind;
    const _bytes = _Some;
    return moonbitlang$core$encoding$utf8$$decode$46$inner(moonbitlang$core$bytes$$Bytes$sub$46$inner(_bytes, 0, _bytes.length), true);
  }
}
function hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(self, path, bytes) {
  return new Result$Ok$26$(moonbitlang$core$builtin$$Map$set$135$(self.files, path, bytes));
}
function hackwaly$tinycc$host$$Host$remove_file$0$(self, path) {
  if (!moonbitlang$core$builtin$$Map$contains$135$(self.files, path)) {
    const _bind = moonbitlang$core$builtin$$fail$8$(`File not found in InMemoryHost: ${path}`, "@hackwaly/tinycc/host/mem_host:in_memory_host.mbt:35:5-35:52");
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  return new Result$Ok$26$(moonbitlang$core$builtin$$Map$remove$135$(self.files, path));
}
function hackwaly$tinycc$host$mem_host$$new() {
  const _bind = [];
  return { files: moonbitlang$core$builtin$$Map$from_array$135$({ buf: _bind, start: 0, end: 0 }) };
}
function hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes() {
  const host = hackwaly$tinycc$host$mem_host$$new();
  let _try_err;
  _L: {
    _L$2: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/TargetConditionals.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$11, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$11.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err = _tmp$27;
        break _L$2;
      }
      break _L;
    }
    $panic();
  }
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/assert.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$14, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$14.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$2 = _tmp$27;
        break _L$3;
      }
      break _L$2;
    }
    $panic();
  }
  let _try_err$3;
  _L$3: {
    _L$4: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/crt_externs.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$17, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$17.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$3 = _tmp$27;
        break _L$4;
      }
      break _L$3;
    }
    $panic();
  }
  let _try_err$4;
  _L$4: {
    _L$5: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/ctype.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$20, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$20.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$4 = _tmp$27;
        break _L$5;
      }
      break _L$4;
    }
    $panic();
  }
  let _try_err$5;
  _L$5: {
    _L$6: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/dirent.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$23, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$23.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$5 = _tmp$27;
        break _L$6;
      }
      break _L$5;
    }
    $panic();
  }
  let _try_err$6;
  _L$6: {
    _L$7: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/dispatch/dispatch.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$26, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$26.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$6 = _tmp$27;
        break _L$7;
      }
      break _L$6;
    }
    $panic();
  }
  let _try_err$7;
  _L$7: {
    _L$8: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/dlfcn.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$29, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$29.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$7 = _tmp$27;
        break _L$8;
      }
      break _L$7;
    }
    $panic();
  }
  let _try_err$8;
  _L$8: {
    _L$9: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/errno.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$32, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$32.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$8 = _tmp$27;
        break _L$9;
      }
      break _L$8;
    }
    $panic();
  }
  let _try_err$9;
  _L$9: {
    _L$10: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/fcntl.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$35, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$35.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$9 = _tmp$27;
        break _L$10;
      }
      break _L$9;
    }
    $panic();
  }
  let _try_err$10;
  _L$10: {
    _L$11: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/fenv.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$38, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$38.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$10 = _tmp$27;
        break _L$11;
      }
      break _L$10;
    }
    $panic();
  }
  let _try_err$11;
  _L$11: {
    _L$12: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/float.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$41, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$41.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$11 = _tmp$27;
        break _L$12;
      }
      break _L$11;
    }
    $panic();
  }
  let _try_err$12;
  _L$12: {
    _L$13: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/glob.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$44, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$44.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$12 = _tmp$27;
        break _L$13;
      }
      break _L$12;
    }
    $panic();
  }
  let _try_err$13;
  _L$13: {
    _L$14: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/inttypes.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$47, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$47.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$13 = _tmp$27;
        break _L$14;
      }
      break _L$13;
    }
    $panic();
  }
  let _try_err$14;
  _L$14: {
    _L$15: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/libkern/OSCacheControl.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$50, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$50.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$14 = _tmp$27;
        break _L$15;
      }
      break _L$14;
    }
    $panic();
  }
  let _try_err$15;
  _L$15: {
    _L$16: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/libproc.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$53, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$53.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$15 = _tmp$27;
        break _L$16;
      }
      break _L$15;
    }
    $panic();
  }
  let _try_err$16;
  _L$16: {
    _L$17: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/limits.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$56, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$56.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$16 = _tmp$27;
        break _L$17;
      }
      break _L$16;
    }
    $panic();
  }
  let _try_err$17;
  _L$17: {
    _L$18: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/locale.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$59, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$59.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$17 = _tmp$27;
        break _L$18;
      }
      break _L$17;
    }
    $panic();
  }
  let _try_err$18;
  _L$18: {
    _L$19: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/malloc/malloc.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$62, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$62.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$18 = _tmp$27;
        break _L$19;
      }
      break _L$18;
    }
    $panic();
  }
  let _try_err$19;
  _L$19: {
    _L$20: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/math.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$65, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$65.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$19 = _tmp$27;
        break _L$20;
      }
      break _L$19;
    }
    $panic();
  }
  let _try_err$20;
  _L$20: {
    _L$21: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/pthread.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$68, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$68.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$20 = _tmp$27;
        break _L$21;
      }
      break _L$20;
    }
    $panic();
  }
  let _try_err$21;
  _L$21: {
    _L$22: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/semaphore.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$71, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$71.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$21 = _tmp$27;
        break _L$22;
      }
      break _L$21;
    }
    $panic();
  }
  let _try_err$22;
  _L$22: {
    _L$23: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/setjmp.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$74, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$74.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$22 = _tmp$27;
        break _L$23;
      }
      break _L$22;
    }
    $panic();
  }
  let _try_err$23;
  _L$23: {
    _L$24: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/signal.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$77, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$77.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$23 = _tmp$27;
        break _L$24;
      }
      break _L$23;
    }
    $panic();
  }
  let _try_err$24;
  _L$24: {
    _L$25: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stdarg.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$80, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$80.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$24 = _tmp$27;
        break _L$25;
      }
      break _L$24;
    }
    $panic();
  }
  let _try_err$25;
  _L$25: {
    _L$26: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stdatomic.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$83, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$83.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$25 = _tmp$27;
        break _L$26;
      }
      break _L$25;
    }
    $panic();
  }
  let _try_err$26;
  _L$26: {
    _L$27: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stdbool.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$86, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$86.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$26 = _tmp$27;
        break _L$27;
      }
      break _L$26;
    }
    $panic();
  }
  let _try_err$27;
  _L$27: {
    _L$28: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stddef.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$89, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$89.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$27 = _tmp$27;
        break _L$28;
      }
      break _L$27;
    }
    $panic();
  }
  let _try_err$28;
  _L$28: {
    _L$29: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stdint.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$92, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$92.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$28 = _tmp$27;
        break _L$29;
      }
      break _L$28;
    }
    $panic();
  }
  let _try_err$29;
  _L$29: {
    _L$30: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stdio.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$95, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$95.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$29 = _tmp$27;
        break _L$30;
      }
      break _L$29;
    }
    $panic();
  }
  let _try_err$30;
  _L$30: {
    _L$31: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stdlib.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$98, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$98.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$30 = _tmp$27;
        break _L$31;
      }
      break _L$30;
    }
    $panic();
  }
  let _try_err$31;
  _L$31: {
    _L$32: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/stdnoreturn.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$101, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$101.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$31 = _tmp$27;
        break _L$32;
      }
      break _L$31;
    }
    $panic();
  }
  let _try_err$32;
  _L$32: {
    _L$33: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/string.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$104, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$104.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$32 = _tmp$27;
        break _L$33;
      }
      break _L$32;
    }
    $panic();
  }
  let _try_err$33;
  _L$33: {
    _L$34: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/file.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$107, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$107.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$33 = _tmp$27;
        break _L$34;
      }
      break _L$33;
    }
    $panic();
  }
  let _try_err$34;
  _L$34: {
    _L$35: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/ioctl.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$110, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$110.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$34 = _tmp$27;
        break _L$35;
      }
      break _L$34;
    }
    $panic();
  }
  let _try_err$35;
  _L$35: {
    _L$36: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/mman.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$113, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$113.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$35 = _tmp$27;
        break _L$36;
      }
      break _L$35;
    }
    $panic();
  }
  let _try_err$36;
  _L$36: {
    _L$37: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/mount.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$116, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$116.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$36 = _tmp$27;
        break _L$37;
      }
      break _L$36;
    }
    $panic();
  }
  let _try_err$37;
  _L$37: {
    _L$38: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/ptrace.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$119, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$119.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$37 = _tmp$27;
        break _L$38;
      }
      break _L$37;
    }
    $panic();
  }
  let _try_err$38;
  _L$38: {
    _L$39: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/select.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$122, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$122.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$38 = _tmp$27;
        break _L$39;
      }
      break _L$38;
    }
    $panic();
  }
  let _try_err$39;
  _L$39: {
    _L$40: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/stat.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$125, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$125.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$39 = _tmp$27;
        break _L$40;
      }
      break _L$39;
    }
    $panic();
  }
  let _try_err$40;
  _L$40: {
    _L$41: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/statvfs.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$128, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$128.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$40 = _tmp$27;
        break _L$41;
      }
      break _L$40;
    }
    $panic();
  }
  let _try_err$41;
  _L$41: {
    _L$42: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/syscall.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$131, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$131.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$41 = _tmp$27;
        break _L$42;
      }
      break _L$41;
    }
    $panic();
  }
  let _try_err$42;
  _L$42: {
    _L$43: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/time.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$134, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$134.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$42 = _tmp$27;
        break _L$43;
      }
      break _L$42;
    }
    $panic();
  }
  let _try_err$43;
  _L$43: {
    _L$44: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/types.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$137, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$137.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$43 = _tmp$27;
        break _L$44;
      }
      break _L$43;
    }
    $panic();
  }
  let _try_err$44;
  _L$44: {
    _L$45: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/ucontext.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$140, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$140.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$44 = _tmp$27;
        break _L$45;
      }
      break _L$44;
    }
    $panic();
  }
  let _try_err$45;
  _L$45: {
    _L$46: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/uio.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$143, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$143.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$45 = _tmp$27;
        break _L$46;
      }
      break _L$45;
    }
    $panic();
  }
  let _try_err$46;
  _L$46: {
    _L$47: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/utsname.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$146, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$146.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$46 = _tmp$27;
        break _L$47;
      }
      break _L$46;
    }
    $panic();
  }
  let _try_err$47;
  _L$47: {
    _L$48: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/sys/wait.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$149, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$149.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$47 = _tmp$27;
        break _L$48;
      }
      break _L$47;
    }
    $panic();
  }
  let _try_err$48;
  _L$48: {
    _L$49: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/termios.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$152, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$152.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$48 = _tmp$27;
        break _L$49;
      }
      break _L$48;
    }
    $panic();
  }
  let _try_err$49;
  _L$49: {
    _L$50: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/time.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$155, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$155.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$49 = _tmp$27;
        break _L$50;
      }
      break _L$49;
    }
    $panic();
  }
  let _try_err$50;
  _L$50: {
    _L$51: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/unistd.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$158, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$158.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$50 = _tmp$27;
        break _L$51;
      }
      break _L$50;
    }
    $panic();
  }
  let _try_err$51;
  _L$51: {
    _L$52: {
      const _bind = hackwaly$tinycc$host$$Host$write_bytes_to_file$0$(host, "/include/utime.h", moonbitlang$core$encoding$utf8$$encode$46$inner({ str: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$161, start: 0, end: hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes$46$42$bind$124$161.length }, false));
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp$27 = _err._0;
        _try_err$51 = _tmp$27;
        break _L$52;
      }
      break _L$51;
    }
    $panic();
  }
  return { self: host, method_table: $$$64$hackwaly$47$tinycc$47$host$47$mem_host$46$InMemoryHost$36$as$36$64$hackwaly$47$tinycc$47$host$46$Host };
}
function hackwaly$tinycc$jsapi$$run_args(host, args) {
  return hackwaly$tinycc$driver$$run_args(host, args);
}
function hackwaly$tinycc$jsapi$$new_in_memory_host() {
  return { self: hackwaly$tinycc$host$mem_host$$new(), method_table: $$$64$hackwaly$47$tinycc$47$host$47$mem_host$46$InMemoryHost$36$as$36$64$hackwaly$47$tinycc$47$host$46$Host };
}
function hackwaly$tinycc$jsapi$$host_write_string_to_file(host, path, content) {
  let _try_err;
  _L: {
    const _bind = host.method_table.method_3(host.self, path, moonbitlang$core$encoding$utf8$$encode$46$inner({ str: content, start: 0, end: content.length }, false));
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
      return;
    } else {
      const _err = _bind;
      const _tmp$27 = _err._0;
      _try_err = _tmp$27;
      break _L;
    }
  }
  $panic();
}
function hackwaly$tinycc$jsapi$$host_read_file(host, path) {
  let _try_err;
  _L: {
    const _bind = host.method_table.method_2(host.self, path);
    if (_bind.$tag === 1) {
      const _ok = _bind;
      return _ok._0;
    } else {
      const _err = _bind;
      const _tmp$27 = _err._0;
      _try_err = _tmp$27;
      break _L;
    }
  }
  return $panic();
}
export { hackwaly$tinycc$jsapi$$new_in_memory_host_with_includes as new_in_memory_host_with_includes, hackwaly$tinycc$jsapi$$run_args as run_args, hackwaly$tinycc$jsapi$$new_in_memory_host as new_in_memory_host, hackwaly$tinycc$jsapi$$host_write_string_to_file as host_write_string_to_file, hackwaly$tinycc$jsapi$$host_read_file as host_read_file }
